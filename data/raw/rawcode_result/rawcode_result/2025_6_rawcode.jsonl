{"patches_id": 1, "files_id": 1, "language": "inc", "raw_url": "https://github.com/fusionforge/fusionforge/raw/30f80503efbfb68c3915ef968c5215ab203d8118/src%2Fetc%2Fhttpd.conf.d%2Fplugin-generic.inc", "raw_code": "ScriptAliasMatch ^/plugins/([^/]*)/cgi-bin/(.*) {core/source_path}/plugins/$1/cgi-bin/$2\n\nAlias {core/url_prefix}anonscm/ {core/data_path}/chroot/scmrepos/\n\n<DirectoryMatch {core/data_path}/chroot/scmrepos/[^/]*>\n  Options -Indexes\n</DirectoryMatch>\n<DirectoryMatch {core/data_path}/chroot/scmrepos/[^/]*/.*>\n  # Enable directory index listing, but disable symlinks and CGI\n  Options Indexes\n\n  # Permit HTTP Auth for somewhat private projects (mechanism\n  # other than the SCM anon bit in the forge)\n  AllowOverride AuthConfig\n\n  # Prevent cookie theft in case a script does manage to execute\n  RequestHeader unset Cookie\n\n  # Disable all scripting engines (taken from Savannah)\n  # except for empty filenames == directory index\n  <Files \"?*\">\n    SetHandler default\n  </Files>\n\n  # Disable PHP5 explicitly for security (CVE-2014-0468)\n  <IfModule mod_php5.c>\n    php_admin_flag engine off\n  </IfModule>\n</DirectoryMatch>\n", "patch": "@@ -6,5 +6,24 @@ Alias {core/url_prefix}anonscm/ {core/data_path}/chroot/scmrepos/\n   Options -Indexes\n </DirectoryMatch>\n <DirectoryMatch {core/data_path}/chroot/scmrepos/[^/]*/.*>\n-  Options +Indexes\n+  # Enable directory index listing, but disable symlinks and CGI\n+  Options Indexes\n+\n+  # Permit HTTP Auth for somewhat private projects (mechanism\n+  # other than the SCM anon bit in the forge)\n+  AllowOverride AuthConfig\n+\n+  # Prevent cookie theft in case a script does manage to execute\n+  RequestHeader unset Cookie\n+\n+  # Disable all scripting engines (taken from Savannah)\n+  # except for empty filenames == directory index\n+  <Files \"?*\">\n+    SetHandler default\n+  </Files>\n+\n+  # Disable PHP5 explicitly for security (CVE-2014-0468)\n+  <IfModule mod_php5.c>\n+    php_admin_flag engine off\n+  </IfModule>\n </DirectoryMatch>"}
{"patches_id": 2, "files_id": 2, "language": "yml", "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/.travis.yml", "raw_code": "env:\n  global:\n    - ARTIFACTS_AWS_REGION=us-east-1\n    - ARTIFACTS_S3_BUCKET=matplotlib-test-results\n    - secure: RgJI7BBL8aX5FTOQe7xiXqWHMxWokd6GNUWp1NUV2mRLXPb9dI0RXqZt3UJwKTAzf1z/OtlHDmEkBoTVK81E9iUxK5npwyyjhJ8yTJmwfQtQF2n51Q1Ww9p+XSLORrOzZc7kAo6Kw6FIXN1pfctgYq2bQkrwJPRx/oPR8f6hcbY=\n    - secure: E7OCdqhZ+PlwJcn+Hd6ns9TDJgEUXiUNEI0wu7xjxB2vBRRIKtZMbuaZjd+iKDqCKuVOJKu0ClBUYxmgmpLicTwi34CfTUYt6D4uhrU+8hBBOn1iiK51cl/aBvlUUrqaRLVhukNEBGZcyqAjXSA/Qsnp2iELEmAfOUa92ZYo1sk=\n    - BUILD_DOCS=false\n    - TEST_ARGS=--no-pep8\n    - NUMPY=numpy\n\nlanguage: python\n\nmatrix:\n  include:\n    - python: 2.6\n      env: NUMPY=numpy==1.6\n    - python: 2.7\n    - python: 3.3\n    - python: 3.4\n    - python: 2.7\n      env: TEST_ARGS=--pep8\n    - python: 2.7\n      env: BUILD_DOCS=true\n\ninstall:\n  - pip install -q --use-mirrors nose python-dateutil $NUMPY pep8 pyparsing pillow\n  - sudo apt-get update && sudo apt-get -qq install inkscape libav-tools gdb\n  # We use --no-install-recommends to avoid pulling in additional large latex docs that we don't need\n  - if [[ $BUILD_DOCS == true ]]; then sudo apt-get install -qq --no-install-recommends dvipng texlive-latex-base texlive-latex-extra texlive-fonts-recommended graphviz; fi\n  - if [[ $BUILD_DOCS == true ]]; then pip install sphinx numpydoc linkchecker; fi\n  - python setup.py install\n\nscript:\n  # The number of processes is hardcoded, because using too many causes the\n  # Travis VM to run out of memory (since so many copies of inkscape and\n  # ghostscript are running at the same time).\n  - echo Testing using 8 processes\n  # Generate the font caches in a single process before starting the\n  # multiple processes\n  - gcc --version\n  - python -c \"from matplotlib import font_manager\"\n  - if [[ $BUILD_DOCS == false ]]; then export MPL_REPO_DIR=$PWD; fi # pep8-conformance test of the examples\n  - if [[ $BUILD_DOCS == false ]]; then mkdir ../tmp_test_dir; fi\n  - if [[ $BUILD_DOCS == false ]]; then cd ../tmp_test_dir; fi\n  - if [[ $BUILD_DOCS == false ]]; then gdb -return-child-result -batch -ex r -ex bt --args python ../matplotlib/tests.py -sv $TEST_ARGS; fi\n  - if [[ $BUILD_DOCS == true ]]; then cd doc; python make.py html --small; fi\n  # We don't build the LaTeX docs here, so linkchecker will complain\n  - if [[ $BUILD_DOCS == true ]]; then touch build/html/Matplotlib.pdf; fi\n  - if [[ $BUILD_DOCS == true ]]; then linkchecker build/html/index.html; fi\n\nafter_failure:\n  - tar cjf result_images.tar.bz2 result_images\n  - if [[ $TRAVIS_PULL_REQUEST == false ]]; then gem install travis-artifacts; fi\n  - if [[ $TRAVIS_PULL_REQUEST == false ]]; then travis-artifacts upload --path result_images.tar.bz2; fi\n  - if [[ $TRAVIS_PULL_REQUEST != false ]]; then echo \"The result images will only be uploaded if they are on the matplotlib/matplotlib repo - this is for security reasons to prevent arbitrary PRs echoing security details.\" else echo https://s3.amazonaws.com/matplotlib-test-results/artifacts/${TRAVIS_BUILD_NUMBER}/${TRAVIS_JOB_NUMBER}/result_images.tar.bz2; fi\n", "patch": "@@ -24,8 +24,8 @@ matrix:\n \n install:\n   - pip install -q --use-mirrors nose python-dateutil $NUMPY pep8 pyparsing pillow\n-  - sudo apt-get update && sudo apt-get -qq install inkscape libav-tools\n-  # We use --no-install-recommends to avoid pulling in additional large latex docs that we don't need \n+  - sudo apt-get update && sudo apt-get -qq install inkscape libav-tools gdb\n+  # We use --no-install-recommends to avoid pulling in additional large latex docs that we don't need\n   - if [[ $BUILD_DOCS == true ]]; then sudo apt-get install -qq --no-install-recommends dvipng texlive-latex-base texlive-latex-extra texlive-fonts-recommended graphviz; fi\n   - if [[ $BUILD_DOCS == true ]]; then pip install sphinx numpydoc linkchecker; fi\n   - python setup.py install\n@@ -37,11 +37,12 @@ script:\n   - echo Testing using 8 processes\n   # Generate the font caches in a single process before starting the\n   # multiple processes\n+  - gcc --version\n   - python -c \"from matplotlib import font_manager\"\n   - if [[ $BUILD_DOCS == false ]]; then export MPL_REPO_DIR=$PWD; fi # pep8-conformance test of the examples\n   - if [[ $BUILD_DOCS == false ]]; then mkdir ../tmp_test_dir; fi\n   - if [[ $BUILD_DOCS == false ]]; then cd ../tmp_test_dir; fi\n-  - if [[ $BUILD_DOCS == false ]]; then python ../matplotlib/tests.py -sv --processes=8 --process-timeout=300 $TEST_ARGS; fi\n+  - if [[ $BUILD_DOCS == false ]]; then gdb -return-child-result -batch -ex r -ex bt --args python ../matplotlib/tests.py -sv $TEST_ARGS; fi\n   - if [[ $BUILD_DOCS == true ]]; then cd doc; python make.py html --small; fi\n   # We don't build the LaTeX docs here, so linkchecker will complain\n   - if [[ $BUILD_DOCS == true ]]; then touch build/html/Matplotlib.pdf; fi"}
{"patches_id": 2, "files_id": 3, "language": "py", "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/examples%2Fpylab_examples%2Fagg_buffer_to_array.py", "raw_code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# make an agg figure\nfig, ax = plt.subplots()\nax.plot([1,2,3])\nax.set_title('a simple figure')\nfig.canvas.draw()\n\n# grab the pixel buffer and dump it into a numpy array\nX = np.array(fig.canvas.renderer._renderer)\n\n# now display the array X as an Axes in a new figure\nfig2 = plt.figure()\nax2 = fig2.add_subplot(111, frameon=False)\nax2.imshow(X)\nplt.show()\n", "patch": "@@ -8,12 +8,7 @@\n fig.canvas.draw()\n \n # grab the pixel buffer and dump it into a numpy array\n-buf = fig.canvas.buffer_rgba()\n-l, b, w, h = fig.bbox.bounds\n-# The array needs to be copied, because the underlying buffer\n-# may be reallocated when the window is resized.\n-X = np.frombuffer(buf, np.uint8).copy()\n-X.shape = h,w,4\n+X = np.array(fig.canvas.renderer._renderer)\n \n # now display the array X as an Axes in a new figure\n fig2 = plt.figure()"}
{"patches_id": 2, "files_id": 4, "language": "py", "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/examples%2Fpylab_examples%2Fmathtext_demo.py", "raw_code": "#!/usr/bin/env python\n\"\"\"\nUse matplotlib's internal LaTeX parser and layout engine.  For true\nlatex rendering, see the text.usetex option\n\"\"\"\nimport numpy as np\nfrom matplotlib.pyplot import figure, show\n\nfig = figure()\nfig.subplots_adjust(bottom=0.2)\n\nax = fig.add_subplot(111, axisbg='y')\nax.plot([1,2,3], 'r')\nx = np.arange(0.0, 3.0, 0.1)\n\nax.grid(True)\nax.set_xlabel(r'$\\Delta_i^j$', fontsize=20)\nax.set_ylabel(r'$\\Delta_{i+1}^j$', fontsize=20)\ntex = r'$\\mathcal{R}\\prod_{i=\\alpha_{i+1}}^\\infty a_i\\sin(2 \\pi f x_i)$'\n\nax.text(1, 1.6, tex, fontsize=20, va='bottom')\n\nax.legend([r\"$\\sqrt{x^2}$\"])\n\nax.set_title(r'$\\Delta_i^j \\hspace{0.4} \\mathrm{versus} \\hspace{0.4} \\Delta_{i+1}^j$', fontsize=20)\n\nshow()\n", "patch": "@@ -24,5 +24,4 @@\n \n ax.set_title(r'$\\Delta_i^j \\hspace{0.4} \\mathrm{versus} \\hspace{0.4} \\Delta_{i+1}^j$', fontsize=20)\n \n-\n show()"}
{"patches_id": 2, "files_id": 5, "language": "py", "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2F__init__.py", "raw_code": "\"\"\"\nThis is an object-oriented plotting library.\n\nA procedural interface is provided by the companion pyplot module,\nwhich may be imported directly, e.g.::\n\n    import matplotlib.pyplot as plt\n\nor using ipython::\n\n    ipython\n\nat your terminal, followed by::\n\n    In [1]: %matplotlib\n    In [2]: import matplotlib.pyplot as plt\n\nat the ipython shell prompt.\n\nFor the most part, direct use of the object-oriented library is\nencouraged when programming; pyplot is primarily for working\ninteractively.  The\nexceptions are the pyplot commands :func:`~matplotlib.pyplot.figure`,\n:func:`~matplotlib.pyplot.subplot`,\n:func:`~matplotlib.pyplot.subplots`, and\n:func:`~pyplot.savefig`, which can greatly simplify scripting.\n\nModules include:\n\n    :mod:`matplotlib.axes`\n        defines the :class:`~matplotlib.axes.Axes` class.  Most pylab\n        commands are wrappers for :class:`~matplotlib.axes.Axes`\n        methods.  The axes module is the highest level of OO access to\n        the library.\n\n    :mod:`matplotlib.figure`\n        defines the :class:`~matplotlib.figure.Figure` class.\n\n    :mod:`matplotlib.artist`\n        defines the :class:`~matplotlib.artist.Artist` base class for\n        all classes that draw things.\n\n    :mod:`matplotlib.lines`\n        defines the :class:`~matplotlib.lines.Line2D` class for\n        drawing lines and markers\n\n    :mod:`matplotlib.patches`\n        defines classes for drawing polygons\n\n    :mod:`matplotlib.text`\n        defines the :class:`~matplotlib.text.Text`,\n        :class:`~matplotlib.text.TextWithDash`, and\n        :class:`~matplotlib.text.Annotate` classes\n\n    :mod:`matplotlib.image`\n        defines the :class:`~matplotlib.image.AxesImage` and\n        :class:`~matplotlib.image.FigureImage` classes\n\n    :mod:`matplotlib.collections`\n        classes for efficient drawing of groups of lines or polygons\n\n    :mod:`matplotlib.colors`\n        classes for interpreting color specifications and for making\n        colormaps\n\n    :mod:`matplotlib.cm`\n        colormaps and the :class:`~matplotlib.image.ScalarMappable`\n        mixin class for providing color mapping functionality to other\n        classes\n\n    :mod:`matplotlib.ticker`\n        classes for calculating tick mark locations and for formatting\n        tick labels\n\n    :mod:`matplotlib.backends`\n        a subpackage with modules for various gui libraries and output\n        formats\n\nThe base matplotlib namespace includes:\n\n    :data:`~matplotlib.rcParams`\n        a global dictionary of default configuration settings.  It is\n        initialized by code which may be overridded by a matplotlibrc\n        file.\n\n    :func:`~matplotlib.rc`\n        a function for setting groups of rcParams values\n\n    :func:`~matplotlib.use`\n        a function for setting the matplotlib backend.  If used, this\n        function must be called immediately after importing matplotlib\n        for the first time.  In particular, it must be called\n        **before** importing pylab (if pylab is imported).\n\nmatplotlib was initially written by John D. Hunter (1968-2012) and is now\ndeveloped and maintained by a host of others.\n\nOccasionally the internal documentation (python docstrings) will refer\nto MATLAB&reg;, a registered trademark of The MathWorks, Inc.\n\n\"\"\"\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport six\nimport sys\nimport distutils.version\n\n__version__ = str('1.5.x')\n__version__numpy__ = str('1.6')  # minimum required numpy version\n\n\ntry:\n    import dateutil\nexcept ImportError:\n    raise ImportError(\"matplotlib requires dateutil\")\n\n\ndef compare_versions(a, b):\n    \"return True if a is greater than or equal to b\"\n    if a:\n        if six.PY3:\n            if isinstance(a, bytes):\n                a = a.decode('ascii')\n            if isinstance(b, bytes):\n                b = b.decode('ascii')\n        a = distutils.version.LooseVersion(a)\n        b = distutils.version.LooseVersion(b)\n        return a >= b\n    else:\n        return False\n\nif not compare_versions(six.__version__, '1.3'):\n    raise ImportError(\n        'six 1.3 or later is required; you have %s' % (\n            six.__version__))\n\ntry:\n    import pyparsing\nexcept ImportError:\n    raise ImportError(\"matplotlib requires pyparsing\")\nelse:\n    if not compare_versions(pyparsing.__version__, '1.5.6'):\n        raise ImportError(\n            \"matplotlib requires pyparsing >= 1.5.6\")\n\n    # pyparsing 2.0.0 bug, but it may be patched in distributions\n    try:\n        f = pyparsing.Forward()\n        f <<= pyparsing.Literal('a')\n        bad_pyparsing = f is None\n    except TypeError:\n        bad_pyparsing = True\n\n    # pyparsing 1.5.6 does not have <<= on the Forward class, but\n    # pyparsing 2.0.0 and later will spew deprecation warnings if\n    # using << instead.  Additionally, the <<= in pyparsing 1.5.7 is\n    # broken, since it doesn't return self.  In order to support\n    # pyparsing 1.5.6 and above with a common code base, this small\n    # monkey patch is applied.\n    if bad_pyparsing:\n        def _forward_ilshift(self, other):\n            self.__lshift__(other)\n            return self\n        pyparsing.Forward.__ilshift__ = _forward_ilshift\n\ntry:\n    from urllib.request import urlopen\nexcept ImportError:\n    from urllib2 import urlopen\n\nimport io\nimport locale\nimport os\nimport re\nimport tempfile\nimport warnings\nimport contextlib\nimport distutils.sysconfig\n\n# cbook must import matplotlib only within function\n# definitions, so it is safe to import from it here.\nfrom matplotlib.cbook import is_string_like\nfrom matplotlib.compat import subprocess\n\ntry:\n    reload\nexcept NameError:\n    # Python 3\n    from imp import reload\n\n\nif not hasattr(sys, 'argv'):  # for modpython\n    sys.argv = [str('modpython')]\n\n\nfrom matplotlib.rcsetup import (defaultParams,\n                                validate_backend)\n\nmajor, minor1, minor2, s, tmp = sys.version_info\n_python24 = (major == 2 and minor1 >= 4) or major >= 3\n\n# the havedate check was a legacy from old matplotlib which preceeded\n# datetime support\n_havedate = True\n\nif not _python24:\n    raise ImportError('matplotlib requires Python 2.4 or later')\n\n\nimport numpy\nif not compare_versions(numpy.__version__, __version__numpy__):\n    raise ImportError(\n        'numpy %s or later is required; you have %s' % (\n            __version__numpy__, numpy.__version__))\n\n\ndef _is_writable_dir(p):\n    \"\"\"\n    p is a string pointing to a putative writable dir -- return True p\n    is such a string, else False\n    \"\"\"\n    try:\n        p + ''  # test is string like\n    except TypeError:\n        return False\n\n    # Test whether the operating system thinks it's a writable directory.\n    # Note that this check is necessary on Google App Engine, because the\n    # subsequent check will succeed even though p may not be writable.\n    if not os.access(p, os.W_OK) or not os.path.isdir(p):\n        return False\n\n    # Also test that it is actually possible to write to a file here.\n    try:\n        t = tempfile.TemporaryFile(dir=p)\n        try:\n            t.write(b'1')\n        finally:\n            t.close()\n    except OSError:\n        return False\n\n    return True\n\n\nclass Verbose:\n    \"\"\"\n    A class to handle reporting.  Set the fileo attribute to any file\n    instance to handle the output.  Default is sys.stdout\n    \"\"\"\n    levels = ('silent', 'helpful', 'debug', 'debug-annoying')\n    vald = dict([(level, i) for i, level in enumerate(levels)])\n\n    # parse the verbosity from the command line; flags look like\n    # --verbose-silent or --verbose-helpful\n    _commandLineVerbose = None\n\n    for arg in sys.argv[1:]:\n        # cast to str because we are using unicode_literals,\n        # and argv is always str\n        if not arg.startswith(str('--verbose-')):\n            continue\n        level_str = arg[10:]\n        # If it doesn't match one of ours, then don't even\n        # bother noting it, we are just a 3rd-party library\n        # to somebody else's script.\n        if level_str in levels:\n            _commandLineVerbose = level_str\n\n    def __init__(self):\n        self.set_level('silent')\n        self.fileo = sys.stdout\n\n    def set_level(self, level):\n        'set the verbosity to one of the Verbose.levels strings'\n\n        if self._commandLineVerbose is not None:\n            level = self._commandLineVerbose\n        if level not in self.levels:\n            warnings.warn('matplotlib: unrecognized --verbose-* string \"%s\".'\n                          ' Legal values are %s' % (level, self.levels))\n        else:\n            self.level = level\n\n    def set_fileo(self, fname):\n        std = {\n            'sys.stdout': sys.stdout,\n            'sys.stderr': sys.stderr,\n        }\n        if fname in std:\n            self.fileo = std[fname]\n        else:\n            try:\n                fileo = open(fname, 'w')\n            except IOError:\n                raise ValueError('Verbose object could not open log file \"{}\"'\n                                 ' for writing.\\nCheck your matplotlibrc '\n                                 'verbose.fileo setting'.format(fname))\n            else:\n                self.fileo = fileo\n\n    def report(self, s, level='helpful'):\n        \"\"\"\n        print message s to self.fileo if self.level>=level.  Return\n        value indicates whether a message was issued\n\n        \"\"\"\n        if self.ge(level):\n            print(s, file=self.fileo)\n            return True\n        return False\n\n    def wrap(self, fmt, func, level='helpful', always=True):\n        \"\"\"\n        return a callable function that wraps func and reports it\n        output through the verbose handler if current verbosity level\n        is higher than level\n\n        if always is True, the report will occur on every function\n        call; otherwise only on the first time the function is called\n        \"\"\"\n        assert six.callable(func)\n\n        def wrapper(*args, **kwargs):\n            ret = func(*args, **kwargs)\n\n            if (always or not wrapper._spoke):\n                spoke = self.report(fmt % ret, level)\n                if not wrapper._spoke:\n                    wrapper._spoke = spoke\n            return ret\n        wrapper._spoke = False\n        wrapper.__doc__ = func.__doc__\n        return wrapper\n\n    def ge(self, level):\n        'return true if self.level is >= level'\n        return self.vald[self.level] >= self.vald[level]\n\n\nverbose = Verbose()\n\n\ndef checkdep_dvipng():\n    try:\n        s = subprocess.Popen(['dvipng', '-version'], stdout=subprocess.PIPE,\n                             stderr=subprocess.PIPE)\n        stdout, stderr = s.communicate()\n        line = stdout.decode('ascii').split('\\n')[1]\n        v = line.split()[-1]\n        return v\n    except (IndexError, ValueError, OSError):\n        return None\n\n\ndef checkdep_ghostscript():\n    if sys.platform == 'win32':\n        gs_execs = ['gswin32c', 'gswin64c', 'gs']\n    else:\n        gs_execs = ['gs']\n    for gs_exec in gs_execs:\n        try:\n            s = subprocess.Popen(\n                [gs_exec, '--version'], stdout=subprocess.PIPE,\n                stderr=subprocess.PIPE)\n            stdout, stderr = s.communicate()\n            if s.returncode == 0:\n                v = stdout[:-1].decode('ascii')\n                return gs_exec, v\n        except (IndexError, ValueError, OSError):\n            pass\n    return None, None\n\n\ndef checkdep_tex():\n    try:\n        s = subprocess.Popen(['tex', '-version'], stdout=subprocess.PIPE,\n                             stderr=subprocess.PIPE)\n        stdout, stderr = s.communicate()\n        line = stdout.decode('ascii').split('\\n')[0]\n        pattern = '3\\.1\\d+'\n        match = re.search(pattern, line)\n        v = match.group(0)\n        return v\n    except (IndexError, ValueError, AttributeError, OSError):\n        return None\n\n\ndef checkdep_pdftops():\n    try:\n        s = subprocess.Popen(['pdftops', '-v'], stdout=subprocess.PIPE,\n                             stderr=subprocess.PIPE)\n        stdout, stderr = s.communicate()\n        lines = stderr.decode('ascii').split('\\n')\n        for line in lines:\n            if 'version' in line:\n                v = line.split()[-1]\n        return v\n    except (IndexError, ValueError, UnboundLocalError, OSError):\n        return None\n\n\ndef checkdep_inkscape():\n    try:\n        s = subprocess.Popen(['inkscape', '-V'], stdout=subprocess.PIPE,\n                             stderr=subprocess.PIPE)\n        stdout, stderr = s.communicate()\n        lines = stdout.decode('ascii').split('\\n')\n        for line in lines:\n            if 'Inkscape' in line:\n                v = line.split()[1]\n                break\n        return v\n    except (IndexError, ValueError, UnboundLocalError, OSError):\n        return None\n\n\ndef checkdep_xmllint():\n    try:\n        s = subprocess.Popen(['xmllint', '--version'], stdout=subprocess.PIPE,\n                             stderr=subprocess.PIPE)\n        stdout, stderr = s.communicate()\n        lines = stderr.decode('ascii').split('\\n')\n        for line in lines:\n            if 'version' in line:\n                v = line.split()[-1]\n                break\n        return v\n    except (IndexError, ValueError, UnboundLocalError, OSError):\n        return None\n\n\ndef checkdep_ps_distiller(s):\n    if not s:\n        return False\n\n    flag = True\n    gs_req = '7.07'\n    gs_sugg = '7.07'\n    gs_exec, gs_v = checkdep_ghostscript()\n    if compare_versions(gs_v, gs_sugg):\n        pass\n    elif compare_versions(gs_v, gs_req):\n        verbose.report(('ghostscript-%s found. ghostscript-%s or later '\n                        'is recommended to use the ps.usedistiller option.')\n                       % (gs_v, gs_sugg))\n    else:\n        flag = False\n        warnings.warn(('matplotlibrc ps.usedistiller option can not be used '\n                       'unless ghostscript-%s or later is installed on your '\n                       'system') % gs_req)\n\n    if s == 'xpdf':\n        pdftops_req = '3.0'\n        pdftops_req_alt = '0.9'  # poppler version numbers, ugh\n        pdftops_v = checkdep_pdftops()\n        if compare_versions(pdftops_v, pdftops_req):\n            pass\n        elif (compare_versions(pdftops_v, pdftops_req_alt) and not\n              compare_versions(pdftops_v, '1.0')):\n            pass\n        else:\n            flag = False\n            warnings.warn(('matplotlibrc ps.usedistiller can not be set to '\n                           'xpdf unless xpdf-%s or later is installed on '\n                           'your system') % pdftops_req)\n\n    if flag:\n        return s\n    else:\n        return False\n\n\ndef checkdep_usetex(s):\n    if not s:\n        return False\n\n    tex_req = '3.1415'\n    gs_req = '7.07'\n    gs_sugg = '7.07'\n    dvipng_req = '1.5'\n    flag = True\n\n    tex_v = checkdep_tex()\n    if compare_versions(tex_v, tex_req):\n        pass\n    else:\n        flag = False\n        warnings.warn(('matplotlibrc text.usetex option can not be used '\n                       'unless TeX-%s or later is '\n                       'installed on your system') % tex_req)\n\n    dvipng_v = checkdep_dvipng()\n    if compare_versions(dvipng_v, dvipng_req):\n        pass\n    else:\n        flag = False\n        warnings.warn('matplotlibrc text.usetex can not be used with *Agg '\n                      'backend unless dvipng-1.5 or later is '\n                      'installed on your system')\n\n    gs_exec, gs_v = checkdep_ghostscript()\n    if compare_versions(gs_v, gs_sugg):\n        pass\n    elif compare_versions(gs_v, gs_req):\n        verbose.report(('ghostscript-%s found. ghostscript-%s or later is '\n                        'recommended for use with the text.usetex '\n                        'option.') % (gs_v, gs_sugg))\n    else:\n        flag = False\n        warnings.warn(('matplotlibrc text.usetex can not be used '\n                       'unless ghostscript-%s or later is '\n                       'installed on your system') % gs_req)\n\n    return flag\n\n\ndef _get_home():\n    \"\"\"Find user's home directory if possible.\n    Otherwise, returns None.\n\n    :see:\n        http://mail.python.org/pipermail/python-list/2005-February/325395.html\n    \"\"\"\n    try:\n        if six.PY2 and sys.platform == 'win32':\n            path = os.path.expanduser(b\"~\").decode(sys.getfilesystemencoding())\n        else:\n            path = os.path.expanduser(\"~\")\n    except ImportError:\n        # This happens on Google App Engine (pwd module is not present).\n        pass\n    else:\n        if os.path.isdir(path):\n            return path\n    for evar in ('HOME', 'USERPROFILE', 'TMP'):\n        path = os.environ.get(evar)\n        if path is not None and os.path.isdir(path):\n            return path\n    return None\n\n\ndef _create_tmp_config_dir():\n    \"\"\"\n    If the config directory can not be created, create a temporary\n    directory.\n\n    Returns None if a writable temporary directory could not be created.\n    \"\"\"\n    import getpass\n    import tempfile\n\n    try:\n        tempdir = tempfile.gettempdir()\n    except NotImplementedError:\n        # Some restricted platforms (such as Google App Engine) do not provide\n        # gettempdir.\n        return None\n    tempdir = os.path.join(tempdir, 'matplotlib-%s' % getpass.getuser())\n    os.environ['MPLCONFIGDIR'] = tempdir\n\n    return tempdir\n\n\nget_home = verbose.wrap('$HOME=%s', _get_home, always=False)\n\n\ndef _get_xdg_config_dir():\n    \"\"\"\n    Returns the XDG configuration directory, according to the `XDG\n    base directory spec\n    <http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html>`_.\n    \"\"\"\n    path = os.environ.get('XDG_CONFIG_HOME')\n    if path is None:\n        path = get_home()\n        if path is not None:\n            path = os.path.join(path, '.config')\n    return path\n\n\ndef _get_xdg_cache_dir():\n    \"\"\"\n    Returns the XDG cache directory, according to the `XDG\n    base directory spec\n    <http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html>`_.\n    \"\"\"\n    path = os.environ.get('XDG_CACHE_HOME')\n    if path is None:\n        path = get_home()\n        if path is not None:\n            path = os.path.join(path, '.cache')\n    return path\n\n\ndef _get_config_or_cache_dir(xdg_base):\n    from matplotlib.cbook import mkdirs\n\n    configdir = os.environ.get('MPLCONFIGDIR')\n    if configdir is not None:\n        if not os.path.exists(configdir):\n            from matplotlib.cbook import mkdirs\n            mkdirs(configdir)\n\n        if not _is_writable_dir(configdir):\n            return _create_tmp_config_dir()\n        return configdir\n\n    p = None\n    h = get_home()\n    if h is not None:\n        p = os.path.join(h, '.matplotlib')\n    if (sys.platform.startswith('linux') and xdg_base):\n        p = os.path.join(xdg_base, 'matplotlib')\n\n    if p is not None:\n        if os.path.exists(p):\n            if _is_writable_dir(p):\n                return p\n        else:\n            try:\n                mkdirs(p)\n            except OSError:\n                pass\n            else:\n                return p\n\n    return _create_tmp_config_dir()\n\n\ndef _get_configdir():\n    \"\"\"\n    Return the string representing the configuration directory.\n\n    The directory is chosen as follows:\n\n    1. If the MPLCONFIGDIR environment variable is supplied, choose that.\n\n    2a. On Linux, if `$HOME/.matplotlib` exists, choose that, but warn that\n        that is the old location.  Barring that, follow the XDG specification\n        and look first in `$XDG_CONFIG_HOME`, if defined, or `$HOME/.config`.\n\n    2b. On other platforms, choose `$HOME/.matplotlib`.\n\n    3. If the chosen directory exists and is writable, use that as the\n       configuration directory.\n    4. If possible, create a temporary directory, and use it as the\n       configuration directory.\n    5. A writable directory could not be found or created; return None.\n    \"\"\"\n    return _get_config_or_cache_dir(_get_xdg_config_dir())\n\nget_configdir = verbose.wrap('CONFIGDIR=%s', _get_configdir, always=False)\n\n\ndef _get_cachedir():\n    \"\"\"\n    Return the location of the cache directory.\n\n    The procedure used to find the directory is the same as for\n    _get_config_dir, except using `$XDG_CACHE_HOME`/`~/.cache` instead.\n    \"\"\"\n    return _get_config_or_cache_dir(_get_xdg_cache_dir())\n\nget_cachedir = verbose.wrap('CACHEDIR=%s', _get_cachedir, always=False)\n\n\ndef _get_data_path():\n    'get the path to matplotlib data'\n\n    if 'MATPLOTLIBDATA' in os.environ:\n        path = os.environ['MATPLOTLIBDATA']\n        if not os.path.isdir(path):\n            raise RuntimeError('Path in environment MATPLOTLIBDATA not a '\n                               'directory')\n        return path\n\n    path = os.sep.join([os.path.dirname(__file__), 'mpl-data'])\n    if os.path.isdir(path):\n        return path\n\n    # setuptools' namespace_packages may highjack this init file\n    # so need to try something known to be in matplotlib, not basemap\n    import matplotlib.afm\n    path = os.sep.join([os.path.dirname(matplotlib.afm.__file__), 'mpl-data'])\n    if os.path.isdir(path):\n        return path\n\n    # py2exe zips pure python, so still need special check\n    if getattr(sys, 'frozen', None):\n        exe_path = os.path.dirname(sys.executable)\n        path = os.path.join(exe_path, 'mpl-data')\n        if os.path.isdir(path):\n            return path\n\n        # Try again assuming we need to step up one more directory\n        path = os.path.join(os.path.split(exe_path)[0], 'mpl-data')\n        if os.path.isdir(path):\n            return path\n\n        # Try again assuming sys.path[0] is a dir not a exe\n        path = os.path.join(sys.path[0], 'mpl-data')\n        if os.path.isdir(path):\n            return path\n\n    raise RuntimeError('Could not find the matplotlib data files')\n\n\ndef _get_data_path_cached():\n    if defaultParams['datapath'][0] is None:\n        defaultParams['datapath'][0] = _get_data_path()\n    return defaultParams['datapath'][0]\n\nget_data_path = verbose.wrap('matplotlib data path %s', _get_data_path_cached,\n                             always=False)\n\n\ndef get_example_data(fname):\n    \"\"\"\n    get_example_data is deprecated -- use matplotlib.cbook.get_sample_data\n                                      instead\n    \"\"\"\n    raise NotImplementedError('get_example_data is deprecated -- use '\n                              'matplotlib.cbook.get_sample_data instead')\n\n\ndef get_py2exe_datafiles():\n    datapath = get_data_path()\n    _, tail = os.path.split(datapath)\n    d = {}\n    for root, _, files in os.walk(datapath):\n        # Need to explicitly remove cocoa_agg files or py2exe complains\n        # NOTE I dont know why, but do as previous version\n        if 'Matplotlib.nib' in files:\n            files.remove('Matplotlib.nib')\n        files = [os.path.join(root, filename) for filename in files]\n        root = root.replace(tail, 'mpl-data')\n        root = root[root.index('mpl-data'):]\n        d[root] = files\n    return list(d.items())\n\n\ndef matplotlib_fname():\n    \"\"\"\n    Get the location of the config file.\n\n    The file location is determined in the following order\n\n    - `$PWD/matplotlibrc`\n\n    - environment variable `MATPLOTLIBRC`\n\n    - `$MPLCONFIGDIR/matplotlib`\n\n    - On Linux,\n\n          - `$HOME/.matplotlib/matplotlibrc`, if it exists\n\n          - or `$XDG_CONFIG_HOME/matplotlib/matplotlibrc` (if\n            $XDG_CONFIG_HOME is defined)\n\n          - or `$HOME/.config/matplotlib/matplotlibrc` (if\n            $XDG_CONFIG_HOME is not defined)\n\n    - On other platforms,\n\n         - `$HOME/.matplotlib/matplotlibrc` if `$HOME` is defined.\n\n    - Lastly, it looks in `$MATPLOTLIBDATA/matplotlibrc` for a\n      system-defined copy.\n    \"\"\"\n    if six.PY2:\n        cwd = os.getcwdu()\n    else:\n        cwd = os.getcwd()\n    fname = os.path.join(cwd, 'matplotlibrc')\n    if os.path.exists(fname):\n        return fname\n\n    if 'MATPLOTLIBRC' in os.environ:\n        path = os.environ['MATPLOTLIBRC']\n        if os.path.exists(path):\n            fname = os.path.join(path, 'matplotlibrc')\n            if os.path.exists(fname):\n                return fname\n\n    configdir = _get_configdir()\n    if configdir is not None:\n        fname = os.path.join(configdir, 'matplotlibrc')\n        if os.path.exists(fname):\n            home = get_home()\n            if (sys.platform.startswith('linux') and\n                home is not None and\n                os.path.exists(os.path.join(\n                    home, '.matplotlib', 'matplotlibrc'))):\n                warnings.warn(\n                    \"Found matplotlib configuration in ~/.matplotlib/. \"\n                    \"To conform with the XDG base directory standard, \"\n                    \"this configuration location has been deprecated \"\n                    \"on Linux, and the new location is now %s/matplotlib/. \"\n                    \"Please move your configuration there to ensure that \"\n                    \"matplotlib will continue to find it in the future.\" %\n                    _get_xdg_config_dir())\n                return os.path.join(\n                    home, '.matplotlib', 'matplotlibrc')\n            return fname\n\n    path = get_data_path()  # guaranteed to exist or raise\n    fname = os.path.join(path, 'matplotlibrc')\n    if not os.path.exists(fname):\n        warnings.warn('Could not find matplotlibrc; using defaults')\n\n    return fname\n\n\n_deprecated_map = {\n    'text.fontstyle':   ('font.style', lambda x: x),\n    'text.fontangle':   ('font.style', lambda x: x),\n    'text.fontvariant': ('font.variant', lambda x: x),\n    'text.fontweight':  ('font.weight', lambda x: x),\n    'text.fontsize':    ('font.size', lambda x: x),\n    'tick.size':        ('tick.major.size', lambda x: x),\n    'svg.embed_char_paths': ('svg.fonttype',\n                             lambda x: \"path\" if x else \"none\"),\n    'savefig.extension': ('savefig.format', lambda x: x),\n    }\n\n_deprecated_ignore_map = {\n    }\n\n\nclass RcParams(dict):\n\n    \"\"\"\n    A dictionary object including validation\n\n    validating functions are defined and associated with rc parameters in\n    :mod:`matplotlib.rcsetup`\n    \"\"\"\n\n    validate = dict((key, converter) for key, (default, converter) in\n                    six.iteritems(defaultParams))\n    msg_depr = \"%s is deprecated and replaced with %s; please use the latter.\"\n    msg_depr_ignore = \"%s is deprecated and ignored. Use %s\"\n\n    def __setitem__(self, key, val):\n        try:\n            if key in _deprecated_map:\n                alt_key, alt_val = _deprecated_map[key]\n                warnings.warn(self.msg_depr % (key, alt_key))\n                key = alt_key\n                val = alt_val(val)\n            elif key in _deprecated_ignore_map:\n                alt = _deprecated_ignore_map[key]\n                warnings.warn(self.msg_depr_ignore % (key, alt))\n                return\n            try:\n                cval = self.validate[key](val)\n            except ValueError as ve:\n                raise ValueError(\"Key %s: %s\" % (key, str(ve)))\n            dict.__setitem__(self, key, cval)\n        except KeyError:\n            raise KeyError('%s is not a valid rc parameter.\\\nSee rcParams.keys() for a list of valid parameters.' % (key,))\n\n    def __getitem__(self, key):\n        if key in _deprecated_map:\n            alt_key, alt_val = _deprecated_map[key]\n            warnings.warn(self.msg_depr % (key, alt_key))\n            key = alt_key\n        elif key in _deprecated_ignore_map:\n            alt = _deprecated_ignore_map[key]\n            warnings.warn(self.msg_depr_ignore % (key, alt))\n            key = alt\n        return dict.__getitem__(self, key)\n\n    def __repr__(self):\n        import pprint\n        class_name = self.__class__.__name__\n        indent = len(class_name) + 1\n        repr_split = pprint.pformat(dict(self), indent=1,\n                                    width=80 - indent).split('\\n')\n        repr_indented = ('\\n' + ' ' * indent).join(repr_split)\n        return '{0}({1})'.format(class_name, repr_indented)\n\n    def __str__(self):\n        return '\\n'.join('{0}: {1}'.format(k, v)\n                         for k, v in sorted(self.items()))\n\n    def keys(self):\n        \"\"\"\n        Return sorted list of keys.\n        \"\"\"\n        k = list(dict.keys(self))\n        k.sort()\n        return k\n\n    def values(self):\n        \"\"\"\n        Return values in order of sorted keys.\n        \"\"\"\n        return [self[k] for k in self.keys()]\n\n    def find_all(self, pattern):\n        \"\"\"\n        Return the subset of this RcParams dictionary whose keys match,\n        using :func:`re.search`, the given ``pattern``.\n\n        .. note::\n\n            Changes to the returned dictionary are *not* propagated to\n            the parent RcParams dictionary.\n\n        \"\"\"\n        import re\n        pattern_re = re.compile(pattern)\n        return RcParams((key, value)\n                        for key, value in self.items()\n                        if pattern_re.search(key))\n\n\ndef rc_params(fail_on_error=False):\n    \"\"\"Return a :class:`matplotlib.RcParams` instance from the\n    default matplotlib rc file.\n    \"\"\"\n    fname = matplotlib_fname()\n    if not os.path.exists(fname):\n        # this should never happen, default in mpl-data should always be found\n        message = 'could not find rc file; returning defaults'\n        ret = RcParams([(key, default) for key, (default, _) in\n                        six.iteritems(defaultParams)])\n        warnings.warn(message)\n        return ret\n\n    return rc_params_from_file(fname, fail_on_error)\n\n\nURL_REGEX = re.compile(r'http://|https://|ftp://|file://|file:\\\\')\n\n\ndef is_url(filename):\n    \"\"\"Return True if string is an http, ftp, or file URL path.\"\"\"\n    return URL_REGEX.match(filename) is not None\n\n\ndef _url_lines(f):\n    # Compatibility for urlopen in python 3, which yields bytes.\n    for line in f:\n        yield line.decode('utf8')\n\n\n@contextlib.contextmanager\ndef _open_file_or_url(fname):\n    if is_url(fname):\n        f = urlopen(fname)\n        yield _url_lines(f)\n        f.close()\n    else:\n        with io.open(fname, encoding=locale.getdefaultlocale()[1]) as f:\n            yield f\n\n\n_error_details_fmt = 'line #%d\\n\\t\"%s\"\\n\\tin file \"%s\"'\n\n\ndef _rc_params_in_file(fname, fail_on_error=False):\n    \"\"\"Return :class:`matplotlib.RcParams` from the contents of the given file.\n\n    Unlike `rc_params_from_file`, the configuration class only contains the\n    parameters specified in the file (i.e. default values are not filled in).\n    \"\"\"\n    cnt = 0\n    rc_temp = {}\n    with _open_file_or_url(fname) as fd:\n        for line in fd:\n            cnt += 1\n            strippedline = line.split('#', 1)[0].strip()\n            if not strippedline:\n                continue\n            tup = strippedline.split(':', 1)\n            if len(tup) != 2:\n                error_details = _error_details_fmt % (cnt, line, fname)\n                warnings.warn('Illegal %s' % error_details)\n                continue\n            key, val = tup\n            key = key.strip()\n            val = val.strip()\n            if key in rc_temp:\n                warnings.warn('Duplicate key in file \"%s\", line #%d' %\n                              (fname, cnt))\n            rc_temp[key] = (val, line, cnt)\n\n    config = RcParams()\n\n    for key in ('verbose.level', 'verbose.fileo'):\n        if key in rc_temp:\n            val, line, cnt = rc_temp.pop(key)\n            if fail_on_error:\n                config[key] = val  # try to convert to proper type or raise\n            else:\n                try:\n                    config[key] = val  # try to convert to proper type or skip\n                except Exception as msg:\n                    error_details = _error_details_fmt % (cnt, line, fname)\n                    warnings.warn('Bad val \"%s\" on %s\\n\\t%s' %\n                                  (val, error_details, msg))\n\n    for key, (val, line, cnt) in six.iteritems(rc_temp):\n        if key in defaultParams:\n            if fail_on_error:\n                config[key] = val  # try to convert to proper type or raise\n            else:\n                try:\n                    config[key] = val  # try to convert to proper type or skip\n                except Exception as msg:\n                    error_details = _error_details_fmt % (cnt, line, fname)\n                    warnings.warn('Bad val \"%s\" on %s\\n\\t%s' %\n                                  (val, error_details, msg))\n        elif key in _deprecated_ignore_map:\n            warnings.warn('%s is deprecated. Update your matplotlibrc to use '\n                          '%s instead.' % (key, _deprecated_ignore_map[key]))\n\n        else:\n            print(\"\"\"\nBad key \"%s\" on line %d in\n%s.\nYou probably need to get an updated matplotlibrc file from\nhttp://matplotlib.sf.net/_static/matplotlibrc or from the matplotlib source\ndistribution\"\"\" % (key, cnt, fname), file=sys.stderr)\n\n    return config\n\n\ndef rc_params_from_file(fname, fail_on_error=False, use_default_template=True):\n    \"\"\"Return :class:`matplotlib.RcParams` from the contents of the given file.\n\n    Parameters\n    ----------\n    fname : str\n        Name of file parsed for matplotlib settings.\n    fail_on_error : bool\n        If True, raise an error when the parser fails to convert a parameter.\n    use_default_template : bool\n        If True, initialize with default parameters before updating with those\n        in the given file. If False, the configuration class only contains the\n        parameters specified in the file. (Useful for updating dicts.)\n    \"\"\"\n    config_from_file = _rc_params_in_file(fname, fail_on_error)\n\n    if not use_default_template:\n        return config_from_file\n\n    iter_params = six.iteritems(defaultParams)\n    config = RcParams([(key, default) for key, (default, _) in iter_params])\n    config.update(config_from_file)\n\n    verbose.set_level(config['verbose.level'])\n    verbose.set_fileo(config['verbose.fileo'])\n\n    if config['datapath'] is None:\n        config['datapath'] = get_data_path()\n\n    if not config['text.latex.preamble'] == ['']:\n        verbose.report(\"\"\"\n*****************************************************************\nYou have the following UNSUPPORTED LaTeX preamble customizations:\n%s\nPlease do not ask for support with these customizations active.\n*****************************************************************\n\"\"\" % '\\n'.join(config['text.latex.preamble']), 'helpful')\n\n    verbose.report('loaded rc file %s' % fname)\n\n    return config\n\n\n# this is the instance used by the matplotlib classes\nrcParams = rc_params()\n\nif rcParams['examples.directory']:\n    # paths that are intended to be relative to matplotlib_fname()\n    # are allowed for the examples.directory parameter.\n    # However, we will need to fully qualify the path because\n    # Sphinx requires absolute paths.\n    if not os.path.isabs(rcParams['examples.directory']):\n        _basedir, _fname = os.path.split(matplotlib_fname())\n        # Sometimes matplotlib_fname() can return relative paths,\n        # Also, using realpath() guarentees that Sphinx will use\n        # the same path that matplotlib sees (in case of weird symlinks).\n        _basedir = os.path.realpath(_basedir)\n        _fullpath = os.path.join(_basedir, rcParams['examples.directory'])\n        rcParams['examples.directory'] = _fullpath\n\nrcParamsOrig = rcParams.copy()\n\nrcParamsDefault = RcParams([(key, default) for key, (default, converter) in\n                            six.iteritems(defaultParams)])\n\nrcParams['ps.usedistiller'] = checkdep_ps_distiller(\n    rcParams['ps.usedistiller']\n)\nrcParams['text.usetex'] = checkdep_usetex(rcParams['text.usetex'])\n\nif rcParams['axes.formatter.use_locale']:\n    import locale\n    locale.setlocale(locale.LC_ALL, '')\n\n\ndef rc(group, **kwargs):\n    \"\"\"\n    Set the current rc params.  Group is the grouping for the rc, e.g.,\n    for ``lines.linewidth`` the group is ``lines``, for\n    ``axes.facecolor``, the group is ``axes``, and so on.  Group may\n    also be a list or tuple of group names, e.g., (*xtick*, *ytick*).\n    *kwargs* is a dictionary attribute name/value pairs, eg::\n\n      rc('lines', linewidth=2, color='r')\n\n    sets the current rc params and is equivalent to::\n\n      rcParams['lines.linewidth'] = 2\n      rcParams['lines.color'] = 'r'\n\n    The following aliases are available to save typing for interactive\n    users:\n\n    =====   =================\n    Alias   Property\n    =====   =================\n    'lw'    'linewidth'\n    'ls'    'linestyle'\n    'c'     'color'\n    'fc'    'facecolor'\n    'ec'    'edgecolor'\n    'mew'   'markeredgewidth'\n    'aa'    'antialiased'\n    =====   =================\n\n    Thus you could abbreviate the above rc command as::\n\n          rc('lines', lw=2, c='r')\n\n\n    Note you can use python's kwargs dictionary facility to store\n    dictionaries of default parameters.  e.g., you can customize the\n    font rc as follows::\n\n      font = {'family' : 'monospace',\n              'weight' : 'bold',\n              'size'   : 'larger'}\n\n      rc('font', **font)  # pass in the font dict as kwargs\n\n    This enables you to easily switch between several configurations.\n    Use :func:`~matplotlib.pyplot.rcdefaults` to restore the default\n    rc params after changes.\n    \"\"\"\n\n    aliases = {\n        'lw':  'linewidth',\n        'ls':  'linestyle',\n        'c':   'color',\n        'fc':  'facecolor',\n        'ec':  'edgecolor',\n        'mew': 'markeredgewidth',\n        'aa':  'antialiased',\n        }\n\n    if is_string_like(group):\n        group = (group,)\n    for g in group:\n        for k, v in six.iteritems(kwargs):\n            name = aliases.get(k) or k\n            key = '%s.%s' % (g, name)\n            try:\n                rcParams[key] = v\n            except KeyError:\n                raise KeyError(('Unrecognized key \"%s\" for group \"%s\" and '\n                                'name \"%s\"') % (key, g, name))\n\n\ndef rcdefaults():\n    \"\"\"\n    Restore the default rc params.  These are not the params loaded by\n    the rc file, but mpl's internal params.  See rc_file_defaults for\n    reloading the default params from the rc file\n    \"\"\"\n    rcParams.clear()\n    rcParams.update(rcParamsDefault)\n\n\ndef rc_file(fname):\n    \"\"\"\n    Update rc params from file.\n    \"\"\"\n    rcParams.update(rc_params_from_file(fname))\n\n\nclass rc_context(object):\n    \"\"\"\n    Return a context manager for managing rc settings.\n\n    This allows one to do::\n\n        with mpl.rc_context(fname='screen.rc'):\n            plt.plot(x, a)\n            with mpl.rc_context(fname='print.rc'):\n                plt.plot(x, b)\n            plt.plot(x, c)\n\n    The 'a' vs 'x' and 'c' vs 'x' plots would have settings from\n    'screen.rc', while the 'b' vs 'x' plot would have settings from\n    'print.rc'.\n\n    A dictionary can also be passed to the context manager::\n\n        with mpl.rc_context(rc={'text.usetex': True}, fname='screen.rc'):\n            plt.plot(x, a)\n\n    The 'rc' dictionary takes precedence over the settings loaded from\n    'fname'.  Passing a dictionary only is also valid.\n    \"\"\"\n\n    def __init__(self, rc=None, fname=None):\n        self.rcdict = rc\n        self.fname = fname\n        self._rcparams = rcParams.copy()\n        if self.fname:\n            rc_file(self.fname)\n        if self.rcdict:\n            rcParams.update(self.rcdict)\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, type, value, tb):\n        rcParams.update(self._rcparams)\n\n\ndef rc_file_defaults():\n    \"\"\"\n    Restore the default rc params from the original matplotlib rc that\n    was loaded\n    \"\"\"\n    rcParams.update(rcParamsOrig)\n\n_use_error_msg = \"\"\" This call to matplotlib.use() has no effect\nbecause the backend has already been chosen;\nmatplotlib.use() must be called *before* pylab, matplotlib.pyplot,\nor matplotlib.backends is imported for the first time.\n\"\"\"\n\n\ndef use(arg, warn=True, force=False):\n    \"\"\"\n    Set the matplotlib backend to one of the known backends.\n\n    The argument is case-insensitive. *warn* specifies whether a\n    warning should be issued if a backend has already been set up.\n    *force* is an **experimental** flag that tells matplotlib to\n    attempt to initialize a new backend by reloading the backend\n    module.\n\n    .. note::\n\n        This function must be called *before* importing pyplot for\n        the first time; or, if you are not using pyplot, it must be called\n        before importing matplotlib.backends.  If warn is True, a warning\n        is issued if you try and call this after pylab or pyplot have been\n        loaded.  In certain black magic use cases, e.g.\n        :func:`pyplot.switch_backend`, we are doing the reloading necessary to\n        make the backend switch work (in some cases, e.g., pure image\n        backends) so one can set warn=False to suppress the warnings.\n\n    To find out which backend is currently set, see\n    :func:`matplotlib.get_backend`.\n\n    \"\"\"\n    # Lets determine the proper backend name first\n    if arg.startswith('module://'):\n        name = arg\n    else:\n        # Lowercase only non-module backend names (modules are case-sensitive)\n        arg = arg.lower()\n        name = validate_backend(arg)\n\n    # Check if we've already set up a backend\n    if 'matplotlib.backends' in sys.modules:\n        # Warn only if called with a different name\n        if (rcParams['backend'] != name) and warn:\n            warnings.warn(_use_error_msg)\n\n        # Unless we've been told to force it, just return\n        if not force:\n            return\n        need_reload = True\n    else:\n        need_reload = False\n\n    # Store the backend name\n    rcParams['backend'] = name\n\n    # If needed we reload here because a lot of setup code is triggered on\n    # module import. See backends/__init__.py for more detail.\n    if need_reload:\n        reload(sys.modules['matplotlib.backends'])\n\n\ndef get_backend():\n    \"\"\"Return the name of the current backend.\"\"\"\n    return rcParams['backend']\n\n\ndef interactive(b):\n    \"\"\"\n    Set interactive mode to boolean b.\n\n    If b is True, then draw after every plotting command, eg, after xlabel\n    \"\"\"\n    rcParams['interactive'] = b\n\n\ndef is_interactive():\n    'Return true if plot mode is interactive'\n    return rcParams['interactive']\n\n\ndef tk_window_focus():\n    \"\"\"Return true if focus maintenance under TkAgg on win32 is on.\n     This currently works only for python.exe and IPython.exe.\n     Both IDLE and Pythonwin.exe fail badly when tk_window_focus is on.\"\"\"\n    if rcParams['backend'] != 'TkAgg':\n        return False\n    return rcParams['tk.window_focus']\n\n# Now allow command line to override\n\n# Allow command line access to the backend with -d (MATLAB compatible\n# flag)\n\nfor s in sys.argv[1:]:\n    # cast to str because we are using unicode_literals,\n    # and argv is always str\n    if s.startswith(str('-d')) and len(s) > 2:  # look for a -d flag\n        try:\n            use(s[2:])\n        except (KeyError, ValueError):\n            pass\n        # we don't want to assume all -d flags are backends, eg -debug\n\ndefault_test_modules = [\n    'matplotlib.tests.test_agg',\n    'matplotlib.tests.test_animation',\n    'matplotlib.tests.test_arrow_patches',\n    'matplotlib.tests.test_artist',\n    'matplotlib.tests.test_axes',\n    'matplotlib.tests.test_axes_grid1',\n    'matplotlib.tests.test_backend_pdf',\n    'matplotlib.tests.test_backend_pgf',\n    'matplotlib.tests.test_backend_ps',\n    'matplotlib.tests.test_backend_qt4',\n    'matplotlib.tests.test_backend_svg',\n    'matplotlib.tests.test_basic',\n    'matplotlib.tests.test_bbox_tight',\n    'matplotlib.tests.test_cbook',\n    'matplotlib.tests.test_coding_standards',\n    'matplotlib.tests.test_collections',\n    'matplotlib.tests.test_colorbar',\n    'matplotlib.tests.test_colors',\n    'matplotlib.tests.test_compare_images',\n    'matplotlib.tests.test_contour',\n    'matplotlib.tests.test_dates',\n    'matplotlib.tests.test_delaunay',\n    'matplotlib.tests.test_figure',\n    'matplotlib.tests.test_font_manager',\n    'matplotlib.tests.test_gridspec',\n    'matplotlib.tests.test_image',\n    'matplotlib.tests.test_legend',\n    'matplotlib.tests.test_lines',\n    'matplotlib.tests.test_mathtext',\n    'matplotlib.tests.test_mlab',\n    'matplotlib.tests.test_patches',\n    'matplotlib.tests.test_path',\n    'matplotlib.tests.test_patheffects',\n    'matplotlib.tests.test_pickle',\n    'matplotlib.tests.test_png',\n    'matplotlib.tests.test_quiver',\n    'matplotlib.tests.test_rcparams',\n    'matplotlib.tests.test_scale',\n    'matplotlib.tests.test_simplification',\n    'matplotlib.tests.test_spines',\n    'matplotlib.tests.test_streamplot',\n    'matplotlib.tests.test_style',\n    'matplotlib.tests.test_subplots',\n    'matplotlib.tests.test_table',\n    'matplotlib.tests.test_text',\n    'matplotlib.tests.test_ticker',\n    'matplotlib.tests.test_tightlayout',\n    'matplotlib.tests.test_transforms',\n    'matplotlib.tests.test_triangulation',\n    'mpl_toolkits.tests.test_mplot3d',\n    ]\n\n\ndef test(verbosity=1):\n    \"\"\"run the matplotlib test suite\"\"\"\n    try:\n        import faulthandler\n    except ImportError:\n        pass\n    else:\n        faulthandler.enable()\n\n    old_backend = rcParams['backend']\n    try:\n        use('agg')\n        import nose\n        import nose.plugins.builtin\n        from .testing.noseclasses import KnownFailure\n        from nose.plugins.manager import PluginManager\n        from nose.plugins import multiprocess\n\n        # store the old values before overriding\n        plugins = []\n        plugins.append(KnownFailure())\n        plugins.extend([plugin() for plugin in nose.plugins.builtin.plugins])\n\n        manager = PluginManager(plugins=plugins)\n        config = nose.config.Config(verbosity=verbosity, plugins=manager)\n\n        # Nose doesn't automatically instantiate all of the plugins in the\n        # child processes, so we have to provide the multiprocess plugin with\n        # a list.\n        multiprocess._instantiate_plugins = [KnownFailure]\n\n        success = nose.run(\n            defaultTest=default_test_modules,\n            config=config,\n        )\n    finally:\n        if old_backend.lower() != 'agg':\n            use(old_backend)\n\n    return success\n\ntest.__test__ = False  # nose: this function is not a test\n\nverbose.report('matplotlib version %s' % __version__)\nverbose.report('verbose.level %s' % verbose.level)\nverbose.report('interactive is %s' % is_interactive())\nverbose.report('platform is %s' % sys.platform)\nverbose.report('loaded modules: %s' % six.iterkeys(sys.modules), 'debug')\n", "patch": "@@ -1405,6 +1405,13 @@ def tk_window_focus():\n \n def test(verbosity=1):\n     \"\"\"run the matplotlib test suite\"\"\"\n+    try:\n+        import faulthandler\n+    except ImportError:\n+        pass\n+    else:\n+        faulthandler.enable()\n+\n     old_backend = rcParams['backend']\n     try:\n         use('agg')"}
{"patches_id": 2, "files_id": 6, "language": "py", "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Faxes%2F_base.py", "raw_code": "from __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport six\nfrom six.moves import xrange\n\nimport itertools\nimport warnings\nimport math\nfrom operator import itemgetter\n\nimport numpy as np\nfrom numpy import ma\n\nimport matplotlib\nrcParams = matplotlib.rcParams\n\nfrom matplotlib import cbook\nfrom matplotlib.cbook import _string_to_bool\nfrom matplotlib import docstring\nimport matplotlib.colors as mcolors\nimport matplotlib.lines as mlines\nimport matplotlib.patches as mpatches\nimport matplotlib.artist as martist\nimport matplotlib.transforms as mtransforms\nimport matplotlib.ticker as mticker\nimport matplotlib.axis as maxis\nimport matplotlib.scale as mscale\nimport matplotlib.spines as mspines\nimport matplotlib.font_manager as font_manager\nimport matplotlib.text as mtext\nimport matplotlib.image as mimage\nfrom matplotlib.artist import allow_rasterization\n\n\nfrom matplotlib.cbook import iterable\n\n\nis_string_like = cbook.is_string_like\nis_sequence_of_strings = cbook.is_sequence_of_strings\n\n\ndef _process_plot_format(fmt):\n    \"\"\"\n    Process a MATLAB style color/line style format string.  Return a\n    (*linestyle*, *color*) tuple as a result of the processing.  Default\n    values are ('-', 'b').  Example format strings include:\n\n    * 'ko': black circles\n    * '.b': blue dots\n    * 'r--': red dashed lines\n\n    .. seealso::\n\n        :func:`~matplotlib.Line2D.lineStyles` and\n        :func:`~matplotlib.pyplot.colors`\n            for all possible styles and color format string.\n    \"\"\"\n\n    linestyle = None\n    marker = None\n    color = None\n\n    # Is fmt just a colorspec?\n    try:\n        color = mcolors.colorConverter.to_rgb(fmt)\n\n        # We need to differentiate grayscale '1.0' from tri_down marker '1'\n        try:\n            fmtint = str(int(fmt))\n        except ValueError:\n            return linestyle, marker, color  # Yes\n        else:\n            if fmt != fmtint:\n                # user definitely doesn't want tri_down marker\n                return linestyle, marker, color  # Yes\n            else:\n                # ignore converted color\n                color = None\n    except ValueError:\n        pass  # No, not just a color.\n\n    # handle the multi char special cases and strip them from the\n    # string\n    if fmt.find('--') >= 0:\n        linestyle = '--'\n        fmt = fmt.replace('--', '')\n    if fmt.find('-.') >= 0:\n        linestyle = '-.'\n        fmt = fmt.replace('-.', '')\n    if fmt.find(' ') >= 0:\n        linestyle = 'None'\n        fmt = fmt.replace(' ', '')\n\n    chars = [c for c in fmt]\n\n    for c in chars:\n        if c in mlines.lineStyles:\n            if linestyle is not None:\n                raise ValueError(\n                    'Illegal format string \"%s\"; two linestyle symbols' % fmt)\n            linestyle = c\n        elif c in mlines.lineMarkers:\n            if marker is not None:\n                raise ValueError(\n                    'Illegal format string \"%s\"; two marker symbols' % fmt)\n            marker = c\n        elif c in mcolors.colorConverter.colors:\n            if color is not None:\n                raise ValueError(\n                    'Illegal format string \"%s\"; two color symbols' % fmt)\n            color = c\n        else:\n            raise ValueError(\n                'Unrecognized character %c in format string' % c)\n\n    if linestyle is None and marker is None:\n        linestyle = rcParams['lines.linestyle']\n    if linestyle is None:\n        linestyle = 'None'\n    if marker is None:\n        marker = 'None'\n\n    return linestyle, marker, color\n\n\nclass _process_plot_var_args(object):\n    \"\"\"\n    Process variable length arguments to the plot command, so that\n    plot commands like the following are supported::\n\n      plot(t, s)\n      plot(t1, s1, t2, s2)\n      plot(t1, s1, 'ko', t2, s2)\n      plot(t1, s1, 'ko', t2, s2, 'r--', t3, e3)\n\n    an arbitrary number of *x*, *y*, *fmt* are allowed\n    \"\"\"\n    def __init__(self, axes, command='plot'):\n        self.axes = axes\n        self.command = command\n        self.set_color_cycle()\n\n    def __getstate__(self):\n        # note: it is not possible to pickle a itertools.cycle instance\n        return {'axes': self.axes, 'command': self.command}\n\n    def __setstate__(self, state):\n        self.__dict__ = state.copy()\n        self.set_color_cycle()\n\n    def set_color_cycle(self, clist=None):\n        if clist is None:\n            clist = rcParams['axes.color_cycle']\n        self.color_cycle = itertools.cycle(clist)\n\n    def __call__(self, *args, **kwargs):\n\n        if self.axes.xaxis is not None and self.axes.yaxis is not None:\n            xunits = kwargs.pop('xunits', self.axes.xaxis.units)\n\n            if self.axes.name == 'polar':\n                xunits = kwargs.pop('thetaunits', xunits)\n\n            yunits = kwargs.pop('yunits', self.axes.yaxis.units)\n\n            if self.axes.name == 'polar':\n                yunits = kwargs.pop('runits', yunits)\n\n            if xunits != self.axes.xaxis.units:\n                self.axes.xaxis.set_units(xunits)\n\n            if yunits != self.axes.yaxis.units:\n                self.axes.yaxis.set_units(yunits)\n\n        ret = self._grab_next_args(*args, **kwargs)\n        return ret\n\n    def set_lineprops(self, line, **kwargs):\n        assert self.command == 'plot', 'set_lineprops only works with \"plot\"'\n        for key, val in six.iteritems(kwargs):\n            funcName = \"set_%s\" % key\n            if not hasattr(line, funcName):\n                raise TypeError('There is no line property \"%s\"' % key)\n            func = getattr(line, funcName)\n            func(val)\n\n    def set_patchprops(self, fill_poly, **kwargs):\n        assert self.command == 'fill', 'set_patchprops only works with \"fill\"'\n        for key, val in six.iteritems(kwargs):\n            funcName = \"set_%s\" % key\n            if not hasattr(fill_poly, funcName):\n                raise TypeError('There is no patch property \"%s\"' % key)\n            func = getattr(fill_poly, funcName)\n            func(val)\n\n    def _xy_from_xy(self, x, y):\n        if self.axes.xaxis is not None and self.axes.yaxis is not None:\n            bx = self.axes.xaxis.update_units(x)\n            by = self.axes.yaxis.update_units(y)\n\n            if self.command != 'plot':\n                # the Line2D class can handle unitized data, with\n                # support for post hoc unit changes etc.  Other mpl\n                # artists, eg Polygon which _process_plot_var_args\n                # also serves on calls to fill, cannot.  So this is a\n                # hack to say: if you are not \"plot\", which is\n                # creating Line2D, then convert the data now to\n                # floats.  If you are plot, pass the raw data through\n                # to Line2D which will handle the conversion.  So\n                # polygons will not support post hoc conversions of\n                # the unit type since they are not storing the orig\n                # data.  Hopefully we can rationalize this at a later\n                # date - JDH\n                if bx:\n                    x = self.axes.convert_xunits(x)\n                if by:\n                    y = self.axes.convert_yunits(y)\n\n        x = np.atleast_1d(x)  # like asanyarray, but converts scalar to array\n        y = np.atleast_1d(y)\n        if x.shape[0] != y.shape[0]:\n            raise ValueError(\"x and y must have same first dimension\")\n        if x.ndim > 2 or y.ndim > 2:\n            raise ValueError(\"x and y can be no greater than 2-D\")\n\n        if x.ndim == 1:\n            x = x[:, np.newaxis]\n        if y.ndim == 1:\n            y = y[:, np.newaxis]\n        return x, y\n\n    def _makeline(self, x, y, kw, kwargs):\n        kw = kw.copy()  # Don't modify the original kw.\n        if 'color' not in kw and 'color' not in kwargs:\n            kw['color'] = six.next(self.color_cycle)\n            # (can't use setdefault because it always evaluates\n            # its second argument)\n        seg = mlines.Line2D(x, y,\n                            axes=self.axes,\n                            **kw\n                            )\n        self.set_lineprops(seg, **kwargs)\n        return seg\n\n    def _makefill(self, x, y, kw, kwargs):\n        try:\n            facecolor = kw['color']\n        except KeyError:\n            facecolor = six.next(self.color_cycle)\n        seg = mpatches.Polygon(np.hstack((x[:, np.newaxis],\n                                          y[:, np.newaxis])),\n                               facecolor=facecolor,\n                               fill=True,\n                               closed=kw['closed'])\n        self.set_patchprops(seg, **kwargs)\n        return seg\n\n    def _plot_args(self, tup, kwargs):\n        ret = []\n        if len(tup) > 1 and is_string_like(tup[-1]):\n            linestyle, marker, color = _process_plot_format(tup[-1])\n            tup = tup[:-1]\n        elif len(tup) == 3:\n            raise ValueError('third arg must be a format string')\n        else:\n            linestyle, marker, color = None, None, None\n        kw = {}\n        for k, v in zip(('linestyle', 'marker', 'color'),\n                        (linestyle, marker, color)):\n            if v is not None:\n                kw[k] = v\n\n        y = np.atleast_1d(tup[-1])\n\n        if len(tup) == 2:\n            x = np.atleast_1d(tup[0])\n        else:\n            x = np.arange(y.shape[0], dtype=float)\n\n        x, y = self._xy_from_xy(x, y)\n\n        if self.command == 'plot':\n            func = self._makeline\n        else:\n            kw['closed'] = kwargs.get('closed', True)\n            func = self._makefill\n\n        ncx, ncy = x.shape[1], y.shape[1]\n        for j in xrange(max(ncx, ncy)):\n            seg = func(x[:, j % ncx], y[:, j % ncy], kw, kwargs)\n            ret.append(seg)\n        return ret\n\n    def _grab_next_args(self, *args, **kwargs):\n\n        remaining = args\n        while 1:\n\n            if len(remaining) == 0:\n                return\n            if len(remaining) <= 3:\n                for seg in self._plot_args(remaining, kwargs):\n                    yield seg\n                return\n\n            if is_string_like(remaining[2]):\n                isplit = 3\n            else:\n                isplit = 2\n\n            for seg in self._plot_args(remaining[:isplit], kwargs):\n                yield seg\n            remaining = remaining[isplit:]\n\n\nclass _AxesBase(martist.Artist):\n    \"\"\"\n    \"\"\"\n    name = \"rectilinear\"\n\n    _shared_x_axes = cbook.Grouper()\n    _shared_y_axes = cbook.Grouper()\n\n    def __str__(self):\n        return \"Axes(%g,%g;%gx%g)\" % tuple(self._position.bounds)\n\n    def __init__(self, fig, rect,\n                 axisbg=None,  # defaults to rc axes.facecolor\n                 frameon=True,\n                 sharex=None,  # use Axes instance's xaxis info\n                 sharey=None,  # use Axes instance's yaxis info\n                 label='',\n                 xscale=None,\n                 yscale=None,\n                 **kwargs\n                 ):\n        \"\"\"\n        Build an :class:`Axes` instance in\n        :class:`~matplotlib.figure.Figure` *fig* with\n        *rect=[left, bottom, width, height]* in\n        :class:`~matplotlib.figure.Figure` coordinates\n\n        Optional keyword arguments:\n\n          ================   =========================================\n          Keyword            Description\n          ================   =========================================\n          *adjustable*       [ 'box' | 'datalim' | 'box-forced']\n          *alpha*            float: the alpha transparency (can be None)\n          *anchor*           [ 'C', 'SW', 'S', 'SE', 'E', 'NE', 'N',\n                               'NW', 'W' ]\n          *aspect*           [ 'auto' | 'equal' | aspect_ratio ]\n          *autoscale_on*     [ *True* | *False* ] whether or not to\n                             autoscale the *viewlim*\n          *axis_bgcolor*     any matplotlib color, see\n                             :func:`~matplotlib.pyplot.colors`\n          *axisbelow*        draw the grids and ticks below the other\n                             artists\n          *cursor_props*     a (*float*, *color*) tuple\n          *figure*           a :class:`~matplotlib.figure.Figure`\n                             instance\n          *frame_on*         a boolean - draw the axes frame\n          *label*            the axes label\n          *navigate*         [ *True* | *False* ]\n          *navigate_mode*    [ 'PAN' | 'ZOOM' | None ] the navigation\n                             toolbar button status\n          *position*         [left, bottom, width, height] in\n                             class:`~matplotlib.figure.Figure` coords\n          *sharex*           an class:`~matplotlib.axes.Axes` instance\n                             to share the x-axis with\n          *sharey*           an class:`~matplotlib.axes.Axes` instance\n                             to share the y-axis with\n          *title*            the title string\n          *visible*          [ *True* | *False* ] whether the axes is\n                             visible\n          *xlabel*           the xlabel\n          *xlim*             (*xmin*, *xmax*) view limits\n          *xscale*           [%(scale)s]\n          *xticklabels*      sequence of strings\n          *xticks*           sequence of floats\n          *ylabel*           the ylabel strings\n          *ylim*             (*ymin*, *ymax*) view limits\n          *yscale*           [%(scale)s]\n          *yticklabels*      sequence of strings\n          *yticks*           sequence of floats\n          ================   =========================================\n        \"\"\" % {'scale': ' | '.join(\n            [repr(x) for x in mscale.get_scale_names()])}\n        martist.Artist.__init__(self)\n        if isinstance(rect, mtransforms.Bbox):\n            self._position = rect\n        else:\n            self._position = mtransforms.Bbox.from_bounds(*rect)\n        self._originalPosition = self._position.frozen()\n        self.set_axes(self)\n        self.set_aspect('auto')\n        self._adjustable = 'box'\n        self.set_anchor('C')\n        self._sharex = sharex\n        self._sharey = sharey\n        if sharex is not None:\n            self._shared_x_axes.join(self, sharex)\n            if sharex._adjustable == 'box':\n                sharex._adjustable = 'datalim'\n                #warnings.warn(\n                #    'shared axes: \"adjustable\" is being changed to \"datalim\"')\n            self._adjustable = 'datalim'\n        if sharey is not None:\n            self._shared_y_axes.join(self, sharey)\n            if sharey._adjustable == 'box':\n                sharey._adjustable = 'datalim'\n                #warnings.warn(\n                #    'shared axes: \"adjustable\" is being changed to \"datalim\"')\n            self._adjustable = 'datalim'\n        self.set_label(label)\n        self.set_figure(fig)\n\n        self.set_axes_locator(kwargs.get(\"axes_locator\", None))\n\n        self.spines = self._gen_axes_spines()\n\n        # this call may differ for non-sep axes, eg polar\n        self._init_axis()\n\n        if axisbg is None:\n            axisbg = rcParams['axes.facecolor']\n        self._axisbg = axisbg\n        self._frameon = frameon\n        self._axisbelow = rcParams['axes.axisbelow']\n\n        self._rasterization_zorder = None\n\n        self._hold = rcParams['axes.hold']\n        self._connected = {}  # a dict from events to (id, func)\n        self.cla()\n        # funcs used to format x and y - fall back on major formatters\n        self.fmt_xdata = None\n        self.fmt_ydata = None\n\n        self.set_cursor_props((1, 'k'))  # set the cursor properties for axes\n\n        self._cachedRenderer = None\n        self.set_navigate(True)\n        self.set_navigate_mode(None)\n\n        if xscale:\n            self.set_xscale(xscale)\n        if yscale:\n            self.set_yscale(yscale)\n\n        if len(kwargs):\n            self.update(kwargs)\n\n        if self.xaxis is not None:\n            self._xcid = self.xaxis.callbacks.connect('units finalize',\n                                                      self.relim)\n\n        if self.yaxis is not None:\n            self._ycid = self.yaxis.callbacks.connect('units finalize',\n                                                      self.relim)\n\n    def __setstate__(self, state):\n        self.__dict__ = state\n        # put the _remove_method back on all artists contained within the axes\n        for container_name in ['lines', 'collections', 'tables', 'patches',\n                               'texts', 'images']:\n            container = getattr(self, container_name)\n            for artist in container:\n                artist._remove_method = container.remove\n\n    def get_window_extent(self, *args, **kwargs):\n        \"\"\"\n        get the axes bounding box in display space; *args* and\n        *kwargs* are empty\n        \"\"\"\n        return self.bbox\n\n    def _init_axis(self):\n        \"move this out of __init__ because non-separable axes don't use it\"\n        self.xaxis = maxis.XAxis(self)\n        self.spines['bottom'].register_axis(self.xaxis)\n        self.spines['top'].register_axis(self.xaxis)\n        self.yaxis = maxis.YAxis(self)\n        self.spines['left'].register_axis(self.yaxis)\n        self.spines['right'].register_axis(self.yaxis)\n        self._update_transScale()\n\n    def set_figure(self, fig):\n        \"\"\"\n        Set the class:`~matplotlib.axes.Axes` figure\n\n        accepts a class:`~matplotlib.figure.Figure` instance\n        \"\"\"\n        martist.Artist.set_figure(self, fig)\n\n        self.bbox = mtransforms.TransformedBbox(self._position,\n                                                fig.transFigure)\n        # these will be updated later as data is added\n        self.dataLim = mtransforms.Bbox.null()\n        self.viewLim = mtransforms.Bbox.unit()\n        self.transScale = mtransforms.TransformWrapper(\n            mtransforms.IdentityTransform())\n\n        self._set_lim_and_transforms()\n\n    def _set_lim_and_transforms(self):\n        \"\"\"\n        set the *dataLim* and *viewLim*\n        :class:`~matplotlib.transforms.Bbox` attributes and the\n        *transScale*, *transData*, *transLimits* and *transAxes*\n        transformations.\n\n        .. note::\n\n            This method is primarily used by rectilinear projections\n            of the :class:`~matplotlib.axes.Axes` class, and is meant\n            to be overridden by new kinds of projection axes that need\n            different transformations and limits. (See\n            :class:`~matplotlib.projections.polar.PolarAxes` for an\n            example.\n\n        \"\"\"\n        self.transAxes = mtransforms.BboxTransformTo(self.bbox)\n\n        # Transforms the x and y axis separately by a scale factor.\n        # It is assumed that this part will have non-linear components\n        # (e.g., for a log scale).\n        self.transScale = mtransforms.TransformWrapper(\n            mtransforms.IdentityTransform())\n\n        # An affine transformation on the data, generally to limit the\n        # range of the axes\n        self.transLimits = mtransforms.BboxTransformFrom(\n            mtransforms.TransformedBbox(self.viewLim, self.transScale))\n\n        # The parentheses are important for efficiency here -- they\n        # group the last two (which are usually affines) separately\n        # from the first (which, with log-scaling can be non-affine).\n        self.transData = self.transScale + (self.transLimits + self.transAxes)\n\n        self._xaxis_transform = mtransforms.blended_transform_factory(\n            self.transData, self.transAxes)\n        self._yaxis_transform = mtransforms.blended_transform_factory(\n            self.transAxes, self.transData)\n\n    def get_xaxis_transform(self, which='grid'):\n        \"\"\"\n        Get the transformation used for drawing x-axis labels, ticks\n        and gridlines.  The x-direction is in data coordinates and the\n        y-direction is in axis coordinates.\n\n        .. note::\n\n            This transformation is primarily used by the\n            :class:`~matplotlib.axis.Axis` class, and is meant to be\n            overridden by new kinds of projections that may need to\n            place axis elements in different locations.\n\n        \"\"\"\n        if which == 'grid':\n            return self._xaxis_transform\n        elif which == 'tick1':\n            # for cartesian projection, this is bottom spine\n            return self.spines['bottom'].get_spine_transform()\n        elif which == 'tick2':\n            # for cartesian projection, this is top spine\n            return self.spines['top'].get_spine_transform()\n        else:\n            raise ValueError('unknown value for which')\n\n    def get_xaxis_text1_transform(self, pad_points):\n        \"\"\"\n        Get the transformation used for drawing x-axis labels, which\n        will add the given amount of padding (in points) between the\n        axes and the label.  The x-direction is in data coordinates\n        and the y-direction is in axis coordinates.  Returns a\n        3-tuple of the form::\n\n          (transform, valign, halign)\n\n        where *valign* and *halign* are requested alignments for the\n        text.\n\n        .. note::\n\n            This transformation is primarily used by the\n            :class:`~matplotlib.axis.Axis` class, and is meant to be\n            overridden by new kinds of projections that may need to\n            place axis elements in different locations.\n\n        \"\"\"\n        return (self.get_xaxis_transform(which='tick1') +\n                mtransforms.ScaledTranslation(0, -1 * pad_points / 72.0,\n                                              self.figure.dpi_scale_trans),\n                \"top\", \"center\")\n\n    def get_xaxis_text2_transform(self, pad_points):\n        \"\"\"\n        Get the transformation used for drawing the secondary x-axis\n        labels, which will add the given amount of padding (in points)\n        between the axes and the label.  The x-direction is in data\n        coordinates and the y-direction is in axis coordinates.\n        Returns a 3-tuple of the form::\n\n          (transform, valign, halign)\n\n        where *valign* and *halign* are requested alignments for the\n        text.\n\n        .. note::\n\n            This transformation is primarily used by the\n            :class:`~matplotlib.axis.Axis` class, and is meant to be\n            overridden by new kinds of projections that may need to\n            place axis elements in different locations.\n\n        \"\"\"\n        return (self.get_xaxis_transform(which='tick2') +\n                mtransforms.ScaledTranslation(0, pad_points / 72.0,\n                                              self.figure.dpi_scale_trans),\n                \"bottom\", \"center\")\n\n    def get_yaxis_transform(self, which='grid'):\n        \"\"\"\n        Get the transformation used for drawing y-axis labels, ticks\n        and gridlines.  The x-direction is in axis coordinates and the\n        y-direction is in data coordinates.\n\n        .. note::\n\n            This transformation is primarily used by the\n            :class:`~matplotlib.axis.Axis` class, and is meant to be\n            overridden by new kinds of projections that may need to\n            place axis elements in different locations.\n\n        \"\"\"\n        if which == 'grid':\n            return self._yaxis_transform\n        elif which == 'tick1':\n            # for cartesian projection, this is bottom spine\n            return self.spines['left'].get_spine_transform()\n        elif which == 'tick2':\n            # for cartesian projection, this is top spine\n            return self.spines['right'].get_spine_transform()\n        else:\n            raise ValueError('unknown value for which')\n\n    def get_yaxis_text1_transform(self, pad_points):\n        \"\"\"\n        Get the transformation used for drawing y-axis labels, which\n        will add the given amount of padding (in points) between the\n        axes and the label.  The x-direction is in axis coordinates\n        and the y-direction is in data coordinates.  Returns a 3-tuple\n        of the form::\n\n          (transform, valign, halign)\n\n        where *valign* and *halign* are requested alignments for the\n        text.\n\n        .. note::\n\n            This transformation is primarily used by the\n            :class:`~matplotlib.axis.Axis` class, and is meant to be\n            overridden by new kinds of projections that may need to\n            place axis elements in different locations.\n\n        \"\"\"\n        return (self.get_yaxis_transform(which='tick1') +\n                mtransforms.ScaledTranslation(-1 * pad_points / 72.0, 0,\n                                              self.figure.dpi_scale_trans),\n                \"center\", \"right\")\n\n    def get_yaxis_text2_transform(self, pad_points):\n        \"\"\"\n        Get the transformation used for drawing the secondary y-axis\n        labels, which will add the given amount of padding (in points)\n        between the axes and the label.  The x-direction is in axis\n        coordinates and the y-direction is in data coordinates.\n        Returns a 3-tuple of the form::\n\n          (transform, valign, halign)\n\n        where *valign* and *halign* are requested alignments for the\n        text.\n\n        .. note::\n\n            This transformation is primarily used by the\n            :class:`~matplotlib.axis.Axis` class, and is meant to be\n            overridden by new kinds of projections that may need to\n            place axis elements in different locations.\n\n        \"\"\"\n        return (self.get_yaxis_transform(which='tick2') +\n                mtransforms.ScaledTranslation(pad_points / 72.0, 0,\n                                              self.figure.dpi_scale_trans),\n                \"center\", \"left\")\n\n    def _update_transScale(self):\n        self.transScale.set(\n            mtransforms.blended_transform_factory(\n                self.xaxis.get_transform(), self.yaxis.get_transform()))\n        if hasattr(self, \"lines\"):\n            for line in self.lines:\n                try:\n                    line._transformed_path.invalidate()\n                except AttributeError:\n                    pass\n\n    def get_position(self, original=False):\n        'Return the a copy of the axes rectangle as a Bbox'\n        if original:\n            return self._originalPosition.frozen()\n        else:\n            return self._position.frozen()\n\n    def set_position(self, pos, which='both'):\n        \"\"\"\n        Set the axes position with::\n\n          pos = [left, bottom, width, height]\n\n        in relative 0,1 coords, or *pos* can be a\n        :class:`~matplotlib.transforms.Bbox`\n\n        There are two position variables: one which is ultimately\n        used, but which may be modified by :meth:`apply_aspect`, and a\n        second which is the starting point for :meth:`apply_aspect`.\n\n\n        Optional keyword arguments:\n          *which*\n\n            ==========   ====================\n            value        description\n            ==========   ====================\n            'active'     to change the first\n            'original'   to change the second\n            'both'       to change both\n            ==========   ====================\n\n        \"\"\"\n        if not isinstance(pos, mtransforms.BboxBase):\n            pos = mtransforms.Bbox.from_bounds(*pos)\n        if which in ('both', 'active'):\n            self._position.set(pos)\n        if which in ('both', 'original'):\n            self._originalPosition.set(pos)\n\n    def reset_position(self):\n        \"\"\"Make the original position the active position\"\"\"\n        pos = self.get_position(original=True)\n        self.set_position(pos, which='active')\n\n    def set_axes_locator(self, locator):\n        \"\"\"\n        set axes_locator\n\n        ACCEPT: a callable object which takes an axes instance and renderer and\n                 returns a bbox.\n        \"\"\"\n        self._axes_locator = locator\n\n    def get_axes_locator(self):\n        \"\"\"\n        return axes_locator\n        \"\"\"\n        return self._axes_locator\n\n    def _set_artist_props(self, a):\n        \"\"\"set the boilerplate props for artists added to axes\"\"\"\n        a.set_figure(self.figure)\n        if not a.is_transform_set():\n            a.set_transform(self.transData)\n\n        a.set_axes(self)\n\n    def _gen_axes_patch(self):\n        \"\"\"\n        Returns the patch used to draw the background of the axes.  It\n        is also used as the clipping path for any data elements on the\n        axes.\n\n        In the standard axes, this is a rectangle, but in other\n        projections it may not be.\n\n        .. note::\n\n            Intended to be overridden by new projection types.\n\n        \"\"\"\n        return mpatches.Rectangle((0.0, 0.0), 1.0, 1.0)\n\n    def _gen_axes_spines(self, locations=None, offset=0.0, units='inches'):\n        \"\"\"\n        Returns a dict whose keys are spine names and values are\n        Line2D or Patch instances. Each element is used to draw a\n        spine of the axes.\n\n        In the standard axes, this is a single line segment, but in\n        other projections it may not be.\n\n        .. note::\n\n            Intended to be overridden by new projection types.\n\n        \"\"\"\n        return {\n            'left': mspines.Spine.linear_spine(self, 'left'),\n            'right': mspines.Spine.linear_spine(self, 'right'),\n            'bottom': mspines.Spine.linear_spine(self, 'bottom'),\n            'top': mspines.Spine.linear_spine(self, 'top'), }\n\n    def cla(self):\n        \"\"\"Clear the current axes.\"\"\"\n        # Note: this is called by Axes.__init__()\n        self.xaxis.cla()\n        self.yaxis.cla()\n        for name, spine in six.iteritems(self.spines):\n            spine.cla()\n\n        self.ignore_existing_data_limits = True\n        self.callbacks = cbook.CallbackRegistry()\n\n        if self._sharex is not None:\n            # major and minor are class instances with\n            # locator and formatter attributes\n            self.xaxis.major = self._sharex.xaxis.major\n            self.xaxis.minor = self._sharex.xaxis.minor\n            x0, x1 = self._sharex.get_xlim()\n            self.set_xlim(x0, x1, emit=False, auto=None)\n\n            # Save the current formatter/locator so we don't lose it\n            majf = self._sharex.xaxis.get_major_formatter()\n            minf = self._sharex.xaxis.get_minor_formatter()\n            majl = self._sharex.xaxis.get_major_locator()\n            minl = self._sharex.xaxis.get_minor_locator()\n\n            # This overwrites the current formatter/locator\n            self.xaxis._set_scale(self._sharex.xaxis.get_scale())\n\n            # Reset the formatter/locator\n            self.xaxis.set_major_formatter(majf)\n            self.xaxis.set_minor_formatter(minf)\n            self.xaxis.set_major_locator(majl)\n            self.xaxis.set_minor_locator(minl)\n        else:\n            self.xaxis._set_scale('linear')\n\n        if self._sharey is not None:\n            self.yaxis.major = self._sharey.yaxis.major\n            self.yaxis.minor = self._sharey.yaxis.minor\n            y0, y1 = self._sharey.get_ylim()\n            self.set_ylim(y0, y1, emit=False, auto=None)\n\n            # Save the current formatter/locator so we don't lose it\n            majf = self._sharey.yaxis.get_major_formatter()\n            minf = self._sharey.yaxis.get_minor_formatter()\n            majl = self._sharey.yaxis.get_major_locator()\n            minl = self._sharey.yaxis.get_minor_locator()\n\n            # This overwrites the current formatter/locator\n            self.yaxis._set_scale(self._sharey.yaxis.get_scale())\n\n            # Reset the formatter/locator\n            self.yaxis.set_major_formatter(majf)\n            self.yaxis.set_minor_formatter(minf)\n            self.yaxis.set_major_locator(majl)\n            self.yaxis.set_minor_locator(minl)\n        else:\n            self.yaxis._set_scale('linear')\n\n        self._autoscaleXon = True\n        self._autoscaleYon = True\n        self._xmargin = rcParams['axes.xmargin']\n        self._ymargin = rcParams['axes.ymargin']\n        self._tight = False\n        self._update_transScale()  # needed?\n\n        self._get_lines = _process_plot_var_args(self)\n        self._get_patches_for_fill = _process_plot_var_args(self, 'fill')\n\n        self._gridOn = rcParams['axes.grid']\n        self.lines = []\n        self.patches = []\n        self.texts = []\n        self.tables = []\n        self.artists = []\n        self.images = []\n        self._current_image = None  # strictly for pyplot via _sci, _gci\n        self.legend_ = None\n        self.collections = []  # collection.Collection instances\n        self.containers = []\n\n        self.grid(self._gridOn, which=rcParams['axes.grid.which'])\n        props = font_manager.FontProperties(size=rcParams['axes.titlesize'],\n                                        weight=rcParams['axes.titleweight'])\n\n        self.titleOffsetTrans = mtransforms.ScaledTranslation(\n            0.0, 5.0 / 72.0, self.figure.dpi_scale_trans)\n        self.title = mtext.Text(\n            x=0.5, y=1.0, text='',\n            fontproperties=props,\n            verticalalignment='baseline',\n            horizontalalignment='center',\n            )\n        self._left_title = mtext.Text(\n            x=0.0, y=1.0, text='',\n            fontproperties=props.copy(),\n            verticalalignment='baseline',\n            horizontalalignment='left', )\n        self._right_title = mtext.Text(\n            x=1.0, y=1.0, text='',\n            fontproperties=props.copy(),\n            verticalalignment='baseline',\n            horizontalalignment='right',\n            )\n\n        for _title in (self.title, self._left_title, self._right_title):\n            _title.set_transform(self.transAxes + self.titleOffsetTrans)\n            _title.set_clip_box(None)\n            self._set_artist_props(_title)\n\n        # the patch draws the background of the axes.  we want this to\n        # be below the other artists; the axesPatch name is\n        # deprecated.  We use the frame to draw the edges so we are\n        # setting the edgecolor to None\n        self.patch = self.axesPatch = self._gen_axes_patch()\n        self.patch.set_figure(self.figure)\n        self.patch.set_facecolor(self._axisbg)\n        self.patch.set_edgecolor('None')\n        self.patch.set_linewidth(0)\n        self.patch.set_transform(self.transAxes)\n\n        self.axison = True\n\n        self.xaxis.set_clip_path(self.patch)\n        self.yaxis.set_clip_path(self.patch)\n\n        self._shared_x_axes.clean()\n        self._shared_y_axes.clean()\n\n    def clear(self):\n        \"\"\"clear the axes\"\"\"\n        self.cla()\n\n    def set_color_cycle(self, clist):\n        \"\"\"\n        Set the color cycle for any future plot commands on this Axes.\n\n        *clist* is a list of mpl color specifiers.\n        \"\"\"\n        self._get_lines.set_color_cycle(clist)\n        self._get_patches_for_fill.set_color_cycle(clist)\n\n    def ishold(self):\n        \"\"\"return the HOLD status of the axes\"\"\"\n        return self._hold\n\n    def hold(self, b=None):\n        \"\"\"\n        Call signature::\n\n          hold(b=None)\n\n        Set the hold state.  If *hold* is *None* (default), toggle the\n        *hold* state.  Else set the *hold* state to boolean value *b*.\n\n        Examples::\n\n          # toggle hold\n          hold()\n\n          # turn hold on\n          hold(True)\n\n          # turn hold off\n          hold(False)\n\n        When hold is *True*, subsequent plot commands will be added to\n        the current axes.  When hold is *False*, the current axes and\n        figure will be cleared on the next plot command\n\n        \"\"\"\n        if b is None:\n            self._hold = not self._hold\n        else:\n            self._hold = b\n\n    def get_aspect(self):\n        return self._aspect\n\n    def set_aspect(self, aspect, adjustable=None, anchor=None):\n        \"\"\"\n        *aspect*\n\n          ========   ================================================\n          value      description\n          ========   ================================================\n          'auto'     automatic; fill position rectangle with data\n          'normal'   same as 'auto'; deprecated\n          'equal'    same scaling from data to plot units for x and y\n           num       a circle will be stretched such that the height\n                     is num times the width. aspect=1 is the same as\n                     aspect='equal'.\n          ========   ================================================\n\n        *adjustable*\n\n          ============   =====================================\n          value          description\n          ============   =====================================\n          'box'          change physical size of axes\n          'datalim'      change xlim or ylim\n          'box-forced'   same as 'box', but axes can be shared\n          ============   =====================================\n\n        'box' does not allow axes sharing, as this can cause\n        unintended side effect. For cases when sharing axes is\n        fine, use 'box-forced'.\n\n        *anchor*\n\n          =====   =====================\n          value   description\n          =====   =====================\n          'C'     centered\n          'SW'    lower left corner\n          'S'     middle of bottom edge\n          'SE'    lower right corner\n          etc.\n          =====   =====================\n\n        .. deprecated:: 1.2\n            the option 'normal' for aspect is deprecated. Use 'auto' instead.\n        \"\"\"\n        if aspect == 'normal':\n            cbook.warn_deprecated(\n                '1.2', name='normal', alternative='auto', obj_type='aspect')\n            self._aspect = 'auto'\n\n        elif aspect in ('equal', 'auto'):\n            self._aspect = aspect\n        else:\n            self._aspect = float(aspect)  # raise ValueError if necessary\n\n        if adjustable is not None:\n            self.set_adjustable(adjustable)\n        if anchor is not None:\n            self.set_anchor(anchor)\n\n    def get_adjustable(self):\n        return self._adjustable\n\n    def set_adjustable(self, adjustable):\n        \"\"\"\n        ACCEPTS: [ 'box' | 'datalim' | 'box-forced']\n        \"\"\"\n        if adjustable in ('box', 'datalim', 'box-forced'):\n            if self in self._shared_x_axes or self in self._shared_y_axes:\n                if adjustable == 'box':\n                    raise ValueError(\n                        'adjustable must be \"datalim\" for shared axes')\n            self._adjustable = adjustable\n        else:\n            raise ValueError('argument must be \"box\", or \"datalim\"')\n\n    def get_anchor(self):\n        return self._anchor\n\n    def set_anchor(self, anchor):\n        \"\"\"\n        *anchor*\n\n          =====  ============\n          value  description\n          =====  ============\n          'C'    Center\n          'SW'   bottom left\n          'S'    bottom\n          'SE'   bottom right\n          'E'    right\n          'NE'   top right\n          'N'    top\n          'NW'   top left\n          'W'    left\n          =====  ============\n\n        \"\"\"\n        if (anchor in list(six.iterkeys(mtransforms.Bbox.coefs)) or\n                len(anchor) == 2):\n            self._anchor = anchor\n        else:\n            raise ValueError('argument must be among %s' %\n                             ', '.join(six.iterkeys(mtransforms.Bbox.coefs)))\n\n    def get_data_ratio(self):\n        \"\"\"\n        Returns the aspect ratio of the raw data.\n\n        This method is intended to be overridden by new projection\n        types.\n        \"\"\"\n        xmin, xmax = self.get_xbound()\n        ymin, ymax = self.get_ybound()\n\n        xsize = max(math.fabs(xmax - xmin), 1e-30)\n        ysize = max(math.fabs(ymax - ymin), 1e-30)\n\n        return ysize / xsize\n\n    def get_data_ratio_log(self):\n        \"\"\"\n        Returns the aspect ratio of the raw data in log scale.\n        Will be used when both axis scales are in log.\n        \"\"\"\n        xmin, xmax = self.get_xbound()\n        ymin, ymax = self.get_ybound()\n\n        xsize = max(math.fabs(math.log10(xmax) - math.log10(xmin)), 1e-30)\n        ysize = max(math.fabs(math.log10(ymax) - math.log10(ymin)), 1e-30)\n\n        return ysize / xsize\n\n    def apply_aspect(self, position=None):\n        \"\"\"\n        Use :meth:`_aspect` and :meth:`_adjustable` to modify the\n        axes box or the view limits.\n        \"\"\"\n        if position is None:\n            position = self.get_position(original=True)\n\n        aspect = self.get_aspect()\n\n        if self.name != 'polar':\n            xscale, yscale = self.get_xscale(), self.get_yscale()\n            if xscale == \"linear\" and yscale == \"linear\":\n                aspect_scale_mode = \"linear\"\n            elif xscale == \"log\" and yscale == \"log\":\n                aspect_scale_mode = \"log\"\n            elif ((xscale == \"linear\" and yscale == \"log\") or\n                  (xscale == \"log\" and yscale == \"linear\")):\n                if aspect != \"auto\":\n                    warnings.warn(\n                        'aspect is not supported for Axes with xscale=%s, '\n                        'yscale=%s' % (xscale, yscale))\n                    aspect = \"auto\"\n            else:  # some custom projections have their own scales.\n                pass\n        else:\n            aspect_scale_mode = \"linear\"\n\n        if aspect == 'auto':\n            self.set_position(position, which='active')\n            return\n\n        if aspect == 'equal':\n            A = 1\n        else:\n            A = aspect\n\n        #Ensure at drawing time that any Axes involved in axis-sharing\n        # does not have its position changed.\n        if self in self._shared_x_axes or self in self._shared_y_axes:\n            if self._adjustable == 'box':\n                self._adjustable = 'datalim'\n                warnings.warn(\n                    'shared axes: \"adjustable\" is being changed to \"datalim\"')\n\n        figW, figH = self.get_figure().get_size_inches()\n        fig_aspect = figH / figW\n        if self._adjustable in ['box', 'box-forced']:\n            if aspect_scale_mode == \"log\":\n                box_aspect = A * self.get_data_ratio_log()\n            else:\n                box_aspect = A * self.get_data_ratio()\n            pb = position.frozen()\n            pb1 = pb.shrunk_to_aspect(box_aspect, pb, fig_aspect)\n            self.set_position(pb1.anchored(self.get_anchor(), pb), 'active')\n            return\n\n        # reset active to original in case it had been changed\n        # by prior use of 'box'\n        self.set_position(position, which='active')\n\n        xmin, xmax = self.get_xbound()\n        ymin, ymax = self.get_ybound()\n\n        if aspect_scale_mode == \"log\":\n            xmin, xmax = math.log10(xmin), math.log10(xmax)\n            ymin, ymax = math.log10(ymin), math.log10(ymax)\n\n        xsize = max(math.fabs(xmax - xmin), 1e-30)\n        ysize = max(math.fabs(ymax - ymin), 1e-30)\n\n        l, b, w, h = position.bounds\n        box_aspect = fig_aspect * (h / w)\n        data_ratio = box_aspect / A\n\n        y_expander = (data_ratio * xsize / ysize - 1.0)\n        #print 'y_expander', y_expander\n        # If y_expander > 0, the dy/dx viewLim ratio needs to increase\n        if abs(y_expander) < 0.005:\n            #print 'good enough already'\n            return\n\n        if aspect_scale_mode == \"log\":\n            dL = self.dataLim\n            dL_width = math.log10(dL.x1) - math.log10(dL.x0)\n            dL_height = math.log10(dL.y1) - math.log10(dL.y0)\n            xr = 1.05 * dL_width\n            yr = 1.05 * dL_height\n        else:\n            dL = self.dataLim\n            xr = 1.05 * dL.width\n            yr = 1.05 * dL.height\n\n        xmarg = xsize - xr\n        ymarg = ysize - yr\n        Ysize = data_ratio * xsize\n        Xsize = ysize / data_ratio\n        Xmarg = Xsize - xr\n        Ymarg = Ysize - yr\n        xm = 0  # Setting these targets to, e.g., 0.05*xr does not seem to\n                # help.\n        ym = 0\n        #print 'xmin, xmax, ymin, ymax', xmin, xmax, ymin, ymax\n        #print 'xsize, Xsize, ysize, Ysize', xsize, Xsize, ysize, Ysize\n\n        changex = (self in self._shared_y_axes\n                   and self not in self._shared_x_axes)\n        changey = (self in self._shared_x_axes\n                   and self not in self._shared_y_axes)\n        if changex and changey:\n            warnings.warn(\"adjustable='datalim' cannot work with shared \"\n                          \"x and y axes\")\n            return\n        if changex:\n            adjust_y = False\n        else:\n            #print 'xmarg, ymarg, Xmarg, Ymarg', xmarg, ymarg, Xmarg, Ymarg\n            if xmarg > xm and ymarg > ym:\n                adjy = ((Ymarg > 0 and y_expander < 0)\n                        or (Xmarg < 0 and y_expander > 0))\n            else:\n                adjy = y_expander > 0\n            #print 'y_expander, adjy', y_expander, adjy\n            adjust_y = changey or adjy  # (Ymarg > xmarg)\n        if adjust_y:\n            yc = 0.5 * (ymin + ymax)\n            y0 = yc - Ysize / 2.0\n            y1 = yc + Ysize / 2.0\n            if aspect_scale_mode == \"log\":\n                self.set_ybound((10. ** y0, 10. ** y1))\n            else:\n                self.set_ybound((y0, y1))\n            #print 'New y0, y1:', y0, y1\n            #print 'New ysize, ysize/xsize', y1-y0, (y1-y0)/xsize\n        else:\n            xc = 0.5 * (xmin + xmax)\n            x0 = xc - Xsize / 2.0\n            x1 = xc + Xsize / 2.0\n            if aspect_scale_mode == \"log\":\n                self.set_xbound((10. ** x0, 10. ** x1))\n            else:\n                self.set_xbound((x0, x1))\n            #print 'New x0, x1:', x0, x1\n            #print 'New xsize, ysize/xsize', x1-x0, ysize/(x1-x0)\n\n    def axis(self, *v, **kwargs):\n        \"\"\"\n        Convenience method for manipulating the x and y view limits\n        and the aspect ratio of the plot. For details, see\n        :func:`~matplotlib.pyplot.axis`.\n\n        *kwargs* are passed on to :meth:`set_xlim` and\n        :meth:`set_ylim`\n        \"\"\"\n        if len(v) == 0 and len(kwargs) == 0:\n            xmin, xmax = self.get_xlim()\n            ymin, ymax = self.get_ylim()\n            return xmin, xmax, ymin, ymax\n\n        if len(v) == 1 and is_string_like(v[0]):\n            s = v[0].lower()\n            if s == 'on':\n                self.set_axis_on()\n            elif s == 'off':\n                self.set_axis_off()\n            elif s in ('equal', 'tight', 'scaled', 'normal', 'auto', 'image'):\n                self.set_autoscale_on(True)\n                self.set_aspect('auto')\n                self.autoscale_view(tight=False)\n                # self.apply_aspect()\n                if s == 'equal':\n                    self.set_aspect('equal', adjustable='datalim')\n                elif s == 'scaled':\n                    self.set_aspect('equal', adjustable='box', anchor='C')\n                    self.set_autoscale_on(False)  # Req. by Mark Bakker\n                elif s == 'tight':\n                    self.autoscale_view(tight=True)\n                    self.set_autoscale_on(False)\n                elif s == 'image':\n                    self.autoscale_view(tight=True)\n                    self.set_autoscale_on(False)\n                    self.set_aspect('equal', adjustable='box', anchor='C')\n\n            else:\n                raise ValueError('Unrecognized string %s to axis; '\n                                 'try on or off' % s)\n            xmin, xmax = self.get_xlim()\n            ymin, ymax = self.get_ylim()\n            return xmin, xmax, ymin, ymax\n\n        emit = kwargs.get('emit', True)\n        try:\n            v[0]\n        except IndexError:\n            xmin = kwargs.get('xmin', None)\n            xmax = kwargs.get('xmax', None)\n            auto = False  # turn off autoscaling, unless...\n            if xmin is None and xmax is None:\n                auto = None  # leave autoscaling state alone\n            xmin, xmax = self.set_xlim(xmin, xmax, emit=emit, auto=auto)\n\n            ymin = kwargs.get('ymin', None)\n            ymax = kwargs.get('ymax', None)\n            auto = False  # turn off autoscaling, unless...\n            if ymin is None and ymax is None:\n                auto = None  # leave autoscaling state alone\n            ymin, ymax = self.set_ylim(ymin, ymax, emit=emit, auto=auto)\n            return xmin, xmax, ymin, ymax\n\n        v = v[0]\n        if len(v) != 4:\n            raise ValueError('v must contain [xmin xmax ymin ymax]')\n\n        self.set_xlim([v[0], v[1]], emit=emit, auto=False)\n        self.set_ylim([v[2], v[3]], emit=emit, auto=False)\n\n        return v\n\n    def get_legend(self):\n        \"\"\"\n        Return the legend.Legend instance, or None if no legend is defined\n        \"\"\"\n        return self.legend_\n\n    def get_images(self):\n        \"\"\"return a list of Axes images contained by the Axes\"\"\"\n        return cbook.silent_list('AxesImage', self.images)\n\n    def get_lines(self):\n        \"\"\"Return a list of lines contained by the Axes\"\"\"\n        return cbook.silent_list('Line2D', self.lines)\n\n    def get_xaxis(self):\n        \"\"\"Return the XAxis instance\"\"\"\n        return self.xaxis\n\n    def get_xgridlines(self):\n        \"\"\"Get the x grid lines as a list of Line2D instances\"\"\"\n        return cbook.silent_list('Line2D xgridline',\n                                 self.xaxis.get_gridlines())\n\n    def get_xticklines(self):\n        \"\"\"Get the xtick lines as a list of Line2D instances\"\"\"\n        return cbook.silent_list('Text xtickline',\n                                 self.xaxis.get_ticklines())\n\n    def get_yaxis(self):\n        \"\"\"Return the YAxis instance\"\"\"\n        return self.yaxis\n\n    def get_ygridlines(self):\n        \"\"\"Get the y grid lines as a list of Line2D instances\"\"\"\n        return cbook.silent_list('Line2D ygridline',\n                                 self.yaxis.get_gridlines())\n\n    def get_yticklines(self):\n        \"\"\"Get the ytick lines as a list of Line2D instances\"\"\"\n        return cbook.silent_list('Line2D ytickline',\n                                 self.yaxis.get_ticklines())\n\n    #### Adding and tracking artists\n\n    def _sci(self, im):\n        \"\"\"\n        helper for :func:`~matplotlib.pyplot.sci`;\n        do not use elsewhere.\n        \"\"\"\n        if isinstance(im, matplotlib.contour.ContourSet):\n            if im.collections[0] not in self.collections:\n                raise ValueError(\n                    \"ContourSet must be in current Axes\")\n        elif im not in self.images and im not in self.collections:\n            raise ValueError(\n                \"Argument must be an image, collection, or ContourSet in \"\n                \"this Axes\")\n        self._current_image = im\n\n    def _gci(self):\n        \"\"\"\n        Helper for :func:`~matplotlib.pyplot.gci`;\n        do not use elsewhere.\n        \"\"\"\n        return self._current_image\n\n    def has_data(self):\n        \"\"\"\n        Return *True* if any artists have been added to axes.\n\n        This should not be used to determine whether the *dataLim*\n        need to be updated, and may not actually be useful for\n        anything.\n        \"\"\"\n        return (\n            len(self.collections) +\n            len(self.images) +\n            len(self.lines) +\n            len(self.patches)) > 0\n\n    def add_artist(self, a):\n        \"\"\"Add any :class:`~matplotlib.artist.Artist` to the axes.\n\n        Use `add_artist` only for artists for which there is no dedicated\n        \"add\" method; and if necessary, use a method such as\n        `update_datalim` or `update_datalim_numerix` to manually update the\n        dataLim if the artist is to be included in autoscaling.\n\n        Returns the artist.\n        \"\"\"\n        a.set_axes(self)\n        self.artists.append(a)\n        self._set_artist_props(a)\n        a.set_clip_path(self.patch)\n        a._remove_method = lambda h: self.artists.remove(h)\n        return a\n\n    def add_collection(self, collection, autolim=True):\n        \"\"\"\n        Add a :class:`~matplotlib.collections.Collection` instance\n        to the axes.\n\n        Returns the collection.\n        \"\"\"\n        label = collection.get_label()\n        if not label:\n            collection.set_label('_collection%d' % len(self.collections))\n        self.collections.append(collection)\n        self._set_artist_props(collection)\n\n        if collection.get_clip_path() is None:\n            collection.set_clip_path(self.patch)\n\n        if autolim:\n            self.update_datalim(collection.get_datalim(self.transData))\n\n        collection._remove_method = lambda h: self.collections.remove(h)\n        return collection\n\n    def add_image(self, image):\n        \"\"\"\n        Add a :class:`~matplotlib.image.AxesImage` to the axes.\n\n        Returns the image.\n        \"\"\"\n        self._set_artist_props(image)\n        self.images.append(image)\n        image._remove_method = lambda h: self.images.remove(h)\n        return image\n\n    def add_line(self, line):\n        \"\"\"\n        Add a :class:`~matplotlib.lines.Line2D` to the list of plot\n        lines\n\n        Returns the line.\n        \"\"\"\n        self._set_artist_props(line)\n        if line.get_clip_path() is None:\n            line.set_clip_path(self.patch)\n\n        self._update_line_limits(line)\n        if not line.get_label():\n            line.set_label('_line%d' % len(self.lines))\n        self.lines.append(line)\n        line._remove_method = lambda h: self.lines.remove(h)\n        return line\n\n    def _update_line_limits(self, line):\n        \"\"\"\n        Figures out the data limit of the given line, updating self.dataLim.\n        \"\"\"\n        path = line.get_path()\n        if path.vertices.size == 0:\n            return\n\n        line_trans = line.get_transform()\n\n        if line_trans == self.transData:\n            data_path = path\n\n        elif any(line_trans.contains_branch_seperately(self.transData)):\n            # identify the transform to go from line's coordinates\n            # to data coordinates\n            trans_to_data = line_trans - self.transData\n\n            # if transData is affine we can use the cached non-affine component\n            # of line's path. (since the non-affine part of line_trans is\n            # entirely encapsulated in trans_to_data).\n            if self.transData.is_affine:\n                line_trans_path = line._get_transformed_path()\n                na_path, _ = line_trans_path.get_transformed_path_and_affine()\n                data_path = trans_to_data.transform_path_affine(na_path)\n            else:\n                data_path = trans_to_data.transform_path(path)\n        else:\n            # for backwards compatibility we update the dataLim with the\n            # coordinate range of the given path, even though the coordinate\n            # systems are completely different. This may occur in situations\n            # such as when ax.transAxes is passed through for absolute\n            # positioning.\n            data_path = path\n\n        if data_path.vertices.size > 0:\n            updatex, updatey = line_trans.contains_branch_seperately(\n                self.transData)\n            self.dataLim.update_from_path(data_path,\n                                          self.ignore_existing_data_limits,\n                                          updatex=updatex,\n                                          updatey=updatey)\n            self.ignore_existing_data_limits = False\n\n    def add_patch(self, p):\n        \"\"\"\n        Add a :class:`~matplotlib.patches.Patch` *p* to the list of\n        axes patches; the clipbox will be set to the Axes clipping\n        box.  If the transform is not set, it will be set to\n        :attr:`transData`.\n\n        Returns the patch.\n        \"\"\"\n\n        self._set_artist_props(p)\n        if p.get_clip_path() is None:\n            p.set_clip_path(self.patch)\n        self._update_patch_limits(p)\n        self.patches.append(p)\n        p._remove_method = lambda h: self.patches.remove(h)\n        return p\n\n    def _update_patch_limits(self, patch):\n        \"\"\"update the data limits for patch *p*\"\"\"\n        # hist can add zero height Rectangles, which is useful to keep\n        # the bins, counts and patches lined up, but it throws off log\n        # scaling.  We'll ignore rects with zero height or width in\n        # the auto-scaling\n\n        # cannot check for '==0' since unitized data may not compare to zero\n        # issue #2150 - we update the limits if patch has non zero width\n        # or height.\n        if (isinstance(patch, mpatches.Rectangle) and\n                ((not patch.get_width()) and (not patch.get_height()))):\n            return\n        vertices = patch.get_path().vertices\n        if vertices.size > 0:\n            xys = patch.get_patch_transform().transform(vertices)\n            if patch.get_data_transform() != self.transData:\n                patch_to_data = (patch.get_data_transform() -\n                                    self.transData)\n                xys = patch_to_data.transform(xys)\n\n            updatex, updatey = patch.get_transform().\\\n                contains_branch_seperately(self.transData)\n            self.update_datalim(xys, updatex=updatex,\n                                updatey=updatey)\n\n    def add_table(self, tab):\n        \"\"\"\n        Add a :class:`~matplotlib.tables.Table` instance to the\n        list of axes tables\n\n        Returns the table.\n        \"\"\"\n        self._set_artist_props(tab)\n        self.tables.append(tab)\n        tab.set_clip_path(self.patch)\n        tab._remove_method = lambda h: self.tables.remove(h)\n        return tab\n\n    def add_container(self, container):\n        \"\"\"\n        Add a :class:`~matplotlib.container.Container` instance\n        to the axes.\n\n        Returns the collection.\n        \"\"\"\n        label = container.get_label()\n        if not label:\n            container.set_label('_container%d' % len(self.containers))\n        self.containers.append(container)\n        container.set_remove_method(lambda h: self.containers.remove(h))\n        return container\n\n    def relim(self, visible_only=False):\n        \"\"\"\n        Recompute the data limits based on current artists. If you want to\n        exclude invisible artists from the calculation, set\n        ``visible_only=True``\n\n        At present, :class:`~matplotlib.collections.Collection`\n        instances are not supported.\n        \"\"\"\n        # Collections are deliberately not supported (yet); see\n        # the TODO note in artists.py.\n        self.dataLim.ignore(True)\n        self.dataLim.set_points(mtransforms.Bbox.null().get_points())\n        self.ignore_existing_data_limits = True\n\n        for line in self.lines:\n            if not visible_only or line.get_visible():\n                self._update_line_limits(line)\n\n        for p in self.patches:\n            if not visible_only or p.get_visible():\n                self._update_patch_limits(p)\n\n    def update_datalim(self, xys, updatex=True, updatey=True):\n        \"\"\"\n        Update the data lim bbox with seq of xy tups or equiv. 2-D array\n        \"\"\"\n        # if no data is set currently, the bbox will ignore its\n        # limits and set the bound to be the bounds of the xydata.\n        # Otherwise, it will compute the bounds of it's current data\n        # and the data in xydata\n\n        if iterable(xys) and not len(xys):\n            return\n        if not ma.isMaskedArray(xys):\n            xys = np.asarray(xys)\n        self.dataLim.update_from_data_xy(xys, self.ignore_existing_data_limits,\n                                         updatex=updatex, updatey=updatey)\n        self.ignore_existing_data_limits = False\n\n    def update_datalim_numerix(self, x, y):\n        \"\"\"\n        Update the data lim bbox with seq of xy tups\n        \"\"\"\n        # if no data is set currently, the bbox will ignore it's\n        # limits and set the bound to be the bounds of the xydata.\n        # Otherwise, it will compute the bounds of it's current data\n        # and the data in xydata\n        if iterable(x) and not len(x):\n            return\n        self.dataLim.update_from_data(x, y, self.ignore_existing_data_limits)\n        self.ignore_existing_data_limits = False\n\n    def update_datalim_bounds(self, bounds):\n        \"\"\"\n        Update the datalim to include the given\n        :class:`~matplotlib.transforms.Bbox` *bounds*\n        \"\"\"\n        self.dataLim.set(mtransforms.Bbox.union([self.dataLim, bounds]))\n\n    def _process_unit_info(self, xdata=None, ydata=None, kwargs=None):\n        \"\"\"Look for unit *kwargs* and update the axis instances as necessary\"\"\"\n\n        if self.xaxis is None or self.yaxis is None:\n            return\n\n        #print 'processing', self.get_geometry()\n        if xdata is not None:\n            # we only need to update if there is nothing set yet.\n            if not self.xaxis.have_units():\n                self.xaxis.update_units(xdata)\n            #print '\\tset from xdata', self.xaxis.units\n\n        if ydata is not None:\n            # we only need to update if there is nothing set yet.\n            if not self.yaxis.have_units():\n                self.yaxis.update_units(ydata)\n            #print '\\tset from ydata', self.yaxis.units\n\n        # process kwargs 2nd since these will override default units\n        if kwargs is not None:\n            xunits = kwargs.pop('xunits', self.xaxis.units)\n            if self.name == 'polar':\n                xunits = kwargs.pop('thetaunits', xunits)\n            if xunits != self.xaxis.units:\n                #print '\\tkw setting xunits', xunits\n                self.xaxis.set_units(xunits)\n                # If the units being set imply a different converter,\n                # we need to update.\n                if xdata is not None:\n                    self.xaxis.update_units(xdata)\n\n            yunits = kwargs.pop('yunits', self.yaxis.units)\n            if self.name == 'polar':\n                yunits = kwargs.pop('runits', yunits)\n            if yunits != self.yaxis.units:\n                #print '\\tkw setting yunits', yunits\n                self.yaxis.set_units(yunits)\n                # If the units being set imply a different converter,\n                # we need to update.\n                if ydata is not None:\n                    self.yaxis.update_units(ydata)\n\n    def in_axes(self, mouseevent):\n        \"\"\"\n        Return *True* if the given *mouseevent* (in display coords)\n        is in the Axes\n        \"\"\"\n        return self.patch.contains(mouseevent)[0]\n\n    def get_autoscale_on(self):\n        \"\"\"\n        Get whether autoscaling is applied for both axes on plot commands\n        \"\"\"\n        return self._autoscaleXon and self._autoscaleYon\n\n    def get_autoscalex_on(self):\n        \"\"\"\n        Get whether autoscaling for the x-axis is applied on plot commands\n        \"\"\"\n        return self._autoscaleXon\n\n    def get_autoscaley_on(self):\n        \"\"\"\n        Get whether autoscaling for the y-axis is applied on plot commands\n        \"\"\"\n        return self._autoscaleYon\n\n    def set_autoscale_on(self, b):\n        \"\"\"\n        Set whether autoscaling is applied on plot commands\n\n        accepts: [ *True* | *False* ]\n        \"\"\"\n        self._autoscaleXon = b\n        self._autoscaleYon = b\n\n    def set_autoscalex_on(self, b):\n        \"\"\"\n        Set whether autoscaling for the x-axis is applied on plot commands\n\n        accepts: [ *True* | *False* ]\n        \"\"\"\n        self._autoscaleXon = b\n\n    def set_autoscaley_on(self, b):\n        \"\"\"\n        Set whether autoscaling for the y-axis is applied on plot commands\n\n        accepts: [ *True* | *False* ]\n        \"\"\"\n        self._autoscaleYon = b\n\n    def set_xmargin(self, m):\n        \"\"\"\n        Set padding of X data limits prior to autoscaling.\n\n        *m* times the data interval will be added to each\n        end of that interval before it is used in autoscaling.\n\n        accepts: float in range 0 to 1\n        \"\"\"\n        if m < 0 or m > 1:\n            raise ValueError(\"margin must be in range 0 to 1\")\n        self._xmargin = m\n\n    def set_ymargin(self, m):\n        \"\"\"\n        Set padding of Y data limits prior to autoscaling.\n\n        *m* times the data interval will be added to each\n        end of that interval before it is used in autoscaling.\n\n        accepts: float in range 0 to 1\n        \"\"\"\n        if m < 0 or m > 1:\n            raise ValueError(\"margin must be in range 0 to 1\")\n        self._ymargin = m\n\n    def margins(self, *args, **kw):\n        \"\"\"\n        Set or retrieve autoscaling margins.\n\n        signatures::\n\n            margins()\n\n        returns xmargin, ymargin\n\n        ::\n\n            margins(margin)\n\n            margins(xmargin, ymargin)\n\n            margins(x=xmargin, y=ymargin)\n\n            margins(..., tight=False)\n\n        All three forms above set the xmargin and ymargin parameters.\n        All keyword parameters are optional.  A single argument\n        specifies both xmargin and ymargin.  The *tight* parameter\n        is passed to :meth:`autoscale_view`, which is executed after\n        a margin is changed; the default here is *True*, on the\n        assumption that when margins are specified, no additional\n        padding to match tick marks is usually desired.  Setting\n        *tight* to *None* will preserve the previous setting.\n\n        Specifying any margin changes only the autoscaling; for example,\n        if *xmargin* is not None, then *xmargin* times the X data\n        interval will be added to each end of that interval before\n        it is used in autoscaling.\n\n        \"\"\"\n        if not args and not kw:\n            return self._xmargin, self._ymargin\n\n        tight = kw.pop('tight', True)\n        mx = kw.pop('x', None)\n        my = kw.pop('y', None)\n        if len(args) == 1:\n            mx = my = args[0]\n        elif len(args) == 2:\n            mx, my = args\n        elif len(args) > 2:\n            raise ValueError(\"more than two arguments were supplied\")\n        if mx is not None:\n            self.set_xmargin(mx)\n        if my is not None:\n            self.set_ymargin(my)\n\n        scalex = (mx is not None)\n        scaley = (my is not None)\n\n        self.autoscale_view(tight=tight, scalex=scalex, scaley=scaley)\n\n    def set_rasterization_zorder(self, z):\n        \"\"\"\n        Set zorder value below which artists will be rasterized.  Set\n        to `None` to disable rasterizing of artists below a particular\n        zorder.\n        \"\"\"\n        self._rasterization_zorder = z\n\n    def get_rasterization_zorder(self):\n        \"\"\"\n        Get zorder value below which artists will be rasterized\n        \"\"\"\n        return self._rasterization_zorder\n\n    def autoscale(self, enable=True, axis='both', tight=None):\n        \"\"\"\n        Autoscale the axis view to the data (toggle).\n\n        Convenience method for simple axis view autoscaling.\n        It turns autoscaling on or off, and then,\n        if autoscaling for either axis is on, it performs\n        the autoscaling on the specified axis or axes.\n\n        *enable*: [True | False | None]\n            True (default) turns autoscaling on, False turns it off.\n            None leaves the autoscaling state unchanged.\n\n        *axis*: ['x' | 'y' | 'both']\n            which axis to operate on; default is 'both'\n\n        *tight*: [True | False | None]\n            If True, set view limits to data limits;\n            if False, let the locator and margins expand the view limits;\n            if None, use tight scaling if the only artist is an image,\n            otherwise treat *tight* as False.\n            The *tight* setting is retained for future autoscaling\n            until it is explicitly changed.\n\n\n        Returns None.\n        \"\"\"\n        if enable is None:\n            scalex = True\n            scaley = True\n        else:\n            scalex = False\n            scaley = False\n            if axis in ['x', 'both']:\n                self._autoscaleXon = bool(enable)\n                scalex = self._autoscaleXon\n            if axis in ['y', 'both']:\n                self._autoscaleYon = bool(enable)\n                scaley = self._autoscaleYon\n        self.autoscale_view(tight=tight, scalex=scalex, scaley=scaley)\n\n    def autoscale_view(self, tight=None, scalex=True, scaley=True):\n        \"\"\"\n        Autoscale the view limits using the data limits. You can\n        selectively autoscale only a single axis, eg, the xaxis by\n        setting *scaley* to *False*.  The autoscaling preserves any\n        axis direction reversal that has already been done.\n\n        The data limits are not updated automatically when artist data are\n        changed after the artist has been added to an Axes instance.  In that\n        case, use :meth:`matplotlib.axes.Axes.relim` prior to calling\n        autoscale_view.\n        \"\"\"\n        if tight is None:\n            # if image data only just use the datalim\n            _tight = self._tight or (len(self.images) > 0 and\n                                     len(self.lines) == 0 and\n                                     len(self.patches) == 0)\n        else:\n            _tight = self._tight = bool(tight)\n\n        if scalex and self._autoscaleXon:\n            xshared = self._shared_x_axes.get_siblings(self)\n            dl = [ax.dataLim for ax in xshared]\n            #ignore non-finite data limits if good limits exist\n            finite_dl = [d for d in dl if np.isfinite(d).all()]\n            if len(finite_dl):\n                dl = finite_dl\n\n            bb = mtransforms.BboxBase.union(dl)\n            x0, x1 = bb.intervalx\n            xlocator = self.xaxis.get_major_locator()\n            try:\n                # e.g., DateLocator has its own nonsingular()\n                x0, x1 = xlocator.nonsingular(x0, x1)\n            except AttributeError:\n                # Default nonsingular for, e.g., MaxNLocator\n                x0, x1 = mtransforms.nonsingular(x0, x1, increasing=False,\n                                                 expander=0.05)\n            if self._xmargin > 0:\n                delta = (x1 - x0) * self._xmargin\n                x0 -= delta\n                x1 += delta\n            if not _tight:\n                x0, x1 = xlocator.view_limits(x0, x1)\n            self.set_xbound(x0, x1)\n\n        if scaley and self._autoscaleYon:\n            yshared = self._shared_y_axes.get_siblings(self)\n            dl = [ax.dataLim for ax in yshared]\n            #ignore non-finite data limits if good limits exist\n            finite_dl = [d for d in dl if np.isfinite(d).all()]\n            if len(finite_dl):\n                dl = finite_dl\n\n            bb = mtransforms.BboxBase.union(dl)\n            y0, y1 = bb.intervaly\n            ylocator = self.yaxis.get_major_locator()\n            try:\n                y0, y1 = ylocator.nonsingular(y0, y1)\n            except AttributeError:\n                y0, y1 = mtransforms.nonsingular(y0, y1, increasing=False,\n                                                 expander=0.05)\n            if self._ymargin > 0:\n                delta = (y1 - y0) * self._ymargin\n                y0 -= delta\n                y1 += delta\n            if not _tight:\n                y0, y1 = ylocator.view_limits(y0, y1)\n            self.set_ybound(y0, y1)\n\n    #### Drawing\n\n    @allow_rasterization\n    def draw(self, renderer=None, inframe=False):\n        \"\"\"Draw everything (plot lines, axes, labels)\"\"\"\n        if renderer is None:\n            renderer = self._cachedRenderer\n\n        if renderer is None:\n            raise RuntimeError('No renderer defined')\n        if not self.get_visible():\n            return\n        renderer.open_group('axes')\n\n        locator = self.get_axes_locator()\n        if locator:\n            pos = locator(self, renderer)\n            self.apply_aspect(pos)\n        else:\n            self.apply_aspect()\n\n        artists = []\n\n        artists.extend(self.collections)\n        artists.extend(self.patches)\n        artists.extend(self.lines)\n        artists.extend(self.texts)\n        artists.extend(self.artists)\n\n        # the frame draws the edges around the axes patch -- we\n        # decouple these so the patch can be in the background and the\n        # frame in the foreground. Do this before drawing the axis\n        # objects so that the spine has the opportunity to update them.\n        if self.axison and self._frameon:\n            artists.extend(six.itervalues(self.spines))\n\n        if self.axison and not inframe:\n            if self._axisbelow:\n                self.xaxis.set_zorder(0.5)\n                self.yaxis.set_zorder(0.5)\n            else:\n                self.xaxis.set_zorder(2.5)\n                self.yaxis.set_zorder(2.5)\n            artists.extend([self.xaxis, self.yaxis])\n        if not inframe:\n            artists.append(self.title)\n            artists.append(self._left_title)\n            artists.append(self._right_title)\n        artists.extend(self.tables)\n        if self.legend_ is not None:\n            artists.append(self.legend_)\n\n        if self.figure.canvas.is_saving():\n            dsu = [(a.zorder, a) for a in artists]\n        else:\n            dsu = [(a.zorder, a) for a in artists\n                   if not a.get_animated()]\n\n        # add images to dsu if the backend support compositing.\n        # otherwise, does the manaul compositing  without adding images to dsu.\n        if len(self.images) <= 1 or renderer.option_image_nocomposite():\n            dsu.extend([(im.zorder, im) for im in self.images])\n            _do_composite = False\n        else:\n            _do_composite = True\n\n        dsu.sort(key=itemgetter(0))\n\n        # rasterize artists with negative zorder\n        # if the minimum zorder is negative, start rasterization\n        rasterization_zorder = self._rasterization_zorder\n        if (rasterization_zorder is not None and\n            len(dsu) > 0 and dsu[0][0] < rasterization_zorder):\n            renderer.start_rasterizing()\n            dsu_rasterized = [l for l in dsu if l[0] < rasterization_zorder]\n            dsu = [l for l in dsu if l[0] >= rasterization_zorder]\n        else:\n            dsu_rasterized = []\n\n        # the patch draws the background rectangle -- the frame below\n        # will draw the edges\n        if self.axison and self._frameon:\n            self.patch.draw(renderer)\n\n        if _do_composite:\n            # make a composite image blending alpha\n            # list of (mimage.Image, ox, oy)\n\n            zorder_images = [(im.zorder, im) for im in self.images\n                             if im.get_visible()]\n            zorder_images.sort(key=lambda x: x[0])\n\n            mag = renderer.get_image_magnification()\n            ims = [(im.make_image(mag), 0, 0, im.get_alpha())\n                   for z, im in zorder_images]\n\n            l, b, r, t = self.bbox.extents\n            width = int(mag * ((round(r) + 0.5) - (round(l) - 0.5)))\n            height = int(mag * ((round(t) + 0.5) - (round(b) - 0.5)))\n            im = mimage.from_images(height,\n                                    width,\n                                    ims)\n\n            im.is_grayscale = False\n            l, b, w, h = self.bbox.bounds\n            # composite images need special args so they will not\n            # respect z-order for now\n\n            gc = renderer.new_gc()\n            gc.set_clip_rectangle(self.bbox)\n            gc.set_clip_path(mtransforms.TransformedPath(\n                self.patch.get_path(),\n                self.patch.get_transform()))\n\n            renderer.draw_image(gc, round(l), round(b), im)\n            gc.restore()\n\n        if dsu_rasterized:\n            for zorder, a in dsu_rasterized:\n                a.draw(renderer)\n            renderer.stop_rasterizing()\n\n        for zorder, a in dsu:\n            a.draw(renderer)\n\n        renderer.close_group('axes')\n        self._cachedRenderer = renderer\n\n    def draw_artist(self, a):\n        \"\"\"\n        This method can only be used after an initial draw which\n        caches the renderer.  It is used to efficiently update Axes\n        data (axis ticks, labels, etc are not updated)\n        \"\"\"\n        assert self._cachedRenderer is not None\n        a.draw(self._cachedRenderer)\n\n    def redraw_in_frame(self):\n        \"\"\"\n        This method can only be used after an initial draw which\n        caches the renderer.  It is used to efficiently update Axes\n        data (axis ticks, labels, etc are not updated)\n        \"\"\"\n        assert self._cachedRenderer is not None\n        self.draw(self._cachedRenderer, inframe=True)\n\n    def get_renderer_cache(self):\n        return self._cachedRenderer\n\n    #### Axes rectangle characteristics\n\n    def get_frame_on(self):\n        \"\"\"\n        Get whether the axes rectangle patch is drawn\n        \"\"\"\n        return self._frameon\n\n    def set_frame_on(self, b):\n        \"\"\"\n        Set whether the axes rectangle patch is drawn\n\n        ACCEPTS: [ *True* | *False* ]\n        \"\"\"\n        self._frameon = b\n\n    def get_axisbelow(self):\n        \"\"\"\n        Get whether axis below is true or not\n        \"\"\"\n        return self._axisbelow\n\n    def set_axisbelow(self, b):\n        \"\"\"\n        Set whether the axis ticks and gridlines are above or below most\n        artists\n\n        ACCEPTS: [ *True* | *False* ]\n        \"\"\"\n        self._axisbelow = b\n\n    @docstring.dedent_interpd\n    def grid(self, b=None, which='major', axis='both', **kwargs):\n        \"\"\"\n        Turn the axes grids on or off.\n\n        Call signature::\n\n           grid(self, b=None, which='major', axis='both', **kwargs)\n\n        Set the axes grids on or off; *b* is a boolean.  (For MATLAB\n        compatibility, *b* may also be a string, 'on' or 'off'.)\n\n        If *b* is *None* and ``len(kwargs)==0``, toggle the grid state.  If\n        *kwargs* are supplied, it is assumed that you want a grid and *b*\n        is thus set to *True*.\n\n        *which* can be 'major' (default), 'minor', or 'both' to control\n        whether major tick grids, minor tick grids, or both are affected.\n\n        *axis* can be 'both' (default), 'x', or 'y' to control which\n        set of gridlines are drawn.\n\n        *kwargs* are used to set the grid line properties, eg::\n\n           ax.grid(color='r', linestyle='-', linewidth=2)\n\n        Valid :class:`~matplotlib.lines.Line2D` kwargs are\n\n        %(Line2D)s\n\n        \"\"\"\n        if len(kwargs):\n            b = True\n        b = _string_to_bool(b)\n\n        if axis == 'x' or axis == 'both':\n            self.xaxis.grid(b, which=which, **kwargs)\n        if axis == 'y' or axis == 'both':\n            self.yaxis.grid(b, which=which, **kwargs)\n\n    def ticklabel_format(self, **kwargs):\n        \"\"\"\n        Change the `~matplotlib.ticker.ScalarFormatter` used by\n        default for linear axes.\n\n        Optional keyword arguments:\n\n          ============   =========================================\n          Keyword        Description\n          ============   =========================================\n          *style*        [ 'sci' (or 'scientific') | 'plain' ]\n                         plain turns off scientific notation\n          *scilimits*    (m, n), pair of integers; if *style*\n                         is 'sci', scientific notation will\n                         be used for numbers outside the range\n                         10`m`:sup: to 10`n`:sup:.\n                         Use (0,0) to include all numbers.\n          *useOffset*    [True | False | offset]; if True,\n                         the offset will be calculated as needed;\n                         if False, no offset will be used; if a\n                         numeric offset is specified, it will be\n                         used.\n          *axis*         [ 'x' | 'y' | 'both' ]\n          *useLocale*    If True, format the number according to\n                         the current locale.  This affects things\n                         such as the character used for the\n                         decimal separator.  If False, use\n                         C-style (English) formatting.  The\n                         default setting is controlled by the\n                         axes.formatter.use_locale rcparam.\n          ============   =========================================\n\n        Only the major ticks are affected.\n        If the method is called when the\n        :class:`~matplotlib.ticker.ScalarFormatter` is not the\n        :class:`~matplotlib.ticker.Formatter` being used, an\n        :exc:`AttributeError` will be raised.\n\n        \"\"\"\n        style = kwargs.pop('style', '').lower()\n        scilimits = kwargs.pop('scilimits', None)\n        useOffset = kwargs.pop('useOffset', None)\n        useLocale = kwargs.pop('useLocale', None)\n        axis = kwargs.pop('axis', 'both').lower()\n        if scilimits is not None:\n            try:\n                m, n = scilimits\n                m + n + 1  # check that both are numbers\n            except (ValueError, TypeError):\n                raise ValueError(\"scilimits must be a sequence of 2 integers\")\n        if style[:3] == 'sci':\n            sb = True\n        elif style in ['plain', 'comma']:\n            sb = False\n            if style == 'plain':\n                cb = False\n            else:\n                cb = True\n                raise NotImplementedError(\"comma style remains to be added\")\n        elif style == '':\n            sb = None\n        else:\n            raise ValueError(\"%s is not a valid style value\")\n        try:\n            if sb is not None:\n                if axis == 'both' or axis == 'x':\n                    self.xaxis.major.formatter.set_scientific(sb)\n                if axis == 'both' or axis == 'y':\n                    self.yaxis.major.formatter.set_scientific(sb)\n            if scilimits is not None:\n                if axis == 'both' or axis == 'x':\n                    self.xaxis.major.formatter.set_powerlimits(scilimits)\n                if axis == 'both' or axis == 'y':\n                    self.yaxis.major.formatter.set_powerlimits(scilimits)\n            if useOffset is not None:\n                if axis == 'both' or axis == 'x':\n                    self.xaxis.major.formatter.set_useOffset(useOffset)\n                if axis == 'both' or axis == 'y':\n                    self.yaxis.major.formatter.set_useOffset(useOffset)\n            if useLocale is not None:\n                if axis == 'both' or axis == 'x':\n                    self.xaxis.major.formatter.set_useLocale(useLocale)\n                if axis == 'both' or axis == 'y':\n                    self.yaxis.major.formatter.set_useLocale(useLocale)\n        except AttributeError:\n            raise AttributeError(\n                \"This method only works with the ScalarFormatter.\")\n\n    def locator_params(self, axis='both', tight=None, **kwargs):\n        \"\"\"\n        Control behavior of tick locators.\n\n        Keyword arguments:\n\n        *axis*\n            ['x' | 'y' | 'both']  Axis on which to operate;\n            default is 'both'.\n\n        *tight*\n            [True | False | None] Parameter passed to :meth:`autoscale_view`.\n            Default is None, for no change.\n\n        Remaining keyword arguments are passed to directly to the\n        :meth:`~matplotlib.ticker.MaxNLocator.set_params` method.\n\n        Typically one might want to reduce the maximum number\n        of ticks and use tight bounds when plotting small\n        subplots, for example::\n\n            ax.locator_params(tight=True, nbins=4)\n\n        Because the locator is involved in autoscaling,\n        :meth:`autoscale_view` is called automatically after\n        the parameters are changed.\n\n        This presently works only for the\n        :class:`~matplotlib.ticker.MaxNLocator` used\n        by default on linear axes, but it may be generalized.\n        \"\"\"\n        _x = axis in ['x', 'both']\n        _y = axis in ['y', 'both']\n        if _x:\n            self.xaxis.get_major_locator().set_params(**kwargs)\n        if _y:\n            self.yaxis.get_major_locator().set_params(**kwargs)\n        self.autoscale_view(tight=tight, scalex=_x, scaley=_y)\n\n    def tick_params(self, axis='both', **kwargs):\n        \"\"\"\n        Change the appearance of ticks and tick labels.\n\n        Keyword arguments:\n\n        *axis* : ['x' | 'y' | 'both']\n            Axis on which to operate; default is 'both'.\n\n        *reset* : [True | False]\n            If *True*, set all parameters to defaults\n            before processing other keyword arguments.  Default is\n            *False*.\n\n        *which* : ['major' | 'minor' | 'both']\n            Default is 'major'; apply arguments to *which* ticks.\n\n        *direction* : ['in' | 'out' | 'inout']\n            Puts ticks inside the axes, outside the axes, or both.\n\n        *length*\n            Tick length in points.\n\n        *width*\n            Tick width in points.\n\n        *color*\n            Tick color; accepts any mpl color spec.\n\n        *pad*\n            Distance in points between tick and label.\n\n        *labelsize*\n            Tick label font size in points or as a string (e.g., 'large').\n\n        *labelcolor*\n            Tick label color; mpl color spec.\n\n        *colors*\n            Changes the tick color and the label color to the same value:\n            mpl color spec.\n\n        *zorder*\n            Tick and label zorder.\n\n        *bottom*, *top*, *left*, *right* : [bool | 'on' | 'off']\n            controls whether to draw the respective ticks.\n\n        *labelbottom*, *labeltop*, *labelleft*, *labelright*\n            Boolean or ['on' | 'off'], controls whether to draw the\n            respective tick labels.\n\n        Example::\n\n            ax.tick_params(direction='out', length=6, width=2, colors='r')\n\n        This will make all major ticks be red, pointing out of the box,\n        and with dimensions 6 points by 2 points.  Tick labels will\n        also be red.\n\n        \"\"\"\n        if axis in ['x', 'both']:\n            xkw = dict(kwargs)\n            xkw.pop('left', None)\n            xkw.pop('right', None)\n            xkw.pop('labelleft', None)\n            xkw.pop('labelright', None)\n            self.xaxis.set_tick_params(**xkw)\n        if axis in ['y', 'both']:\n            ykw = dict(kwargs)\n            ykw.pop('top', None)\n            ykw.pop('bottom', None)\n            ykw.pop('labeltop', None)\n            ykw.pop('labelbottom', None)\n            self.yaxis.set_tick_params(**ykw)\n\n    def set_axis_off(self):\n        \"\"\"turn off the axis\"\"\"\n        self.axison = False\n\n    def set_axis_on(self):\n        \"\"\"turn on the axis\"\"\"\n        self.axison = True\n\n    def get_axis_bgcolor(self):\n        \"\"\"Return the axis background color\"\"\"\n        return self._axisbg\n\n    def set_axis_bgcolor(self, color):\n        \"\"\"\n        set the axes background color\n\n        ACCEPTS: any matplotlib color - see\n        :func:`~matplotlib.pyplot.colors`\n        \"\"\"\n\n        self._axisbg = color\n        self.patch.set_facecolor(color)\n\n    ### data limits, ticks, tick labels, and formatting\n\n    def invert_xaxis(self):\n        \"Invert the x-axis.\"\n        left, right = self.get_xlim()\n        self.set_xlim(right, left, auto=None)\n\n    def xaxis_inverted(self):\n        \"\"\"Returns *True* if the x-axis is inverted.\"\"\"\n        left, right = self.get_xlim()\n        return right < left\n\n    def get_xbound(self):\n        \"\"\"\n        Returns the x-axis numerical bounds where::\n\n          lowerBound < upperBound\n\n        \"\"\"\n        left, right = self.get_xlim()\n        if left < right:\n            return left, right\n        else:\n            return right, left\n\n    def set_xbound(self, lower=None, upper=None):\n        \"\"\"\n        Set the lower and upper numerical bounds of the x-axis.\n        This method will honor axes inversion regardless of parameter order.\n        It will not change the _autoscaleXon attribute.\n        \"\"\"\n        if upper is None and iterable(lower):\n            lower, upper = lower\n\n        old_lower, old_upper = self.get_xbound()\n\n        if lower is None:\n            lower = old_lower\n        if upper is None:\n            upper = old_upper\n\n        if self.xaxis_inverted():\n            if lower < upper:\n                self.set_xlim(upper, lower, auto=None)\n            else:\n                self.set_xlim(lower, upper, auto=None)\n        else:\n            if lower < upper:\n                self.set_xlim(lower, upper, auto=None)\n            else:\n                self.set_xlim(upper, lower, auto=None)\n\n    def get_xlim(self):\n        \"\"\"\n        Get the x-axis range [*left*, *right*]\n        \"\"\"\n        return tuple(self.viewLim.intervalx)\n\n    def set_xlim(self, left=None, right=None, emit=True, auto=False, **kw):\n        \"\"\"\n        Call signature::\n\n          set_xlim(self, *args, **kwargs):\n\n        Set the data limits for the xaxis\n\n        Examples::\n\n          set_xlim((left, right))\n          set_xlim(left, right)\n          set_xlim(left=1) # right unchanged\n          set_xlim(right=1) # left unchanged\n\n        Keyword arguments:\n\n          *left*: scalar\n            The left xlim; *xmin*, the previous name, may still be used\n\n          *right*: scalar\n            The right xlim; *xmax*, the previous name, may still be used\n\n          *emit*: [ *True* | *False* ]\n            Notify observers of limit change\n\n          *auto*: [ *True* | *False* | *None* ]\n            Turn *x* autoscaling on (*True*), off (*False*; default),\n            or leave unchanged (*None*)\n\n        Note, the *left* (formerly *xmin*) value may be greater than\n        the *right* (formerly *xmax*).\n        For example, suppose *x* is years before present.\n        Then one might use::\n\n          set_ylim(5000, 0)\n\n        so 5000 years ago is on the left of the plot and the\n        present is on the right.\n\n        Returns the current xlimits as a length 2 tuple\n\n        ACCEPTS: length 2 sequence of floats\n        \"\"\"\n        if 'xmin' in kw:\n            left = kw.pop('xmin')\n        if 'xmax' in kw:\n            right = kw.pop('xmax')\n        if kw:\n            raise ValueError(\"unrecognized kwargs: %s\" %\n                             list(six.iterkeys(kw)))\n\n        if right is None and iterable(left):\n            left, right = left\n\n        self._process_unit_info(xdata=(left, right))\n        if left is not None:\n            left = self.convert_xunits(left)\n        if right is not None:\n            right = self.convert_xunits(right)\n\n        old_left, old_right = self.get_xlim()\n        if left is None:\n            left = old_left\n        if right is None:\n            right = old_right\n\n        if left == right:\n            warnings.warn(\n                ('Attempting to set identical left==right results\\n'\n                 'in singular transformations; automatically expanding.\\n'\n                 'left=%s, right=%s') % (left, right))\n        left, right = mtransforms.nonsingular(left, right, increasing=False)\n        left, right = self.xaxis.limit_range_for_scale(left, right)\n\n        self.viewLim.intervalx = (left, right)\n        if auto is not None:\n            self._autoscaleXon = bool(auto)\n\n        if emit:\n            self.callbacks.process('xlim_changed', self)\n            # Call all of the other x-axes that are shared with this one\n            for other in self._shared_x_axes.get_siblings(self):\n                if other is not self:\n                    other.set_xlim(self.viewLim.intervalx,\n                                   emit=False, auto=auto)\n                    if (other.figure != self.figure and\n                        other.figure.canvas is not None):\n                        other.figure.canvas.draw_idle()\n\n        return left, right\n\n    def get_xscale(self):\n        return self.xaxis.get_scale()\n    get_xscale.__doc__ = \"Return the xaxis scale string: %s\"\"\" % (\n        \", \".join(mscale.get_scale_names()))\n\n    @docstring.dedent_interpd\n    def set_xscale(self, value, **kwargs):\n        \"\"\"\n        Call signature::\n\n          set_xscale(value)\n\n        Set the scaling of the x-axis: %(scale)s\n\n        ACCEPTS: [%(scale)s]\n\n        Different kwargs are accepted, depending on the scale:\n        %(scale_docs)s\n        \"\"\"\n        # If the scale is being set to log, clip nonposx to prevent headaches\n        # around zero\n        if value.lower() == 'log' and 'nonposx' not in kwargs.keys():\n            kwargs['nonposx'] = 'clip'\n        self.xaxis._set_scale(value, **kwargs)\n        self.autoscale_view(scaley=False)\n        self._update_transScale()\n\n    def get_xticks(self, minor=False):\n        \"\"\"Return the x ticks as a list of locations\"\"\"\n        return self.xaxis.get_ticklocs(minor=minor)\n\n    def set_xticks(self, ticks, minor=False):\n        \"\"\"\n        Set the x ticks with list of *ticks*\n\n        ACCEPTS: sequence of floats\n        \"\"\"\n        return self.xaxis.set_ticks(ticks, minor=minor)\n\n    def get_xmajorticklabels(self):\n        \"\"\"\n        Get the xtick labels as a list of :class:`~matplotlib.text.Text`\n        instances.\n        \"\"\"\n        return cbook.silent_list('Text xticklabel',\n                                 self.xaxis.get_majorticklabels())\n\n    def get_xminorticklabels(self):\n        \"\"\"\n        Get the x minor tick labels as a list of\n        :class:`matplotlib.text.Text` instances.\n        \"\"\"\n        return cbook.silent_list('Text xticklabel',\n                                 self.xaxis.get_minorticklabels())\n\n    def get_xticklabels(self, minor=False, which=None):\n        \"\"\"\n        Get the x tick labels as a list of :class:`~matplotlib.text.Text`\n        instances.\n\n        Parameters\n        ----------\n        minor : bool\n           If True return the minor ticklabels,\n           else return the major ticklabels\n\n        which : None, ('minor', 'major', 'both')\n           Overrides `minor`.\n\n           Selects which ticklabels to return\n\n        Returns\n        -------\n        ret : list\n           List of :class:`~matplotlib.text.Text` instances.\n        \"\"\"\n        return cbook.silent_list('Text xticklabel',\n                                 self.xaxis.get_ticklabels(minor=minor,\n                                                           which=which))\n\n    @docstring.dedent_interpd\n    def set_xticklabels(self, labels, fontdict=None, minor=False, **kwargs):\n        \"\"\"\n        Call signature::\n\n          set_xticklabels(labels, fontdict=None, minor=False, **kwargs)\n\n        Set the xtick labels with list of strings *labels*. Return a\n        list of axis text instances.\n\n        *kwargs* set the :class:`~matplotlib.text.Text` properties.\n        Valid properties are\n        %(Text)s\n\n        ACCEPTS: sequence of strings\n        \"\"\"\n        return self.xaxis.set_ticklabels(labels, fontdict,\n                                         minor=minor, **kwargs)\n\n    def invert_yaxis(self):\n        \"\"\"\n        Invert the y-axis.\n        \"\"\"\n        bottom, top = self.get_ylim()\n        self.set_ylim(top, bottom, auto=None)\n\n    def yaxis_inverted(self):\n        \"\"\"Returns *True* if the y-axis is inverted.\"\"\"\n        bottom, top = self.get_ylim()\n        return top < bottom\n\n    def get_ybound(self):\n        \"\"\"\n        Return y-axis numerical bounds in the form of\n        ``lowerBound < upperBound``\n        \"\"\"\n        bottom, top = self.get_ylim()\n        if bottom < top:\n            return bottom, top\n        else:\n            return top, bottom\n\n    def set_ybound(self, lower=None, upper=None):\n        \"\"\"\n        Set the lower and upper numerical bounds of the y-axis.\n        This method will honor axes inversion regardless of parameter order.\n        It will not change the _autoscaleYon attribute.\n        \"\"\"\n        if upper is None and iterable(lower):\n            lower, upper = lower\n\n        old_lower, old_upper = self.get_ybound()\n\n        if lower is None:\n            lower = old_lower\n        if upper is None:\n            upper = old_upper\n\n        if self.yaxis_inverted():\n            if lower < upper:\n                self.set_ylim(upper, lower, auto=None)\n            else:\n                self.set_ylim(lower, upper, auto=None)\n        else:\n            if lower < upper:\n                self.set_ylim(lower, upper, auto=None)\n            else:\n                self.set_ylim(upper, lower, auto=None)\n\n    def get_ylim(self):\n        \"\"\"\n        Get the y-axis range [*bottom*, *top*]\n        \"\"\"\n        return tuple(self.viewLim.intervaly)\n\n    def set_ylim(self, bottom=None, top=None, emit=True, auto=False, **kw):\n        \"\"\"\n        Call signature::\n\n          set_ylim(self, *args, **kwargs):\n\n        Set the data limits for the yaxis\n\n        Examples::\n\n          set_ylim((bottom, top))\n          set_ylim(bottom, top)\n          set_ylim(bottom=1) # top unchanged\n          set_ylim(top=1) # bottom unchanged\n\n        Keyword arguments:\n\n          *bottom*: scalar\n            The bottom ylim; the previous name, *ymin*, may still be used\n\n          *top*: scalar\n            The top ylim; the previous name, *ymax*, may still be used\n\n          *emit*: [ *True* | *False* ]\n            Notify observers of limit change\n\n          *auto*: [ *True* | *False* | *None* ]\n            Turn *y* autoscaling on (*True*), off (*False*; default),\n            or leave unchanged (*None*)\n\n        Note, the *bottom* (formerly *ymin*) value may be greater than\n        the *top* (formerly *ymax*).\n        For example, suppose *y* is depth in the ocean.\n        Then one might use::\n\n          set_ylim(5000, 0)\n\n        so 5000 m depth is at the bottom of the plot and the\n        surface, 0 m, is at the top.\n\n        Returns the current ylimits as a length 2 tuple\n\n        ACCEPTS: length 2 sequence of floats\n        \"\"\"\n        if 'ymin' in kw:\n            bottom = kw.pop('ymin')\n        if 'ymax' in kw:\n            top = kw.pop('ymax')\n        if kw:\n            raise ValueError(\"unrecognized kwargs: %s\" %\n                             list(six.iterkeys(kw)))\n\n        if top is None and iterable(bottom):\n            bottom, top = bottom\n\n        if bottom is not None:\n            bottom = self.convert_yunits(bottom)\n        if top is not None:\n            top = self.convert_yunits(top)\n\n        old_bottom, old_top = self.get_ylim()\n\n        if bottom is None:\n            bottom = old_bottom\n        if top is None:\n            top = old_top\n\n        if bottom == top:\n            warnings.warn(\n                ('Attempting to set identical bottom==top results\\n'\n                 'in singular transformations; automatically expanding.\\n'\n                 'bottom=%s, top=%s') % (bottom, top))\n\n        bottom, top = mtransforms.nonsingular(bottom, top, increasing=False)\n        bottom, top = self.yaxis.limit_range_for_scale(bottom, top)\n\n        self.viewLim.intervaly = (bottom, top)\n        if auto is not None:\n            self._autoscaleYon = bool(auto)\n\n        if emit:\n            self.callbacks.process('ylim_changed', self)\n            # Call all of the other y-axes that are shared with this one\n            for other in self._shared_y_axes.get_siblings(self):\n                if other is not self:\n                    other.set_ylim(self.viewLim.intervaly,\n                                   emit=False, auto=auto)\n                    if (other.figure != self.figure and\n                            other.figure.canvas is not None):\n                        other.figure.canvas.draw_idle()\n\n        return bottom, top\n\n    def get_yscale(self):\n        return self.yaxis.get_scale()\n    get_yscale.__doc__ = \"Return the yaxis scale string: %s\"\"\" % (\n        \", \".join(mscale.get_scale_names()))\n\n    @docstring.dedent_interpd\n    def set_yscale(self, value, **kwargs):\n        \"\"\"\n        Call signature::\n\n          set_yscale(value)\n\n        Set the scaling of the y-axis: %(scale)s\n\n        ACCEPTS: [%(scale)s]\n\n        Different kwargs are accepted, depending on the scale:\n        %(scale_docs)s\n        \"\"\"\n        # If the scale is being set to log, clip nonposy to prevent headaches\n        # around zero\n        if value.lower() == 'log' and 'nonposy' not in kwargs.keys():\n            kwargs['nonposy'] = 'clip'\n        self.yaxis._set_scale(value, **kwargs)\n        self.autoscale_view(scalex=False)\n        self._update_transScale()\n\n    def get_yticks(self, minor=False):\n        \"\"\"Return the y ticks as a list of locations\"\"\"\n        return self.yaxis.get_ticklocs(minor=minor)\n\n    def set_yticks(self, ticks, minor=False):\n        \"\"\"\n        Set the y ticks with list of *ticks*\n\n        ACCEPTS: sequence of floats\n\n        Keyword arguments:\n\n          *minor*: [ *False* | *True* ]\n            Sets the minor ticks if *True*\n        \"\"\"\n        return self.yaxis.set_ticks(ticks, minor=minor)\n\n    def get_ymajorticklabels(self):\n        \"\"\"\n        Get the major y tick labels as a list of\n        :class:`~matplotlib.text.Text` instances.\n        \"\"\"\n        return cbook.silent_list('Text yticklabel',\n                                 self.yaxis.get_majorticklabels())\n\n    def get_yminorticklabels(self):\n        \"\"\"\n        Get the minor y tick labels as a list of\n        :class:`~matplotlib.text.Text` instances.\n        \"\"\"\n        return cbook.silent_list('Text yticklabel',\n                                 self.yaxis.get_minorticklabels())\n\n    def get_yticklabels(self, minor=False, which=None):\n        \"\"\"\n        Get the x tick labels as a list of :class:`~matplotlib.text.Text`\n        instances.\n\n        Parameters\n        ----------\n        minor : bool\n           If True return the minor ticklabels,\n           else return the major ticklabels\n\n        which : None, ('minor', 'major', 'both')\n           Overrides `minor`.\n\n           Selects which ticklabels to return\n\n        Returns\n        -------\n        ret : list\n           List of :class:`~matplotlib.text.Text` instances.\n        \"\"\"\n        return cbook.silent_list('Text yticklabel',\n                                  self.yaxis.get_ticklabels(minor=minor,\n                                                            which=which))\n\n    @docstring.dedent_interpd\n    def set_yticklabels(self, labels, fontdict=None, minor=False, **kwargs):\n        \"\"\"\n        Call signature::\n\n          set_yticklabels(labels, fontdict=None, minor=False, **kwargs)\n\n        Set the y tick labels with list of strings *labels*.  Return a list of\n        :class:`~matplotlib.text.Text` instances.\n\n        *kwargs* set :class:`~matplotlib.text.Text` properties for the labels.\n        Valid properties are\n        %(Text)s\n\n        ACCEPTS: sequence of strings\n        \"\"\"\n        return self.yaxis.set_ticklabels(labels, fontdict,\n                                         minor=minor, **kwargs)\n\n    def xaxis_date(self, tz=None):\n        \"\"\"\n        Sets up x-axis ticks and labels that treat the x data as dates.\n\n        *tz* is a timezone string or :class:`tzinfo` instance.\n        Defaults to rc value.\n        \"\"\"\n        # should be enough to inform the unit conversion interface\n        # dates are coming in\n        self.xaxis.axis_date(tz)\n\n    def yaxis_date(self, tz=None):\n        \"\"\"\n        Sets up y-axis ticks and labels that treat the y data as dates.\n\n        *tz* is a timezone string or :class:`tzinfo` instance.\n        Defaults to rc value.\n        \"\"\"\n        self.yaxis.axis_date(tz)\n\n    def format_xdata(self, x):\n        \"\"\"\n        Return *x* string formatted.  This function will use the attribute\n        self.fmt_xdata if it is callable, else will fall back on the xaxis\n        major formatter\n        \"\"\"\n        try:\n            return self.fmt_xdata(x)\n        except TypeError:\n            func = self.xaxis.get_major_formatter().format_data_short\n            val = func(x)\n            return val\n\n    def format_ydata(self, y):\n        \"\"\"\n        Return y string formatted.  This function will use the\n        :attr:`fmt_ydata` attribute if it is callable, else will fall\n        back on the yaxis major formatter\n        \"\"\"\n        try:\n            return self.fmt_ydata(y)\n        except TypeError:\n            func = self.yaxis.get_major_formatter().format_data_short\n            val = func(y)\n            return val\n\n    def format_coord(self, x, y):\n        \"\"\"Return a format string formatting the *x*, *y* coord\"\"\"\n        if x is None:\n            xs = '???'\n        else:\n            xs = self.format_xdata(x)\n        if y is None:\n            ys = '???'\n        else:\n            ys = self.format_ydata(y)\n        return 'x=%s y=%s' % (xs, ys)\n\n    def minorticks_on(self):\n        'Add autoscaling minor ticks to the axes.'\n        for ax in (self.xaxis, self.yaxis):\n            if ax.get_scale() == 'log':\n                s = ax._scale\n                ax.set_minor_locator(mticker.LogLocator(s.base, s.subs))\n            else:\n                ax.set_minor_locator(mticker.AutoMinorLocator())\n\n    def minorticks_off(self):\n        \"\"\"Remove minor ticks from the axes.\"\"\"\n        self.xaxis.set_minor_locator(mticker.NullLocator())\n        self.yaxis.set_minor_locator(mticker.NullLocator())\n\n    #### Interactive manipulation\n\n    def can_zoom(self):\n        \"\"\"\n        Return *True* if this axes supports the zoom box button functionality.\n        \"\"\"\n        return True\n\n    def can_pan(self):\n        \"\"\"\n        Return *True* if this axes supports any pan/zoom button functionality.\n        \"\"\"\n        return True\n\n    def get_navigate(self):\n        \"\"\"\n        Get whether the axes responds to navigation commands\n        \"\"\"\n        return self._navigate\n\n    def set_navigate(self, b):\n        \"\"\"\n        Set whether the axes responds to navigation toolbar commands\n\n        ACCEPTS: [ *True* | *False* ]\n        \"\"\"\n        self._navigate = b\n\n    def get_navigate_mode(self):\n        \"\"\"\n        Get the navigation toolbar button status: 'PAN', 'ZOOM', or None\n        \"\"\"\n        return self._navigate_mode\n\n    def set_navigate_mode(self, b):\n        \"\"\"\n        Set the navigation toolbar button status;\n\n        .. warning::\n            this is not a user-API function.\n\n        \"\"\"\n        self._navigate_mode = b\n\n    def start_pan(self, x, y, button):\n        \"\"\"\n        Called when a pan operation has started.\n\n        *x*, *y* are the mouse coordinates in display coords.\n        button is the mouse button number:\n\n        * 1: LEFT\n        * 2: MIDDLE\n        * 3: RIGHT\n\n        .. note::\n\n            Intended to be overridden by new projection types.\n\n        \"\"\"\n        self._pan_start = cbook.Bunch(\n            lim=self.viewLim.frozen(),\n            trans=self.transData.frozen(),\n            trans_inverse=self.transData.inverted().frozen(),\n            bbox=self.bbox.frozen(),\n            x=x,\n            y=y)\n\n    def end_pan(self):\n        \"\"\"\n        Called when a pan operation completes (when the mouse button\n        is up.)\n\n        .. note::\n\n            Intended to be overridden by new projection types.\n\n        \"\"\"\n        del self._pan_start\n\n    def drag_pan(self, button, key, x, y):\n        \"\"\"\n        Called when the mouse moves during a pan operation.\n\n        *button* is the mouse button number:\n\n        * 1: LEFT\n        * 2: MIDDLE\n        * 3: RIGHT\n\n        *key* is a \"shift\" key\n\n        *x*, *y* are the mouse coordinates in display coords.\n\n        .. note::\n\n            Intended to be overridden by new projection types.\n\n        \"\"\"\n        def format_deltas(key, dx, dy):\n            if key == 'control':\n                if abs(dx) > abs(dy):\n                    dy = dx\n                else:\n                    dx = dy\n            elif key == 'x':\n                dy = 0\n            elif key == 'y':\n                dx = 0\n            elif key == 'shift':\n                if 2 * abs(dx) < abs(dy):\n                    dx = 0\n                elif 2 * abs(dy) < abs(dx):\n                    dy = 0\n                elif abs(dx) > abs(dy):\n                    dy = dy / abs(dy) * abs(dx)\n                else:\n                    dx = dx / abs(dx) * abs(dy)\n            return (dx, dy)\n\n        p = self._pan_start\n        dx = x - p.x\n        dy = y - p.y\n        if dx == 0 and dy == 0:\n            return\n        if button == 1:\n            dx, dy = format_deltas(key, dx, dy)\n            result = p.bbox.translated(-dx, -dy) \\\n                .transformed(p.trans_inverse)\n        elif button == 3:\n            try:\n                dx = -dx / float(self.bbox.width)\n                dy = -dy / float(self.bbox.height)\n                dx, dy = format_deltas(key, dx, dy)\n                if self.get_aspect() != 'auto':\n                    dx = 0.5 * (dx + dy)\n                    dy = dx\n\n                alpha = np.power(10.0, (dx, dy))\n                start = np.array([p.x, p.y])\n                oldpoints = p.lim.transformed(p.trans)\n                newpoints = start + alpha * (oldpoints - start)\n                result = mtransforms.Bbox(newpoints) \\\n                    .transformed(p.trans_inverse)\n            except OverflowError:\n                warnings.warn('Overflow while panning')\n                return\n\n        self.set_xlim(*result.intervalx)\n        self.set_ylim(*result.intervaly)\n\n    def get_cursor_props(self):\n        \"\"\"\n        Return the cursor propertiess as a (*linewidth*, *color*)\n        tuple, where *linewidth* is a float and *color* is an RGBA\n        tuple\n        \"\"\"\n        return self._cursorProps\n\n    def set_cursor_props(self, *args):\n        \"\"\"\n        Set the cursor property as::\n\n          ax.set_cursor_props(linewidth, color)\n\n        or::\n\n          ax.set_cursor_props((linewidth, color))\n\n        ACCEPTS: a (*float*, *color*) tuple\n        \"\"\"\n        if len(args) == 1:\n            lw, c = args[0]\n        elif len(args) == 2:\n            lw, c = args\n        else:\n            raise ValueError('args must be a (linewidth, color) tuple')\n        c = mcolors.colorConverter.to_rgba(c)\n        self._cursorProps = lw, c\n\n    def get_children(self):\n        \"\"\"return a list of child artists\"\"\"\n        children = []\n        children.append(self.xaxis)\n        children.append(self.yaxis)\n        children.extend(self.lines)\n        children.extend(self.patches)\n        children.extend(self.texts)\n        children.extend(self.tables)\n        children.extend(self.artists)\n        children.extend(self.images)\n        if self.legend_ is not None:\n            children.append(self.legend_)\n        children.extend(self.collections)\n        children.append(self.title)\n        children.append(self._left_title)\n        children.append(self._right_title)\n        children.append(self.patch)\n        children.extend(six.itervalues(self.spines))\n        return children\n\n    def contains(self, mouseevent):\n        \"\"\"\n        Test whether the mouse event occured in the axes.\n\n        Returns *True* / *False*, {}\n        \"\"\"\n        if six.callable(self._contains):\n            return self._contains(self, mouseevent)\n\n        return self.patch.contains(mouseevent)\n\n    def contains_point(self, point):\n        \"\"\"\n        Returns *True* if the point (tuple of x,y) is inside the axes\n        (the area defined by the its patch). A pixel coordinate is\n        required.\n\n        \"\"\"\n        return self.patch.contains_point(point, radius=1.0)\n\n    def pick(self, *args):\n        \"\"\"\n        Call signature::\n\n            pick(mouseevent)\n\n        each child artist will fire a pick event if mouseevent is over\n        the artist and the artist has picker set\n        \"\"\"\n        martist.Artist.pick(self, args[0])\n\n    def get_default_bbox_extra_artists(self):\n        return [artist for artist in self.get_children()\n                if artist.get_visible()]\n\n    def get_tightbbox(self, renderer, call_axes_locator=True):\n        \"\"\"\n        Return the tight bounding box of the axes.\n        The dimension of the Bbox in canvas coordinate.\n\n        If *call_axes_locator* is *False*, it does not call the\n        _axes_locator attribute, which is necessary to get the correct\n        bounding box. ``call_axes_locator==False`` can be used if the\n        caller is only intereted in the relative size of the tightbbox\n        compared to the axes bbox.\n        \"\"\"\n\n        bb = []\n\n        if not self.get_visible():\n            return None\n\n        locator = self.get_axes_locator()\n        if locator and call_axes_locator:\n            pos = locator(self, renderer)\n            self.apply_aspect(pos)\n        else:\n            self.apply_aspect()\n\n        bb.append(self.get_window_extent(renderer))\n\n        if self.title.get_visible():\n            bb.append(self.title.get_window_extent(renderer))\n        if self._left_title.get_visible():\n            bb.append(self._left_title.get_window_extent(renderer))\n        if self._right_title.get_visible():\n            bb.append(self._right_title.get_window_extent(renderer))\n\n        bb_xaxis = self.xaxis.get_tightbbox(renderer)\n        if bb_xaxis:\n            bb.append(bb_xaxis)\n\n        bb_yaxis = self.yaxis.get_tightbbox(renderer)\n        if bb_yaxis:\n            bb.append(bb_yaxis)\n\n        _bbox = mtransforms.Bbox.union(\n            [b for b in bb if b.width != 0 or b.height != 0])\n\n        return _bbox\n\n    def _make_twin_axes(self, *kl, **kwargs):\n        \"\"\"\n        make a twinx axes of self. This is used for twinx and twiny.\n        \"\"\"\n        ax2 = self.figure.add_axes(self.get_position(True), *kl, **kwargs)\n        return ax2\n\n    def twinx(self):\n        \"\"\"\n        Call signature::\n\n          ax = twinx()\n\n        create a twin of Axes for generating a plot with a sharex\n        x-axis but independent y axis.  The y-axis of self will have\n        ticks on left and the returned axes will have ticks on the\n        right.\n\n        .. note::\n            For those who are 'picking' artists while using twinx, pick\n            events are only called for the artists in the top-most axes.\n        \"\"\"\n        ax2 = self._make_twin_axes(sharex=self)\n        ax2.yaxis.tick_right()\n        ax2.yaxis.set_label_position('right')\n        ax2.yaxis.set_offset_position('right')\n        self.yaxis.tick_left()\n        ax2.xaxis.set_visible(False)\n        ax2.patch.set_visible(False)\n        return ax2\n\n    def twiny(self):\n        \"\"\"\n        Call signature::\n\n          ax = twiny()\n\n        create a twin of Axes for generating a plot with a shared\n        y-axis but independent x axis.  The x-axis of self will have\n        ticks on bottom and the returned axes will have ticks on the\n        top.\n\n        .. note::\n            For those who are 'picking' artists while using twiny, pick\n            events are only called for the artists in the top-most axes.\n        \"\"\"\n\n        ax2 = self._make_twin_axes(sharey=self)\n        ax2.xaxis.tick_top()\n        ax2.xaxis.set_label_position('top')\n        self.xaxis.tick_bottom()\n        ax2.yaxis.set_visible(False)\n        ax2.patch.set_visible(False)\n        return ax2\n\n    def get_shared_x_axes(self):\n        'Return a copy of the shared axes Grouper object for x axes'\n        return self._shared_x_axes\n\n    def get_shared_y_axes(self):\n        'Return a copy of the shared axes Grouper object for y axes'\n        return self._shared_y_axes\n", "patch": "@@ -2063,8 +2063,8 @@ def draw(self, renderer=None, inframe=False):\n                    for z, im in zorder_images]\n \n             l, b, r, t = self.bbox.extents\n-            width = mag * ((round(r) + 0.5) - (round(l) - 0.5))\n-            height = mag * ((round(t) + 0.5) - (round(b) - 0.5))\n+            width = int(mag * ((round(r) + 0.5) - (round(l) - 0.5)))\n+            height = int(mag * ((round(t) + 0.5) - (round(b) - 0.5)))\n             im = mimage.from_images(height,\n                                     width,\n                                     ims)"}
{"patches_id": 2, "files_id": 7, "language": "py", "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Fbackends%2Fbackend_agg.py", "raw_code": "\"\"\"\nAn agg http://antigrain.com/ backend\n\nFeatures that are implemented\n\n * capstyles and join styles\n * dashes\n * linewidth\n * lines, rectangles, ellipses\n * clipping to a rectangle\n * output to RGBA and PNG, optionally JPEG and TIFF\n * alpha blending\n * DPI scaling properly - everything scales properly (dashes, linewidths, etc)\n * draw polygon\n * freetype2 w/ ft2font\n\nTODO:\n\n  * integrate screen dpi w/ ppi and text\n\n\"\"\"\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport six\n\nimport threading\nimport numpy as np\n\nfrom matplotlib import verbose, rcParams\nfrom matplotlib.backend_bases import RendererBase,\\\n     FigureManagerBase, FigureCanvasBase\nfrom matplotlib.cbook import is_string_like, maxdict, restrict_dict\nfrom matplotlib.figure import Figure\nfrom matplotlib.font_manager import findfont\nfrom matplotlib.ft2font import FT2Font, LOAD_FORCE_AUTOHINT, LOAD_NO_HINTING, \\\n     LOAD_DEFAULT, LOAD_NO_AUTOHINT\nfrom matplotlib.mathtext import MathTextParser\nfrom matplotlib.path import Path\nfrom matplotlib.transforms import Bbox, BboxBase\n\nfrom matplotlib.backends._backend_agg import RendererAgg as _RendererAgg\nfrom matplotlib import _png\n\ntry:\n    from PIL import Image\n    _has_pil = True\nexcept ImportError:\n    _has_pil = False\n\nbackend_version = 'v2.2'\n\ndef get_hinting_flag():\n    mapping = {\n        True: LOAD_FORCE_AUTOHINT,\n        False: LOAD_NO_HINTING,\n        'either': LOAD_DEFAULT,\n        'native': LOAD_NO_AUTOHINT,\n        'auto': LOAD_FORCE_AUTOHINT,\n        'none': LOAD_NO_HINTING\n        }\n    return mapping[rcParams['text.hinting']]\n\n\nclass RendererAgg(RendererBase):\n    \"\"\"\n    The renderer handles all the drawing primitives using a graphics\n    context instance that controls the colors/styles\n    \"\"\"\n    debug=1\n\n    # we want to cache the fonts at the class level so that when\n    # multiple figures are created we can reuse them.  This helps with\n    # a bug on windows where the creation of too many figures leads to\n    # too many open file handles.  However, storing them at the class\n    # level is not thread safe.  The solution here is to let the\n    # FigureCanvas acquire a lock on the fontd at the start of the\n    # draw, and release it when it is done.  This allows multiple\n    # renderers to share the cached fonts, but only one figure can\n    # draw at at time and so the font cache is used by only one\n    # renderer at a time\n\n    lock = threading.RLock()\n    _fontd = maxdict(50)\n    def __init__(self, width, height, dpi):\n        if __debug__: verbose.report('RendererAgg.__init__', 'debug-annoying')\n        RendererBase.__init__(self)\n        self.texd = maxdict(50)  # a cache of tex image rasters\n\n        self.dpi = dpi\n        self.width = width\n        self.height = height\n        if __debug__: verbose.report('RendererAgg.__init__ width=%s, height=%s'%(width, height), 'debug-annoying')\n        self._renderer = _RendererAgg(int(width), int(height), dpi, debug=False)\n        self._filter_renderers = []\n\n        if __debug__: verbose.report('RendererAgg.__init__ _RendererAgg done',\n                                     'debug-annoying')\n\n        self._update_methods()\n        self.mathtext_parser = MathTextParser('Agg')\n\n        self.bbox = Bbox.from_bounds(0, 0, self.width, self.height)\n        if __debug__: verbose.report('RendererAgg.__init__ done',\n                                     'debug-annoying')\n\n    def __getstate__(self):\n        # We only want to preserve the init keywords of the Renderer.\n        # Anything else can be re-created.\n        return {'width': self.width, 'height': self.height, 'dpi': self.dpi}\n\n    def __setstate__(self, state):\n        self.__init__(state['width'], state['height'], state['dpi'])\n\n    def _get_hinting_flag(self):\n        if rcParams['text.hinting']:\n            return LOAD_FORCE_AUTOHINT\n        else:\n            return LOAD_NO_HINTING\n\n    # for filtering to work with rasterization, methods needs to be wrapped.\n    # maybe there is better way to do it.\n    def draw_markers(self, *kl, **kw):\n        return self._renderer.draw_markers(*kl, **kw)\n\n    def draw_path_collection(self, *kl, **kw):\n        return self._renderer.draw_path_collection(*kl, **kw)\n\n    def _update_methods(self):\n        self.draw_quad_mesh = self._renderer.draw_quad_mesh\n        self.draw_gouraud_triangle = self._renderer.draw_gouraud_triangle\n        self.draw_gouraud_triangles = self._renderer.draw_gouraud_triangles\n        self.draw_image = self._renderer.draw_image\n        self.copy_from_bbox = self._renderer.copy_from_bbox\n        self.get_content_extents = self._renderer.get_content_extents\n\n    def tostring_rgba_minimized(self):\n        extents = self.get_content_extents()\n        bbox = [[extents[0], self.height - (extents[1] + extents[3])],\n                [extents[0] + extents[2], self.height - extents[1]]]\n        region = self.copy_from_bbox(bbox)\n        return np.array(region), extents\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        \"\"\"\n        Draw the path\n        \"\"\"\n        nmax = rcParams['agg.path.chunksize'] # here at least for testing\n        npts = path.vertices.shape[0]\n        if (nmax > 100 and npts > nmax and path.should_simplify and\n                rgbFace is None and gc.get_hatch() is None):\n            nch = np.ceil(npts/float(nmax))\n            chsize = int(np.ceil(npts/nch))\n            i0 = np.arange(0, npts, chsize)\n            i1 = np.zeros_like(i0)\n            i1[:-1] = i0[1:] - 1\n            i1[-1] = npts\n            for ii0, ii1 in zip(i0, i1):\n                v = path.vertices[ii0:ii1,:]\n                c = path.codes\n                if c is not None:\n                    c = c[ii0:ii1]\n                    c[0] = Path.MOVETO # move to end of last chunk\n                p = Path(v, c)\n                self._renderer.draw_path(gc, p, transform, rgbFace)\n        else:\n            self._renderer.draw_path(gc, path, transform, rgbFace)\n\n    def draw_mathtext(self, gc, x, y, s, prop, angle):\n        \"\"\"\n        Draw the math text using matplotlib.mathtext\n        \"\"\"\n        if __debug__: verbose.report('RendererAgg.draw_mathtext',\n                                     'debug-annoying')\n        ox, oy, width, height, descent, font_image, used_characters = \\\n            self.mathtext_parser.parse(s, self.dpi, prop)\n\n        xd = descent * np.sin(np.deg2rad(angle))\n        yd = descent * np.cos(np.deg2rad(angle))\n        x = np.round(x + ox + xd)\n        y = np.round(y - oy + yd)\n        self._renderer.draw_text_image(font_image, x, y + 1, angle, gc)\n\n    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        \"\"\"\n        Render the text\n        \"\"\"\n        if __debug__: verbose.report('RendererAgg.draw_text', 'debug-annoying')\n\n        if ismath:\n            return self.draw_mathtext(gc, x, y, s, prop, angle)\n\n        flags = get_hinting_flag()\n        font = self._get_agg_font(prop)\n        if font is None: return None\n        if len(s) == 1 and ord(s) > 127:\n            font.load_char(ord(s), flags=flags)\n        else:\n            # We pass '0' for angle here, since it will be rotated (in raster\n            # space) in the following call to draw_text_image).\n            font.set_text(s, 0, flags=flags)\n        font.draw_glyphs_to_bitmap(antialiased=rcParams['text.antialiased'])\n        d = font.get_descent() / 64.0\n        # The descent needs to be adjusted for the angle\n        xd = -d * np.sin(np.deg2rad(angle))\n        yd = d * np.cos(np.deg2rad(angle))\n\n        #print x, y, int(x), int(y), s\n        self._renderer.draw_text_image(\n            font, np.round(x - xd), np.round(y + yd) + 1, angle, gc)\n\n    def get_text_width_height_descent(self, s, prop, ismath):\n        \"\"\"\n        get the width and height in display coords of the string s\n        with FontPropertry prop\n\n        # passing rgb is a little hack to make caching in the\n        # texmanager more efficient.  It is not meant to be used\n        # outside the backend\n        \"\"\"\n        if rcParams['text.usetex']:\n            # todo: handle props\n            size = prop.get_size_in_points()\n            texmanager = self.get_texmanager()\n            fontsize = prop.get_size_in_points()\n            w, h, d = texmanager.get_text_width_height_descent(s, fontsize,\n                                                               renderer=self)\n            return w, h, d\n\n        if ismath:\n            ox, oy, width, height, descent, fonts, used_characters = \\\n                self.mathtext_parser.parse(s, self.dpi, prop)\n            return width, height, descent\n\n        flags = get_hinting_flag()\n        font = self._get_agg_font(prop)\n        font.set_text(s, 0.0, flags=flags)  # the width and height of unrotated string\n        w, h = font.get_width_height()\n        d = font.get_descent()\n        w /= 64.0  # convert from subpixels\n        h /= 64.0\n        d /= 64.0\n        return w, h, d\n\n\n    def draw_tex(self, gc, x, y, s, prop, angle, ismath='TeX!', mtext=None):\n        # todo, handle props, angle, origins\n        size = prop.get_size_in_points()\n\n        texmanager = self.get_texmanager()\n        key = s, size, self.dpi, angle, texmanager.get_font_config()\n        im = self.texd.get(key)\n        if im is None:\n            Z = texmanager.get_grey(s, size, self.dpi)\n            Z = np.array(Z * 255.0, np.uint8)\n\n        w, h, d = self.get_text_width_height_descent(s, prop, ismath)\n        xd = d * np.sin(np.deg2rad(angle))\n        yd = d * np.cos(np.deg2rad(angle))\n        x = np.round(x + xd)\n        y = np.round(y + yd)\n\n        self._renderer.draw_text_image(Z, x, y, angle, gc)\n\n    def get_canvas_width_height(self):\n        'return the canvas width and height in display coords'\n        return self.width, self.height\n\n    def _get_agg_font(self, prop):\n        \"\"\"\n        Get the font for text instance t, cacheing for efficiency\n        \"\"\"\n        if __debug__: verbose.report('RendererAgg._get_agg_font',\n                                     'debug-annoying')\n\n        key = hash(prop)\n        font = RendererAgg._fontd.get(key)\n\n        if font is None:\n            fname = findfont(prop)\n            font = RendererAgg._fontd.get(fname)\n            if font is None:\n                font = FT2Font(\n                    fname,\n                    hinting_factor=rcParams['text.hinting_factor'])\n                RendererAgg._fontd[fname] = font\n            RendererAgg._fontd[key] = font\n\n        font.clear()\n        size = prop.get_size_in_points()\n        font.set_size(size, self.dpi)\n\n        return font\n\n    def points_to_pixels(self, points):\n        \"\"\"\n        convert point measures to pixes using dpi and the pixels per\n        inch of the display\n        \"\"\"\n        if __debug__: verbose.report('RendererAgg.points_to_pixels',\n                                     'debug-annoying')\n        return points*self.dpi/72.0\n\n    def tostring_rgb(self):\n        if __debug__: verbose.report('RendererAgg.tostring_rgb',\n                                     'debug-annoying')\n        return self._renderer.tostring_rgb()\n\n    def tostring_argb(self):\n        if __debug__: verbose.report('RendererAgg.tostring_argb',\n                                     'debug-annoying')\n        return self._renderer.tostring_argb()\n\n    def buffer_rgba(self):\n        if __debug__: verbose.report('RendererAgg.buffer_rgba',\n                                     'debug-annoying')\n        return self._renderer.buffer_rgba()\n\n    def clear(self):\n        self._renderer.clear()\n\n    def option_image_nocomposite(self):\n        # It is generally faster to composite each image directly to\n        # the Figure, and there's no file size benefit to compositing\n        # with the Agg backend\n        return True\n\n    def option_scale_image(self):\n        \"\"\"\n        agg backend support arbitrary scaling of image.\n        \"\"\"\n        return True\n\n    def restore_region(self, region, bbox=None, xy=None):\n        \"\"\"\n        Restore the saved region. If bbox (instance of BboxBase, or\n        its extents) is given, only the region specified by the bbox\n        will be restored. *xy* (a tuple of two floasts) optionally\n        specifies the new position (the LLC of the original region,\n        not the LLC of the bbox) where the region will be restored.\n\n        >>> region = renderer.copy_from_bbox()\n        >>> x1, y1, x2, y2 = region.get_extents()\n        >>> renderer.restore_region(region, bbox=(x1+dx, y1, x2, y2),\n        ...                         xy=(x1-dx, y1))\n\n        \"\"\"\n        if bbox is not None or xy is not None:\n            if bbox is None:\n                x1, y1, x2, y2 = region.get_extents()\n            elif isinstance(bbox, BboxBase):\n                x1, y1, x2, y2 = bbox.extents\n            else:\n                x1, y1, x2, y2 = bbox\n\n            if xy is None:\n                ox, oy = x1, y1\n            else:\n                ox, oy = xy\n\n            self._renderer.restore_region(region, x1, y1, x2, y2, ox, oy)\n\n        else:\n            self._renderer.restore_region(region)\n\n    def start_filter(self):\n        \"\"\"\n        Start filtering. It simply create a new canvas (the old one is saved).\n        \"\"\"\n        self._filter_renderers.append(self._renderer)\n        self._renderer = _RendererAgg(int(self.width), int(self.height),\n                                      self.dpi)\n        self._update_methods()\n\n    def stop_filter(self, post_processing):\n        \"\"\"\n        Save the plot in the current canvas as a image and apply\n        the *post_processing* function.\n\n           def post_processing(image, dpi):\n             # ny, nx, depth = image.shape\n             # image (numpy array) has RGBA channels and has a depth of 4.\n             ...\n             # create a new_image (numpy array of 4 channels, size can be\n             # different). The resulting image may have offsets from\n             # lower-left corner of the original image\n             return new_image, offset_x, offset_y\n\n        The saved renderer is restored and the returned image from\n        post_processing is plotted (using draw_image) on it.\n        \"\"\"\n\n        # WARNING.\n        # For agg_filter to work, the rendere's method need\n        # to overridden in the class. See draw_markers, and draw_path_collections\n\n        from matplotlib._image import fromarray\n\n        width, height = int(self.width), int(self.height)\n\n        buffer, bounds = self.tostring_rgba_minimized()\n\n        l, b, w, h = bounds\n\n\n        self._renderer = self._filter_renderers.pop()\n        self._update_methods()\n\n        if w > 0 and h > 0:\n            img = np.fromstring(buffer, np.uint8)\n            img, ox, oy = post_processing(img.reshape((h, w, 4)) / 255.,\n                                          self.dpi)\n            image = fromarray(img, 1)\n\n            gc = self.new_gc()\n            self._renderer.draw_image(gc,\n                                      l+ox, height - b - h +oy,\n                                      image)\n\n\ndef new_figure_manager(num, *args, **kwargs):\n    \"\"\"\n    Create a new figure manager instance\n    \"\"\"\n    if __debug__: verbose.report('backend_agg.new_figure_manager',\n                                 'debug-annoying')\n\n\n    FigureClass = kwargs.pop('FigureClass', Figure)\n    thisFig = FigureClass(*args, **kwargs)\n    return new_figure_manager_given_figure(num, thisFig)\n\n\ndef new_figure_manager_given_figure(num, figure):\n    \"\"\"\n    Create a new figure manager instance for the given figure.\n    \"\"\"\n    canvas = FigureCanvasAgg(figure)\n    manager = FigureManagerBase(canvas, num)\n    return manager\n\n\nclass FigureCanvasAgg(FigureCanvasBase):\n    \"\"\"\n    The canvas the figure renders into.  Calls the draw and print fig\n    methods, creates the renderers, etc...\n\n    Public attribute\n\n      figure - A Figure instance\n    \"\"\"\n\n    def copy_from_bbox(self, bbox):\n        renderer = self.get_renderer()\n        return renderer.copy_from_bbox(bbox)\n\n    def restore_region(self, region, bbox=None, xy=None):\n        renderer = self.get_renderer()\n        return renderer.restore_region(region, bbox, xy)\n\n    def draw(self):\n        \"\"\"\n        Draw the figure using the renderer\n        \"\"\"\n        if __debug__: verbose.report('FigureCanvasAgg.draw', 'debug-annoying')\n\n        self.renderer = self.get_renderer(cleared=True)\n        # acquire a lock on the shared font cache\n        RendererAgg.lock.acquire()\n\n        try:\n            self.figure.draw(self.renderer)\n        finally:\n            RendererAgg.lock.release()\n\n    def get_renderer(self, cleared=False):\n        l, b, w, h = self.figure.bbox.bounds\n        key = w, h, self.figure.dpi\n        try: self._lastKey, self.renderer\n        except AttributeError: need_new_renderer = True\n        else:  need_new_renderer = (self._lastKey != key)\n\n        if need_new_renderer:\n            self.renderer = RendererAgg(w, h, self.figure.dpi)\n            self._lastKey = key\n        elif cleared:\n            self.renderer.clear()\n        return self.renderer\n\n    def tostring_rgb(self):\n        if __debug__: verbose.report('FigureCanvasAgg.tostring_rgb',\n                                     'debug-annoying')\n        return self.renderer.tostring_rgb()\n\n    def tostring_argb(self):\n        if __debug__: verbose.report('FigureCanvasAgg.tostring_argb',\n                                     'debug-annoying')\n        return self.renderer.tostring_argb()\n\n    def buffer_rgba(self):\n        if __debug__: verbose.report('FigureCanvasAgg.buffer_rgba',\n                                     'debug-annoying')\n        return self.renderer.buffer_rgba()\n\n    def print_raw(self, filename_or_obj, *args, **kwargs):\n        FigureCanvasAgg.draw(self)\n        renderer = self.get_renderer()\n        original_dpi = renderer.dpi\n        renderer.dpi = self.figure.dpi\n        if is_string_like(filename_or_obj):\n            fileobj = open(filename_or_obj, 'wb')\n            close = True\n        else:\n            fileobj = filename_or_obj\n            close = False\n        try:\n            fileobj.write(renderer._renderer.buffer_rgba())\n        finally:\n            if close:\n                filename_or_obj.close()\n        renderer.dpi = original_dpi\n    print_rgba = print_raw\n\n    def print_png(self, filename_or_obj, *args, **kwargs):\n        FigureCanvasAgg.draw(self)\n        renderer = self.get_renderer()\n        original_dpi = renderer.dpi\n        renderer.dpi = self.figure.dpi\n        if is_string_like(filename_or_obj):\n            filename_or_obj = open(filename_or_obj, 'wb')\n            close = True\n        else:\n            close = False\n        try:\n            _png.write_png(renderer._renderer, filename_or_obj, self.figure.dpi)\n        finally:\n            if close:\n                filename_or_obj.close()\n        renderer.dpi = original_dpi\n\n    def print_to_buffer(self):\n        FigureCanvasAgg.draw(self)\n        renderer = self.get_renderer()\n        original_dpi = renderer.dpi\n        renderer.dpi = self.figure.dpi\n        result = (renderer._renderer.buffer_rgba(),\n                  (int(renderer.width), int(renderer.height)))\n        renderer.dpi = original_dpi\n        return result\n\n    if _has_pil:\n\n        # add JPEG support\n        def print_jpg(self, filename_or_obj, *args, **kwargs):\n            \"\"\"\n            Supported kwargs:\n\n            *quality*: The image quality, on a scale from 1 (worst) to\n                95 (best). The default is 95, if not given in the\n                matplotlibrc file in the savefig.jpeg_quality parameter.\n                Values above 95 should be avoided; 100 completely\n                disables the JPEG quantization stage.\n\n            *optimize*: If present, indicates that the encoder should\n                make an extra pass over the image in order to select\n                optimal encoder settings.\n\n            *progressive*: If present, indicates that this image\n                should be stored as a progressive JPEG file.\n            \"\"\"\n            buf, size = self.print_to_buffer()\n            if kwargs.pop(\"dryrun\", False):\n                return\n            image = Image.frombuffer('RGBA', size, buf, 'raw', 'RGBA', 0, 1)\n            options = restrict_dict(kwargs, ['quality', 'optimize',\n                                             'progressive'])\n\n            if 'quality' not in options:\n                options['quality'] = rcParams['savefig.jpeg_quality']\n\n            return image.save(filename_or_obj, format='jpeg', **options)\n        print_jpeg = print_jpg\n\n        # add TIFF support\n        def print_tif(self, filename_or_obj, *args, **kwargs):\n            buf, size = self.print_to_buffer()\n            if kwargs.pop(\"dryrun\", False):\n                return\n            image = Image.frombuffer('RGBA', size, buf, 'raw', 'RGBA', 0, 1)\n            dpi = (self.figure.dpi, self.figure.dpi)\n            return image.save(filename_or_obj, format='tiff',\n                              dpi=dpi)\n        print_tiff = print_tif\n\n\nFigureCanvas = FigureCanvasAgg\n", "patch": "@@ -127,15 +127,19 @@ def draw_path_collection(self, *kl, **kw):\n         return self._renderer.draw_path_collection(*kl, **kw)\n \n     def _update_methods(self):\n-        #self.draw_path = self._renderer.draw_path  # see below\n-        #self.draw_markers = self._renderer.draw_markers\n-        #self.draw_path_collection = self._renderer.draw_path_collection\n         self.draw_quad_mesh = self._renderer.draw_quad_mesh\n         self.draw_gouraud_triangle = self._renderer.draw_gouraud_triangle\n         self.draw_gouraud_triangles = self._renderer.draw_gouraud_triangles\n         self.draw_image = self._renderer.draw_image\n         self.copy_from_bbox = self._renderer.copy_from_bbox\n-        self.tostring_rgba_minimized = self._renderer.tostring_rgba_minimized\n+        self.get_content_extents = self._renderer.get_content_extents\n+\n+    def tostring_rgba_minimized(self):\n+        extents = self.get_content_extents()\n+        bbox = [[extents[0], self.height - (extents[1] + extents[3])],\n+                [extents[0] + extents[2], self.height - extents[1]]]\n+        region = self.copy_from_bbox(bbox)\n+        return np.array(region), extents\n \n     def draw_path(self, gc, path, transform, rgbFace=None):\n         \"\"\"\n@@ -203,7 +207,7 @@ def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n \n         #print x, y, int(x), int(y), s\n         self._renderer.draw_text_image(\n-            font.get_image(), np.round(x - xd), np.round(y + yd) + 1, angle, gc)\n+            font, np.round(x - xd), np.round(y + yd) + 1, angle, gc)\n \n     def get_text_width_height_descent(self, s, prop, ismath):\n         \"\"\"\n@@ -354,7 +358,7 @@ def restore_region(self, region, bbox=None, xy=None):\n             else:\n                 ox, oy = xy\n \n-            self._renderer.restore_region2(region, x1, y1, x2, y2, ox, oy)\n+            self._renderer.restore_region(region, x1, y1, x2, y2, ox, oy)\n \n         else:\n             self._renderer.restore_region(region)\n@@ -394,7 +398,7 @@ def post_processing(image, dpi):\n \n         width, height = int(self.width), int(self.height)\n \n-        buffer, bounds = self._renderer.tostring_rgba_minimized()\n+        buffer, bounds = self.tostring_rgba_minimized()\n \n         l, b, w, h = bounds\n \n@@ -407,7 +411,6 @@ def post_processing(image, dpi):\n             img, ox, oy = post_processing(img.reshape((h, w, 4)) / 255.,\n                                           self.dpi)\n             image = fromarray(img, 1)\n-            image.flipud_out()\n \n             gc = self.new_gc()\n             self._renderer.draw_image(gc,\n@@ -505,12 +508,13 @@ def print_raw(self, filename_or_obj, *args, **kwargs):\n         original_dpi = renderer.dpi\n         renderer.dpi = self.figure.dpi\n         if is_string_like(filename_or_obj):\n-            filename_or_obj = open(filename_or_obj, 'wb')\n+            fileobj = open(filename_or_obj, 'wb')\n             close = True\n         else:\n+            fileobj = filename_or_obj\n             close = False\n         try:\n-            renderer._renderer.write_rgba(filename_or_obj)\n+            fileobj.write(renderer._renderer.buffer_rgba())\n         finally:\n             if close:\n                 filename_or_obj.close()\n@@ -528,9 +532,7 @@ def print_png(self, filename_or_obj, *args, **kwargs):\n         else:\n             close = False\n         try:\n-            _png.write_png(renderer._renderer.buffer_rgba(),\n-                           renderer.width, renderer.height,\n-                           filename_or_obj, self.figure.dpi)\n+            _png.write_png(renderer._renderer, filename_or_obj, self.figure.dpi)\n         finally:\n             if close:\n                 filename_or_obj.close()"}
{"patches_id": 2, "files_id": 8, "language": "py", "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Fbackends%2Fbackend_cairo.py", "raw_code": "\"\"\"\nA Cairo backend for matplotlib\nAuthor: Steve Chaplin\n\nCairo is a vector graphics library with cross-device output support.\nFeatures of Cairo:\n * anti-aliasing\n * alpha channel\n * saves image files as PNG, PostScript, PDF\n\nhttp://cairographics.org\nRequires (in order, all available from Cairo website):\n    cairo, pycairo\n\nNaming Conventions\n  * classes MixedUpperCase\n  * varables lowerUpper\n  * functions underscore_separated\n\"\"\"\n\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport six\n\nimport os, sys, warnings, gzip\n\nimport numpy as np\n\ndef _fn_name(): return sys._getframe(1).f_code.co_name\n\ntry:\n    import cairocffi as cairo\nexcept ImportError:\n    try:\n        import cairo\n    except ImportError:\n        raise ImportError(\"Cairo backend requires that cairocffi or pycairo is installed.\")\n    else:\n        HAS_CAIRO_CFFI = False\nelse:\n    HAS_CAIRO_CFFI = True\n\n_version_required = (1,2,0)\nif cairo.version_info < _version_required:\n    raise ImportError (\"Pycairo %d.%d.%d is installed\\n\"\n                       \"Pycairo %d.%d.%d or later is required\"\n                        % (cairo.version_info + _version_required))\nbackend_version = cairo.version\ndel _version_required\n\nfrom matplotlib.backend_bases import RendererBase, GraphicsContextBase,\\\n     FigureManagerBase, FigureCanvasBase\nfrom matplotlib.cbook        import is_string_like\nfrom matplotlib.figure       import Figure\nfrom matplotlib.mathtext     import MathTextParser\nfrom matplotlib.path         import Path\nfrom matplotlib.transforms   import Bbox, Affine2D\nfrom matplotlib.font_manager import ttfFontProperty\n\n_debug = False\n#_debug = True\n\n# Image::color_conv(format) for draw_image()\nif sys.byteorder == 'little':\n    BYTE_FORMAT = 0 # BGRA\nelse:\n    BYTE_FORMAT = 1 # ARGB\n\n\nclass RendererCairo(RendererBase):\n    fontweights = {\n        100          : cairo.FONT_WEIGHT_NORMAL,\n        200          : cairo.FONT_WEIGHT_NORMAL,\n        300          : cairo.FONT_WEIGHT_NORMAL,\n        400          : cairo.FONT_WEIGHT_NORMAL,\n        500          : cairo.FONT_WEIGHT_NORMAL,\n        600          : cairo.FONT_WEIGHT_BOLD,\n        700          : cairo.FONT_WEIGHT_BOLD,\n        800          : cairo.FONT_WEIGHT_BOLD,\n        900          : cairo.FONT_WEIGHT_BOLD,\n        'ultralight' : cairo.FONT_WEIGHT_NORMAL,\n        'light'      : cairo.FONT_WEIGHT_NORMAL,\n        'normal'     : cairo.FONT_WEIGHT_NORMAL,\n        'medium'     : cairo.FONT_WEIGHT_NORMAL,\n        'semibold'   : cairo.FONT_WEIGHT_BOLD,\n        'bold'       : cairo.FONT_WEIGHT_BOLD,\n        'heavy'      : cairo.FONT_WEIGHT_BOLD,\n        'ultrabold'  : cairo.FONT_WEIGHT_BOLD,\n        'black'      : cairo.FONT_WEIGHT_BOLD,\n                   }\n    fontangles = {\n        'italic'  : cairo.FONT_SLANT_ITALIC,\n        'normal'  : cairo.FONT_SLANT_NORMAL,\n        'oblique' : cairo.FONT_SLANT_OBLIQUE,\n        }\n\n\n    def __init__(self, dpi):\n        \"\"\"\n        \"\"\"\n        if _debug: print('%s.%s()' % (self.__class__.__name__, _fn_name()))\n        self.dpi = dpi\n        self.gc = GraphicsContextCairo (renderer=self)\n        self.text_ctx = cairo.Context (\n           cairo.ImageSurface (cairo.FORMAT_ARGB32,1,1))\n        self.mathtext_parser = MathTextParser('Cairo')\n\n        RendererBase.__init__(self)\n\n    def set_ctx_from_surface (self, surface):\n        self.gc.ctx = cairo.Context (surface)\n\n\n    def set_width_height(self, width, height):\n        self.width  = width\n        self.height = height\n        self.matrix_flipy = cairo.Matrix (yy=-1, y0=self.height)\n        # use matrix_flipy for ALL rendering?\n        # - problem with text? - will need to switch matrix_flipy off, or do a\n        # font transform?\n\n\n    def _fill_and_stroke (self, ctx, fill_c, alpha, alpha_overrides):\n        if fill_c is not None:\n            ctx.save()\n            if len(fill_c) == 3 or alpha_overrides:\n                ctx.set_source_rgba (fill_c[0], fill_c[1], fill_c[2], alpha)\n            else:\n                ctx.set_source_rgba (fill_c[0], fill_c[1], fill_c[2], fill_c[3])\n            ctx.fill_preserve()\n            ctx.restore()\n        ctx.stroke()\n\n    @staticmethod\n    def convert_path(ctx, path, transform):\n        for points, code in path.iter_segments(transform):\n            if code == Path.MOVETO:\n                ctx.move_to(*points)\n            elif code == Path.CLOSEPOLY:\n                ctx.close_path()\n            elif code == Path.LINETO:\n                ctx.line_to(*points)\n            elif code == Path.CURVE3:\n                ctx.curve_to(points[0], points[1],\n                             points[0], points[1],\n                             points[2], points[3])\n            elif code == Path.CURVE4:\n                ctx.curve_to(*points)\n\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        if len(path.vertices) > 18980:\n            raise ValueError(\"The Cairo backend can not draw paths longer than 18980 points.\")\n\n        ctx = gc.ctx\n\n        transform = transform + \\\n            Affine2D().scale(1.0, -1.0).translate(0, self.height)\n\n        ctx.new_path()\n        self.convert_path(ctx, path, transform)\n\n        self._fill_and_stroke(ctx, rgbFace, gc.get_alpha(), gc.get_forced_alpha())\n\n    def draw_image(self, gc, x, y, im):\n        # bbox - not currently used\n        if _debug: print('%s.%s()' % (self.__class__.__name__, _fn_name()))\n\n        rows, cols, buf = im.color_conv (BYTE_FORMAT)\n        surface = cairo.ImageSurface.create_for_data (\n                      buf, cairo.FORMAT_ARGB32, cols, rows, cols*4)\n        ctx = gc.ctx\n        y = self.height - y - rows\n\n        ctx.save()\n        ctx.set_source_surface (surface, x, y)\n        if gc.get_alpha() != 1.0:\n            ctx.paint_with_alpha(gc.get_alpha())\n        else:\n            ctx.paint()\n        ctx.restore()\n\n    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # Note: x,y are device/display coords, not user-coords, unlike other\n        # draw_* methods\n        if _debug: print('%s.%s()' % (self.__class__.__name__, _fn_name()))\n\n        if ismath:\n            self._draw_mathtext(gc, x, y, s, prop, angle)\n\n        else:\n            ctx = gc.ctx\n            ctx.new_path()\n            ctx.move_to (x, y)\n            ctx.select_font_face (prop.get_name(),\n                                  self.fontangles [prop.get_style()],\n                                  self.fontweights[prop.get_weight()])\n\n            size = prop.get_size_in_points() * self.dpi / 72.0\n\n            ctx.save()\n            if angle:\n                ctx.rotate (-angle * np.pi / 180)\n            ctx.set_font_size (size)\n\n            if HAS_CAIRO_CFFI:\n                if not isinstance(s, six.text_type):\n                    s = six.text_type(s)\n            else:\n                if not six.PY3 and isinstance(s, six.text_type):\n                    s = s.encode(\"utf-8\")\n\n            ctx.show_text(s)\n            ctx.restore()\n\n    def _draw_mathtext(self, gc, x, y, s, prop, angle):\n        if _debug: print('%s.%s()' % (self.__class__.__name__, _fn_name()))\n\n        ctx = gc.ctx\n        width, height, descent, glyphs, rects = self.mathtext_parser.parse(\n            s, self.dpi, prop)\n\n        ctx.save()\n        ctx.translate(x, y)\n        if angle:\n            ctx.rotate (-angle * np.pi / 180)\n\n        for font, fontsize, s, ox, oy in glyphs:\n            ctx.new_path()\n            ctx.move_to(ox, oy)\n\n            fontProp = ttfFontProperty(font)\n            ctx.save()\n            ctx.select_font_face (fontProp.name,\n                                  self.fontangles [fontProp.style],\n                                  self.fontweights[fontProp.weight])\n\n            size = fontsize * self.dpi / 72.0\n            ctx.set_font_size(size)\n            if isinstance(s, six.text_type):\n                s = s.encode(\"utf-8\")\n            ctx.show_text(s)\n            ctx.restore()\n\n        for ox, oy, w, h in rects:\n            ctx.new_path()\n            ctx.rectangle (ox, oy, w, h)\n            ctx.set_source_rgb (0, 0, 0)\n            ctx.fill_preserve()\n\n        ctx.restore()\n\n\n    def flipy(self):\n        if _debug: print('%s.%s()' % (self.__class__.__name__, _fn_name()))\n        return True\n        #return False # tried - all draw objects ok except text (and images?)\n        # which comes out mirrored!\n\n\n    def get_canvas_width_height(self):\n        if _debug: print('%s.%s()' % (self.__class__.__name__, _fn_name()))\n        return self.width, self.height\n\n\n    def get_text_width_height_descent(self, s, prop, ismath):\n        if _debug: print('%s.%s()' % (self.__class__.__name__, _fn_name()))\n        if ismath:\n            width, height, descent, fonts, used_characters = self.mathtext_parser.parse(\n               s, self.dpi, prop)\n            return width, height, descent\n\n        ctx = self.text_ctx\n        ctx.save()\n        ctx.select_font_face (prop.get_name(),\n                              self.fontangles [prop.get_style()],\n                              self.fontweights[prop.get_weight()])\n\n        # Cairo (says it) uses 1/96 inch user space units, ref: cairo_gstate.c\n        # but if /96.0 is used the font is too small\n\n        size = prop.get_size_in_points() * self.dpi / 72.0\n\n        # problem - scale remembers last setting and font can become\n        # enormous causing program to crash\n        # save/restore prevents the problem\n        ctx.set_font_size (size)\n\n        y_bearing, w, h = ctx.text_extents (s)[1:4]\n        ctx.restore()\n\n        return w, h, h + y_bearing\n\n\n    def new_gc(self):\n        if _debug: print('%s.%s()' % (self.__class__.__name__, _fn_name()))\n        self.gc.ctx.save()\n        self.gc._alpha = 1.0\n        self.gc._forced_alpha = False # if True, _alpha overrides A from RGBA\n        return self.gc\n\n\n    def points_to_pixels(self, points):\n        if _debug: print('%s.%s()' % (self.__class__.__name__, _fn_name()))\n        return points/72.0 * self.dpi\n\n\nclass GraphicsContextCairo(GraphicsContextBase):\n    _joind = {\n        'bevel' : cairo.LINE_JOIN_BEVEL,\n        'miter' : cairo.LINE_JOIN_MITER,\n        'round' : cairo.LINE_JOIN_ROUND,\n        }\n\n    _capd = {\n        'butt'       : cairo.LINE_CAP_BUTT,\n        'projecting' : cairo.LINE_CAP_SQUARE,\n        'round'      : cairo.LINE_CAP_ROUND,\n        }\n\n\n    def __init__(self, renderer):\n        GraphicsContextBase.__init__(self)\n        self.renderer = renderer\n\n\n    def restore(self):\n        self.ctx.restore()\n\n\n    def set_alpha(self, alpha):\n        GraphicsContextBase.set_alpha(self, alpha)\n        _alpha = self.get_alpha()\n        rgb = self._rgb\n        if self.get_forced_alpha():\n            self.ctx.set_source_rgba (rgb[0], rgb[1], rgb[2], _alpha)\n        else:\n            self.ctx.set_source_rgba (rgb[0], rgb[1], rgb[2], rgb[3])\n\n\n    #def set_antialiased(self, b):\n        # enable/disable anti-aliasing is not (yet) supported by Cairo\n\n\n    def set_capstyle(self, cs):\n        if cs in ('butt', 'round', 'projecting'):\n            self._capstyle = cs\n            self.ctx.set_line_cap (self._capd[cs])\n        else:\n            raise ValueError('Unrecognized cap style.  Found %s' % cs)\n\n\n    def set_clip_rectangle(self, rectangle):\n        if not rectangle: return\n        x,y,w,h = rectangle.bounds\n        # pixel-aligned clip-regions are faster\n        x,y,w,h = round(x), round(y), round(w), round(h)\n        ctx = self.ctx\n        ctx.new_path()\n        ctx.rectangle (x, self.renderer.height - h - y, w, h)\n        ctx.clip ()\n\n    def set_clip_path(self, path):\n        if not path: return\n        tpath, affine = path.get_transformed_path_and_affine()\n        ctx = self.ctx\n        ctx.new_path()\n        affine = affine + Affine2D().scale(1.0, -1.0).translate(0.0, self.renderer.height)\n        RendererCairo.convert_path(ctx, tpath, affine)\n        ctx.clip()\n\n    def set_dashes(self, offset, dashes):\n        self._dashes = offset, dashes\n        if dashes == None:\n            self.ctx.set_dash([], 0)  # switch dashes off\n        else:\n            self.ctx.set_dash(\n                list(self.renderer.points_to_pixels(np.asarray(dashes))), offset)\n\n\n    def set_foreground(self, fg, isRGBA=None):\n        GraphicsContextBase.set_foreground(self, fg, isRGBA)\n        if len(self._rgb) == 3:\n            self.ctx.set_source_rgb(*self._rgb)\n        else:\n            self.ctx.set_source_rgba(*self._rgb)\n\n    def set_graylevel(self, frac):\n        GraphicsContextBase.set_graylevel(self, frac)\n        if len(self._rgb) == 3:\n            self.ctx.set_source_rgb(*self._rgb)\n        else:\n            self.ctx.set_source_rgba(*self._rgb)\n\n\n    def set_joinstyle(self, js):\n        if js in ('miter', 'round', 'bevel'):\n            self._joinstyle = js\n            self.ctx.set_line_join(self._joind[js])\n        else:\n            raise ValueError('Unrecognized join style.  Found %s' % js)\n\n\n    def set_linewidth(self, w):\n        self._linewidth = w\n        self.ctx.set_line_width (self.renderer.points_to_pixels(w))\n\n\ndef new_figure_manager(num, *args, **kwargs): # called by backends/__init__.py\n    \"\"\"\n    Create a new figure manager instance\n    \"\"\"\n    if _debug: print('%s()' % (_fn_name()))\n    FigureClass = kwargs.pop('FigureClass', Figure)\n    thisFig = FigureClass(*args, **kwargs)\n    return new_figure_manager_given_figure(num, thisFig)\n\n\ndef new_figure_manager_given_figure(num, figure):\n    \"\"\"\n    Create a new figure manager instance for the given figure.\n    \"\"\"\n    canvas  = FigureCanvasCairo(figure)\n    manager = FigureManagerBase(canvas, num)\n    return manager\n\n\nclass FigureCanvasCairo (FigureCanvasBase):\n    def print_png(self, fobj, *args, **kwargs):\n        width, height = self.get_width_height()\n\n        renderer = RendererCairo (self.figure.dpi)\n        renderer.set_width_height (width, height)\n        surface = cairo.ImageSurface (cairo.FORMAT_ARGB32, width, height)\n        renderer.set_ctx_from_surface (surface)\n\n        self.figure.draw (renderer)\n        surface.write_to_png (fobj)\n\n    def print_pdf(self, fobj, *args, **kwargs):\n        return self._save(fobj, 'pdf', *args, **kwargs)\n\n    def print_ps(self, fobj, *args, **kwargs):\n        return self._save(fobj, 'ps', *args, **kwargs)\n\n    def print_svg(self, fobj, *args, **kwargs):\n        return self._save(fobj, 'svg', *args, **kwargs)\n\n    def print_svgz(self, fobj, *args, **kwargs):\n        return self._save(fobj, 'svgz', *args, **kwargs)\n\n    def _save (self, fo, format, **kwargs):\n        # save PDF/PS/SVG\n        orientation = kwargs.get('orientation', 'portrait')\n\n        dpi = 72\n        self.figure.dpi = dpi\n        w_in, h_in = self.figure.get_size_inches()\n        width_in_points, height_in_points = w_in * dpi, h_in * dpi\n\n        if orientation == 'landscape':\n            width_in_points, height_in_points = (height_in_points,\n                                                 width_in_points)\n\n        if format == 'ps':\n            if not hasattr(cairo, 'PSSurface'):\n                raise RuntimeError ('cairo has not been compiled with PS '\n                                    'support enabled')\n            surface = cairo.PSSurface (fo, width_in_points, height_in_points)\n        elif format == 'pdf':\n            if not hasattr(cairo, 'PDFSurface'):\n                raise RuntimeError ('cairo has not been compiled with PDF '\n                                    'support enabled')\n            surface = cairo.PDFSurface (fo, width_in_points, height_in_points)\n        elif format in ('svg', 'svgz'):\n            if not hasattr(cairo, 'SVGSurface'):\n                raise RuntimeError ('cairo has not been compiled with SVG '\n                                    'support enabled')\n            if format == 'svgz':\n                filename = fo\n                if is_string_like(fo):\n                    fo = open(fo, 'wb')\n                    close = True\n                else:\n                    close = False\n                try:\n                    fo = gzip.GzipFile(None, 'wb', fileobj=fo)\n                finally:\n                    if close:\n                        fo.close()\n            surface = cairo.SVGSurface (fo, width_in_points, height_in_points)\n        else:\n           warnings.warn (\"unknown format: %s\" % format)\n           return\n\n        # surface.set_dpi() can be used\n        renderer = RendererCairo (self.figure.dpi)\n        renderer.set_width_height (width_in_points, height_in_points)\n        renderer.set_ctx_from_surface (surface)\n        ctx = renderer.gc.ctx\n\n        if orientation == 'landscape':\n            ctx.rotate (np.pi/2)\n            ctx.translate (0, -height_in_points)\n            # cairo/src/cairo_ps_surface.c\n            # '%%Orientation: Portrait' is always written to the file header\n            # '%%Orientation: Landscape' would possibly cause problems\n            # since some printers would rotate again ?\n            # TODO:\n            # add portrait/landscape checkbox to FileChooser\n\n        self.figure.draw (renderer)\n\n        show_fig_border = False  # for testing figure orientation and scaling\n        if show_fig_border:\n            ctx.new_path()\n            ctx.rectangle(0, 0, width_in_points, height_in_points)\n            ctx.set_line_width(4.0)\n            ctx.set_source_rgb(1,0,0)\n            ctx.stroke()\n            ctx.move_to(30,30)\n            ctx.select_font_face ('sans-serif')\n            ctx.set_font_size(20)\n            ctx.show_text('Origin corner')\n\n        ctx.show_page()\n        surface.finish()\n\n\nFigureCanvas = FigureCanvasCairo\n", "patch": "@@ -167,8 +167,6 @@ def draw_image(self, gc, x, y, im):\n         # bbox - not currently used\n         if _debug: print('%s.%s()' % (self.__class__.__name__, _fn_name()))\n \n-        im.flipud_out()\n-\n         rows, cols, buf = im.color_conv (BYTE_FORMAT)\n         surface = cairo.ImageSurface.create_for_data (\n                       buf, cairo.FORMAT_ARGB32, cols, rows, cols*4)\n@@ -183,8 +181,6 @@ def draw_image(self, gc, x, y, im):\n             ctx.paint()\n         ctx.restore()\n \n-        im.flipud_out()\n-\n     def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n         # Note: x,y are device/display coords, not user-coords, unlike other\n         # draw_* methods"}
{"patches_id": 2, "files_id": 9, "language": "py", "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Fbackends%2Fbackend_gdk.py", "raw_code": "from __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport six\n\nimport math\nimport os\nimport sys\nimport warnings\ndef fn_name(): return sys._getframe(1).f_code.co_name\n\nimport gobject\nimport gtk; gdk = gtk.gdk\nimport pango\npygtk_version_required = (2,2,0)\nif gtk.pygtk_version < pygtk_version_required:\n    raise ImportError (\"PyGTK %d.%d.%d is installed\\n\"\n                      \"PyGTK %d.%d.%d or later is required\"\n                      % (gtk.pygtk_version + pygtk_version_required))\ndel pygtk_version_required\n\nimport numpy as np\n\nimport matplotlib\nfrom matplotlib import rcParams\nfrom matplotlib._pylab_helpers import Gcf\nfrom matplotlib.backend_bases import RendererBase, GraphicsContextBase, \\\n     FigureManagerBase, FigureCanvasBase\nfrom matplotlib.cbook import is_string_like\nfrom matplotlib.figure import Figure\nfrom matplotlib.mathtext import MathTextParser\nfrom matplotlib.transforms import Affine2D\nfrom matplotlib.backends._backend_gdk import pixbuf_get_pixels_array\n\nbackend_version = \"%d.%d.%d\" % gtk.pygtk_version\n_debug = False\n\n# Image formats that this backend supports - for FileChooser and print_figure()\nIMAGE_FORMAT  = ['eps', 'jpg', 'png', 'ps', 'svg'] + ['bmp'] # , 'raw', 'rgb']\nIMAGE_FORMAT.sort()\nIMAGE_FORMAT_DEFAULT  = 'png'\n\n\nclass RendererGDK(RendererBase):\n    fontweights = {\n        100          : pango.WEIGHT_ULTRALIGHT,\n        200          : pango.WEIGHT_LIGHT,\n        300          : pango.WEIGHT_LIGHT,\n        400          : pango.WEIGHT_NORMAL,\n        500          : pango.WEIGHT_NORMAL,\n        600          : pango.WEIGHT_BOLD,\n        700          : pango.WEIGHT_BOLD,\n        800          : pango.WEIGHT_HEAVY,\n        900          : pango.WEIGHT_ULTRABOLD,\n        'ultralight' : pango.WEIGHT_ULTRALIGHT,\n        'light'      : pango.WEIGHT_LIGHT,\n        'normal'     : pango.WEIGHT_NORMAL,\n        'medium'     : pango.WEIGHT_NORMAL,\n        'semibold'   : pango.WEIGHT_BOLD,\n        'bold'       : pango.WEIGHT_BOLD,\n        'heavy'      : pango.WEIGHT_HEAVY,\n        'ultrabold'  : pango.WEIGHT_ULTRABOLD,\n        'black'      : pango.WEIGHT_ULTRABOLD,\n                   }\n\n    # cache for efficiency, these must be at class, not instance level\n    layoutd = {}  # a map from text prop tups to pango layouts\n    rotated = {}  # a map from text prop tups to rotated text pixbufs\n\n    def __init__(self, gtkDA, dpi):\n        # widget gtkDA is used for:\n        #  '<widget>.create_pango_layout(s)'\n        #  cmap line below)\n        self.gtkDA = gtkDA\n        self.dpi   = dpi\n        self._cmap = gtkDA.get_colormap()\n        self.mathtext_parser = MathTextParser(\"Agg\")\n\n    def set_pixmap (self, pixmap):\n        self.gdkDrawable = pixmap\n\n    def set_width_height (self, width, height):\n        \"\"\"w,h is the figure w,h not the pixmap w,h\n        \"\"\"\n        self.width, self.height = width, height\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        transform = transform + Affine2D(). \\\n            scale(1.0, -1.0).translate(0, self.height)\n        polygons = path.to_polygons(transform, self.width, self.height)\n        for polygon in polygons:\n            # draw_polygon won't take an arbitrary sequence -- it must be a list\n            # of tuples\n            polygon = [(int(round(x)), int(round(y))) for x, y in polygon]\n            if rgbFace is not None:\n                saveColor = gc.gdkGC.foreground\n                gc.gdkGC.foreground = gc.rgb_to_gdk_color(rgbFace)\n                self.gdkDrawable.draw_polygon(gc.gdkGC, True, polygon)\n                gc.gdkGC.foreground = saveColor\n            if gc.gdkGC.line_width > 0:\n                self.gdkDrawable.draw_lines(gc.gdkGC, polygon)\n\n    def draw_image(self, gc, x, y, im):\n        bbox = gc.get_clip_rectangle()\n\n        if bbox != None:\n            l,b,w,h = bbox.bounds\n            #rectangle = (int(l), self.height-int(b+h),\n            #             int(w), int(h))\n            # set clip rect?\n\n        rows, cols, image_str = im.as_rgba_str()\n\n        image_array = np.fromstring(image_str, np.uint8)\n        image_array.shape = rows, cols, 4\n\n        pixbuf = gtk.gdk.Pixbuf(gtk.gdk.COLORSPACE_RGB,\n                                has_alpha=True, bits_per_sample=8,\n                                width=cols, height=rows)\n\n        array = pixbuf_get_pixels_array(pixbuf)\n        array[:,:,:] = image_array[::-1]\n\n        gc = self.new_gc()\n\n\n        y = self.height-y-rows\n\n        try: # new in 2.2\n            # can use None instead of gc.gdkGC, if don't need clipping\n            self.gdkDrawable.draw_pixbuf (gc.gdkGC, pixbuf, 0, 0,\n                                          int(x), int(y), cols, rows,\n                                          gdk.RGB_DITHER_NONE, 0, 0)\n        except AttributeError:\n            # deprecated in 2.2\n            pixbuf.render_to_drawable(self.gdkDrawable, gc.gdkGC, 0, 0,\n                                  int(x), int(y), cols, rows,\n                                  gdk.RGB_DITHER_NONE, 0, 0)\n\n\n    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        x, y = int(x), int(y)\n\n        if x < 0 or y < 0: # window has shrunk and text is off the edge\n            return\n\n        if angle not in (0,90):\n            warnings.warn('backend_gdk: unable to draw text at angles ' +\n                          'other than 0 or 90')\n        elif ismath:\n            self._draw_mathtext(gc, x, y, s, prop, angle)\n\n        elif angle==90:\n            self._draw_rotated_text(gc, x, y, s, prop, angle)\n\n        else:\n            layout, inkRect, logicalRect = self._get_pango_layout(s, prop)\n            l, b, w, h = inkRect\n            if (x + w > self.width or y + h > self.height):\n                return\n\n            self.gdkDrawable.draw_layout(gc.gdkGC, x, y-h-b, layout)\n\n\n    def _draw_mathtext(self, gc, x, y, s, prop, angle):\n        ox, oy, width, height, descent, font_image, used_characters = \\\n            self.mathtext_parser.parse(s, self.dpi, prop)\n\n        if angle==90:\n            width, height = height, width\n            x -= width\n        y -= height\n\n        imw = font_image.get_width()\n        imh = font_image.get_height()\n        N = imw * imh\n\n        # a numpixels by num fonts array\n        Xall = np.zeros((N,1), np.uint8)\n\n        image_str = font_image.as_str()\n        Xall[:,0] = np.fromstring(image_str, np.uint8)\n\n        # get the max alpha at each pixel\n        Xs = np.amax(Xall,axis=1)\n\n        # convert it to it's proper shape\n        Xs.shape = imh, imw\n\n        pixbuf = gtk.gdk.Pixbuf(gtk.gdk.COLORSPACE_RGB, has_alpha=True,\n                                bits_per_sample=8, width=imw, height=imh)\n\n        array = pixbuf_get_pixels_array(pixbuf)\n\n        rgb = gc.get_rgb()\n        array[:,:,0]=int(rgb[0]*255)\n        array[:,:,1]=int(rgb[1]*255)\n        array[:,:,2]=int(rgb[2]*255)\n        array[:,:,3]=Xs\n\n        try: # new in 2.2\n            # can use None instead of gc.gdkGC, if don't need clipping\n            self.gdkDrawable.draw_pixbuf (gc.gdkGC, pixbuf, 0, 0,\n                                          int(x), int(y), imw, imh,\n                                          gdk.RGB_DITHER_NONE, 0, 0)\n        except AttributeError:\n            # deprecated in 2.2\n            pixbuf.render_to_drawable(self.gdkDrawable, gc.gdkGC, 0, 0,\n                                  int(x), int(y), imw, imh,\n                                  gdk.RGB_DITHER_NONE, 0, 0)\n\n\n    def _draw_rotated_text(self, gc, x, y, s, prop, angle):\n        \"\"\"\n        Draw the text rotated 90 degrees, other angles are not supported\n        \"\"\"\n        # this function (and its called functions) is a bottleneck\n        # Pango 1.6 supports rotated text, but pygtk 2.4.0 does not yet have\n        # wrapper functions\n        # GTK+ 2.6 pixbufs support rotation\n\n        gdrawable = self.gdkDrawable\n        ggc = gc.gdkGC\n\n        layout, inkRect, logicalRect = self._get_pango_layout(s, prop)\n        l, b, w, h = inkRect\n        x = int(x-h)\n        y = int(y-w)\n\n        if (x < 0 or y < 0 or # window has shrunk and text is off the edge\n            x + w > self.width or y + h > self.height):\n            return\n\n        key = (x,y,s,angle,hash(prop))\n        imageVert = self.rotated.get(key)\n        if imageVert != None:\n            gdrawable.draw_image(ggc, imageVert, 0, 0, x, y, h, w)\n            return\n\n        imageBack = gdrawable.get_image(x, y, w, h)\n        imageVert = gdrawable.get_image(x, y, h, w)\n        imageFlip = gtk.gdk.Image(type=gdk.IMAGE_FASTEST,\n                                  visual=gdrawable.get_visual(),\n                                  width=w, height=h)\n        if imageFlip == None or imageBack == None or imageVert == None:\n            warnings.warn(\"Could not renderer vertical text\")\n            return\n        imageFlip.set_colormap(self._cmap)\n        for i in range(w):\n            for j in range(h):\n                imageFlip.put_pixel(i, j, imageVert.get_pixel(j,w-i-1) )\n\n        gdrawable.draw_image(ggc, imageFlip, 0, 0, x, y, w, h)\n        gdrawable.draw_layout(ggc, x, y-b, layout)\n\n        imageIn  = gdrawable.get_image(x, y, w, h)\n        for i in range(w):\n            for j in range(h):\n                imageVert.put_pixel(j, i, imageIn.get_pixel(w-i-1,j) )\n\n        gdrawable.draw_image(ggc, imageBack, 0, 0, x, y, w, h)\n        gdrawable.draw_image(ggc, imageVert, 0, 0, x, y, h, w)\n        self.rotated[key] = imageVert\n\n\n    def _get_pango_layout(self, s, prop):\n        \"\"\"\n        Create a pango layout instance for Text 's' with properties 'prop'.\n        Return - pango layout (from cache if already exists)\n\n        Note that pango assumes a logical DPI of 96\n        Ref: pango/fonts.c/pango_font_description_set_size() manual page\n        \"\"\"\n        # problem? - cache gets bigger and bigger, is never cleared out\n        # two (not one) layouts are created for every text item s (then they\n        # are cached) - why?\n\n        key = self.dpi, s, hash(prop)\n        value = self.layoutd.get(key)\n        if value != None:\n            return value\n\n        size = prop.get_size_in_points() * self.dpi / 96.0\n        size = round(size)\n\n        font_str = '%s, %s %i' % (prop.get_name(), prop.get_style(), size,)\n        font = pango.FontDescription(font_str)\n\n        # later - add fontweight to font_str\n        font.set_weight(self.fontweights[prop.get_weight()])\n\n        layout = self.gtkDA.create_pango_layout(s)\n        layout.set_font_description(font)\n        inkRect, logicalRect = layout.get_pixel_extents()\n\n        self.layoutd[key] = layout, inkRect, logicalRect\n        return layout, inkRect, logicalRect\n\n\n    def flipy(self):\n        return True\n\n    def get_canvas_width_height(self):\n        return self.width, self.height\n\n    def get_text_width_height_descent(self, s, prop, ismath):\n        if ismath:\n            ox, oy, width, height, descent, font_image, used_characters = \\\n                self.mathtext_parser.parse(s, self.dpi, prop)\n            return width, height, descent\n\n        layout, inkRect, logicalRect = self._get_pango_layout(s, prop)\n        l, b, w, h = inkRect\n        ll, lb, lw, lh = logicalRect\n\n        return w, h + 1, h - lh\n\n    def new_gc(self):\n        return GraphicsContextGDK(renderer=self)\n\n\n    def points_to_pixels(self, points):\n        return points/72.0 * self.dpi\n\n\nclass GraphicsContextGDK(GraphicsContextBase):\n    # a cache shared by all class instances\n    _cached = {}  # map: rgb color -> gdk.Color\n\n    _joind = {\n        'bevel' : gdk.JOIN_BEVEL,\n        'miter' : gdk.JOIN_MITER,\n        'round' : gdk.JOIN_ROUND,\n        }\n\n    _capd = {\n        'butt'       : gdk.CAP_BUTT,\n        'projecting' : gdk.CAP_PROJECTING,\n        'round'      : gdk.CAP_ROUND,\n        }\n\n\n    def __init__(self, renderer):\n        GraphicsContextBase.__init__(self)\n        self.renderer = renderer\n        self.gdkGC    = gtk.gdk.GC(renderer.gdkDrawable)\n        self._cmap    = renderer._cmap\n\n\n    def rgb_to_gdk_color(self, rgb):\n        \"\"\"\n        rgb - an RGB tuple (three 0.0-1.0 values)\n        return an allocated gtk.gdk.Color\n        \"\"\"\n        try:\n            return self._cached[tuple(rgb)]\n        except KeyError:\n            color = self._cached[tuple(rgb)] = \\\n                    self._cmap.alloc_color(\n                        int(rgb[0]*65535),int(rgb[1]*65535),int(rgb[2]*65535))\n            return color\n\n\n    #def set_antialiased(self, b):\n        # anti-aliasing is not supported by GDK\n\n    def set_capstyle(self, cs):\n        GraphicsContextBase.set_capstyle(self, cs)\n        self.gdkGC.cap_style = self._capd[self._capstyle]\n\n\n    def set_clip_rectangle(self, rectangle):\n        GraphicsContextBase.set_clip_rectangle(self, rectangle)\n        if rectangle is None:\n            return\n        l,b,w,h = rectangle.bounds\n        rectangle = (int(l), self.renderer.height-int(b+h)+1,\n                     int(w), int(h))\n        #rectangle = (int(l), self.renderer.height-int(b+h),\n        #             int(w+1), int(h+2))\n        self.gdkGC.set_clip_rectangle(rectangle)\n\n    def set_dashes(self, dash_offset, dash_list):\n        GraphicsContextBase.set_dashes(self, dash_offset, dash_list)\n\n        if dash_list == None:\n            self.gdkGC.line_style = gdk.LINE_SOLID\n        else:\n            pixels = self.renderer.points_to_pixels(np.asarray(dash_list))\n            dl = [max(1, int(round(val))) for val in pixels]\n            self.gdkGC.set_dashes(dash_offset, dl)\n            self.gdkGC.line_style = gdk.LINE_ON_OFF_DASH\n\n\n    def set_foreground(self, fg, isRGBA=False):\n        GraphicsContextBase.set_foreground(self, fg, isRGBA)\n        self.gdkGC.foreground = self.rgb_to_gdk_color(self.get_rgb())\n\n\n    def set_graylevel(self, frac):\n        GraphicsContextBase.set_graylevel(self, frac)\n        self.gdkGC.foreground = self.rgb_to_gdk_color(self.get_rgb())\n\n\n    def set_joinstyle(self, js):\n        GraphicsContextBase.set_joinstyle(self, js)\n        self.gdkGC.join_style = self._joind[self._joinstyle]\n\n\n    def set_linewidth(self, w):\n        GraphicsContextBase.set_linewidth(self, w)\n        if w == 0:\n            self.gdkGC.line_width = 0\n        else:\n            pixels = self.renderer.points_to_pixels(w)\n            self.gdkGC.line_width = max(1, int(round(pixels)))\n\n\ndef new_figure_manager(num, *args, **kwargs):\n    \"\"\"\n    Create a new figure manager instance\n    \"\"\"\n    FigureClass = kwargs.pop('FigureClass', Figure)\n    thisFig = FigureClass(*args, **kwargs)\n    return new_figure_manager_given_figure(num, thisFig)\n\n\ndef new_figure_manager_given_figure(num, figure):\n    \"\"\"\n    Create a new figure manager instance for the given figure.\n    \"\"\"\n    canvas  = FigureCanvasGDK(figure)\n    manager = FigureManagerBase(canvas, num)\n    return manager\n\n\nclass FigureCanvasGDK (FigureCanvasBase):\n    def __init__(self, figure):\n        FigureCanvasBase.__init__(self, figure)\n\n        self._renderer_init()\n\n    def _renderer_init(self):\n        self._renderer = RendererGDK (gtk.DrawingArea(), self.figure.dpi)\n\n    def _render_figure(self, pixmap, width, height):\n        self._renderer.set_pixmap (pixmap)\n        self._renderer.set_width_height (width, height)\n        self.figure.draw (self._renderer)\n\n    filetypes = FigureCanvasBase.filetypes.copy()\n    filetypes['jpg'] = 'JPEG'\n    filetypes['jpeg'] = 'JPEG'\n\n    def print_jpeg(self, filename, *args, **kwargs):\n        return self._print_image(filename, 'jpeg')\n    print_jpg = print_jpeg\n\n    def print_png(self, filename, *args, **kwargs):\n        return self._print_image(filename, 'png')\n\n    def _print_image(self, filename, format, *args, **kwargs):\n        width, height = self.get_width_height()\n        pixmap = gtk.gdk.Pixmap (None, width, height, depth=24)\n        self._render_figure(pixmap, width, height)\n\n        # jpg colors don't match the display very well, png colors match\n        # better\n        pixbuf = gtk.gdk.Pixbuf(gtk.gdk.COLORSPACE_RGB, 0, 8,\n                                width, height)\n        pixbuf.get_from_drawable(pixmap, pixmap.get_colormap(),\n                                 0, 0, 0, 0, width, height)\n\n        # set the default quality, if we are writing a JPEG.\n        # http://www.pygtk.org/docs/pygtk/class-gdkpixbuf.html#method-gdkpixbuf--save\n        options = cbook.restrict_dict(kwargs, ['quality'])\n        if format in ['jpg','jpeg']:\n           if 'quality' not in options:\n              options['quality'] = rcParams['savefig.jpeg_quality']\n           options['quality'] = str(options['quality'])\n\n        pixbuf.save(filename, format, options=options)\n", "patch": "@@ -109,7 +109,6 @@ def draw_image(self, gc, x, y, im):\n             #             int(w), int(h))\n             # set clip rect?\n \n-        im.flipud_out()\n         rows, cols, image_str = im.as_rgba_str()\n \n         image_array = np.fromstring(image_str, np.uint8)\n@@ -120,7 +119,7 @@ def draw_image(self, gc, x, y, im):\n                                 width=cols, height=rows)\n \n         array = pixbuf_get_pixels_array(pixbuf)\n-        array[:,:,:] = image_array\n+        array[:,:,:] = image_array[::-1]\n \n         gc = self.new_gc()\n \n@@ -138,9 +137,6 @@ def draw_image(self, gc, x, y, im):\n                                   int(x), int(y), cols, rows,\n                                   gdk.RGB_DITHER_NONE, 0, 0)\n \n-        # unflip\n-        im.flipud_out()\n-\n \n     def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n         x, y = int(x), int(y)"}
{"patches_id": 2, "files_id": 10, "language": "py", "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Fbackends%2Fbackend_macosx.py", "raw_code": "from __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport six\n\nimport os\nimport numpy\n\nfrom matplotlib._pylab_helpers import Gcf\nfrom matplotlib.backend_bases import RendererBase, GraphicsContextBase,\\\n     FigureManagerBase, FigureCanvasBase, NavigationToolbar2, TimerBase\nfrom matplotlib.backend_bases import ShowBase\n\nfrom matplotlib.cbook import maxdict\nfrom matplotlib.figure import Figure\nfrom matplotlib.path import Path\nfrom matplotlib.mathtext import MathTextParser\nfrom matplotlib.colors import colorConverter\nfrom matplotlib import rcParams\n\nfrom matplotlib.widgets import SubplotTool\n\nimport matplotlib\nfrom matplotlib.backends import _macosx\n\n\nclass Show(ShowBase):\n    def mainloop(self):\n        _macosx.show()\nshow = Show()\n\n\nclass RendererMac(RendererBase):\n    \"\"\"\n    The renderer handles drawing/rendering operations. Most of the renderer's\n    methods forward the command to the renderer's graphics context. The\n    renderer does not wrap a C object and is written in pure Python.\n    \"\"\"\n\n    texd = maxdict(50)  # a cache of tex image rasters\n\n    def __init__(self, dpi, width, height):\n        RendererBase.__init__(self)\n        self.dpi = dpi\n        self.width = width\n        self.height = height\n        self.gc = GraphicsContextMac()\n        self.gc.set_dpi(self.dpi)\n        self.mathtext_parser = MathTextParser('MacOSX')\n\n    def set_width_height (self, width, height):\n        self.width, self.height = width, height\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        if rgbFace is not None:\n            rgbFace = tuple(rgbFace)\n        linewidth = gc.get_linewidth()\n        gc.draw_path(path, transform, linewidth, rgbFace)\n\n    def draw_markers(self, gc, marker_path, marker_trans, path, trans, rgbFace=None):\n        if rgbFace is not None:\n            rgbFace = tuple(rgbFace)\n        linewidth = gc.get_linewidth()\n        gc.draw_markers(marker_path, marker_trans, path, trans, linewidth, rgbFace)\n\n    def draw_path_collection(self, gc, master_transform, paths, all_transforms,\n                             offsets, offsetTrans, facecolors, edgecolors,\n                             linewidths, linestyles, antialiaseds, urls,\n                             offset_position):\n        if offset_position=='data':\n            offset_position = True\n        else:\n            offset_position = False\n        path_ids = []\n        for path, transform in self._iter_collection_raw_paths(\n            master_transform, paths, all_transforms):\n            path_ids.append((path, transform))\n        master_transform = master_transform.get_matrix()\n        offsetTrans = offsetTrans.get_matrix()\n        gc.draw_path_collection(master_transform, path_ids, all_transforms,\n                             offsets, offsetTrans, facecolors, edgecolors,\n                             linewidths, linestyles, antialiaseds,\n                             offset_position)\n\n    def draw_quad_mesh(self, gc, master_transform, meshWidth, meshHeight,\n                       coordinates, offsets, offsetTrans, facecolors,\n                       antialiased, edgecolors):\n        gc.draw_quad_mesh(master_transform.get_matrix(),\n                          meshWidth,\n                          meshHeight,\n                          coordinates,\n                          offsets,\n                          offsetTrans.get_matrix(),\n                          facecolors,\n                          antialiased,\n                          edgecolors)\n\n    def new_gc(self):\n        self.gc.save()\n        self.gc.set_hatch(None)\n        self.gc._alpha = 1.0\n        self.gc._forced_alpha = False # if True, _alpha overrides A from RGBA\n        return self.gc\n\n    def draw_gouraud_triangle(self, gc, points, colors, transform):\n        points = transform.transform(points)\n        gc.draw_gouraud_triangle(points, colors)\n\n    def get_image_magnification(self):\n        return self.gc.get_image_magnification()\n\n    def draw_image(self, gc, x, y, im):\n        nrows, ncols, data = im.as_rgba_str()\n        gc.draw_image(x, y, nrows, ncols, data)\n\n    def draw_tex(self, gc, x, y, s, prop, angle, ismath='TeX!', mtext=None):\n        # todo, handle props, angle, origins\n        scale = self.gc.get_image_magnification()\n        size = prop.get_size_in_points()\n        texmanager = self.get_texmanager()\n        key = s, size, self.dpi, angle, texmanager.get_font_config()\n        im = self.texd.get(key) # Not sure what this does; just copied from backend_agg.py\n        if im is None:\n            Z = texmanager.get_grey(s, size, self.dpi*scale)\n            Z = numpy.array(255.0 - Z * 255.0, numpy.uint8)\n\n        gc.draw_mathtext(x, y, angle, Z)\n\n    def _draw_mathtext(self, gc, x, y, s, prop, angle):\n        scale = self.gc.get_image_magnification()\n        ox, oy, width, height, descent, image, used_characters = \\\n            self.mathtext_parser.parse(s, self.dpi*scale, prop)\n        gc.draw_mathtext(x, y, angle, 255 - image.as_array())\n\n    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        if ismath:\n            self._draw_mathtext(gc, x, y, s, prop, angle)\n        else:\n            family =  prop.get_family()\n            weight = prop.get_weight()\n            style = prop.get_style()\n            points = prop.get_size_in_points()\n            size = self.points_to_pixels(points)\n            gc.draw_text(x, y, six.text_type(s), family, size, weight, style, angle)\n\n    def get_text_width_height_descent(self, s, prop, ismath):\n        if ismath=='TeX':\n            # todo: handle props\n            texmanager = self.get_texmanager()\n            fontsize = prop.get_size_in_points()\n            w, h, d = texmanager.get_text_width_height_descent(s, fontsize,\n                                                               renderer=self)\n            return w, h, d\n        if ismath:\n            ox, oy, width, height, descent, fonts, used_characters = \\\n                self.mathtext_parser.parse(s, self.dpi, prop)\n            return width, height, descent\n        family =  prop.get_family()\n        weight = prop.get_weight()\n        style = prop.get_style()\n        points = prop.get_size_in_points()\n        size = self.points_to_pixels(points)\n        width, height, descent = self.gc.get_text_width_height_descent(\n            six.text_type(s), family, size, weight, style)\n        return  width, height, 0.0*descent\n\n    def flipy(self):\n        return False\n\n    def points_to_pixels(self, points):\n        return points/72.0 * self.dpi\n\n    def option_image_nocomposite(self):\n        return True\n\n\nclass GraphicsContextMac(_macosx.GraphicsContext, GraphicsContextBase):\n    \"\"\"\n    The GraphicsContext wraps a Quartz graphics context. All methods\n    are implemented at the C-level in macosx.GraphicsContext. These\n    methods set drawing properties such as the line style, fill color,\n    etc. The actual drawing is done by the Renderer, which draws into\n    the GraphicsContext.\n    \"\"\"\n    def __init__(self):\n        GraphicsContextBase.__init__(self)\n        _macosx.GraphicsContext.__init__(self)\n\n    def set_alpha(self, alpha):\n        GraphicsContextBase.set_alpha(self, alpha)\n        _alpha = self.get_alpha()\n        _macosx.GraphicsContext.set_alpha(self, _alpha, self.get_forced_alpha())\n        rgb = self.get_rgb()\n        _macosx.GraphicsContext.set_foreground(self, rgb)\n\n    def set_foreground(self, fg, isRGBA=False):\n        GraphicsContextBase.set_foreground(self, fg, isRGBA)\n        rgb = self.get_rgb()\n        _macosx.GraphicsContext.set_foreground(self, rgb)\n\n    def set_graylevel(self, fg):\n        GraphicsContextBase.set_graylevel(self, fg)\n        _macosx.GraphicsContext.set_graylevel(self, fg)\n\n    def set_clip_rectangle(self, box):\n        GraphicsContextBase.set_clip_rectangle(self, box)\n        if not box: return\n        _macosx.GraphicsContext.set_clip_rectangle(self, box.bounds)\n\n    def set_clip_path(self, path):\n        GraphicsContextBase.set_clip_path(self, path)\n        if not path: return\n        path = path.get_fully_transformed_path()\n        _macosx.GraphicsContext.set_clip_path(self, path)\n\n\n########################################################################\n#\n# The following functions and classes are for pylab and implement\n# window/figure managers, etc...\n#\n########################################################################\n\ndef draw_if_interactive():\n    \"\"\"\n    For performance reasons, we don't want to redraw the figure after\n    each draw command. Instead, we mark the figure as invalid, so that\n    it will be redrawn as soon as the event loop resumes via PyOS_InputHook.\n    This function should be called after each draw event, even if\n    matplotlib is not running interactively.\n    \"\"\"\n    if matplotlib.is_interactive():\n        figManager =  Gcf.get_active()\n        if figManager is not None:\n            figManager.canvas.invalidate()\n\n\ndef new_figure_manager(num, *args, **kwargs):\n    \"\"\"\n    Create a new figure manager instance\n    \"\"\"\n    FigureClass = kwargs.pop('FigureClass', Figure)\n    figure = FigureClass(*args, **kwargs)\n    return new_figure_manager_given_figure(num, figure)\n\n\ndef new_figure_manager_given_figure(num, figure):\n    \"\"\"\n    Create a new figure manager instance for the given figure.\n    \"\"\"\n    canvas = FigureCanvasMac(figure)\n    manager = FigureManagerMac(canvas, num)\n    return manager\n\n\nclass TimerMac(_macosx.Timer, TimerBase):\n    '''\n    Subclass of :class:`backend_bases.TimerBase` that uses CoreFoundation\n    run loops for timer events.\n\n    Attributes:\n    * interval: The time between timer events in milliseconds. Default\n        is 1000 ms.\n    * single_shot: Boolean flag indicating whether this timer should\n        operate as single shot (run once and then stop). Defaults to False.\n    * callbacks: Stores list of (func, args) tuples that will be called\n        upon timer events. This list can be manipulated directly, or the\n        functions add_callback and remove_callback can be used.\n    '''\n    # completely implemented at the C-level (in _macosx.Timer)\n\n\nclass FigureCanvasMac(_macosx.FigureCanvas, FigureCanvasBase):\n    \"\"\"\n    The canvas the figure renders into.  Calls the draw and print fig\n    methods, creates the renderers, etc...\n\n    Public attribute\n\n      figure - A Figure instance\n\n    Events such as button presses, mouse movements, and key presses\n    are handled in the C code and the base class methods\n    button_press_event, button_release_event, motion_notify_event,\n    key_press_event, and key_release_event are called from there.\n    \"\"\"\n\n    filetypes = FigureCanvasBase.filetypes.copy()\n    filetypes['bmp'] = 'Windows bitmap'\n    filetypes['jpeg'] = 'JPEG'\n    filetypes['jpg'] = 'JPEG'\n    filetypes['gif'] = 'Graphics Interchange Format'\n    filetypes['tif'] = 'Tagged Image Format File'\n    filetypes['tiff'] = 'Tagged Image Format File'\n\n    def __init__(self, figure):\n        FigureCanvasBase.__init__(self, figure)\n        width, height = self.get_width_height()\n        self.renderer = RendererMac(figure.dpi, width, height)\n        _macosx.FigureCanvas.__init__(self, width, height)\n\n    def resize(self, width, height):\n        self.renderer.set_width_height(width, height)\n        dpi = self.figure.dpi\n        width /= dpi\n        height /= dpi\n        self.figure.set_size_inches(width, height)\n\n    def _print_bitmap(self, filename, *args, **kwargs):\n        # In backend_bases.py, print_figure changes the dpi of the figure.\n        # But since we are essentially redrawing the picture, we need the\n        # original dpi. Pick it up from the renderer.\n        dpi = kwargs['dpi']\n        old_dpi = self.figure.dpi\n        self.figure.dpi = self.renderer.dpi\n        width, height = self.figure.get_size_inches()\n        width, height = width*dpi, height*dpi\n        filename = six.text_type(filename)\n        self.write_bitmap(filename, width, height, dpi)\n        self.figure.dpi = old_dpi\n\n    def print_bmp(self, filename, *args, **kwargs):\n        self._print_bitmap(filename, *args, **kwargs)\n\n    def print_jpg(self, filename, *args, **kwargs):\n        self._print_bitmap(filename, *args, **kwargs)\n\n    def print_jpeg(self, filename, *args, **kwargs):\n        self._print_bitmap(filename, *args, **kwargs)\n\n    def print_tif(self, filename, *args, **kwargs):\n        self._print_bitmap(filename, *args, **kwargs)\n\n    def print_tiff(self, filename, *args, **kwargs):\n        self._print_bitmap(filename, *args, **kwargs)\n\n    def print_gif(self, filename, *args, **kwargs):\n        self._print_bitmap(filename, *args, **kwargs)\n\n    def new_timer(self, *args, **kwargs):\n        \"\"\"\n        Creates a new backend-specific subclass of :class:`backend_bases.Timer`.\n        This is useful for getting periodic events through the backend's native\n        event loop. Implemented only for backends with GUIs.\n\n        optional arguments:\n\n        *interval*\n          Timer interval in milliseconds\n        *callbacks*\n          Sequence of (func, args, kwargs) where func(*args, **kwargs) will\n          be executed by the timer every *interval*.\n        \"\"\"\n        return TimerMac(*args, **kwargs)\n\n\nclass FigureManagerMac(_macosx.FigureManager, FigureManagerBase):\n    \"\"\"\n    Wrap everything up into a window for the pylab interface\n    \"\"\"\n    def __init__(self, canvas, num):\n        FigureManagerBase.__init__(self, canvas, num)\n        title = \"Figure %d\" % num\n        _macosx.FigureManager.__init__(self, canvas, title)\n        if rcParams['toolbar']=='toolbar2':\n            self.toolbar = NavigationToolbar2Mac(canvas)\n        else:\n            self.toolbar = None\n        if self.toolbar is not None:\n            self.toolbar.update()\n\n        def notify_axes_change(fig):\n            'this will be called whenever the current axes is changed'\n            if self.toolbar != None: self.toolbar.update()\n        self.canvas.figure.add_axobserver(notify_axes_change)\n\n        if matplotlib.is_interactive():\n            self.show()\n\n    def close(self):\n        Gcf.destroy(self.num)\n\n\nclass NavigationToolbar2Mac(_macosx.NavigationToolbar2, NavigationToolbar2):\n\n    def __init__(self, canvas):\n        NavigationToolbar2.__init__(self, canvas)\n\n    def _init_toolbar(self):\n        basedir = os.path.join(rcParams['datapath'], \"images\")\n        _macosx.NavigationToolbar2.__init__(self, basedir)\n\n    def draw_rubberband(self, event, x0, y0, x1, y1):\n        self.canvas.set_rubberband(int(x0), int(y0), int(x1), int(y1))\n\n    def release(self, event):\n        self.canvas.remove_rubberband()\n\n    def set_cursor(self, cursor):\n        _macosx.set_cursor(cursor)\n\n    def save_figure(self, *args):\n        filename = _macosx.choose_save_file('Save the figure',\n                                            self.canvas.get_default_filename())\n        if filename is None: # Cancel\n            return\n        self.canvas.print_figure(filename)\n\n    def prepare_configure_subplots(self):\n        toolfig = Figure(figsize=(6,3))\n        canvas = FigureCanvasMac(toolfig)\n        toolfig.subplots_adjust(top=0.9)\n        tool = SubplotTool(self.canvas.figure, toolfig)\n        return canvas\n\n    def set_message(self, message):\n        _macosx.NavigationToolbar2.set_message(self, message.encode('utf-8'))\n\n    def dynamic_update(self):\n        self.canvas.draw_idle()\n\n########################################################################\n#\n# Now just provide the standard names that backend.__init__ is expecting\n#\n########################################################################\n\nFigureCanvas = FigureCanvasMac\nFigureManager = FigureManagerMac\n", "patch": "@@ -110,10 +110,8 @@ def get_image_magnification(self):\n         return self.gc.get_image_magnification()\n \n     def draw_image(self, gc, x, y, im):\n-        im.flipud_out()\n         nrows, ncols, data = im.as_rgba_str()\n         gc.draw_image(x, y, nrows, ncols, data)\n-        im.flipud_out()\n \n     def draw_tex(self, gc, x, y, s, prop, angle, ismath='TeX!', mtext=None):\n         # todo, handle props, angle, origins"}
{"patches_id": 2, "files_id": 11, "language": "py", "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Fbackends%2Fbackend_mixed.py", "raw_code": "from __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport six\n\nfrom matplotlib._image import frombuffer\nfrom matplotlib.backends.backend_agg import RendererAgg\nfrom matplotlib.tight_bbox import process_figure_for_rasterizing\n\n\nclass MixedModeRenderer(object):\n    \"\"\"\n    A helper class to implement a renderer that switches between\n    vector and raster drawing.  An example may be a PDF writer, where\n    most things are drawn with PDF vector commands, but some very\n    complex objects, such as quad meshes, are rasterised and then\n    output as images.\n    \"\"\"\n    def __init__(self, figure, width, height, dpi, vector_renderer,\n                 raster_renderer_class=None,\n                 bbox_inches_restore=None):\n        \"\"\"\n        figure: The figure instance.\n\n        width: The width of the canvas in logical units\n\n        height: The height of the canvas in logical units\n\n        dpi: The dpi of the canvas\n\n        vector_renderer: An instance of a subclass of RendererBase\n        that will be used for the vector drawing.\n\n        raster_renderer_class: The renderer class to use for the\n        raster drawing.  If not provided, this will use the Agg\n        backend (which is currently the only viable option anyway.)\n        \"\"\"\n        if raster_renderer_class is None:\n            raster_renderer_class = RendererAgg\n\n        self._raster_renderer_class = raster_renderer_class\n        self._width = width\n        self._height = height\n        self.dpi = dpi\n\n        assert not vector_renderer.option_image_nocomposite()\n        self._vector_renderer = vector_renderer\n\n        self._raster_renderer = None\n        self._rasterizing = 0\n\n        # A reference to the figure is needed as we need to change\n        # the figure dpi before and after the rasterization. Although\n        # this looks ugly, I couldn't find a better solution. -JJL\n        self.figure=figure\n        self._figdpi = figure.get_dpi()\n\n        self._bbox_inches_restore = bbox_inches_restore\n\n        self._set_current_renderer(vector_renderer)\n\n    _methods = \"\"\"\n        close_group draw_image draw_markers draw_path\n        draw_path_collection draw_quad_mesh draw_tex draw_text\n        finalize flipy get_canvas_width_height get_image_magnification\n        get_texmanager get_text_width_height_descent new_gc open_group\n        option_image_nocomposite points_to_pixels strip_math\n        start_filter stop_filter draw_gouraud_triangle\n        draw_gouraud_triangles option_scale_image\n        _text2path _get_text_path_transform height width\n        \"\"\".split()\n    def _set_current_renderer(self, renderer):\n        self._renderer = renderer\n\n        for method in self._methods:\n            if hasattr(renderer, method):\n                setattr(self, method, getattr(renderer, method))\n        renderer.start_rasterizing = self.start_rasterizing\n        renderer.stop_rasterizing = self.stop_rasterizing\n\n    def start_rasterizing(self):\n        \"\"\"\n        Enter \"raster\" mode.  All subsequent drawing commands (until\n        stop_rasterizing is called) will be drawn with the raster\n        backend.\n\n        If start_rasterizing is called multiple times before\n        stop_rasterizing is called, this method has no effect.\n        \"\"\"\n\n        # change the dpi of the figure temporarily.\n        self.figure.set_dpi(self.dpi)\n\n        if self._bbox_inches_restore: # when tight bbox is used\n            r = process_figure_for_rasterizing(self.figure,\n                                               self._bbox_inches_restore)\n            self._bbox_inches_restore = r\n\n        if self._rasterizing == 0:\n            self._raster_renderer = self._raster_renderer_class(\n                self._width*self.dpi, self._height*self.dpi, self.dpi)\n            self._set_current_renderer(self._raster_renderer)\n        self._rasterizing += 1\n\n    def stop_rasterizing(self):\n        \"\"\"\n        Exit \"raster\" mode.  All of the drawing that was done since\n        the last start_rasterizing command will be copied to the\n        vector backend by calling draw_image.\n\n        If stop_rasterizing is called multiple times before\n        start_rasterizing is called, this method has no effect.\n        \"\"\"\n        self._rasterizing -= 1\n        if self._rasterizing == 0:\n            self._set_current_renderer(self._vector_renderer)\n\n            width, height = self._width * self.dpi, self._height * self.dpi\n            buffer, bounds = self._raster_renderer.tostring_rgba_minimized()\n            l, b, w, h = bounds\n            if w > 0 and h > 0:\n                image = frombuffer(buffer, w, h, True)\n                image.is_grayscale = False\n                gc = self._renderer.new_gc()\n                # TODO: If the mixedmode resolution differs from the figure's\n                #       dpi, the image must be scaled (dpi->_figdpi). Not all\n                #       backends support this.\n                self._renderer.draw_image(\n                    gc,\n                    float(l) / self.dpi * self._figdpi,\n                    (float(height)-b-h) / self.dpi * self._figdpi,\n                    image)\n            self._raster_renderer = None\n            self._rasterizing = False\n\n            # restore the figure dpi.\n            self.figure.set_dpi(self._figdpi)\n\n        if self._bbox_inches_restore:  # when tight bbox is used\n            r = process_figure_for_rasterizing(self.figure,\n                                               self._bbox_inches_restore,\n                                               self._figdpi)\n            self._bbox_inches_restore = r\n", "patch": "@@ -121,7 +121,6 @@ def stop_rasterizing(self):\n             if w > 0 and h > 0:\n                 image = frombuffer(buffer, w, h, True)\n                 image.is_grayscale = False\n-                image.flipud_out()\n                 gc = self._renderer.new_gc()\n                 # TODO: If the mixedmode resolution differs from the figure's\n                 #       dpi, the image must be scaled (dpi->_figdpi). Not all"}
{"patches_id": 2, "files_id": 12, "language": "py", "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Fbackends%2Fbackend_pdf.py", "raw_code": "# -*- coding: iso-8859-1 -*-\n\n\"\"\"\nA PDF matplotlib backend\nAuthor: Jouni K Seppnen <jks@iki.fi>\n\"\"\"\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport six\nfrom six.moves import map\n\nimport codecs\nimport os\nimport re\nimport sys\nimport time\nimport warnings\nimport zlib\n\nimport numpy as np\nfrom six import unichr\nfrom six import BytesIO\n\nfrom datetime import datetime\nfrom math import ceil, cos, floor, pi, sin\ntry:\n    set\nexcept NameError:\n    from sets import Set as set\n\nimport matplotlib\nfrom matplotlib import __version__, rcParams\nfrom matplotlib._pylab_helpers import Gcf\nfrom matplotlib.backend_bases import RendererBase, GraphicsContextBase,\\\n    FigureManagerBase, FigureCanvasBase\nfrom matplotlib.backends.backend_mixed import MixedModeRenderer\nfrom matplotlib.cbook import Bunch, is_string_like, \\\n    get_realpath_and_stat, is_writable_file_like, maxdict\nfrom matplotlib.mlab import quad2cubic\nfrom matplotlib.figure import Figure\nfrom matplotlib.font_manager import findfont, is_opentype_cff_font\nfrom matplotlib.afm import AFM\nimport matplotlib.type1font as type1font\nimport matplotlib.dviread as dviread\nfrom matplotlib.ft2font import FT2Font, FIXED_WIDTH, ITALIC, LOAD_NO_SCALE, \\\n    LOAD_NO_HINTING, KERNING_UNFITTED\nfrom matplotlib.mathtext import MathTextParser\nfrom matplotlib.transforms import Affine2D, BboxBase\nfrom matplotlib.path import Path\nfrom matplotlib import ttconv\n\n# Overview\n#\n# The low-level knowledge about pdf syntax lies mainly in the pdfRepr\n# function and the classes Reference, Name, Operator, and Stream.  The\n# PdfFile class knows about the overall structure of pdf documents.\n# It provides a \"write\" method for writing arbitrary strings in the\n# file, and an \"output\" method that passes objects through the pdfRepr\n# function before writing them in the file.  The output method is\n# called by the RendererPdf class, which contains the various draw_foo\n# methods.  RendererPdf contains a GraphicsContextPdf instance, and\n# each draw_foo calls self.check_gc before outputting commands.  This\n# method checks whether the pdf graphics state needs to be modified\n# and outputs the necessary commands.  GraphicsContextPdf represents\n# the graphics state, and its \"delta\" method returns the commands that\n# modify the state.\n\n# Add \"pdf.use14corefonts: True\" in your configuration file to use only\n# the 14 PDF core fonts. These fonts do not need to be embedded; every\n# PDF viewing application is required to have them. This results in very\n# light PDF files you can use directly in LaTeX or ConTeXt documents\n# generated with pdfTeX, without any conversion.\n\n# These fonts are: Helvetica, Helvetica-Bold, Helvetica-Oblique,\n# Helvetica-BoldOblique, Courier, Courier-Bold, Courier-Oblique,\n# Courier-BoldOblique, Times-Roman, Times-Bold, Times-Italic,\n# Times-BoldItalic, Symbol, ZapfDingbats.\n#\n# Some tricky points:\n#\n# 1. The clip path can only be widened by popping from the state\n# stack.  Thus the state must be pushed onto the stack before narrowing\n# the clip path.  This is taken care of by GraphicsContextPdf.\n#\n# 2. Sometimes it is necessary to refer to something (e.g., font,\n# image, or extended graphics state, which contains the alpha value)\n# in the page stream by a name that needs to be defined outside the\n# stream.  PdfFile provides the methods fontName, imageObject, and\n# alphaState for this purpose.  The implementations of these methods\n# should perhaps be generalized.\n\n# TODOs:\n#\n# * the alpha channel of images\n# * image compression could be improved (PDF supports png-like compression)\n# * encoding of fonts, including mathtext fonts and unicode support\n# * TTF support has lots of small TODOs, e.g., how do you know if a font\n#   is serif/sans-serif, or symbolic/non-symbolic?\n# * draw_markers, draw_line_collection, etc.\n\n\ndef fill(strings, linelen=75):\n    \"\"\"Make one string from sequence of strings, with whitespace\n    in between. The whitespace is chosen to form lines of at most\n    linelen characters, if possible.\"\"\"\n    currpos = 0\n    lasti = 0\n    result = []\n    for i, s in enumerate(strings):\n        length = len(s)\n        if currpos + length < linelen:\n            currpos += length + 1\n        else:\n            result.append(b' '.join(strings[lasti:i]))\n            lasti = i\n            currpos = length\n    result.append(b' '.join(strings[lasti:]))\n    return b'\\n'.join(result)\n\n# PDF strings are supposed to be able to include any eight-bit data,\n# except that unbalanced parens and backslashes must be escaped by a\n# backslash. However, sf bug #2708559 shows that the carriage return\n# character may get read as a newline; these characters correspond to\n# \\gamma and \\Omega in TeX's math font encoding. Escaping them fixes\n# the bug.\n_string_escape_regex = re.compile(br'([\\\\()\\r\\n])')\n\n\ndef _string_escape(match):\n    m = match.group(0)\n    if m in br'\\()':\n        return b'\\\\' + m\n    elif m == b'\\n':\n        return br'\\n'\n    elif m == b'\\r':\n        return br'\\r'\n    assert False\n\n\ndef pdfRepr(obj):\n    \"\"\"Map Python objects to PDF syntax.\"\"\"\n\n    # Some objects defined later have their own pdfRepr method.\n    if hasattr(obj, 'pdfRepr'):\n        return obj.pdfRepr()\n\n    # Floats. PDF does not have exponential notation (1.0e-10) so we\n    # need to use %f with some precision.  Perhaps the precision\n    # should adapt to the magnitude of the number?\n    elif isinstance(obj, (float, np.floating)):\n        if not np.isfinite(obj):\n            raise ValueError(\"Can only output finite numbers in PDF\")\n        r = (\"%.10f\" % obj).encode('ascii')\n        return r.rstrip(b'0').rstrip(b'.')\n\n    # Booleans. Needs to be tested before integers since\n    # isinstance(True, int) is true.\n    elif isinstance(obj, bool):\n        return [b'false', b'true'][obj]\n\n    # Integers are written as such.\n    elif isinstance(obj, (six.integer_types, np.integer)):\n        return (\"%d\" % obj).encode('ascii')\n\n    # Unicode strings are encoded in UTF-16BE with byte-order mark.\n    elif isinstance(obj, six.text_type):\n        try:\n            # But maybe it's really ASCII?\n            s = obj.encode('ASCII')\n            return pdfRepr(s)\n        except UnicodeEncodeError:\n            s = codecs.BOM_UTF16_BE + obj.encode('UTF-16BE')\n            return pdfRepr(s)\n\n    # Strings are written in parentheses, with backslashes and parens\n    # escaped. Actually balanced parens are allowed, but it is\n    # simpler to escape them all. TODO: cut long strings into lines;\n    # I believe there is some maximum line length in PDF.\n    elif isinstance(obj, bytes):\n        return b'(' + _string_escape_regex.sub(_string_escape, obj) + b')'\n\n    # Dictionaries. The keys must be PDF names, so if we find strings\n    # there, we make Name objects from them. The values may be\n    # anything, so the caller must ensure that PDF names are\n    # represented as Name objects.\n    elif isinstance(obj, dict):\n        r = [b\"<<\"]\n        r.extend([Name(key).pdfRepr() + b\" \" + pdfRepr(val)\n                  for key, val in six.iteritems(obj)])\n        r.append(b\">>\")\n        return fill(r)\n\n    # Lists.\n    elif isinstance(obj, (list, tuple)):\n        r = [b\"[\"]\n        r.extend([pdfRepr(val) for val in obj])\n        r.append(b\"]\")\n        return fill(r)\n\n    # The null keyword.\n    elif obj is None:\n        return b'null'\n\n    # A date.\n    elif isinstance(obj, datetime):\n        r = obj.strftime('D:%Y%m%d%H%M%S')\n        if time.daylight:\n            z = time.altzone\n        else:\n            z = time.timezone\n        if z == 0:\n            r += 'Z'\n        elif z < 0:\n            r += \"+%02d'%02d'\" % ((-z) // 3600, (-z) % 3600)\n        else:\n            r += \"-%02d'%02d'\" % (z // 3600, z % 3600)\n        return pdfRepr(r)\n\n    # A bounding box\n    elif isinstance(obj, BboxBase):\n        return fill([pdfRepr(val) for val in obj.bounds])\n\n    else:\n        msg = \"Don't know a PDF representation for %s objects.\" % type(obj)\n        raise TypeError(msg)\n\n\nclass Reference(object):\n    \"\"\"PDF reference object.\n    Use PdfFile.reserveObject() to create References.\n    \"\"\"\n\n    def __init__(self, id):\n        self.id = id\n\n    def __repr__(self):\n        return \"<Reference %d>\" % self.id\n\n    def pdfRepr(self):\n        return (\"%d 0 R\" % self.id).encode('ascii')\n\n    def write(self, contents, file):\n        write = file.write\n        write((\"%d 0 obj\\n\" % self.id).encode('ascii'))\n        write(pdfRepr(contents))\n        write(b\"\\nendobj\\n\")\n\n\nclass Name(object):\n    \"\"\"PDF name object.\"\"\"\n    __slots__ = ('name',)\n    _regex = re.compile(r'[^!-~]')\n\n    def __init__(self, name):\n        if isinstance(name, Name):\n            self.name = name.name\n        else:\n            if isinstance(name, bytes):\n                name = name.decode('ascii')\n            self.name = self._regex.sub(Name.hexify, name).encode('ascii')\n\n    def __repr__(self):\n        return \"<Name %s>\" % self.name\n\n    def __str__(self):\n        return '/' + six.text_type(self.name)\n\n    @staticmethod\n    def hexify(match):\n        return '#%02x' % ord(match.group())\n\n    def pdfRepr(self):\n        return b'/' + self.name\n\n\nclass Operator(object):\n    \"\"\"PDF operator object.\"\"\"\n    __slots__ = ('op',)\n\n    def __init__(self, op):\n        self.op = op\n\n    def __repr__(self):\n        return '<Operator %s>' % self.op\n\n    def pdfRepr(self):\n        return self.op\n\n# PDF operators (not an exhaustive list)\n_pdfops = dict(\n    close_fill_stroke=b'b', fill_stroke=b'B', fill=b'f', closepath=b'h',\n    close_stroke=b's', stroke=b'S', endpath=b'n', begin_text=b'BT',\n    end_text=b'ET', curveto=b'c', rectangle=b're', lineto=b'l', moveto=b'm',\n    concat_matrix=b'cm', use_xobject=b'Do', setgray_stroke=b'G',\n    setgray_nonstroke=b'g', setrgb_stroke=b'RG', setrgb_nonstroke=b'rg',\n    setcolorspace_stroke=b'CS', setcolorspace_nonstroke=b'cs',\n    setcolor_stroke=b'SCN', setcolor_nonstroke=b'scn', setdash=b'd',\n    setlinejoin=b'j', setlinecap=b'J', setgstate=b'gs', gsave=b'q',\n    grestore=b'Q', textpos=b'Td', selectfont=b'Tf', textmatrix=b'Tm',\n    show=b'Tj', showkern=b'TJ', setlinewidth=b'w', clip=b'W', shading=b'sh')\n\nOp = Bunch(**dict([(name, Operator(value))\n                   for name, value in six.iteritems(_pdfops)]))\n\n\ndef _paint_path(closep, fillp, strokep):\n    \"\"\"Return the PDF operator to paint a path in the following way:\n    closep:  close the path before painting\n    fillp:   fill the path with the fill color\n    strokep: stroke the outline of the path with the line color\"\"\"\n    if strokep:\n        if closep:\n            if fillp:\n                return Op.close_fill_stroke\n            else:\n                return Op.close_stroke\n        else:\n            if fillp:\n                return Op.fill_stroke\n            else:\n                return Op.stroke\n    else:\n        if fillp:\n            return Op.fill\n        else:\n            return Op.endpath\nOp.paint_path = _paint_path\n\n\nclass Stream(object):\n    \"\"\"PDF stream object.\n\n    This has no pdfRepr method. Instead, call begin(), then output the\n    contents of the stream by calling write(), and finally call end().\n    \"\"\"\n    __slots__ = ('id', 'len', 'pdfFile', 'file', 'compressobj', 'extra', 'pos')\n\n    def __init__(self, id, len, file, extra=None):\n        \"\"\"id: object id of stream; len: an unused Reference object for the\n        length of the stream, or None (to use a memory buffer); file:\n        a PdfFile; extra: a dictionary of extra key-value pairs to\n        include in the stream header \"\"\"\n        self.id = id            # object id\n        self.len = len          # id of length object\n        self.pdfFile = file\n        self.file = file.fh      # file to which the stream is written\n        self.compressobj = None  # compression object\n        if extra is None:\n            self.extra = dict()\n        else:\n            self.extra = extra\n\n        self.pdfFile.recordXref(self.id)\n        if rcParams['pdf.compression']:\n            self.compressobj = zlib.compressobj(rcParams['pdf.compression'])\n        if self.len is None:\n            self.file = BytesIO()\n        else:\n            self._writeHeader()\n            self.pos = self.file.tell()\n\n    def _writeHeader(self):\n        write = self.file.write\n        write((\"%d 0 obj\\n\" % self.id).encode('ascii'))\n        dict = self.extra\n        dict['Length'] = self.len\n        if rcParams['pdf.compression']:\n            dict['Filter'] = Name('FlateDecode')\n\n        write(pdfRepr(dict))\n        write(b\"\\nstream\\n\")\n\n    def end(self):\n        \"\"\"Finalize stream.\"\"\"\n\n        self._flush()\n        if self.len is None:\n            contents = self.file.getvalue()\n            self.len = len(contents)\n            self.file = self.pdfFile.fh\n            self._writeHeader()\n            self.file.write(contents)\n            self.file.write(b\"\\nendstream\\nendobj\\n\")\n        else:\n            length = self.file.tell() - self.pos\n            self.file.write(b\"\\nendstream\\nendobj\\n\")\n            self.pdfFile.writeObject(self.len, length)\n\n    def write(self, data):\n        \"\"\"Write some data on the stream.\"\"\"\n\n        if self.compressobj is None:\n            self.file.write(data)\n        else:\n            compressed = self.compressobj.compress(data)\n            self.file.write(compressed)\n\n    def _flush(self):\n        \"\"\"Flush the compression object.\"\"\"\n\n        if self.compressobj is not None:\n            compressed = self.compressobj.flush()\n            self.file.write(compressed)\n            self.compressobj = None\n\n\nclass PdfFile(object):\n    \"\"\"PDF file object.\"\"\"\n\n    def __init__(self, filename):\n        self.nextObject = 1     # next free object id\n        self.xrefTable = [[0, 65535, 'the zero object']]\n        self.passed_in_file_object = False\n        self.original_file_like = None\n        self.tell_base = 0\n        if is_string_like(filename):\n            fh = open(filename, 'wb')\n        elif is_writable_file_like(filename):\n            try:\n                self.tell_base = filename.tell()\n            except IOError:\n                fh = BytesIO()\n                self.original_file_like = filename\n            else:\n                fh = filename\n                self.passed_in_file_object = True\n        else:\n            raise ValueError(\"filename must be a path or a file-like object\")\n\n        self._core14fontdir = os.path.join(\n            rcParams['datapath'], 'fonts', 'pdfcorefonts')\n        self.fh = fh\n        self.currentstream = None  # stream object to write to, if any\n        fh.write(b\"%PDF-1.4\\n\")    # 1.4 is the first version to have alpha\n        # Output some eight-bit chars as a comment so various utilities\n        # recognize the file as binary by looking at the first few\n        # lines (see note in section 3.4.1 of the PDF reference).\n        fh.write(b\"%\\254\\334 \\253\\272\\n\")\n\n        self.rootObject = self.reserveObject('root')\n        self.pagesObject = self.reserveObject('pages')\n        self.pageList = []\n        self.fontObject = self.reserveObject('fonts')\n        self.alphaStateObject = self.reserveObject('extended graphics states')\n        self.hatchObject = self.reserveObject('tiling patterns')\n        self.gouraudObject = self.reserveObject('Gouraud triangles')\n        self.XObjectObject = self.reserveObject('external objects')\n        self.resourceObject = self.reserveObject('resources')\n\n        root = {'Type': Name('Catalog'),\n                'Pages': self.pagesObject}\n        self.writeObject(self.rootObject, root)\n\n        revision = ''\n        self.infoDict = {\n            'Creator': 'matplotlib %s, http://matplotlib.org' % __version__,\n            'Producer': 'matplotlib pdf backend%s' % revision,\n            'CreationDate': datetime.today()\n            }\n\n        self.fontNames = {}     # maps filenames to internal font names\n        self.nextFont = 1       # next free internal font name\n        self.dviFontInfo = {}   # information on dvi fonts\n        self.type1Descriptors = {}  # differently encoded Type-1 fonts may\n                                    # share the same descriptor\n        self.used_characters = {}\n\n        self.alphaStates = {}   # maps alpha values to graphics state objects\n        self.nextAlphaState = 1\n        self.hatchPatterns = {}\n        self.nextHatch = 1\n        self.gouraudTriangles = []\n\n        self.images = {}\n        self.nextImage = 1\n\n        self.markers = {}\n        self.multi_byte_charprocs = {}\n\n        self.paths = []\n\n        # The PDF spec recommends to include every procset\n        procsets = [Name(x)\n                    for x in \"PDF Text ImageB ImageC ImageI\".split()]\n\n        # Write resource dictionary.\n        # Possibly TODO: more general ExtGState (graphics state dictionaries)\n        #                ColorSpace Pattern Shading Properties\n        resources = {'Font': self.fontObject,\n                     'XObject': self.XObjectObject,\n                     'ExtGState': self.alphaStateObject,\n                     'Pattern': self.hatchObject,\n                     'Shading': self.gouraudObject,\n                     'ProcSet': procsets}\n        self.writeObject(self.resourceObject, resources)\n\n    def newPage(self, width, height):\n        self.endStream()\n\n        self.width, self.height = width, height\n        contentObject = self.reserveObject('page contents')\n        thePage = {'Type': Name('Page'),\n                   'Parent': self.pagesObject,\n                   'Resources': self.resourceObject,\n                   'MediaBox': [0, 0, 72 * width, 72 * height],\n                   'Contents': contentObject,\n                   'Group': {'Type': Name('Group'),\n                             'S': Name('Transparency'),\n                             'CS': Name('DeviceRGB')}\n                   }\n        pageObject = self.reserveObject('page')\n        self.writeObject(pageObject, thePage)\n        self.pageList.append(pageObject)\n\n        self.beginStream(contentObject.id,\n                         self.reserveObject('length of content stream'))\n        # Initialize the pdf graphics state to match the default mpl\n        # graphics context: currently only the join style needs to be set\n        self.output(GraphicsContextPdf.joinstyles['round'], Op.setlinejoin)\n\n    def close(self):\n        self.endStream()\n        # Write out the various deferred objects\n        self.writeFonts()\n        self.writeObject(self.alphaStateObject,\n                         dict([(val[0], val[1])\n                               for val in six.itervalues(self.alphaStates)]))\n        self.writeHatches()\n        self.writeGouraudTriangles()\n        xobjects = dict(six.itervalues(self.images))\n        for tup in six.itervalues(self.markers):\n            xobjects[tup[0]] = tup[1]\n        for name, value in six.iteritems(self.multi_byte_charprocs):\n            xobjects[name] = value\n        for name, path, trans, ob, join, cap, padding, filled, stroked \\\n                in self.paths:\n            xobjects[name] = ob\n        self.writeObject(self.XObjectObject, xobjects)\n        self.writeImages()\n        self.writeMarkers()\n        self.writePathCollectionTemplates()\n        self.writeObject(self.pagesObject,\n                         {'Type': Name('Pages'),\n                          'Kids': self.pageList,\n                          'Count': len(self.pageList)})\n        self.writeInfoDict()\n\n        # Finalize the file\n        self.writeXref()\n        self.writeTrailer()\n        if self.passed_in_file_object:\n            self.fh.flush()\n        elif self.original_file_like is not None:\n            self.original_file_like.write(self.fh.getvalue())\n            self.fh.close()\n        else:\n            self.fh.close()\n\n    def write(self, data):\n        if self.currentstream is None:\n            self.fh.write(data)\n        else:\n            self.currentstream.write(data)\n\n    def output(self, *data):\n        self.write(fill(list(map(pdfRepr, data))))\n        self.write(b'\\n')\n\n    def beginStream(self, id, len, extra=None):\n        assert self.currentstream is None\n        self.currentstream = Stream(id, len, self, extra)\n\n    def endStream(self):\n        if self.currentstream is not None:\n            self.currentstream.end()\n            self.currentstream = None\n\n    def fontName(self, fontprop):\n        \"\"\"\n        Select a font based on fontprop and return a name suitable for\n        Op.selectfont. If fontprop is a string, it will be interpreted\n        as the filename (or dvi name) of the font.\n        \"\"\"\n\n        if is_string_like(fontprop):\n            filename = fontprop\n        elif rcParams['pdf.use14corefonts']:\n            filename = findfont(\n                fontprop, fontext='afm', directory=self._core14fontdir)\n            if filename is None:\n                filename = findfont(\n                    \"Helvetica\", fontext='afm', directory=self._core14fontdir)\n        else:\n            filename = findfont(fontprop)\n\n        Fx = self.fontNames.get(filename)\n        if Fx is None:\n            Fx = Name('F%d' % self.nextFont)\n            self.fontNames[filename] = Fx\n            self.nextFont += 1\n            matplotlib.verbose.report(\n                'Assigning font %s = %r' % (Fx, filename),\n                'debug')\n\n        return Fx\n\n    def writeFonts(self):\n        fonts = {}\n        for filename, Fx in six.iteritems(self.fontNames):\n            matplotlib.verbose.report('Embedding font %s' % filename, 'debug')\n            if filename.endswith('.afm'):\n                # from pdf.use14corefonts\n                matplotlib.verbose.report('Writing AFM font', 'debug')\n                fonts[Fx] = self._write_afm_font(filename)\n            elif filename in self.dviFontInfo:\n                # a Type 1 font from a dvi file;\n                # the filename is really the TeX name\n                matplotlib.verbose.report('Writing Type-1 font', 'debug')\n                fonts[Fx] = self.embedTeXFont(filename,\n                                              self.dviFontInfo[filename])\n            else:\n                # a normal TrueType font\n                matplotlib.verbose.report('Writing TrueType font', 'debug')\n                realpath, stat_key = get_realpath_and_stat(filename)\n                chars = self.used_characters.get(stat_key)\n                if chars is not None and len(chars[1]):\n                    fonts[Fx] = self.embedTTF(realpath, chars[1])\n        self.writeObject(self.fontObject, fonts)\n\n    def _write_afm_font(self, filename):\n        with open(filename, 'rb') as fh:\n            font = AFM(fh)\n        fontname = font.get_fontname()\n        fontdict = {'Type': Name('Font'),\n                    'Subtype': Name('Type1'),\n                    'BaseFont': Name(fontname),\n                    'Encoding': Name('WinAnsiEncoding')}\n        fontdictObject = self.reserveObject('font dictionary')\n        self.writeObject(fontdictObject, fontdict)\n        return fontdictObject\n\n    def embedTeXFont(self, texname, fontinfo):\n        msg = ('Embedding TeX font ' + texname + ' - fontinfo=' +\n               repr(fontinfo.__dict__))\n        matplotlib.verbose.report(msg, 'debug')\n\n        # Widths\n        widthsObject = self.reserveObject('font widths')\n        self.writeObject(widthsObject, fontinfo.dvifont.widths)\n\n        # Font dictionary\n        fontdictObject = self.reserveObject('font dictionary')\n        fontdict = {\n            'Type':      Name('Font'),\n            'Subtype':   Name('Type1'),\n            'FirstChar': 0,\n            'LastChar':  len(fontinfo.dvifont.widths) - 1,\n            'Widths':    widthsObject,\n            }\n\n        # Encoding (if needed)\n        if fontinfo.encodingfile is not None:\n            enc = dviread.Encoding(fontinfo.encodingfile)\n            differencesArray = [Name(ch) for ch in enc]\n            differencesArray = [0] + differencesArray\n            fontdict['Encoding'] = \\\n                {'Type': Name('Encoding'),\n                 'Differences': differencesArray}\n\n        # If no file is specified, stop short\n        if fontinfo.fontfile is None:\n            msg = ('Because of TeX configuration (pdftex.map, see updmap '\n                   'option pdftexDownloadBase14) the font {0} is not '\n                   'embedded. This is deprecated as of PDF 1.5 and it may '\n                   'cause the consumer application to show something that '\n                   'was not intended.').format(fontinfo.basefont)\n            warnings.warn(msg)\n            fontdict['BaseFont'] = Name(fontinfo.basefont)\n            self.writeObject(fontdictObject, fontdict)\n            return fontdictObject\n\n        # We have a font file to embed - read it in and apply any effects\n        t1font = type1font.Type1Font(fontinfo.fontfile)\n        if fontinfo.effects:\n            t1font = t1font.transform(fontinfo.effects)\n        fontdict['BaseFont'] = Name(t1font.prop['FontName'])\n\n        # Font descriptors may be shared between differently encoded\n        # Type-1 fonts, so only create a new descriptor if there is no\n        # existing descriptor for this font.\n        effects = (fontinfo.effects.get('slant', 0.0),\n                   fontinfo.effects.get('extend', 1.0))\n        fontdesc = self.type1Descriptors.get((fontinfo.fontfile, effects))\n        if fontdesc is None:\n            fontdesc = self.createType1Descriptor(t1font, fontinfo.fontfile)\n            self.type1Descriptors[(fontinfo.fontfile, effects)] = fontdesc\n        fontdict['FontDescriptor'] = fontdesc\n\n        self.writeObject(fontdictObject, fontdict)\n        return fontdictObject\n\n    def createType1Descriptor(self, t1font, fontfile):\n        # Create and write the font descriptor and the font file\n        # of a Type-1 font\n        fontdescObject = self.reserveObject('font descriptor')\n        fontfileObject = self.reserveObject('font file')\n\n        italic_angle = t1font.prop['ItalicAngle']\n        fixed_pitch = t1font.prop['isFixedPitch']\n\n        flags = 0\n        # fixed width\n        if fixed_pitch:\n            flags |= 1 << 0\n        # TODO: serif\n        if 0:\n            flags |= 1 << 1\n        # TODO: symbolic (most TeX fonts are)\n        if 1:\n            flags |= 1 << 2\n        # non-symbolic\n        else:\n            flags |= 1 << 5\n        # italic\n        if italic_angle:\n            flags |= 1 << 6\n        # TODO: all caps\n        if 0:\n            flags |= 1 << 16\n        # TODO: small caps\n        if 0:\n            flags |= 1 << 17\n        # TODO: force bold\n        if 0:\n            flags |= 1 << 18\n\n        ft2font = FT2Font(fontfile)\n\n        descriptor = {\n            'Type':        Name('FontDescriptor'),\n            'FontName':    Name(t1font.prop['FontName']),\n            'Flags':       flags,\n            'FontBBox':    ft2font.bbox,\n            'ItalicAngle': italic_angle,\n            'Ascent':      ft2font.ascender,\n            'Descent':     ft2font.descender,\n            'CapHeight':   1000,  # TODO: find this out\n            'XHeight':     500,  # TODO: this one too\n            'FontFile':    fontfileObject,\n            'FontFamily':  t1font.prop['FamilyName'],\n            'StemV':       50,  # TODO\n            # (see also revision 3874; but not all TeX distros have AFM files!)\n            #'FontWeight': a number where 400 = Regular, 700 = Bold\n            }\n\n        self.writeObject(fontdescObject, descriptor)\n\n        self.beginStream(fontfileObject.id, None,\n                         {'Length1': len(t1font.parts[0]),\n                          'Length2': len(t1font.parts[1]),\n                          'Length3': 0})\n        self.currentstream.write(t1font.parts[0])\n        self.currentstream.write(t1font.parts[1])\n        self.endStream()\n\n        return fontdescObject\n\n    def _get_xobject_symbol_name(self, filename, symbol_name):\n        return \"%s-%s\" % (\n            os.path.splitext(os.path.basename(filename))[0],\n            symbol_name)\n\n    _identityToUnicodeCMap = \"\"\"/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo\n<< /Registry (Adobe)\n   /Ordering (UCS)\n   /Supplement 0\n>> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<0000> <ffff>\nendcodespacerange\n%d beginbfrange\n%s\nendbfrange\nendcmap\nCMapName currentdict /CMap defineresource pop\nend\nend\"\"\"\n\n    def embedTTF(self, filename, characters):\n        \"\"\"Embed the TTF font from the named file into the document.\"\"\"\n\n        font = FT2Font(filename)\n        fonttype = rcParams['pdf.fonttype']\n\n        def cvt(length, upe=font.units_per_EM, nearest=True):\n            \"Convert font coordinates to PDF glyph coordinates\"\n            value = length / upe * 1000\n            if nearest:\n                return round(value)\n            # Perhaps best to round away from zero for bounding\n            # boxes and the like\n            if value < 0:\n                return floor(value)\n            else:\n                return ceil(value)\n\n        def embedTTFType3(font, characters, descriptor):\n            \"\"\"The Type 3-specific part of embedding a Truetype font\"\"\"\n            widthsObject = self.reserveObject('font widths')\n            fontdescObject = self.reserveObject('font descriptor')\n            fontdictObject = self.reserveObject('font dictionary')\n            charprocsObject = self.reserveObject('character procs')\n            differencesArray = []\n            firstchar, lastchar = 0, 255\n            bbox = [cvt(x, nearest=False) for x in font.bbox]\n\n            fontdict = {\n                'Type': Name('Font'),\n                'BaseFont': ps_name,\n                'FirstChar': firstchar,\n                'LastChar': lastchar,\n                'FontDescriptor': fontdescObject,\n                'Subtype': Name('Type3'),\n                'Name': descriptor['FontName'],\n                'FontBBox': bbox,\n                'FontMatrix': [.001, 0, 0, .001, 0, 0],\n                'CharProcs': charprocsObject,\n                'Encoding': {\n                    'Type': Name('Encoding'),\n                    'Differences': differencesArray},\n                'Widths': widthsObject\n                }\n\n            # Make the \"Widths\" array\n            from encodings import cp1252\n            # The \"decoding_map\" was changed\n            # to a \"decoding_table\" as of Python 2.5.\n            if hasattr(cp1252, 'decoding_map'):\n                def decode_char(charcode):\n                    return cp1252.decoding_map[charcode] or 0\n            else:\n                def decode_char(charcode):\n                    return ord(cp1252.decoding_table[charcode])\n\n            def get_char_width(charcode):\n                s = decode_char(charcode)\n                width = font.load_char(\n                    s, flags=LOAD_NO_SCALE | LOAD_NO_HINTING).horiAdvance\n                return cvt(width)\n\n            widths = [get_char_width(charcode)\n                      for charcode in range(firstchar, lastchar+1)]\n            descriptor['MaxWidth'] = max(widths)\n\n            # Make the \"Differences\" array, sort the ccodes < 255 from\n            # the multi-byte ccodes, and build the whole set of glyph ids\n            # that we need from this font.\n            cmap = font.get_charmap()\n            glyph_ids = []\n            differences = []\n            multi_byte_chars = set()\n            for c in characters:\n                ccode = c\n                gind = cmap.get(ccode) or 0\n                glyph_ids.append(gind)\n                glyph_name = font.get_glyph_name(gind)\n                if ccode <= 255:\n                    differences.append((ccode, glyph_name))\n                else:\n                    multi_byte_chars.add(glyph_name)\n            differences.sort()\n\n            last_c = -2\n            for c, name in differences:\n                if c != last_c + 1:\n                    differencesArray.append(c)\n                differencesArray.append(Name(name))\n                last_c = c\n\n            # Make the charprocs array (using ttconv to generate the\n            # actual outlines)\n            rawcharprocs = ttconv.get_pdf_charprocs(\n                filename.encode(sys.getfilesystemencoding()), glyph_ids)\n            charprocs = {}\n            for charname, stream in six.iteritems(rawcharprocs):\n                charprocDict = {'Length': len(stream)}\n                # The 2-byte characters are used as XObjects, so they\n                # need extra info in their dictionary\n                if charname in multi_byte_chars:\n                    charprocDict['Type'] = Name('XObject')\n                    charprocDict['Subtype'] = Name('Form')\n                    charprocDict['BBox'] = bbox\n                    # Each glyph includes bounding box information,\n                    # but xpdf and ghostscript can't handle it in a\n                    # Form XObject (they segfault!!!), so we remove it\n                    # from the stream here.  It's not needed anyway,\n                    # since the Form XObject includes it in its BBox\n                    # value.\n                    stream = stream[stream.find(b\"d1\") + 2:]\n                charprocObject = self.reserveObject('charProc')\n                self.beginStream(charprocObject.id, None, charprocDict)\n                self.currentstream.write(stream)\n                self.endStream()\n\n                # Send the glyphs with ccode > 255 to the XObject dictionary,\n                # and the others to the font itself\n                if charname in multi_byte_chars:\n                    name = self._get_xobject_symbol_name(filename, charname)\n                    self.multi_byte_charprocs[name] = charprocObject\n                else:\n                    charprocs[charname] = charprocObject\n\n            # Write everything out\n            self.writeObject(fontdictObject, fontdict)\n            self.writeObject(fontdescObject, descriptor)\n            self.writeObject(widthsObject, widths)\n            self.writeObject(charprocsObject, charprocs)\n\n            return fontdictObject\n\n        def embedTTFType42(font, characters, descriptor):\n            \"\"\"The Type 42-specific part of embedding a Truetype font\"\"\"\n            fontdescObject = self.reserveObject('font descriptor')\n            cidFontDictObject = self.reserveObject('CID font dictionary')\n            type0FontDictObject = self.reserveObject('Type 0 font dictionary')\n            cidToGidMapObject = self.reserveObject('CIDToGIDMap stream')\n            fontfileObject = self.reserveObject('font file stream')\n            wObject = self.reserveObject('Type 0 widths')\n            toUnicodeMapObject = self.reserveObject('ToUnicode map')\n\n            cidFontDict = {\n                'Type': Name('Font'),\n                'Subtype': Name('CIDFontType2'),\n                'BaseFont': ps_name,\n                'CIDSystemInfo': {\n                    'Registry': 'Adobe',\n                    'Ordering': 'Identity',\n                    'Supplement': 0},\n                'FontDescriptor': fontdescObject,\n                'W': wObject,\n                'CIDToGIDMap': cidToGidMapObject\n                }\n\n            type0FontDict = {\n                'Type': Name('Font'),\n                'Subtype': Name('Type0'),\n                'BaseFont': ps_name,\n                'Encoding': Name('Identity-H'),\n                'DescendantFonts': [cidFontDictObject],\n                'ToUnicode': toUnicodeMapObject\n                }\n\n            # Make fontfile stream\n            descriptor['FontFile2'] = fontfileObject\n            length1Object = self.reserveObject('decoded length of a font')\n            self.beginStream(\n                fontfileObject.id,\n                self.reserveObject('length of font stream'),\n                {'Length1': length1Object})\n            with open(filename, 'rb') as fontfile:\n                length1 = 0\n                while True:\n                    data = fontfile.read(4096)\n                    if not data:\n                        break\n                    length1 += len(data)\n                    self.currentstream.write(data)\n            self.endStream()\n            self.writeObject(length1Object, length1)\n\n            # Make the 'W' (Widths) array, CidToGidMap and ToUnicode CMap\n            # at the same time\n            cid_to_gid_map = ['\\u0000'] * 65536\n            cmap = font.get_charmap()\n            widths = []\n            max_ccode = 0\n            for c in characters:\n                ccode = c\n                gind = cmap.get(ccode) or 0\n                glyph = font.load_char(ccode, flags=LOAD_NO_HINTING)\n                widths.append((ccode, glyph.horiAdvance / 6))\n                if ccode < 65536:\n                    cid_to_gid_map[ccode] = unichr(gind)\n                max_ccode = max(ccode, max_ccode)\n            widths.sort()\n            cid_to_gid_map = cid_to_gid_map[:max_ccode + 1]\n\n            last_ccode = -2\n            w = []\n            max_width = 0\n            unicode_groups = []\n            for ccode, width in widths:\n                if ccode != last_ccode + 1:\n                    w.append(ccode)\n                    w.append([width])\n                    unicode_groups.append([ccode, ccode])\n                else:\n                    w[-1].append(width)\n                    unicode_groups[-1][1] = ccode\n                max_width = max(max_width, width)\n                last_ccode = ccode\n\n            unicode_bfrange = []\n            for start, end in unicode_groups:\n                unicode_bfrange.append(\n                    \"<%04x> <%04x> [%s]\" %\n                    (start, end,\n                     \" \".join([\"<%04x>\" % x for x in range(start, end+1)])))\n            unicode_cmap = (self._identityToUnicodeCMap %\n                            (len(unicode_groups),\n                             \"\\n\".join(unicode_bfrange))).encode('ascii')\n\n            # CIDToGIDMap stream\n            cid_to_gid_map = \"\".join(cid_to_gid_map).encode(\"utf-16be\")\n            self.beginStream(cidToGidMapObject.id,\n                             None,\n                             {'Length':  len(cid_to_gid_map)})\n            self.currentstream.write(cid_to_gid_map)\n            self.endStream()\n\n            # ToUnicode CMap\n            self.beginStream(toUnicodeMapObject.id,\n                             None,\n                             {'Length': unicode_cmap})\n            self.currentstream.write(unicode_cmap)\n            self.endStream()\n\n            descriptor['MaxWidth'] = max_width\n\n            # Write everything out\n            self.writeObject(cidFontDictObject, cidFontDict)\n            self.writeObject(type0FontDictObject, type0FontDict)\n            self.writeObject(fontdescObject, descriptor)\n            self.writeObject(wObject, w)\n\n            return type0FontDictObject\n\n        # Beginning of main embedTTF function...\n\n        # You are lost in a maze of TrueType tables, all different...\n        sfnt = font.get_sfnt()\n        try:\n            ps_name = sfnt[(1, 0, 0, 6)].decode('macroman')  # Macintosh scheme\n        except KeyError:\n            # Microsoft scheme:\n            ps_name = sfnt[(3, 1, 0x0409, 6)].decode('utf-16be')\n            # (see freetype/ttnameid.h)\n        ps_name = ps_name.encode('ascii', 'replace')\n        ps_name = Name(ps_name)\n        pclt = font.get_sfnt_table('pclt') or {'capHeight': 0, 'xHeight': 0}\n        post = font.get_sfnt_table('post') or {'italicAngle': (0, 0)}\n        ff = font.face_flags\n        sf = font.style_flags\n\n        flags = 0\n        symbolic = False  # ps_name.name in ('Cmsy10', 'Cmmi10', 'Cmex10')\n        if ff & FIXED_WIDTH:\n            flags |= 1 << 0\n        if 0:  # TODO: serif\n            flags |= 1 << 1\n        if symbolic:\n            flags |= 1 << 2\n        else:\n            flags |= 1 << 5\n        if sf & ITALIC:\n            flags |= 1 << 6\n        if 0:  # TODO: all caps\n            flags |= 1 << 16\n        if 0:  # TODO: small caps\n            flags |= 1 << 17\n        if 0:  # TODO: force bold\n            flags |= 1 << 18\n\n        descriptor = {\n            'Type': Name('FontDescriptor'),\n            'FontName': ps_name,\n            'Flags': flags,\n            'FontBBox': [cvt(x, nearest=False) for x in font.bbox],\n            'Ascent': cvt(font.ascender, nearest=False),\n            'Descent': cvt(font.descender, nearest=False),\n            'CapHeight': cvt(pclt['capHeight'], nearest=False),\n            'XHeight': cvt(pclt['xHeight']),\n            'ItalicAngle': post['italicAngle'][1],  # ???\n            'StemV': 0  # ???\n            }\n\n        # The font subsetting to a Type 3 font does not work for\n        # OpenType (.otf) that embed a Postscript CFF font, so avoid that --\n        # save as a (non-subsetted) Type 42 font instead.\n        if is_opentype_cff_font(filename):\n            fonttype = 42\n            msg = (\"'%s' can not be subsetted into a Type 3 font. \"\n                   \"The entire font will be embedded in the output.\")\n            warnings.warn(msg % os.path.basename(filename))\n\n        if fonttype == 3:\n            return embedTTFType3(font, characters, descriptor)\n        elif fonttype == 42:\n            return embedTTFType42(font, characters, descriptor)\n\n    def alphaState(self, alpha):\n        \"\"\"Return name of an ExtGState that sets alpha to the given value\"\"\"\n\n        state = self.alphaStates.get(alpha, None)\n        if state is not None:\n            return state[0]\n\n        name = Name('A%d' % self.nextAlphaState)\n        self.nextAlphaState += 1\n        self.alphaStates[alpha] = \\\n            (name, {'Type': Name('ExtGState'),\n                    'CA': alpha[0], 'ca': alpha[1]})\n        return name\n\n    def hatchPattern(self, hatch_style):\n        # The colors may come in as numpy arrays, which aren't hashable\n        if hatch_style is not None:\n            face, edge, hatch = hatch_style\n            if face is not None:\n                face = tuple(face)\n            if edge is not None:\n                edge = tuple(edge)\n            hatch_style = (face, edge, hatch)\n\n        pattern = self.hatchPatterns.get(hatch_style, None)\n        if pattern is not None:\n            return pattern\n\n        name = Name('H%d' % self.nextHatch)\n        self.nextHatch += 1\n        self.hatchPatterns[hatch_style] = name\n        return name\n\n    def writeHatches(self):\n        hatchDict = dict()\n        sidelen = 72.0\n        for hatch_style, name in six.iteritems(self.hatchPatterns):\n            ob = self.reserveObject('hatch pattern')\n            hatchDict[name] = ob\n            res = {'Procsets':\n                   [Name(x) for x in \"PDF Text ImageB ImageC ImageI\".split()]}\n            self.beginStream(\n                ob.id, None,\n                {'Type': Name('Pattern'),\n                 'PatternType': 1, 'PaintType': 1, 'TilingType': 1,\n                 'BBox': [0, 0, sidelen, sidelen],\n                 'XStep': sidelen, 'YStep': sidelen,\n                 'Resources': res})\n\n            # lst is a tuple of stroke color, fill color,\n            # number of - lines, number of / lines,\n            # number of | lines, number of \\ lines\n            rgb = hatch_style[0]\n            self.output(rgb[0], rgb[1], rgb[2], Op.setrgb_stroke)\n            if hatch_style[1] is not None:\n                rgb = hatch_style[1]\n                self.output(rgb[0], rgb[1], rgb[2], Op.setrgb_nonstroke,\n                            0, 0, sidelen, sidelen, Op.rectangle,\n                            Op.fill)\n\n            self.output(0.1, Op.setlinewidth)\n\n            # TODO: We could make this dpi-dependent, but that would be\n            # an API change\n            self.output(*self.pathOperations(\n                Path.hatch(hatch_style[2]),\n                Affine2D().scale(sidelen),\n                simplify=False))\n            self.output(Op.stroke)\n\n            self.endStream()\n        self.writeObject(self.hatchObject, hatchDict)\n\n    def addGouraudTriangles(self, points, colors):\n        name = Name('GT%d' % len(self.gouraudTriangles))\n        self.gouraudTriangles.append((name, points, colors))\n        return name\n\n    def writeGouraudTriangles(self):\n        gouraudDict = dict()\n        for name, points, colors in self.gouraudTriangles:\n            ob = self.reserveObject('Gouraud triangle')\n            gouraudDict[name] = ob\n            shape = points.shape\n            flat_points = points.reshape((shape[0] * shape[1], 2))\n            flat_colors = colors.reshape((shape[0] * shape[1], 4))\n            points_min = np.min(flat_points, axis=0) - (1 << 8)\n            points_max = np.max(flat_points, axis=0) + (1 << 8)\n            factor = float(0xffffffff) / (points_max - points_min)\n\n            self.beginStream(\n                ob.id, None,\n                {'ShadingType': 4,\n                 'BitsPerCoordinate': 32,\n                 'BitsPerComponent': 8,\n                 'BitsPerFlag': 8,\n                 'ColorSpace': Name('DeviceRGB'),\n                 'AntiAlias': True,\n                 'Decode': [points_min[0], points_max[0],\n                            points_min[1], points_max[1],\n                            0, 1, 0, 1, 0, 1]\n                 })\n\n            streamarr = np.empty(\n                (shape[0] * shape[1],),\n                dtype=[(str('flags'), str('u1')),\n                       (str('points'), str('>u4'), (2,)),\n                       (str('colors'), str('u1'), (3,))])\n            streamarr['flags'] = 0\n            streamarr['points'] = (flat_points - points_min) * factor\n            streamarr['colors'] = flat_colors[:, :3] * 255.0\n\n            self.write(streamarr.tostring())\n            self.endStream()\n        self.writeObject(self.gouraudObject, gouraudDict)\n\n    def imageObject(self, image):\n        \"\"\"Return name of an image XObject representing the given image.\"\"\"\n\n        pair = self.images.get(image, None)\n        if pair is not None:\n            return pair[0]\n\n        name = Name('I%d' % self.nextImage)\n        ob = self.reserveObject('image %d' % self.nextImage)\n        self.nextImage += 1\n        self.images[image] = (name, ob)\n        return name\n\n    ## These two from backend_ps.py\n    ## TODO: alpha (SMask, p. 518 of pdf spec)\n\n    def _rgb(self, im):\n        h, w, s = im.as_rgba_str()\n\n        rgba = np.fromstring(s, np.uint8)\n        rgba.shape = (h, w, 4)\n        rgba = rgba[::-1]\n        rgb = rgba[:, :, :3]\n        a = rgba[:, :, 3:]\n        return h, w, rgb.tostring(), a.tostring()\n\n    def _gray(self, im, rc=0.3, gc=0.59, bc=0.11):\n        rgbat = im.as_rgba_str()\n        rgba = np.fromstring(rgbat[2], np.uint8)\n        rgba.shape = (rgbat[0], rgbat[1], 4)\n        rgba = rgba[::-1]\n        rgba_f = rgba.astype(np.float32)\n        r = rgba_f[:, :, 0]\n        g = rgba_f[:, :, 1]\n        b = rgba_f[:, :, 2]\n        gray = (r*rc + g*gc + b*bc).astype(np.uint8)\n        return rgbat[0], rgbat[1], gray.tostring()\n\n    def writeImages(self):\n        for img, pair in six.iteritems(self.images):\n            if img.is_grayscale:\n                height, width, data = self._gray(img)\n                self.beginStream(\n                    pair[1].id,\n                    self.reserveObject('length of image stream'),\n                    {'Type': Name('XObject'), 'Subtype': Name('Image'),\n                     'Width': width, 'Height': height,\n                     'ColorSpace': Name('DeviceGray'), 'BitsPerComponent': 8})\n                # TODO: predictors (i.e., output png)\n                self.currentstream.write(data)\n                self.endStream()\n            else:\n                height, width, data, adata = self._rgb(img)\n                smaskObject = self.reserveObject(\"smask\")\n                self.beginStream(\n                    smaskObject.id,\n                    self.reserveObject('length of smask stream'),\n                    {'Type': Name('XObject'), 'Subtype': Name('Image'),\n                     'Width': width, 'Height': height,\n                     'ColorSpace': Name('DeviceGray'), 'BitsPerComponent': 8})\n                # TODO: predictors (i.e., output png)\n                self.currentstream.write(adata)\n                self.endStream()\n\n                self.beginStream(\n                    pair[1].id,\n                    self.reserveObject('length of image stream'),\n                    {'Type': Name('XObject'), 'Subtype': Name('Image'),\n                     'Width': width, 'Height': height,\n                     'ColorSpace': Name('DeviceRGB'), 'BitsPerComponent': 8,\n                     'SMask': smaskObject})\n                # TODO: predictors (i.e., output png)\n                self.currentstream.write(data)\n                self.endStream()\n\n    def markerObject(self, path, trans, fillp, strokep, lw, joinstyle,\n                     capstyle):\n        \"\"\"Return name of a marker XObject representing the given path.\"\"\"\n        # self.markers used by markerObject, writeMarkers, close:\n        # mapping from (path operations, fill?, stroke?) to\n        #   [name, object reference, bounding box, linewidth]\n        # This enables different draw_markers calls to share the XObject\n        # if the gc is sufficiently similar: colors etc can vary, but\n        # the choices of whether to fill and whether to stroke cannot.\n        # We need a bounding box enclosing all of the XObject path,\n        # but since line width may vary, we store the maximum of all\n        # occurring line widths in self.markers.\n        # close() is somewhat tightly coupled in that it expects the\n        # first two components of each value in self.markers to be the\n        # name and object reference.\n        pathops = self.pathOperations(path, trans, simplify=False)\n        key = (tuple(pathops), bool(fillp), bool(strokep), joinstyle, capstyle)\n        result = self.markers.get(key)\n        if result is None:\n            name = Name('M%d' % len(self.markers))\n            ob = self.reserveObject('marker %d' % len(self.markers))\n            bbox = path.get_extents(trans)\n            self.markers[key] = [name, ob, bbox, lw]\n        else:\n            if result[-1] < lw:\n                result[-1] = lw\n            name = result[0]\n        return name\n\n    def writeMarkers(self):\n        for ((pathops, fillp, strokep, joinstyle, capstyle),\n             (name, ob, bbox, lw)) in six.iteritems(self.markers):\n            bbox = bbox.padded(lw * 0.5)\n            self.beginStream(\n                ob.id, None,\n                {'Type': Name('XObject'), 'Subtype': Name('Form'),\n                 'BBox': list(bbox.extents)})\n            self.output(GraphicsContextPdf.joinstyles[joinstyle],\n                        Op.setlinejoin)\n            self.output(GraphicsContextPdf.capstyles[capstyle], Op.setlinecap)\n            self.output(*pathops)\n            self.output(Op.paint_path(False, fillp, strokep))\n            self.endStream()\n\n    def pathCollectionObject(self, gc, path, trans, padding, filled, stroked):\n        name = Name('P%d' % len(self.paths))\n        ob = self.reserveObject('path %d' % len(self.paths))\n        self.paths.append(\n            (name, path, trans, ob, gc.get_joinstyle(), gc.get_capstyle(),\n             padding, filled, stroked))\n        return name\n\n    def writePathCollectionTemplates(self):\n        for (name, path, trans, ob, joinstyle, capstyle, padding, filled,\n             stroked) in self.paths:\n            pathops = self.pathOperations(path, trans, simplify=False)\n            bbox = path.get_extents(trans)\n            if not np.all(np.isfinite(bbox.extents)):\n                extents = [0, 0, 0, 0]\n            else:\n                bbox = bbox.padded(padding)\n                extents = list(bbox.extents)\n            self.beginStream(\n                ob.id, None,\n                {'Type': Name('XObject'), 'Subtype': Name('Form'),\n                 'BBox': extents})\n            self.output(GraphicsContextPdf.joinstyles[joinstyle],\n                        Op.setlinejoin)\n            self.output(GraphicsContextPdf.capstyles[capstyle], Op.setlinecap)\n            self.output(*pathops)\n            self.output(Op.paint_path(False, filled, stroked))\n            self.endStream()\n\n    @staticmethod\n    def pathOperations(path, transform, clip=None, simplify=None, sketch=None):\n        cmds = []\n        last_points = None\n        for points, code in path.iter_segments(transform, clip=clip,\n                                               simplify=simplify,\n                                               sketch=sketch):\n            if code == Path.MOVETO:\n                # This is allowed anywhere in the path\n                cmds.extend(points)\n                cmds.append(Op.moveto)\n            elif code == Path.CLOSEPOLY:\n                cmds.append(Op.closepath)\n            elif last_points is None:\n                # The other operations require a previous point\n                raise ValueError('Path lacks initial MOVETO')\n            elif code == Path.LINETO:\n                cmds.extend(points)\n                cmds.append(Op.lineto)\n            elif code == Path.CURVE3:\n                points = quad2cubic(*(list(last_points[-2:]) + list(points)))\n                cmds.extend(points[2:])\n                cmds.append(Op.curveto)\n            elif code == Path.CURVE4:\n                cmds.extend(points)\n                cmds.append(Op.curveto)\n            last_points = points\n        return cmds\n\n    def writePath(self, path, transform, clip=False, sketch=None):\n        if clip:\n            clip = (0.0, 0.0, self.width * 72, self.height * 72)\n            simplify = path.should_simplify\n        else:\n            clip = None\n            simplify = False\n        cmds = self.pathOperations(path, transform, clip, simplify=simplify,\n                                   sketch=sketch)\n        self.output(*cmds)\n\n    def reserveObject(self, name=''):\n        \"\"\"Reserve an ID for an indirect object.\n        The name is used for debugging in case we forget to print out\n        the object with writeObject.\n        \"\"\"\n\n        id = self.nextObject\n        self.nextObject += 1\n        self.xrefTable.append([None, 0, name])\n        return Reference(id)\n\n    def recordXref(self, id):\n        self.xrefTable[id][0] = self.fh.tell() - self.tell_base\n\n    def writeObject(self, object, contents):\n        self.recordXref(object.id)\n        object.write(contents, self)\n\n    def writeXref(self):\n        \"\"\"Write out the xref table.\"\"\"\n\n        self.startxref = self.fh.tell() - self.tell_base\n        self.write((\"xref\\n0 %d\\n\" % self.nextObject).encode('ascii'))\n        i = 0\n        borken = False\n        for offset, generation, name in self.xrefTable:\n            if offset is None:\n                print('No offset for object %d (%s)' % (i, name),\n                      file=sys.stderr)\n                borken = True\n            else:\n                if name == 'the zero object':\n                    key = \"f\"\n                else:\n                    key = \"n\"\n                text = \"%010d %05d %s \\n\" % (offset, generation, key)\n                self.write(text.encode('ascii'))\n            i += 1\n        if borken:\n            raise AssertionError('Indirect object does not exist')\n\n    def writeInfoDict(self):\n        \"\"\"Write out the info dictionary, checking it for good form\"\"\"\n\n        is_date = lambda x: isinstance(x, datetime)\n        check_trapped = (lambda x: isinstance(x, Name) and\n                         x.name in ('True', 'False', 'Unknown'))\n        keywords = {'Title': is_string_like,\n                    'Author': is_string_like,\n                    'Subject': is_string_like,\n                    'Keywords': is_string_like,\n                    'Creator': is_string_like,\n                    'Producer': is_string_like,\n                    'CreationDate': is_date,\n                    'ModDate': is_date,\n                    'Trapped': check_trapped}\n        for k in six.iterkeys(self.infoDict):\n            if k not in keywords:\n                warnings.warn('Unknown infodict keyword: %s' % k)\n            else:\n                if not keywords[k](self.infoDict[k]):\n                    warnings.warn('Bad value for infodict keyword %s' % k)\n\n        self.infoObject = self.reserveObject('info')\n        self.writeObject(self.infoObject, self.infoDict)\n\n    def writeTrailer(self):\n        \"\"\"Write out the PDF trailer.\"\"\"\n\n        self.write(b\"trailer\\n\")\n        self.write(pdfRepr(\n            {'Size': self.nextObject,\n             'Root': self.rootObject,\n             'Info': self.infoObject}))\n        # Could add 'ID'\n        self.write((\"\\nstartxref\\n%d\\n%%%%EOF\\n\" %\n                    self.startxref).encode('ascii'))\n\n\nclass RendererPdf(RendererBase):\n    truetype_font_cache = maxdict(50)\n    afm_font_cache = maxdict(50)\n\n    def __init__(self, file, image_dpi):\n        RendererBase.__init__(self)\n        self.file = file\n        self.gc = self.new_gc()\n        self.mathtext_parser = MathTextParser(\"Pdf\")\n        self.image_dpi = image_dpi\n        self.tex_font_map = None\n\n    def finalize(self):\n        self.file.output(*self.gc.finalize())\n\n    def check_gc(self, gc, fillcolor=None):\n        orig_fill = getattr(gc, '_fillcolor', (0., 0., 0.))\n        gc._fillcolor = fillcolor\n\n        orig_alphas = getattr(gc, '_effective_alphas', (1.0, 1.0))\n\n        if gc._forced_alpha:\n            gc._effective_alphas = (gc._alpha, gc._alpha)\n        elif fillcolor is None or len(fillcolor) < 4:\n            gc._effective_alphas = (gc._rgb[3], 1.0)\n        else:\n            gc._effective_alphas = (gc._rgb[3], fillcolor[3])\n\n        delta = self.gc.delta(gc)\n        if delta:\n            self.file.output(*delta)\n\n        # Restore gc to avoid unwanted side effects\n        gc._fillcolor = orig_fill\n        gc._effective_alphas = orig_alphas\n\n    def tex_font_mapping(self, texfont):\n        if self.tex_font_map is None:\n            self.tex_font_map = \\\n                dviread.PsfontsMap(dviread.find_tex_file('pdftex.map'))\n        return self.tex_font_map[texfont]\n\n    def track_characters(self, font, s):\n        \"\"\"Keeps track of which characters are required from\n        each font.\"\"\"\n        if isinstance(font, six.string_types):\n            fname = font\n        else:\n            fname = font.fname\n        realpath, stat_key = get_realpath_and_stat(fname)\n        used_characters = self.file.used_characters.setdefault(\n            stat_key, (realpath, set()))\n        used_characters[1].update([ord(x) for x in s])\n\n    def merge_used_characters(self, other):\n        for stat_key, (realpath, charset) in six.iteritems(other):\n            used_characters = self.file.used_characters.setdefault(\n                stat_key, (realpath, set()))\n            used_characters[1].update(charset)\n\n    def get_image_magnification(self):\n        return self.image_dpi/72.0\n\n    def option_scale_image(self):\n        \"\"\"\n        pdf backend support arbitrary scaling of image.\n        \"\"\"\n        return True\n\n    def draw_image(self, gc, x, y, im, dx=None, dy=None, transform=None):\n        self.check_gc(gc)\n\n        h, w = im.get_size_out()\n\n        if dx is None:\n            w = 72.0*w/self.image_dpi\n        else:\n            w = dx\n\n        if dy is None:\n            h = 72.0*h/self.image_dpi\n        else:\n            h = dy\n\n        imob = self.file.imageObject(im)\n\n        if transform is None:\n            self.file.output(Op.gsave,\n                             w, 0, 0, h, x, y, Op.concat_matrix,\n                             imob, Op.use_xobject, Op.grestore)\n        else:\n            tr1, tr2, tr3, tr4, tr5, tr6 = transform.to_values()\n\n            self.file.output(Op.gsave,\n                             tr1, tr2, tr3, tr4, tr5, tr6, Op.concat_matrix,\n                             w, 0, 0, h, x, y, Op.concat_matrix,\n                             imob, Op.use_xobject, Op.grestore)\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        self.check_gc(gc, rgbFace)\n        self.file.writePath(\n            path, transform,\n            rgbFace is None and gc.get_hatch_path() is None,\n            gc.get_sketch_params())\n        self.file.output(self.gc.paint())\n\n    def draw_path_collection(self, gc, master_transform, paths, all_transforms,\n                             offsets, offsetTrans, facecolors, edgecolors,\n                             linewidths, linestyles, antialiaseds, urls,\n                             offset_position):\n        # We can only reuse the objects if the presence of fill and\n        # stroke (and the amount of alpha for each) is the same for\n        # all of them\n        can_do_optimization = True\n        facecolors = np.asarray(facecolors)\n        edgecolors = np.asarray(edgecolors)\n\n        if not len(facecolors):\n            filled = False\n            can_do_optimization = not gc.get_hatch()\n        else:\n            if np.all(facecolors[:, 3] == facecolors[0, 3]):\n                filled = facecolors[0, 3] != 0.0\n            else:\n                can_do_optimization = False\n\n        if not len(edgecolors):\n            stroked = False\n        else:\n            if np.all(edgecolors[:, 3] == edgecolors[0, 3]):\n                stroked = edgecolors[0, 3] != 0.0\n            else:\n                can_do_optimization = False\n\n        if not can_do_optimization:\n            return RendererBase.draw_path_collection(\n                self, gc, master_transform, paths, all_transforms,\n                offsets, offsetTrans, facecolors, edgecolors,\n                linewidths, linestyles, antialiaseds, urls,\n                offset_position)\n\n        padding = np.max(linewidths)\n        path_codes = []\n        for i, (path, transform) in enumerate(self._iter_collection_raw_paths(\n                master_transform, paths, all_transforms)):\n            name = self.file.pathCollectionObject(\n                gc, path, transform, padding, filled, stroked)\n            path_codes.append(name)\n\n        output = self.file.output\n        output(*self.gc.push())\n        lastx, lasty = 0, 0\n        for xo, yo, path_id, gc0, rgbFace in self._iter_collection(\n                gc, master_transform, all_transforms, path_codes, offsets,\n                offsetTrans, facecolors, edgecolors, linewidths, linestyles,\n                antialiaseds, urls, offset_position):\n\n            self.check_gc(gc0, rgbFace)\n            dx, dy = xo - lastx, yo - lasty\n            output(1, 0, 0, 1, dx, dy, Op.concat_matrix, path_id,\n                   Op.use_xobject)\n            lastx, lasty = xo, yo\n        output(*self.gc.pop())\n\n    def draw_markers(self, gc, marker_path, marker_trans, path, trans,\n                     rgbFace=None):\n        # For simple paths or small numbers of markers, don't bother\n        # making an XObject\n        if len(path) * len(marker_path) <= 10:\n            RendererBase.draw_markers(self, gc, marker_path, marker_trans,\n                                      path, trans, rgbFace)\n            return\n\n        self.check_gc(gc, rgbFace)\n        fillp = gc.fillp(rgbFace)\n        strokep = gc.strokep()\n\n        output = self.file.output\n        marker = self.file.markerObject(\n            marker_path, marker_trans, fillp, strokep, self.gc._linewidth,\n            gc.get_joinstyle(), gc.get_capstyle())\n\n        output(Op.gsave)\n        lastx, lasty = 0, 0\n        for vertices, code in path.iter_segments(\n                trans,\n                clip=(0, 0, self.file.width*72, self.file.height*72),\n                simplify=False):\n            if len(vertices):\n                x, y = vertices[-2:]\n                if (x < 0 or\n                    y < 0 or\n                    x > self.file.width * 72 or\n                    y > self.file.height * 72):\n                    continue\n                dx, dy = x - lastx, y - lasty\n                output(1, 0, 0, 1, dx, dy, Op.concat_matrix,\n                       marker, Op.use_xobject)\n                lastx, lasty = x, y\n        output(Op.grestore)\n\n    def draw_gouraud_triangle(self, gc, points, colors, trans):\n        self.draw_gouraud_triangles(gc, points.reshape((1, 3, 2)),\n                                    colors.reshape((1, 3, 4)), trans)\n\n    def draw_gouraud_triangles(self, gc, points, colors, trans):\n        assert len(points) == len(colors)\n        assert points.ndim == 3\n        assert points.shape[1] == 3\n        assert points.shape[2] == 2\n        assert colors.ndim == 3\n        assert colors.shape[1] == 3\n        assert colors.shape[2] == 4\n\n        shape = points.shape\n        points = points.reshape((shape[0] * shape[1], 2))\n        tpoints = trans.transform(points)\n        tpoints = tpoints.reshape(shape)\n        name = self.file.addGouraudTriangles(tpoints, colors)\n        self.check_gc(gc)\n        self.file.output(name, Op.shading)\n\n    def _setup_textpos(self, x, y, angle, oldx=0, oldy=0, oldangle=0):\n        if angle == oldangle == 0:\n            self.file.output(x - oldx, y - oldy, Op.textpos)\n        else:\n            angle = angle / 180.0 * pi\n            self.file.output(cos(angle), sin(angle),\n                             -sin(angle), cos(angle),\n                             x, y, Op.textmatrix)\n            self.file.output(0, 0, Op.textpos)\n\n    def draw_mathtext(self, gc, x, y, s, prop, angle):\n        # TODO: fix positioning and encoding\n        width, height, descent, glyphs, rects, used_characters = \\\n            self.mathtext_parser.parse(s, 72, prop)\n        self.merge_used_characters(used_characters)\n\n        # When using Type 3 fonts, we can't use character codes higher\n        # than 255, so we use the \"Do\" command to render those\n        # instead.\n        global_fonttype = rcParams['pdf.fonttype']\n\n        # Set up a global transformation matrix for the whole math expression\n        a = angle / 180.0 * pi\n        self.file.output(Op.gsave)\n        self.file.output(cos(a), sin(a), -sin(a), cos(a), x, y,\n                         Op.concat_matrix)\n\n        self.check_gc(gc, gc._rgb)\n        self.file.output(Op.begin_text)\n        prev_font = None, None\n        oldx, oldy = 0, 0\n        for ox, oy, fontname, fontsize, num, symbol_name in glyphs:\n            if is_opentype_cff_font(fontname):\n                fonttype = 42\n            else:\n                fonttype = global_fonttype\n\n            if fonttype == 42 or num <= 255:\n                self._setup_textpos(ox, oy, 0, oldx, oldy)\n                oldx, oldy = ox, oy\n                if (fontname, fontsize) != prev_font:\n                    self.file.output(self.file.fontName(fontname), fontsize,\n                                     Op.selectfont)\n                    prev_font = fontname, fontsize\n                self.file.output(self.encode_string(unichr(num), fonttype),\n                                 Op.show)\n        self.file.output(Op.end_text)\n\n        # If using Type 3 fonts, render all of the multi-byte characters\n        # as XObjects using the 'Do' command.\n        if global_fonttype == 3:\n            for ox, oy, fontname, fontsize, num, symbol_name in glyphs:\n                if is_opentype_cff_font(fontname):\n                    fonttype = 42\n                else:\n                    fonttype = global_fonttype\n\n                if fonttype == 3 and num > 255:\n                    self.file.fontName(fontname)\n                    self.file.output(Op.gsave,\n                                     0.001 * fontsize, 0,\n                                     0, 0.001 * fontsize,\n                                     ox, oy, Op.concat_matrix)\n                    name = self.file._get_xobject_symbol_name(\n                        fontname, symbol_name)\n                    self.file.output(Name(name), Op.use_xobject)\n                    self.file.output(Op.grestore)\n\n        # Draw any horizontal lines in the math layout\n        for ox, oy, width, height in rects:\n            self.file.output(Op.gsave, ox, oy, width, height,\n                             Op.rectangle, Op.fill, Op.grestore)\n\n        # Pop off the global transformation\n        self.file.output(Op.grestore)\n\n    def draw_tex(self, gc, x, y, s, prop, angle, ismath='TeX!', mtext=None):\n        texmanager = self.get_texmanager()\n        fontsize = prop.get_size_in_points()\n        dvifile = texmanager.make_dvi(s, fontsize)\n        dvi = dviread.Dvi(dvifile, 72)\n        page = six.next(iter(dvi))\n        dvi.close()\n\n        # Gather font information and do some setup for combining\n        # characters into strings. The variable seq will contain a\n        # sequence of font and text entries. A font entry is a list\n        # ['font', name, size] where name is a Name object for the\n        # font. A text entry is ['text', x, y, glyphs, x+w] where x\n        # and y are the starting coordinates, w is the width, and\n        # glyphs is a list; in this phase it will always contain just\n        # one one-character string, but later it may have longer\n        # strings interspersed with kern amounts.\n        oldfont, seq = None, []\n        for x1, y1, dvifont, glyph, width in page.text:\n            if dvifont != oldfont:\n                pdfname = self.file.fontName(dvifont.texname)\n                if dvifont.texname not in self.file.dviFontInfo:\n                    psfont = self.tex_font_mapping(dvifont.texname)\n                    self.file.dviFontInfo[dvifont.texname] = Bunch(\n                        fontfile=psfont.filename,\n                        basefont=psfont.psname,\n                        encodingfile=psfont.encoding,\n                        effects=psfont.effects,\n                        dvifont=dvifont)\n                seq += [['font', pdfname, dvifont.size]]\n                oldfont = dvifont\n            # We need to convert the glyph numbers to bytes, and the easiest\n            # way to do this on both Python 2 and 3 is .encode('latin-1')\n            seq += [['text', x1, y1,\n                     [six.unichr(glyph).encode('latin-1')], x1+width]]\n\n        # Find consecutive text strings with constant y coordinate and\n        # combine into a sequence of strings and kerns, or just one\n        # string (if any kerns would be less than 0.1 points).\n        i, curx, fontsize = 0, 0, None\n        while i < len(seq)-1:\n            elt, nxt = seq[i:i+2]\n            if elt[0] == 'font':\n                fontsize = elt[2]\n            elif elt[0] == nxt[0] == 'text' and elt[2] == nxt[2]:\n                offset = elt[4] - nxt[1]\n                if abs(offset) < 0.1:\n                    elt[3][-1] += nxt[3][0]\n                    elt[4] += nxt[4]-nxt[1]\n                else:\n                    elt[3] += [offset*1000.0/fontsize, nxt[3][0]]\n                    elt[4] = nxt[4]\n                del seq[i+1]\n                continue\n            i += 1\n\n        # Create a transform to map the dvi contents to the canvas.\n        mytrans = Affine2D().rotate_deg(angle).translate(x, y)\n\n        # Output the text.\n        self.check_gc(gc, gc._rgb)\n        self.file.output(Op.begin_text)\n        curx, cury, oldx, oldy = 0, 0, 0, 0\n        for elt in seq:\n            if elt[0] == 'font':\n                self.file.output(elt[1], elt[2], Op.selectfont)\n            elif elt[0] == 'text':\n                curx, cury = mytrans.transform((elt[1], elt[2]))\n                self._setup_textpos(curx, cury, angle, oldx, oldy)\n                oldx, oldy = curx, cury\n                if len(elt[3]) == 1:\n                    self.file.output(elt[3][0], Op.show)\n                else:\n                    self.file.output(elt[3], Op.showkern)\n            else:\n                assert False\n        self.file.output(Op.end_text)\n\n        # Then output the boxes (e.g., variable-length lines of square\n        # roots).\n        boxgc = self.new_gc()\n        boxgc.copy_properties(gc)\n        boxgc.set_linewidth(0)\n        pathops = [Path.MOVETO, Path.LINETO, Path.LINETO, Path.LINETO,\n                   Path.CLOSEPOLY]\n        for x1, y1, h, w in page.boxes:\n            path = Path([[x1, y1], [x1+w, y1], [x1+w, y1+h], [x1, y1+h],\n                         [0, 0]], pathops)\n            self.draw_path(boxgc, path, mytrans, gc._rgb)\n\n    def encode_string(self, s, fonttype):\n        if fonttype in (1, 3):\n            return s.encode('cp1252', 'replace')\n        return s.encode('utf-16be', 'replace')\n\n    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # TODO: combine consecutive texts into one BT/ET delimited section\n\n        # This function is rather complex, since there is no way to\n        # access characters of a Type 3 font with codes > 255.  (Type\n        # 3 fonts can not have a CIDMap).  Therefore, we break the\n        # string into chunks, where each chunk contains exclusively\n        # 1-byte or exclusively 2-byte characters, and output each\n        # chunk a separate command.  1-byte characters use the regular\n        # text show command (Tj), whereas 2-byte characters use the\n        # use XObject command (Do).  If using Type 42 fonts, all of\n        # this complication is avoided, but of course, those fonts can\n        # not be subsetted.\n\n        self.check_gc(gc, gc._rgb)\n        if ismath:\n            return self.draw_mathtext(gc, x, y, s, prop, angle)\n\n        fontsize = prop.get_size_in_points()\n\n        if rcParams['pdf.use14corefonts']:\n            font = self._get_font_afm(prop)\n            l, b, w, h = font.get_str_bbox(s)\n            fonttype = 1\n        else:\n            font = self._get_font_ttf(prop)\n            self.track_characters(font, s)\n            font.set_text(s, 0.0, flags=LOAD_NO_HINTING)\n\n            fonttype = rcParams['pdf.fonttype']\n\n            # We can't subset all OpenType fonts, so switch to Type 42\n            # in that case.\n            if is_opentype_cff_font(font.fname):\n                fonttype = 42\n\n        def check_simple_method(s):\n            \"\"\"Determine if we should use the simple or woven method\n            to output this text, and chunks the string into 1-byte and\n            2-byte sections if necessary.\"\"\"\n            use_simple_method = True\n            chunks = []\n\n            if not rcParams['pdf.use14corefonts']:\n                if fonttype == 3 and not isinstance(s, bytes) and len(s) != 0:\n                    # Break the string into chunks where each chunk is either\n                    # a string of chars <= 255, or a single character > 255.\n                    s = six.text_type(s)\n                    for c in s:\n                        if ord(c) <= 255:\n                            char_type = 1\n                        else:\n                            char_type = 2\n                        if len(chunks) and chunks[-1][0] == char_type:\n                            chunks[-1][1].append(c)\n                        else:\n                            chunks.append((char_type, [c]))\n                    use_simple_method = (len(chunks) == 1\n                                         and chunks[-1][0] == 1)\n            return use_simple_method, chunks\n\n        def draw_text_simple():\n            \"\"\"Outputs text using the simple method.\"\"\"\n            self.file.output(Op.begin_text,\n                             self.file.fontName(prop),\n                             fontsize,\n                             Op.selectfont)\n            self._setup_textpos(x, y, angle)\n            self.file.output(self.encode_string(s, fonttype), Op.show,\n                             Op.end_text)\n\n        def draw_text_woven(chunks):\n            \"\"\"Outputs text using the woven method, alternating\n            between chunks of 1-byte characters and 2-byte characters.\n            Only used for Type 3 fonts.\"\"\"\n            chunks = [(a, ''.join(b)) for a, b in chunks]\n            cmap = font.get_charmap()\n\n            # Do the rotation and global translation as a single matrix\n            # concatenation up front\n            self.file.output(Op.gsave)\n            a = angle / 180.0 * pi\n            self.file.output(cos(a), sin(a), -sin(a), cos(a), x, y,\n                             Op.concat_matrix)\n\n            # Output all the 1-byte characters in a BT/ET group, then\n            # output all the 2-byte characters.\n            for mode in (1, 2):\n                newx = oldx = 0\n                # Output a 1-byte character chunk\n                if mode == 1:\n                    self.file.output(Op.begin_text,\n                                     self.file.fontName(prop),\n                                     fontsize,\n                                     Op.selectfont)\n\n                for chunk_type, chunk in chunks:\n                    if mode == 1 and chunk_type == 1:\n                        self._setup_textpos(newx, 0, 0, oldx, 0, 0)\n                        self.file.output(self.encode_string(chunk, fonttype),\n                                         Op.show)\n                        oldx = newx\n\n                    lastgind = None\n                    for c in chunk:\n                        ccode = ord(c)\n                        gind = cmap.get(ccode)\n                        if gind is not None:\n                            if mode == 2 and chunk_type == 2:\n                                glyph_name = font.get_glyph_name(gind)\n                                self.file.output(Op.gsave)\n                                self.file.output(0.001 * fontsize, 0,\n                                                 0, 0.001 * fontsize,\n                                                 newx, 0, Op.concat_matrix)\n                                name = self.file._get_xobject_symbol_name(\n                                    font.fname, glyph_name)\n                                self.file.output(Name(name), Op.use_xobject)\n                                self.file.output(Op.grestore)\n\n                            # Move the pointer based on the character width\n                            # and kerning\n                            glyph = font.load_char(ccode,\n                                                   flags=LOAD_NO_HINTING)\n                            if lastgind is not None:\n                                kern = font.get_kerning(\n                                    lastgind, gind, KERNING_UNFITTED)\n                            else:\n                                kern = 0\n                            lastgind = gind\n                            newx += kern/64.0 + glyph.linearHoriAdvance/65536.0\n\n                if mode == 1:\n                    self.file.output(Op.end_text)\n\n            self.file.output(Op.grestore)\n\n        use_simple_method, chunks = check_simple_method(s)\n        if use_simple_method:\n            return draw_text_simple()\n        else:\n            return draw_text_woven(chunks)\n\n    def get_text_width_height_descent(self, s, prop, ismath):\n        if rcParams['text.usetex']:\n            texmanager = self.get_texmanager()\n            fontsize = prop.get_size_in_points()\n            w, h, d = texmanager.get_text_width_height_descent(s, fontsize,\n                                                               renderer=self)\n            return w, h, d\n\n        if ismath:\n            w, h, d, glyphs, rects, used_characters = \\\n                self.mathtext_parser.parse(s, 72, prop)\n\n        elif rcParams['pdf.use14corefonts']:\n            font = self._get_font_afm(prop)\n            l, b, w, h, d = font.get_str_bbox_and_descent(s)\n            scale = prop.get_size_in_points()\n            w *= scale / 1000\n            h *= scale / 1000\n            d *= scale / 1000\n        else:\n            font = self._get_font_ttf(prop)\n            font.set_text(s, 0.0, flags=LOAD_NO_HINTING)\n            w, h = font.get_width_height()\n            scale = (1.0 / 64.0)\n            w *= scale\n            h *= scale\n            d = font.get_descent()\n            d *= scale\n        return w, h, d\n\n    def _get_font_afm(self, prop):\n        key = hash(prop)\n        font = self.afm_font_cache.get(key)\n        if font is None:\n            filename = findfont(\n                prop, fontext='afm', directory=self.file._core14fontdir)\n            if filename is None:\n                filename = findfont(\n                    \"Helvetica\", fontext='afm',\n                    directory=self.file._core14fontdir)\n            font = self.afm_font_cache.get(filename)\n            if font is None:\n                with open(filename, 'rb') as fh:\n                    font = AFM(fh)\n                    self.afm_font_cache[filename] = font\n            self.afm_font_cache[key] = font\n        return font\n\n    def _get_font_ttf(self, prop):\n        key = hash(prop)\n        font = self.truetype_font_cache.get(key)\n        if font is None:\n            filename = findfont(prop)\n            font = self.truetype_font_cache.get(filename)\n            if font is None:\n                font = FT2Font(filename)\n                self.truetype_font_cache[filename] = font\n            self.truetype_font_cache[key] = font\n        font.clear()\n        font.set_size(prop.get_size_in_points(), 72)\n        return font\n\n    def flipy(self):\n        return False\n\n    def get_canvas_width_height(self):\n        return self.file.width / 72.0, self.file.height / 72.0\n\n    def new_gc(self):\n        return GraphicsContextPdf(self.file)\n\n\nclass GraphicsContextPdf(GraphicsContextBase):\n\n    def __init__(self, file):\n        GraphicsContextBase.__init__(self)\n        self._fillcolor = (0.0, 0.0, 0.0)\n        self._effective_alphas = (1.0, 1.0)\n        self.file = file\n        self.parent = None\n\n    def __repr__(self):\n        d = dict(self.__dict__)\n        del d['file']\n        del d['parent']\n        return repr(d)\n\n    def strokep(self):\n        \"\"\"\n        Predicate: does the path need to be stroked (its outline drawn)?\n        This tests for the various conditions that disable stroking\n        the path, in which case it would presumably be filled.\n        \"\"\"\n        # _linewidth > 0: in pdf a line of width 0 is drawn at minimum\n        #   possible device width, but e.g., agg doesn't draw at all\n        return (self._linewidth > 0 and self._alpha > 0 and\n                (len(self._rgb) <= 3 or self._rgb[3] != 0.0))\n\n    def fillp(self, *args):\n        \"\"\"\n        Predicate: does the path need to be filled?\n\n        An optional argument can be used to specify an alternative\n        _fillcolor, as needed by RendererPdf.draw_markers.\n        \"\"\"\n        if len(args):\n            _fillcolor = args[0]\n        else:\n            _fillcolor = self._fillcolor\n        return (self._hatch or\n                (_fillcolor is not None and\n                 (len(_fillcolor) <= 3 or _fillcolor[3] != 0.0)))\n\n    def close_and_paint(self):\n        \"\"\"\n        Return the appropriate pdf operator to close the path and\n        cause it to be stroked, filled, or both.\n        \"\"\"\n        return Op.paint_path(True, self.fillp(), self.strokep())\n\n    def paint(self):\n        \"\"\"\n        Return the appropriate pdf operator to cause the path to be\n        stroked, filled, or both.\n        \"\"\"\n        return Op.paint_path(False, self.fillp(), self.strokep())\n\n    capstyles = {'butt': 0, 'round': 1, 'projecting': 2}\n    joinstyles = {'miter': 0, 'round': 1, 'bevel': 2}\n\n    def capstyle_cmd(self, style):\n        return [self.capstyles[style], Op.setlinecap]\n\n    def joinstyle_cmd(self, style):\n        return [self.joinstyles[style], Op.setlinejoin]\n\n    def linewidth_cmd(self, width):\n        return [width, Op.setlinewidth]\n\n    def dash_cmd(self, dashes):\n        offset, dash = dashes\n        if dash is None:\n            dash = []\n            offset = 0\n        return [list(dash), offset, Op.setdash]\n\n    def alpha_cmd(self, alpha, forced, effective_alphas):\n        name = self.file.alphaState(effective_alphas)\n        return [name, Op.setgstate]\n\n    def hatch_cmd(self, hatch):\n        if not hatch:\n            if self._fillcolor is not None:\n                return self.fillcolor_cmd(self._fillcolor)\n            else:\n                return [Name('DeviceRGB'), Op.setcolorspace_nonstroke]\n        else:\n            hatch_style = (self._rgb, self._fillcolor, hatch)\n            name = self.file.hatchPattern(hatch_style)\n            return [Name('Pattern'), Op.setcolorspace_nonstroke,\n                    name, Op.setcolor_nonstroke]\n\n    def rgb_cmd(self, rgb):\n        if rcParams['pdf.inheritcolor']:\n            return []\n        if rgb[0] == rgb[1] == rgb[2]:\n            return [rgb[0], Op.setgray_stroke]\n        else:\n            return list(rgb[:3]) + [Op.setrgb_stroke]\n\n    def fillcolor_cmd(self, rgb):\n        if rgb is None or rcParams['pdf.inheritcolor']:\n            return []\n        elif rgb[0] == rgb[1] == rgb[2]:\n            return [rgb[0], Op.setgray_nonstroke]\n        else:\n            return list(rgb[:3]) + [Op.setrgb_nonstroke]\n\n    def push(self):\n        parent = GraphicsContextPdf(self.file)\n        parent.copy_properties(self)\n        parent.parent = self.parent\n        self.parent = parent\n        return [Op.gsave]\n\n    def pop(self):\n        assert self.parent is not None\n        self.copy_properties(self.parent)\n        self.parent = self.parent.parent\n        return [Op.grestore]\n\n    def clip_cmd(self, cliprect, clippath):\n        \"\"\"Set clip rectangle. Calls self.pop() and self.push().\"\"\"\n        cmds = []\n        # Pop graphics state until we hit the right one or the stack is empty\n        while ((self._cliprect, self._clippath) != (cliprect, clippath)\n                and self.parent is not None):\n            cmds.extend(self.pop())\n        # Unless we hit the right one, set the clip polygon\n        if ((self._cliprect, self._clippath) != (cliprect, clippath) or\n            self.parent is None):\n            cmds.extend(self.push())\n            if self._cliprect != cliprect:\n                cmds.extend([cliprect, Op.rectangle, Op.clip, Op.endpath])\n            if self._clippath != clippath:\n                path, affine = clippath.get_transformed_path_and_affine()\n                cmds.extend(\n                    PdfFile.pathOperations(path, affine, simplify=False) +\n                    [Op.clip, Op.endpath])\n        return cmds\n\n    commands = (\n        # must come first since may pop\n        (('_cliprect', '_clippath'), clip_cmd),\n        (('_alpha', '_forced_alpha', '_effective_alphas'), alpha_cmd),\n        (('_capstyle',), capstyle_cmd),\n        (('_fillcolor',), fillcolor_cmd),\n        (('_joinstyle',), joinstyle_cmd),\n        (('_linewidth',), linewidth_cmd),\n        (('_dashes',), dash_cmd),\n        (('_rgb',), rgb_cmd),\n        (('_hatch',), hatch_cmd),  # must come after fillcolor and rgb\n        )\n\n    # TODO: _linestyle\n\n    def delta(self, other):\n        \"\"\"\n        Copy properties of other into self and return PDF commands\n        needed to transform self into other.\n        \"\"\"\n        cmds = []\n        for params, cmd in self.commands:\n            different = False\n            for p in params:\n                ours = getattr(self, p)\n                theirs = getattr(other, p)\n                try:\n                    different = bool(ours != theirs)\n                except ValueError:\n                    ours = np.asarray(ours)\n                    theirs = np.asarray(theirs)\n                    different = (ours.shape != theirs.shape or\n                                 np.any(ours != theirs))\n                if different:\n                    break\n\n            if different:\n                theirs = [getattr(other, p) for p in params]\n                cmds.extend(cmd(self, *theirs))\n                for p in params:\n                    setattr(self, p, getattr(other, p))\n        return cmds\n\n    def copy_properties(self, other):\n        \"\"\"\n        Copy properties of other into self.\n        \"\"\"\n        GraphicsContextBase.copy_properties(self, other)\n        fillcolor = getattr(other, '_fillcolor', self._fillcolor)\n        effective_alphas = getattr(other, '_effective_alphas',\n                                   self._effective_alphas)\n        self._fillcolor = fillcolor\n        self._effective_alphas = effective_alphas\n\n    def finalize(self):\n        \"\"\"\n        Make sure every pushed graphics state is popped.\n        \"\"\"\n        cmds = []\n        while self.parent is not None:\n            cmds.extend(self.pop())\n        return cmds\n\n########################################################################\n#\n# The following functions and classes are for pylab and implement\n# window/figure managers, etc...\n#\n########################################################################\n\n\ndef new_figure_manager(num, *args, **kwargs):\n    \"\"\"\n    Create a new figure manager instance\n    \"\"\"\n    # if a main-level app must be created, this is the usual place to\n    # do it -- see backend_wx, backend_wxagg and backend_tkagg for\n    # examples.  Not all GUIs require explicit instantiation of a\n    # main-level app (egg backend_gtk, backend_gtkagg) for pylab\n    FigureClass = kwargs.pop('FigureClass', Figure)\n    thisFig = FigureClass(*args, **kwargs)\n    return new_figure_manager_given_figure(num, thisFig)\n\n\ndef new_figure_manager_given_figure(num, figure):\n    \"\"\"\n    Create a new figure manager instance for the given figure.\n    \"\"\"\n    canvas = FigureCanvasPdf(figure)\n    manager = FigureManagerPdf(canvas, num)\n    return manager\n\n\nclass PdfPages(object):\n    \"\"\"\n    A multi-page PDF file.\n\n    Examples\n    --------\n\n    >>> import matplotlib.pyplot as plt\n    >>> # Initialize:\n    >>> with PdfPages('foo.pdf') as pdf:\n    ...     # As many times as you like, create a figure fig and save it:\n    ...     fig = plt.figure()\n    ...     pdf.savefig(fig)\n    ...     # When no figure is specified the current figure is saved\n    ...     pdf.savefig()\n\n    Notes\n    -----\n\n    In reality :class:`PdfPages` is a thin wrapper around :class:`PdfFile`, in\n    order to avoid confusion when using :func:`~matplotlib.pyplot.savefig` and\n    forgetting the format argument.\n    \"\"\"\n    __slots__ = ('_file', 'keep_empty')\n\n    def __init__(self, filename, keep_empty=True):\n        \"\"\"\n        Create a new PdfPages object.\n\n        Parameters\n        ----------\n\n        filename: str\n            Plots using :meth:`PdfPages.savefig` will be written to a file at\n            this location. The file is opened at once and any older file with\n            the same name is overwritten.\n        keep_empty: bool, optional\n            If set to False, then empty pdf files will be deleted automatically\n            when closed.\n        \"\"\"\n        self._file = PdfFile(filename)\n        self.keep_empty = keep_empty\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.close()\n\n    def close(self):\n        \"\"\"\n        Finalize this object, making the underlying file a complete\n        PDF file.\n        \"\"\"\n        self._file.close()\n        if (self.get_pagecount() == 0 and not self.keep_empty\n                and not self._file.passed_in_file_object):\n            os.remove(self._file.fh.name)\n        self._file = None\n\n    def infodict(self):\n        \"\"\"\n        Return a modifiable information dictionary object\n        (see PDF reference section 10.2.1 'Document Information\n        Dictionary').\n        \"\"\"\n        return self._file.infoDict\n\n    def savefig(self, figure=None, **kwargs):\n        \"\"\"\n        Saves a :class:`~matplotlib.figure.Figure` to this file as a new page.\n\n        Any other keyword arguments are passed to\n        :meth:`~matplotlib.figure.Figure.savefig`.\n\n        Parameters\n        ----------\n\n        figure: :class:`~matplotlib.figure.Figure` or int, optional\n            Specifies what figure is saved to file. If not specified, the\n            active figure is saved. If a :class:`~matplotlib.figure.Figure`\n            instance is provided, this figure is saved. If an int is specified,\n            the figure instance to save is looked up by number.\n        \"\"\"\n        if isinstance(figure, Figure):\n            figure.savefig(self, format='pdf', **kwargs)\n        else:\n            if figure is None:\n                figureManager = Gcf.get_active()\n            else:\n                figureManager = Gcf.get_fig_manager(figure)\n            if figureManager is None:\n                raise ValueError(\"No such figure: \" + repr(figure))\n            else:\n                figureManager.canvas.figure.savefig(self, format='pdf',\n                                                    **kwargs)\n\n    def get_pagecount(self):\n        \"\"\"\n        Returns the current number of pages in the multipage pdf file.\n        \"\"\"\n        return len(self._file.pageList)\n\n\nclass FigureCanvasPdf(FigureCanvasBase):\n    \"\"\"\n    The canvas the figure renders into.  Calls the draw and print fig\n    methods, creates the renderers, etc...\n\n    Public attribute\n\n      figure - A Figure instance\n    \"\"\"\n\n    fixed_dpi = 72\n\n    def draw(self):\n        pass\n\n    filetypes = {'pdf': 'Portable Document Format'}\n\n    def get_default_filetype(self):\n        return 'pdf'\n\n    def print_pdf(self, filename, **kwargs):\n        image_dpi = kwargs.get('dpi', 72)  # dpi to use for images\n        self.figure.set_dpi(72)            # there are 72 pdf points to an inch\n        width, height = self.figure.get_size_inches()\n        if isinstance(filename, PdfPages):\n            file = filename._file\n        else:\n            file = PdfFile(filename)\n        try:\n            file.newPage(width, height)\n            _bbox_inches_restore = kwargs.pop(\"bbox_inches_restore\", None)\n            renderer = MixedModeRenderer(\n                self.figure, width, height, image_dpi,\n                RendererPdf(file, image_dpi),\n                bbox_inches_restore=_bbox_inches_restore)\n            self.figure.draw(renderer)\n            renderer.finalize()\n        finally:\n            if isinstance(filename, PdfPages):  # finish off this page\n                file.endStream()\n            else:            # we opened the file above; now finish it off\n                file.close()\n\n\nclass FigureManagerPdf(FigureManagerBase):\n    pass\n\n\nFigureCanvas = FigureCanvasPdf\nFigureManager = FigureManagerPdf\n", "patch": "@@ -1241,6 +1241,7 @@ def _rgb(self, im):\n \n         rgba = np.fromstring(s, np.uint8)\n         rgba.shape = (h, w, 4)\n+        rgba = rgba[::-1]\n         rgb = rgba[:, :, :3]\n         a = rgba[:, :, 3:]\n         return h, w, rgb.tostring(), a.tostring()\n@@ -1249,6 +1250,7 @@ def _gray(self, im, rc=0.3, gc=0.59, bc=0.11):\n         rgbat = im.as_rgba_str()\n         rgba = np.fromstring(rgbat[2], np.uint8)\n         rgba.shape = (rgbat[0], rgbat[1], 4)\n+        rgba = rgba[::-1]\n         rgba_f = rgba.astype(np.float32)\n         r = rgba_f[:, :, 0]\n         g = rgba_f[:, :, 1]\n@@ -1258,7 +1260,6 @@ def _gray(self, im, rc=0.3, gc=0.59, bc=0.11):\n \n     def writeImages(self):\n         for img, pair in six.iteritems(self.images):\n-            img.flipud_out()\n             if img.is_grayscale:\n                 height, width, data = self._gray(img)\n                 self.beginStream(\n@@ -1294,8 +1295,6 @@ def writeImages(self):\n                 self.currentstream.write(data)\n                 self.endStream()\n \n-            img.flipud_out()\n-\n     def markerObject(self, path, trans, fillp, strokep, lw, joinstyle,\n                      capstyle):\n         \"\"\"Return name of a marker XObject representing the given path.\"\"\""}
{"patches_id": 2, "files_id": 13, "language": "py", "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Fbackends%2Fbackend_pgf.py", "raw_code": "from __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport six\n\nimport math\nimport os\nimport sys\nimport re\nimport shutil\nimport tempfile\nimport codecs\nimport atexit\nimport weakref\nimport warnings\n\nimport numpy as np\n\nimport matplotlib as mpl\nfrom matplotlib.backend_bases import RendererBase, GraphicsContextBase,\\\n    FigureManagerBase, FigureCanvasBase\nfrom matplotlib.backends.backend_mixed import MixedModeRenderer\nfrom matplotlib.figure import Figure\nfrom matplotlib.text import Text\nfrom matplotlib.path import Path\nfrom matplotlib import _png, rcParams\nfrom matplotlib.cbook import is_string_like, is_writable_file_like\nfrom matplotlib.compat import subprocess\nfrom matplotlib.compat.subprocess import check_output\n\n\n###############################################################################\n\n# create a list of system fonts, all of these should work with xe/lua-latex\nsystem_fonts = []\nif sys.platform.startswith('win'):\n    from matplotlib import font_manager\n    from matplotlib.ft2font import FT2Font\n    for f in font_manager.win32InstalledFonts():\n        try:\n            system_fonts.append(FT2Font(str(f)).family_name)\n        except:\n            pass # unknown error, skip this font\nelse:\n    # assuming fontconfig is installed and the command 'fc-list' exists\n    try:\n        # list scalable (non-bitmap) fonts\n        fc_list = check_output(['fc-list', ':outline,scalable', 'family'])\n        fc_list = fc_list.decode('utf8')\n        system_fonts = [f.split(',')[0] for f in fc_list.splitlines()]\n        system_fonts = list(set(system_fonts))\n    except:\n        warnings.warn('error getting fonts from fc-list', UserWarning)\n\ndef get_texcommand():\n    \"\"\"Get chosen TeX system from rc.\"\"\"\n    texsystem_options = [\"xelatex\", \"lualatex\", \"pdflatex\"]\n    texsystem = rcParams.get(\"pgf.texsystem\", \"xelatex\")\n    return texsystem if texsystem in texsystem_options else \"xelatex\"\n\n\ndef get_fontspec():\n    \"\"\"Build fontspec preamble from rc.\"\"\"\n    latex_fontspec = []\n    texcommand = get_texcommand()\n\n    if texcommand != \"pdflatex\":\n        latex_fontspec.append(\"\\\\usepackage{fontspec}\")\n\n    if texcommand != \"pdflatex\" and rcParams.get(\"pgf.rcfonts\", True):\n        # try to find fonts from rc parameters\n        families = [\"serif\", \"sans-serif\", \"monospace\"]\n        fontspecs = [r\"\\setmainfont{%s}\", r\"\\setsansfont{%s}\",\n                     r\"\\setmonofont{%s}\"]\n        for family, fontspec in zip(families, fontspecs):\n            matches = [f for f in rcParams[\"font.\" + family]\n                       if f in system_fonts]\n            if matches:\n                latex_fontspec.append(fontspec % matches[0])\n            else:\n                pass  # no fonts found, fallback to LaTeX defaule\n\n    return \"\\n\".join(latex_fontspec)\n\n\ndef get_preamble():\n    \"\"\"Get LaTeX preamble from rc.\"\"\"\n    latex_preamble = rcParams.get(\"pgf.preamble\", \"\")\n    if type(latex_preamble) == list:\n        latex_preamble = \"\\n\".join(latex_preamble)\n    return latex_preamble\n\n###############################################################################\n\n# This almost made me cry!!!\n# In the end, it's better to use only one unit for all coordinates, since the\n# arithmetic in latex seems to produce inaccurate conversions.\nlatex_pt_to_in = 1. / 72.27\nlatex_in_to_pt = 1. / latex_pt_to_in\nmpl_pt_to_in = 1. / 72.\nmpl_in_to_pt = 1. / mpl_pt_to_in\n\n###############################################################################\n# helper functions\n\nNO_ESCAPE = r\"(?<!\\\\)(?:\\\\\\\\)*\"\nre_mathsep = re.compile(NO_ESCAPE + r\"\\$\")\nre_escapetext = re.compile(NO_ESCAPE + \"([_^$%])\")\nrepl_escapetext = lambda m: \"\\\\\" + m.group(1)\nre_mathdefault = re.compile(NO_ESCAPE + r\"(\\\\mathdefault)\")\nrepl_mathdefault = lambda m: m.group(0)[:-len(m.group(1))]\n\n\ndef common_texification(text):\n    \"\"\"\n    Do some necessary and/or useful substitutions for texts to be included in\n    LaTeX documents.\n    \"\"\"\n\n    # Sometimes, matplotlib adds the unknown command \\mathdefault.\n    # Not using \\mathnormal instead since this looks odd for the latex cm font.\n    text = re_mathdefault.sub(repl_mathdefault, text)\n\n    # split text into normaltext and inline math parts\n    parts = re_mathsep.split(text)\n    for i, s in enumerate(parts):\n        if not i % 2:\n            # textmode replacements\n            s = re_escapetext.sub(repl_escapetext, s)\n        else:\n            # mathmode replacements\n            s = r\"\\(\\displaystyle %s\\)\" % s\n        parts[i] = s\n\n    return \"\".join(parts)\n\n\ndef writeln(fh, line):\n    # every line of a file included with \\input must be terminated with %\n    # if not, latex will create additional vertical spaces for some reason\n    fh.write(line)\n    fh.write(\"%\\n\")\n\n\ndef _font_properties_str(prop):\n    # translate font properties to latex commands, return as string\n    commands = []\n\n    families = {\"serif\": r\"\\rmfamily\", \"sans\": r\"\\sffamily\",\n                \"sans-serif\": r\"\\sffamily\", \"monospace\": r\"\\ttfamily\"}\n    family = prop.get_family()[0]\n    if family in families:\n        commands.append(families[family])\n    elif family in system_fonts and get_texcommand() != \"pdflatex\":\n        commands.append(r\"\\setmainfont{%s}\\rmfamily\" % family)\n    else:\n        pass  # print warning?\n\n    size = prop.get_size_in_points()\n    commands.append(r\"\\fontsize{%f}{%f}\" % (size, size * 1.2))\n\n    styles = {\"normal\": r\"\", \"italic\": r\"\\itshape\", \"oblique\": r\"\\slshape\"}\n    commands.append(styles[prop.get_style()])\n\n    boldstyles = [\"semibold\", \"demibold\", \"demi\", \"bold\", \"heavy\",\n                  \"extra bold\", \"black\"]\n    if prop.get_weight() in boldstyles:\n        commands.append(r\"\\bfseries\")\n\n    commands.append(r\"\\selectfont\")\n    return \"\".join(commands)\n\n\ndef make_pdf_to_png_converter():\n    \"\"\"\n    Returns a function that converts a pdf file to a png file.\n    \"\"\"\n\n    tools_available = []\n    # check for pdftocairo\n    try:\n        check_output([\"pdftocairo\", \"-v\"], stderr=subprocess.STDOUT)\n        tools_available.append(\"pdftocairo\")\n    except:\n        pass\n    # check for ghostscript\n    gs, ver = mpl.checkdep_ghostscript()\n    if gs:\n        tools_available.append(\"gs\")\n\n    # pick converter\n    if \"pdftocairo\" in tools_available:\n        def cairo_convert(pdffile, pngfile, dpi):\n            cmd = [\"pdftocairo\", \"-singlefile\", \"-png\",\n                   \"-r %d\" % dpi, pdffile, os.path.splitext(pngfile)[0]]\n            # for some reason this doesn't work without shell\n            check_output(\" \".join(cmd), shell=True, stderr=subprocess.STDOUT)\n        return cairo_convert\n    elif \"gs\" in tools_available:\n        def gs_convert(pdffile, pngfile, dpi):\n            cmd = [gs, '-dQUIET', '-dSAFER', '-dBATCH', '-dNOPAUSE', '-dNOPROMPT',\n                   '-sDEVICE=png16m', '-dUseCIEColor', '-dTextAlphaBits=4',\n                   '-dGraphicsAlphaBits=4', '-dDOINTERPOLATE', '-sOutputFile=%s' % pngfile,\n                   '-r%d' % dpi, pdffile]\n            check_output(cmd, stderr=subprocess.STDOUT)\n        return gs_convert\n    else:\n        raise RuntimeError(\"No suitable pdf to png renderer found.\")\n\n\nclass LatexError(Exception):\n    def __init__(self, message, latex_output=\"\"):\n        Exception.__init__(self, message)\n        self.latex_output = latex_output\n\n\nclass LatexManagerFactory:\n    previous_instance = None\n\n    @staticmethod\n    def get_latex_manager():\n        texcommand = get_texcommand()\n        latex_header = LatexManager._build_latex_header()\n        prev = LatexManagerFactory.previous_instance\n\n        # check if the previous instance of LatexManager can be reused\n        if prev and prev.latex_header == latex_header and prev.texcommand == texcommand:\n            if rcParams.get(\"pgf.debug\", False):\n                print(\"reusing LatexManager\")\n            return prev\n        else:\n            if rcParams.get(\"pgf.debug\", False):\n                print(\"creating LatexManager\")\n            new_inst = LatexManager()\n            LatexManagerFactory.previous_instance = new_inst\n            return new_inst\n\nclass WeakSet:\n    # TODO: Poor man's weakref.WeakSet.\n    #       Remove this once python 2.6 support is dropped from matplotlib.\n\n    def __init__(self):\n        self.weak_key_dict = weakref.WeakKeyDictionary()\n\n    def add(self, item):\n        self.weak_key_dict[item] = None\n\n    def discard(self, item):\n        if item in self.weak_key_dict:\n            del self.weak_key_dict[item]\n\n    def __iter__(self):\n        return six.iterkeys(self.weak_key_dict)\n\n\nclass LatexManager:\n    \"\"\"\n    The LatexManager opens an instance of the LaTeX application for\n    determining the metrics of text elements. The LaTeX environment can be\n    modified by setting fonts and/or a custem preamble in the rc parameters.\n    \"\"\"\n    _unclean_instances = WeakSet()\n\n    @staticmethod\n    def _build_latex_header():\n        latex_preamble = get_preamble()\n        latex_fontspec = get_fontspec()\n        # Create LaTeX header with some content, else LaTeX will load some\n        # math fonts later when we don't expect the additional output on stdout.\n        # TODO: is this sufficient?\n        latex_header = [r\"\\documentclass{minimal}\",\n                        latex_preamble,\n                        latex_fontspec,\n                        r\"\\begin{document}\",\n                        r\"text $math \\mu$\",  # force latex to load fonts now\n                        r\"\\typeout{pgf_backend_query_start}\"]\n        return \"\\n\".join(latex_header)\n\n    @staticmethod\n    def _cleanup_remaining_instances():\n        unclean_instances = list(LatexManager._unclean_instances)\n        for latex_manager in unclean_instances:\n            latex_manager._cleanup()\n\n    def _stdin_writeln(self, s):\n        self.latex_stdin_utf8.write(s)\n        self.latex_stdin_utf8.write(\"\\n\")\n        self.latex_stdin_utf8.flush()\n\n    def _expect(self, s):\n        exp = s.encode(\"utf8\")\n        buf = bytearray()\n        while True:\n            b = self.latex.stdout.read(1)\n            buf += b\n            if buf[-len(exp):] == exp:\n                break\n            if not len(b):\n                raise LatexError(\"LaTeX process halted\", buf.decode(\"utf8\"))\n        return buf.decode(\"utf8\")\n\n    def _expect_prompt(self):\n        return self._expect(\"\\n*\")\n\n    def __init__(self):\n        # create a tmp directory for running latex, remember to cleanup\n        self.tmpdir = tempfile.mkdtemp(prefix=\"mpl_pgf_lm_\")\n        LatexManager._unclean_instances.add(self)\n\n        # test the LaTeX setup to ensure a clean startup of the subprocess\n        self.texcommand = get_texcommand()\n        self.latex_header = LatexManager._build_latex_header()\n        latex_end = \"\\n\\\\makeatletter\\n\\\\@@end\\n\"\n        try:\n            latex = subprocess.Popen([self.texcommand, \"-halt-on-error\"],\n                                     stdin=subprocess.PIPE,\n                                     stdout=subprocess.PIPE,\n                                     cwd=self.tmpdir)\n        except OSError:\n            raise RuntimeError(\"Error starting process '%s'\" % self.texcommand)\n        test_input = self.latex_header + latex_end\n        stdout, stderr = latex.communicate(test_input.encode(\"utf-8\"))\n        if latex.returncode != 0:\n            raise LatexError(\"LaTeX returned an error, probably missing font or error in preamble:\\n%s\" % stdout)\n\n        # open LaTeX process for real work\n        latex = subprocess.Popen([self.texcommand, \"-halt-on-error\"],\n                                 stdin=subprocess.PIPE, stdout=subprocess.PIPE,\n                                 cwd=self.tmpdir)\n        self.latex = latex\n        self.latex_stdin_utf8 = codecs.getwriter(\"utf8\")(self.latex.stdin)\n        # write header with 'pgf_backend_query_start' token\n        self._stdin_writeln(self._build_latex_header())\n        # read all lines until our 'pgf_backend_query_start' token appears\n        self._expect(\"*pgf_backend_query_start\")\n        self._expect_prompt()\n\n        # cache for strings already processed\n        self.str_cache = {}\n\n    def _cleanup(self):\n        if not os.path.isdir(self.tmpdir):\n            return\n        try:\n            self.latex_stdin_utf8.close()\n            self.latex.communicate()\n            self.latex.wait()\n        except:\n            pass\n        try:\n            shutil.rmtree(self.tmpdir)\n            LatexManager._unclean_instances.discard(self)\n        except:\n            sys.stderr.write(\"error deleting tmp directory %s\\n\" % self.tmpdir)\n\n    def __del__(self):\n        if rcParams.get(\"pgf.debug\", False):\n            print(\"deleting LatexManager\")\n        self._cleanup()\n\n    def get_width_height_descent(self, text, prop):\n        \"\"\"\n        Get the width, total height and descent for a text typesetted by the\n        current LaTeX environment.\n        \"\"\"\n\n        # apply font properties and define textbox\n        prop_cmds = _font_properties_str(prop)\n        textbox = \"\\\\sbox0{%s %s}\" % (prop_cmds, text)\n\n        # check cache\n        if textbox in self.str_cache:\n            return self.str_cache[textbox]\n\n        # send textbox to LaTeX and wait for prompt\n        self._stdin_writeln(textbox)\n        try:\n            self._expect_prompt()\n        except LatexError as e:\n            msg = \"Error processing '%s'\\nLaTeX Output:\\n%s\"\n            raise ValueError(msg % (text, e.latex_output))\n\n        # typeout width, height and text offset of the last textbox\n        self._stdin_writeln(r\"\\typeout{\\the\\wd0,\\the\\ht0,\\the\\dp0}\")\n        # read answer from latex and advance to the next prompt\n        try:\n            answer = self._expect_prompt()\n        except LatexError as e:\n            msg = \"Error processing '%s'\\nLaTeX Output:\\n%s\"\n            raise ValueError(msg % (text, e.latex_output))\n\n        # parse metrics from the answer string\n        try:\n            width, height, offset = answer.splitlines()[0].split(\",\")\n        except:\n            msg = \"Error processing '%s'\\nLaTeX Output:\\n%s\" % (text, answer)\n            raise ValueError(msg)\n        w, h, o = float(width[:-2]), float(height[:-2]), float(offset[:-2])\n\n        # the height returned from LaTeX goes from base to top.\n        # the height matplotlib expects goes from bottom to top.\n        self.str_cache[textbox] = (w, h + o, o)\n        return w, h + o, o\n\n\nclass RendererPgf(RendererBase):\n\n    def __init__(self, figure, fh, dummy=False):\n        \"\"\"\n        Creates a new PGF renderer that translates any drawing instruction\n        into text commands to be interpreted in a latex pgfpicture environment.\n\n        Attributes:\n        * figure: Matplotlib figure to initialize height, width and dpi from.\n        * fh: File handle for the output of the drawing commands.\n        \"\"\"\n        RendererBase.__init__(self)\n        self.dpi = figure.dpi\n        self.fh = fh\n        self.figure = figure\n        self.image_counter = 0\n\n        # get LatexManager instance\n        self.latexManager = LatexManagerFactory.get_latex_manager()\n\n        if dummy:\n            # dummy==True deactivate all methods\n            nop = lambda *args, **kwargs: None\n            for m in RendererPgf.__dict__.keys():\n                if m.startswith(\"draw_\"):\n                    self.__dict__[m] = nop\n        else:\n            # if fh does not belong to a filename, deactivate draw_image\n            if not os.path.exists(fh.name):\n                self.__dict__[\"draw_image\"] = lambda *args, **kwargs: None\n\n    def draw_markers(self, gc, marker_path, marker_trans, path, trans, rgbFace=None):\n        writeln(self.fh, r\"\\begin{pgfscope}\")\n\n        # convert from display units to in\n        f = 1. / self.dpi\n\n        # set style and clip\n        self._print_pgf_clip(gc)\n        self._print_pgf_path_styles(gc, rgbFace)\n\n        # build marker definition\n        bl, tr = marker_path.get_extents(marker_trans).get_points()\n        coords = bl[0] * f, bl[1] * f, tr[0] * f, tr[1] * f\n        writeln(self.fh, r\"\\pgfsys@defobject{currentmarker}{\\pgfqpoint{%fin}{%fin}}{\\pgfqpoint{%fin}{%fin}}{\" % coords)\n        self._print_pgf_path(None, marker_path, marker_trans)\n        self._pgf_path_draw(stroke=gc.get_linewidth() != 0.0,\n                            fill=rgbFace is not None)\n        writeln(self.fh, r\"}\")\n\n        # draw marker for each vertex\n        for point, code in path.iter_segments(trans, simplify=False):\n            x, y = point[0] * f, point[1] * f\n            writeln(self.fh, r\"\\begin{pgfscope}\")\n            writeln(self.fh, r\"\\pgfsys@transformshift{%fin}{%fin}\" % (x, y))\n            writeln(self.fh, r\"\\pgfsys@useobject{currentmarker}{}\")\n            writeln(self.fh, r\"\\end{pgfscope}\")\n\n        writeln(self.fh, r\"\\end{pgfscope}\")\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        writeln(self.fh, r\"\\begin{pgfscope}\")\n        # draw the path\n        self._print_pgf_clip(gc)\n        self._print_pgf_path_styles(gc, rgbFace)\n        self._print_pgf_path(gc, path, transform)\n        self._pgf_path_draw(stroke=gc.get_linewidth() != 0.0,\n                            fill=rgbFace is not None)\n        writeln(self.fh, r\"\\end{pgfscope}\")\n\n        # if present, draw pattern on top\n        if gc.get_hatch():\n            writeln(self.fh, r\"\\begin{pgfscope}\")\n            self._print_pgf_path_styles(gc, rgbFace)\n\n            # combine clip and path for clipping\n            self._print_pgf_clip(gc)\n            self._print_pgf_path(gc, path, transform)\n            writeln(self.fh, r\"\\pgfusepath{clip}\")\n\n            # build pattern definition\n            writeln(self.fh, r\"\\pgfsys@defobject{currentpattern}{\\pgfqpoint{0in}{0in}}{\\pgfqpoint{1in}{1in}}{\")\n            writeln(self.fh, r\"\\begin{pgfscope}\")\n            writeln(self.fh, r\"\\pgfpathrectangle{\\pgfqpoint{0in}{0in}}{\\pgfqpoint{1in}{1in}}\")\n            writeln(self.fh, r\"\\pgfusepath{clip}\")\n            scale = mpl.transforms.Affine2D().scale(self.dpi)\n            self._print_pgf_path(None, gc.get_hatch_path(), scale)\n            self._pgf_path_draw(stroke=True)\n            writeln(self.fh, r\"\\end{pgfscope}\")\n            writeln(self.fh, r\"}\")\n            # repeat pattern, filling the bounding rect of the path\n            f = 1. / self.dpi\n            (xmin, ymin), (xmax, ymax) = path.get_extents(transform).get_points()\n            xmin, xmax = f * xmin, f * xmax\n            ymin, ymax = f * ymin, f * ymax\n            repx, repy = int(math.ceil(xmax-xmin)), int(math.ceil(ymax-ymin))\n            writeln(self.fh, r\"\\pgfsys@transformshift{%fin}{%fin}\" % (xmin, ymin))\n            for iy in range(repy):\n                for ix in range(repx):\n                    writeln(self.fh, r\"\\pgfsys@useobject{currentpattern}{}\")\n                    writeln(self.fh, r\"\\pgfsys@transformshift{1in}{0in}\")\n                writeln(self.fh, r\"\\pgfsys@transformshift{-%din}{0in}\" % repx)\n                writeln(self.fh, r\"\\pgfsys@transformshift{0in}{1in}\")\n\n            writeln(self.fh, r\"\\end{pgfscope}\")\n\n    def _print_pgf_clip(self, gc):\n        f = 1. / self.dpi\n        # check for clip box\n        bbox = gc.get_clip_rectangle()\n        if bbox:\n            p1, p2 = bbox.get_points()\n            w, h = p2 - p1\n            coords = p1[0] * f, p1[1] * f, w * f, h * f\n            writeln(self.fh, r\"\\pgfpathrectangle{\\pgfqpoint{%fin}{%fin}}{\\pgfqpoint{%fin}{%fin}} \" % coords)\n            writeln(self.fh, r\"\\pgfusepath{clip}\")\n\n        # check for clip path\n        clippath, clippath_trans = gc.get_clip_path()\n        if clippath is not None:\n            self._print_pgf_path(gc, clippath, clippath_trans)\n            writeln(self.fh, r\"\\pgfusepath{clip}\")\n\n    def _print_pgf_path_styles(self, gc, rgbFace):\n        # cap style\n        capstyles = {\"butt\": r\"\\pgfsetbuttcap\",\n                     \"round\": r\"\\pgfsetroundcap\",\n                     \"projecting\": r\"\\pgfsetrectcap\"}\n        writeln(self.fh, capstyles[gc.get_capstyle()])\n\n        # join style\n        joinstyles = {\"miter\": r\"\\pgfsetmiterjoin\",\n                      \"round\": r\"\\pgfsetroundjoin\",\n                      \"bevel\": r\"\\pgfsetbeveljoin\"}\n        writeln(self.fh, joinstyles[gc.get_joinstyle()])\n\n        # filling\n        has_fill = rgbFace is not None\n\n        if gc.get_forced_alpha():\n            fillopacity = strokeopacity = gc.get_alpha()\n        else:\n            strokeopacity = gc.get_rgb()[3]\n            fillopacity = rgbFace[3] if has_fill and len(rgbFace) > 3 else 1.0\n\n        if has_fill:\n            writeln(self.fh, r\"\\definecolor{currentfill}{rgb}{%f,%f,%f}\" % tuple(rgbFace[:3]))\n            writeln(self.fh, r\"\\pgfsetfillcolor{currentfill}\")\n        if has_fill and fillopacity != 1.0:\n            writeln(self.fh, r\"\\pgfsetfillopacity{%f}\" % fillopacity)\n\n        # linewidth and color\n        lw = gc.get_linewidth() * mpl_pt_to_in * latex_in_to_pt\n        stroke_rgba = gc.get_rgb()\n        writeln(self.fh, r\"\\pgfsetlinewidth{%fpt}\" % lw)\n        writeln(self.fh, r\"\\definecolor{currentstroke}{rgb}{%f,%f,%f}\" % stroke_rgba[:3])\n        writeln(self.fh, r\"\\pgfsetstrokecolor{currentstroke}\")\n        if strokeopacity != 1.0:\n            writeln(self.fh, r\"\\pgfsetstrokeopacity{%f}\" % strokeopacity)\n\n        # line style\n        dash_offset, dash_list = gc.get_dashes()\n        if dash_list is None:\n            writeln(self.fh, r\"\\pgfsetdash{}{0pt}\")\n        else:\n            dash_str = r\"\\pgfsetdash{\"\n            for dash in dash_list:\n                dash_str += r\"{%fpt}\" % dash\n            dash_str += r\"}{%fpt}\" % dash_offset\n            writeln(self.fh, dash_str)\n\n    def _print_pgf_path(self, gc, path, transform):\n        f = 1. / self.dpi\n        # check for clip box\n        bbox = gc.get_clip_rectangle() if gc else None\n        if bbox:\n            p1, p2 = bbox.get_points()\n            clip = (p1[0], p1[1], p2[0], p2[1])\n        else:\n            clip = None\n        # build path\n        for points, code in path.iter_segments(transform, clip=clip):\n            if code == Path.MOVETO:\n                x, y = tuple(points)\n                writeln(self.fh, r\"\\pgfpathmoveto{\\pgfqpoint{%fin}{%fin}}\" %\n                        (f * x, f * y))\n            elif code == Path.CLOSEPOLY:\n                writeln(self.fh, r\"\\pgfpathclose\")\n            elif code == Path.LINETO:\n                x, y = tuple(points)\n                writeln(self.fh, r\"\\pgfpathlineto{\\pgfqpoint{%fin}{%fin}}\" %\n                        (f * x, f * y))\n            elif code == Path.CURVE3:\n                cx, cy, px, py = tuple(points)\n                coords = cx * f, cy * f, px * f, py * f\n                writeln(self.fh, r\"\\pgfpathquadraticcurveto{\\pgfqpoint{%fin}{%fin}}{\\pgfqpoint{%fin}{%fin}}\" % coords)\n            elif code == Path.CURVE4:\n                c1x, c1y, c2x, c2y, px, py = tuple(points)\n                coords = c1x * f, c1y * f, c2x * f, c2y * f, px * f, py * f\n                writeln(self.fh, r\"\\pgfpathcurveto{\\pgfqpoint{%fin}{%fin}}{\\pgfqpoint{%fin}{%fin}}{\\pgfqpoint{%fin}{%fin}}\" % coords)\n\n    def _pgf_path_draw(self, stroke=True, fill=False):\n        actions = []\n        if stroke:\n            actions.append(\"stroke\")\n        if fill:\n            actions.append(\"fill\")\n        writeln(self.fh, r\"\\pgfusepath{%s}\" % \",\".join(actions))\n\n    def draw_image(self, gc, x, y, im):\n        # TODO: Almost no documentation for the behavior of this function.\n        #       Something missing?\n\n        # save the images to png files\n        path = os.path.dirname(self.fh.name)\n        fname = os.path.splitext(os.path.basename(self.fh.name))[0]\n        fname_img = \"%s-img%d.png\" % (fname, self.image_counter)\n        self.image_counter += 1\n        _png.write_png(np.array(im)[::-1], os.path.join(path, fname_img))\n\n        # reference the image in the pgf picture\n        writeln(self.fh, r\"\\begin{pgfscope}\")\n        self._print_pgf_clip(gc)\n        h, w = im.get_size_out()\n        f = 1. / self.dpi  # from display coords to inch\n        writeln(self.fh, r\"\\pgftext[at=\\pgfqpoint{%fin}{%fin},left,bottom]{\\pgfimage[interpolate=true,width=%fin,height=%fin]{%s}}\" % (x * f, y * f, w * f, h * f, fname_img))\n        writeln(self.fh, r\"\\end{pgfscope}\")\n\n    def draw_tex(self, gc, x, y, s, prop, angle, ismath=\"TeX!\", mtext=None):\n        self.draw_text(gc, x, y, s, prop, angle, ismath, mtext)\n\n    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # prepare string for tex\n        s = common_texification(s)\n        prop_cmds = _font_properties_str(prop)\n        s = r\"{%s %s}\" % (prop_cmds, s)\n\n\n        writeln(self.fh, r\"\\begin{pgfscope}\")\n\n        alpha = gc.get_alpha()\n        if alpha != 1.0:\n            writeln(self.fh, r\"\\pgfsetfillopacity{%f}\" % alpha)\n            writeln(self.fh, r\"\\pgfsetstrokeopacity{%f}\" % alpha)\n        rgb = tuple(gc.get_rgb())[:3]\n        if rgb != (0, 0, 0):\n            writeln(self.fh, r\"\\definecolor{textcolor}{rgb}{%f,%f,%f}\" % rgb)\n            writeln(self.fh, r\"\\pgfsetstrokecolor{textcolor}\")\n            writeln(self.fh, r\"\\pgfsetfillcolor{textcolor}\")\n\n        f = 1.0 / self.figure.dpi\n        text_args = []\n        if mtext and (angle == 0 or mtext.get_rotation_mode() == \"anchor\"):\n            # if text anchoring can be supported, get the original coordinates\n            # and add alignment information\n            x, y = mtext.get_transform().transform_point(mtext.get_position())\n            text_args.append(\"x=%fin\" % (x * f))\n            text_args.append(\"y=%fin\" % (y * f))\n\n            halign = {\"left\": \"left\", \"right\": \"right\", \"center\": \"\"}\n            valign = {\"top\": \"top\", \"bottom\": \"bottom\",\n                      \"baseline\": \"base\", \"center\": \"\"}\n            text_args.append(halign[mtext.get_ha()])\n            text_args.append(valign[mtext.get_va()])\n        else:\n            # if not, use the text layout provided by matplotlib\n            text_args.append(\"x=%fin\" % (x * f))\n            text_args.append(\"y=%fin\" % (y * f))\n            text_args.append(\"left\")\n            text_args.append(\"base\")\n\n        if angle != 0:\n            text_args.append(\"rotate=%f\" % angle)\n\n        writeln(self.fh, r\"\\pgftext[%s]{%s}\" % (\",\".join(text_args), s))\n        writeln(self.fh, r\"\\end{pgfscope}\")\n\n    def get_text_width_height_descent(self, s, prop, ismath):\n        # check if the math is supposed to be displaystyled\n        s = common_texification(s)\n\n        # get text metrics in units of latex pt, convert to display units\n        w, h, d = self.latexManager.get_width_height_descent(s, prop)\n        # TODO: this should be latex_pt_to_in instead of mpl_pt_to_in\n        # but having a little bit more space around the text looks better,\n        # plus the bounding box reported by LaTeX is VERY narrow\n        f = mpl_pt_to_in * self.dpi\n        return w * f, h * f, d * f\n\n    def flipy(self):\n        return False\n\n    def get_canvas_width_height(self):\n        return self.figure.get_figwidth(), self.figure.get_figheight()\n\n    def points_to_pixels(self, points):\n        return points * mpl_pt_to_in * self.dpi\n\n    def new_gc(self):\n        return GraphicsContextPgf()\n\n\nclass GraphicsContextPgf(GraphicsContextBase):\n    pass\n\n########################################################################\n\n\ndef draw_if_interactive():\n    pass\n\n\ndef new_figure_manager(num, *args, **kwargs):\n    \"\"\"\n    Create a new figure manager instance\n    \"\"\"\n    # if a main-level app must be created, this is the usual place to\n    # do it -- see backend_wx, backend_wxagg and backend_tkagg for\n    # examples.  Not all GUIs require explicit instantiation of a\n    # main-level app (egg backend_gtk, backend_gtkagg) for pylab\n    FigureClass = kwargs.pop('FigureClass', Figure)\n    thisFig = FigureClass(*args, **kwargs)\n    return new_figure_manager_given_figure(num, thisFig)\n\n\ndef new_figure_manager_given_figure(num, figure):\n    \"\"\"\n    Create a new figure manager instance for the given figure.\n    \"\"\"\n    canvas = FigureCanvasPgf(figure)\n    manager = FigureManagerPgf(canvas, num)\n    return manager\n\n\nclass TmpDirCleaner:\n    remaining_tmpdirs = set()\n\n    @staticmethod\n    def add(tmpdir):\n        TmpDirCleaner.remaining_tmpdirs.add(tmpdir)\n\n    @staticmethod\n    def cleanup_remaining_tmpdirs():\n        for tmpdir in TmpDirCleaner.remaining_tmpdirs:\n            try:\n                shutil.rmtree(tmpdir)\n            except:\n                sys.stderr.write(\"error deleting tmp directory %s\\n\" % tmpdir)\n\n\nclass FigureCanvasPgf(FigureCanvasBase):\n    filetypes = {\"pgf\": \"LaTeX PGF picture\",\n                 \"pdf\": \"LaTeX compiled PGF picture\",\n                 \"png\": \"Portable Network Graphics\", }\n\n    def __init__(self, *args):\n        FigureCanvasBase.__init__(self, *args)\n\n    def get_default_filetype(self):\n        return 'pdf'\n\n    def _print_pgf_to_fh(self, fh, *args, **kwargs):\n        if kwargs.get(\"dryrun\", False):\n            renderer = RendererPgf(self.figure, None, dummy=True)\n            self.figure.draw(renderer)\n            return\n\n        header_text = \"\"\"%% Creator: Matplotlib, PGF backend\n%%\n%% To include the figure in your LaTeX document, write\n%%   \\\\input{<filename>.pgf}\n%%\n%% Make sure the required packages are loaded in your preamble\n%%   \\\\usepackage{pgf}\n%%\n%% Figures using additional raster images can only be included by \\input if\n%% they are in the same directory as the main LaTeX file. For loading figures\n%% from other directories you can use the `import` package\n%%   \\\\usepackage{import}\n%% and then include the figures with\n%%   \\\\import{<path to file>}{<filename>.pgf}\n%%\n\"\"\"\n\n        # append the preamble used by the backend as a comment for debugging\n        header_info_preamble = [\"%% Matplotlib used the following preamble\"]\n        for line in get_preamble().splitlines():\n            header_info_preamble.append(\"%%   \" + line)\n        for line in get_fontspec().splitlines():\n            header_info_preamble.append(\"%%   \" + line)\n        header_info_preamble.append(\"%%\")\n        header_info_preamble = \"\\n\".join(header_info_preamble)\n\n        # get figure size in inch\n        w, h = self.figure.get_figwidth(), self.figure.get_figheight()\n        dpi = self.figure.get_dpi()\n\n        # create pgfpicture environment and write the pgf code\n        fh.write(header_text)\n        fh.write(header_info_preamble)\n        fh.write(\"\\n\")\n        writeln(fh, r\"\\begingroup\")\n        writeln(fh, r\"\\makeatletter\")\n        writeln(fh, r\"\\begin{pgfpicture}\")\n        writeln(fh, r\"\\pgfpathrectangle{\\pgfpointorigin}{\\pgfqpoint{%fin}{%fin}}\" % (w, h))\n        writeln(fh, r\"\\pgfusepath{use as bounding box, clip}\")\n        _bbox_inches_restore = kwargs.pop(\"bbox_inches_restore\", None)\n        renderer = MixedModeRenderer(self.figure, w, h, dpi,\n                                     RendererPgf(self.figure, fh),\n                                     bbox_inches_restore=_bbox_inches_restore)\n        self.figure.draw(renderer)\n\n        # end the pgfpicture environment\n        writeln(fh, r\"\\end{pgfpicture}\")\n        writeln(fh, r\"\\makeatother\")\n        writeln(fh, r\"\\endgroup\")\n\n    def print_pgf(self, fname_or_fh, *args, **kwargs):\n        \"\"\"\n        Output pgf commands for drawing the figure so it can be included and\n        rendered in latex documents.\n        \"\"\"\n        if kwargs.get(\"dryrun\", False):\n            self._print_pgf_to_fh(None, *args, **kwargs)\n            return\n\n        # figure out where the pgf is to be written to\n        if is_string_like(fname_or_fh):\n            with codecs.open(fname_or_fh, \"w\", encoding=\"utf-8\") as fh:\n                self._print_pgf_to_fh(fh, *args, **kwargs)\n        elif is_writable_file_like(fname_or_fh):\n            if not os.path.exists(fname_or_fh.name):\n                warnings.warn(\"streamed pgf-code does not support raster \"\n                              \"graphics, consider using the pgf-to-pdf option\",\n                              UserWarning)\n            self._print_pgf_to_fh(fname_or_fh, *args, **kwargs)\n        else:\n            raise ValueError(\"filename must be a path\")\n\n    def _print_pdf_to_fh(self, fh, *args, **kwargs):\n        w, h = self.figure.get_figwidth(), self.figure.get_figheight()\n\n        try:\n            # create temporary directory for compiling the figure\n            tmpdir = tempfile.mkdtemp(prefix=\"mpl_pgf_\")\n            fname_pgf = os.path.join(tmpdir, \"figure.pgf\")\n            fname_tex = os.path.join(tmpdir, \"figure.tex\")\n            fname_pdf = os.path.join(tmpdir, \"figure.pdf\")\n\n            # print figure to pgf and compile it with latex\n            self.print_pgf(fname_pgf, *args, **kwargs)\n\n            latex_preamble = get_preamble()\n            latex_fontspec = get_fontspec()\n            latexcode = \"\"\"\n\\\\documentclass[12pt]{minimal}\n\\\\usepackage[paperwidth=%fin, paperheight=%fin, margin=0in]{geometry}\n%s\n%s\n\\\\usepackage{pgf}\n\n\\\\begin{document}\n\\\\centering\n\\\\input{figure.pgf}\n\\\\end{document}\"\"\" % (w, h, latex_preamble, latex_fontspec)\n            with codecs.open(fname_tex, \"w\", \"utf-8\") as fh_tex:\n                fh_tex.write(latexcode)\n\n            texcommand = get_texcommand()\n            cmdargs = [texcommand, \"-interaction=nonstopmode\",\n                       \"-halt-on-error\", \"figure.tex\"]\n            try:\n                check_output(cmdargs, stderr=subprocess.STDOUT, cwd=tmpdir)\n            except subprocess.CalledProcessError as e:\n                raise RuntimeError(\"%s was not able to process your file.\\n\\nFull log:\\n%s\" % (texcommand, e.output))\n\n            # copy file contents to target\n            with open(fname_pdf, \"rb\") as fh_src:\n                shutil.copyfileobj(fh_src, fh)\n        finally:\n            try:\n                shutil.rmtree(tmpdir)\n            except:\n                TmpDirCleaner.add(tmpdir)\n\n    def print_pdf(self, fname_or_fh, *args, **kwargs):\n        \"\"\"\n        Use LaTeX to compile a Pgf generated figure to PDF.\n        \"\"\"\n        if kwargs.get(\"dryrun\", False):\n            self._print_pgf_to_fh(None, *args, **kwargs)\n            return\n\n        # figure out where the pdf is to be written to\n        if is_string_like(fname_or_fh):\n            with open(fname_or_fh, \"wb\") as fh:\n                self._print_pdf_to_fh(fh, *args, **kwargs)\n        elif is_writable_file_like(fname_or_fh):\n            self._print_pdf_to_fh(fname_or_fh, *args, **kwargs)\n        else:\n            raise ValueError(\"filename must be a path or a file-like object\")\n\n    def _print_png_to_fh(self, fh, *args, **kwargs):\n        converter = make_pdf_to_png_converter()\n\n        try:\n            # create temporary directory for pdf creation and png conversion\n            tmpdir = tempfile.mkdtemp(prefix=\"mpl_pgf_\")\n            fname_pdf = os.path.join(tmpdir, \"figure.pdf\")\n            fname_png = os.path.join(tmpdir, \"figure.png\")\n            # create pdf and try to convert it to png\n            self.print_pdf(fname_pdf, *args, **kwargs)\n            converter(fname_pdf, fname_png, dpi=self.figure.dpi)\n            # copy file contents to target\n            with open(fname_png, \"rb\") as fh_src:\n                shutil.copyfileobj(fh_src, fh)\n        finally:\n            try:\n                shutil.rmtree(tmpdir)\n            except:\n                TmpDirCleaner.add(tmpdir)\n\n    def print_png(self, fname_or_fh, *args, **kwargs):\n        \"\"\"\n        Use LaTeX to compile a pgf figure to pdf and convert it to png.\n        \"\"\"\n        if kwargs.get(\"dryrun\", False):\n            self._print_pgf_to_fh(None, *args, **kwargs)\n            return\n\n        if is_string_like(fname_or_fh):\n            with open(fname_or_fh, \"wb\") as fh:\n                self._print_png_to_fh(fh, *args, **kwargs)\n        elif is_writable_file_like(fname_or_fh):\n            self._print_png_to_fh(fname_or_fh, *args, **kwargs)\n        else:\n            raise ValueError(\"filename must be a path or a file-like object\")\n\n    def get_renderer(self):\n        return RendererPgf(self.figure, None, dummy=True)\n\n\nclass FigureManagerPgf(FigureManagerBase):\n    def __init__(self, *args):\n        FigureManagerBase.__init__(self, *args)\n\n\nFigureCanvas = FigureCanvasPgf\nFigureManager = FigureManagerPgf\n\n\ndef _cleanup_all():\n    LatexManager._cleanup_remaining_instances()\n    TmpDirCleaner.cleanup_remaining_tmpdirs()\n\natexit.register(_cleanup_all)\n", "patch": "@@ -14,6 +14,8 @@\n import weakref\n import warnings\n \n+import numpy as np\n+\n import matplotlib as mpl\n from matplotlib.backend_bases import RendererBase, GraphicsContextBase,\\\n     FigureManagerBase, FigureCanvasBase\n@@ -619,9 +621,7 @@ def draw_image(self, gc, x, y, im):\n         fname = os.path.splitext(os.path.basename(self.fh.name))[0]\n         fname_img = \"%s-img%d.png\" % (fname, self.image_counter)\n         self.image_counter += 1\n-        im.flipud_out()\n-        rows, cols, buf = im.as_rgba_str()\n-        _png.write_png(buf, cols, rows, os.path.join(path, fname_img))\n+        _png.write_png(np.array(im)[::-1], os.path.join(path, fname_img))\n \n         # reference the image in the pgf picture\n         writeln(self.fh, r\"\\begin{pgfscope}\")"}
{"patches_id": 2, "files_id": 14, "language": "py", "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Fbackends%2Fbackend_ps.py", "raw_code": "\"\"\"\nA PostScript backend, which can produce both PostScript .ps and .eps\n\"\"\"\n\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport six\nfrom six.moves import StringIO\n\nimport glob, math, os, shutil, sys, time\ndef _fn_name(): return sys._getframe(1).f_code.co_name\nimport io\n\ntry:\n    from hashlib import md5\nexcept ImportError:\n    from md5 import md5 #Deprecated in 2.5\n\nfrom tempfile import mkstemp\nfrom matplotlib import verbose, __version__, rcParams, checkdep_ghostscript\nfrom matplotlib._pylab_helpers import Gcf\nfrom matplotlib.afm import AFM\nfrom matplotlib.backend_bases import RendererBase, GraphicsContextBase,\\\n     FigureManagerBase, FigureCanvasBase\n\nfrom matplotlib.cbook import is_string_like, get_realpath_and_stat, \\\n    is_writable_file_like, maxdict, file_requires_unicode\nfrom matplotlib.mlab import quad2cubic\nfrom matplotlib.figure import Figure\n\nfrom matplotlib.font_manager import findfont, is_opentype_cff_font\nfrom matplotlib.ft2font import FT2Font, KERNING_DEFAULT, LOAD_NO_HINTING\nfrom matplotlib.ttconv import convert_ttf_to_ps\nfrom matplotlib.mathtext import MathTextParser\nfrom matplotlib._mathtext_data import uni2type1\nfrom matplotlib.text import Text\nfrom matplotlib.path import Path\nfrom matplotlib.transforms import Affine2D\n\nfrom matplotlib.backends.backend_mixed import MixedModeRenderer\n\n\nimport numpy as np\nimport binascii\nimport re\ntry:\n    set\nexcept NameError:\n    from sets import Set as set\n\nif sys.platform.startswith('win'): cmd_split = '&'\nelse: cmd_split = ';'\n\nbackend_version = 'Level II'\n\ndebugPS = 0\n\n\nclass PsBackendHelper(object):\n\n    def __init__(self):\n        self._cached = {}\n\n    @property\n    def gs_exe(self):\n        \"\"\"\n        excutable name of ghostscript.\n        \"\"\"\n        try:\n            return self._cached[\"gs_exe\"]\n        except KeyError:\n            pass\n\n        gs_exe, gs_version = checkdep_ghostscript()\n        if gs_exe is None:\n            gs_exe = 'gs'\n\n        self._cached[\"gs_exe\"] = gs_exe\n        return gs_exe\n\n    @property\n    def gs_version(self):\n        \"\"\"\n        version of ghostscript.\n        \"\"\"\n        try:\n            return self._cached[\"gs_version\"]\n        except KeyError:\n            pass\n\n        from matplotlib.compat.subprocess import Popen, PIPE\n        s = Popen(self.gs_exe + \" --version\",\n                     shell=True, stdout=PIPE)\n        pipe, stderr = s.communicate()\n        if six.PY3:\n            ver = pipe.decode('ascii')\n        else:\n            ver = pipe\n        try:\n            gs_version = tuple(map(int, ver.strip().split(\".\")))\n        except ValueError:\n            # if something went wrong parsing return null version number\n            gs_version = (0, 0)\n        self._cached[\"gs_version\"] = gs_version\n        return gs_version\n\n    @property\n    def supports_ps2write(self):\n        \"\"\"\n        True if the installed ghostscript supports ps2write device.\n        \"\"\"\n        return self.gs_version[0] >= 9\n\nps_backend_helper = PsBackendHelper()\n\npapersize = {'letter': (8.5,11),\n             'legal': (8.5,14),\n             'ledger': (11,17),\n             'a0': (33.11,46.81),\n             'a1': (23.39,33.11),\n             'a2': (16.54,23.39),\n             'a3': (11.69,16.54),\n             'a4': (8.27,11.69),\n             'a5': (5.83,8.27),\n             'a6': (4.13,5.83),\n             'a7': (2.91,4.13),\n             'a8': (2.07,2.91),\n             'a9': (1.457,2.05),\n             'a10': (1.02,1.457),\n             'b0': (40.55,57.32),\n             'b1': (28.66,40.55),\n             'b2': (20.27,28.66),\n             'b3': (14.33,20.27),\n             'b4': (10.11,14.33),\n             'b5': (7.16,10.11),\n             'b6': (5.04,7.16),\n             'b7': (3.58,5.04),\n             'b8': (2.51,3.58),\n             'b9': (1.76,2.51),\n             'b10': (1.26,1.76)}\n\ndef _get_papertype(w, h):\n    keys = list(six.iterkeys(papersize))\n    keys.sort()\n    keys.reverse()\n    for key in keys:\n        if key.startswith('l'): continue\n        pw, ph = papersize[key]\n        if (w < pw) and (h < ph): return key\n    else:\n        return 'a0'\n\ndef _num_to_str(val):\n    if is_string_like(val): return val\n\n    ival = int(val)\n    if val==ival: return str(ival)\n\n    s = \"%1.3f\"%val\n    s = s.rstrip(\"0\")\n    s = s.rstrip(\".\")\n    return s\n\ndef _nums_to_str(*args):\n    return ' '.join(map(_num_to_str,args))\n\ndef quote_ps_string(s):\n    \"Quote dangerous characters of S for use in a PostScript string constant.\"\n    s=s.replace(\"\\\\\", \"\\\\\\\\\")\n    s=s.replace(\"(\", \"\\\\(\")\n    s=s.replace(\")\", \"\\\\)\")\n    s=s.replace(\"'\", \"\\\\251\")\n    s=s.replace(\"`\", \"\\\\301\")\n    s=re.sub(r\"[^ -~\\n]\", lambda x: r\"\\%03o\"%ord(x.group()), s)\n    return s\n\n\ndef seq_allequal(seq1, seq2):\n    \"\"\"\n    seq1 and seq2 are either None or sequences or arrays\n    Return True if both are None or both are seqs with identical\n    elements\n    \"\"\"\n    if seq1 is None:\n        return seq2 is None\n\n    if seq2 is None:\n        return False\n    #ok, neither are None:, assuming iterable\n\n    if len(seq1) != len(seq2): return False\n    return np.alltrue(np.equal(seq1, seq2))\n\n\nclass RendererPS(RendererBase):\n    \"\"\"\n    The renderer handles all the drawing primitives using a graphics\n    context instance that controls the colors/styles.\n    \"\"\"\n\n    fontd = maxdict(50)\n    afmfontd = maxdict(50)\n\n    def __init__(self, width, height, pswriter, imagedpi=72):\n        \"\"\"\n        Although postscript itself is dpi independent, we need to\n        imform the image code about a requested dpi to generate high\n        res images and them scale them before embeddin them\n        \"\"\"\n        RendererBase.__init__(self)\n        self.width = width\n        self.height = height\n        self._pswriter = pswriter\n        if rcParams['text.usetex']:\n            self.textcnt = 0\n            self.psfrag = []\n        self.imagedpi = imagedpi\n\n        # current renderer state (None=uninitialised)\n        self.color = None\n        self.linewidth = None\n        self.linejoin = None\n        self.linecap = None\n        self.linedash = None\n        self.fontname = None\n        self.fontsize = None\n        self._hatches = {}\n        self.image_magnification = imagedpi/72.0\n        self._clip_paths = {}\n        self._path_collection_id = 0\n\n        self.used_characters = {}\n        self.mathtext_parser = MathTextParser(\"PS\")\n\n        self._afm_font_dir = os.path.join(\n            rcParams['datapath'], 'fonts', 'afm')\n\n    def track_characters(self, font, s):\n        \"\"\"Keeps track of which characters are required from\n        each font.\"\"\"\n        realpath, stat_key = get_realpath_and_stat(font.fname)\n        used_characters = self.used_characters.setdefault(\n            stat_key, (realpath, set()))\n        used_characters[1].update([ord(x) for x in s])\n\n    def merge_used_characters(self, other):\n        for stat_key, (realpath, charset) in six.iteritems(other):\n            used_characters = self.used_characters.setdefault(\n                stat_key, (realpath, set()))\n            used_characters[1].update(charset)\n\n    def set_color(self, r, g, b, store=1):\n        if (r,g,b) != self.color:\n            if r==g and r==b:\n                self._pswriter.write(\"%1.3f setgray\\n\"%r)\n            else:\n                self._pswriter.write(\"%1.3f %1.3f %1.3f setrgbcolor\\n\"%(r,g,b))\n            if store: self.color = (r,g,b)\n\n    def set_linewidth(self, linewidth, store=1):\n        if linewidth != self.linewidth:\n            self._pswriter.write(\"%1.3f setlinewidth\\n\"%linewidth)\n            if store: self.linewidth = linewidth\n\n    def set_linejoin(self, linejoin, store=1):\n        if linejoin != self.linejoin:\n            self._pswriter.write(\"%d setlinejoin\\n\"%linejoin)\n            if store: self.linejoin = linejoin\n\n    def set_linecap(self, linecap, store=1):\n        if linecap != self.linecap:\n            self._pswriter.write(\"%d setlinecap\\n\"%linecap)\n            if store: self.linecap = linecap\n\n    def set_linedash(self, offset, seq, store=1):\n        if self.linedash is not None:\n            oldo, oldseq = self.linedash\n            if seq_allequal(seq, oldseq): return\n\n        if seq is not None and len(seq):\n            s=\"[%s] %d setdash\\n\"%(_nums_to_str(*seq), offset)\n            self._pswriter.write(s)\n        else:\n            self._pswriter.write(\"[] 0 setdash\\n\")\n        if store: self.linedash = (offset,seq)\n\n    def set_font(self, fontname, fontsize, store=1):\n        if rcParams['ps.useafm']: return\n        if (fontname,fontsize) != (self.fontname,self.fontsize):\n            out = (\"/%s findfont\\n\"\n                   \"%1.3f scalefont\\n\"\n                   \"setfont\\n\" % (fontname, fontsize))\n\n            self._pswriter.write(out)\n            if store: self.fontname = fontname\n            if store: self.fontsize = fontsize\n\n    def create_hatch(self, hatch):\n        sidelen = 72\n        if hatch in self._hatches:\n            return self._hatches[hatch]\n        name = 'H%d' % len(self._hatches)\n        self._pswriter.write(\"\"\"\\\n  << /PatternType 1\n     /PaintType 2\n     /TilingType 2\n     /BBox[0 0 %(sidelen)d %(sidelen)d]\n     /XStep %(sidelen)d\n     /YStep %(sidelen)d\n\n     /PaintProc {\n        pop\n        0 setlinewidth\n\"\"\" % locals())\n        self._pswriter.write(\n            self._convert_path(Path.hatch(hatch), Affine2D().scale(72.0),\n                               simplify=False))\n        self._pswriter.write(\"\"\"\\\n          stroke\n     } bind\n   >>\n   matrix\n   makepattern\n   /%(name)s exch def\n\"\"\" % locals())\n        self._hatches[hatch] = name\n        return name\n\n    def get_canvas_width_height(self):\n        'return the canvas width and height in display coords'\n        return self.width, self.height\n\n    def get_text_width_height_descent(self, s, prop, ismath):\n        \"\"\"\n        get the width and height in display coords of the string s\n        with FontPropertry prop\n\n        \"\"\"\n        if rcParams['text.usetex']:\n            texmanager = self.get_texmanager()\n            fontsize = prop.get_size_in_points()\n            w, h, d = texmanager.get_text_width_height_descent(s, fontsize,\n                                                               renderer=self)\n            return w, h, d\n\n        if ismath:\n            width, height, descent, pswriter, used_characters = \\\n                self.mathtext_parser.parse(s, 72, prop)\n            return width, height, descent\n\n        if rcParams['ps.useafm']:\n            if ismath: s = s[1:-1]\n            font = self._get_font_afm(prop)\n            l,b,w,h,d = font.get_str_bbox_and_descent(s)\n\n            fontsize = prop.get_size_in_points()\n            scale = 0.001*fontsize\n            w *= scale\n            h *= scale\n            d *= scale\n            return w, h, d\n\n        font = self._get_font_ttf(prop)\n        font.set_text(s, 0.0, flags=LOAD_NO_HINTING)\n        w, h = font.get_width_height()\n        w /= 64.0  # convert from subpixels\n        h /= 64.0\n        d = font.get_descent()\n        d /= 64.0\n        #print s, w, h\n        return w, h, d\n\n    def flipy(self):\n        'return true if small y numbers are top for renderer'\n        return False\n\n    def _get_font_afm(self, prop):\n        key = hash(prop)\n        font = self.afmfontd.get(key)\n        if font is None:\n            fname = findfont(prop, fontext='afm', directory=self._afm_font_dir)\n            if fname is None:\n                fname = findfont(\n                    \"Helvetica\", fontext='afm', directory=self._afm_font_dir)\n            font = self.afmfontd.get(fname)\n            if font is None:\n                with io.open(fname, 'rb') as fh:\n                    font = AFM(fh)\n                self.afmfontd[fname] = font\n            self.afmfontd[key] = font\n        return font\n\n    def _get_font_ttf(self, prop):\n        key = hash(prop)\n        font = self.fontd.get(key)\n        if font is None:\n            fname = findfont(prop)\n            font = self.fontd.get(fname)\n            if font is None:\n                font = FT2Font(fname)\n                self.fontd[fname] = font\n            self.fontd[key] = font\n        font.clear()\n        size = prop.get_size_in_points()\n        font.set_size(size, 72.0)\n        return font\n\n    def _rgba(self, im):\n        return im.as_rgba_str()\n\n    def _rgb(self, im):\n        h,w,s = im.as_rgba_str()\n\n        rgba = np.fromstring(s, np.uint8)\n        rgba.shape = (h, w, 4)\n        rgb = rgba[::-1,:,:3]\n        return h, w, rgb.tostring()\n\n    def _gray(self, im, rc=0.3, gc=0.59, bc=0.11):\n        rgbat = im.as_rgba_str()\n        rgba = np.fromstring(rgbat[2], np.uint8)\n        rgba.shape = (rgbat[0], rgbat[1], 4)\n        rgba = rgba[::-1]\n        rgba_f = rgba.astype(np.float32)\n        r = rgba_f[:,:,0]\n        g = rgba_f[:,:,1]\n        b = rgba_f[:,:,2]\n        gray = (r*rc + g*gc + b*bc).astype(np.uint8)\n        return rgbat[0], rgbat[1], gray.tostring()\n\n    def _hex_lines(self, s, chars_per_line=128):\n        s = binascii.b2a_hex(s)\n        nhex = len(s)\n        lines = []\n        for i in range(0,nhex,chars_per_line):\n            limit = min(i+chars_per_line, nhex)\n            lines.append(s[i:limit])\n        return lines\n\n    def get_image_magnification(self):\n        \"\"\"\n        Get the factor by which to magnify images passed to draw_image.\n        Allows a backend to have images at a different resolution to other\n        artists.\n        \"\"\"\n        return self.image_magnification\n\n    def option_scale_image(self):\n        \"\"\"\n        ps backend support arbitrary scaling of image.\n        \"\"\"\n        return True\n\n    def _get_image_h_w_bits_command(self, im):\n        if im.is_grayscale:\n            h, w, bits = self._gray(im)\n            imagecmd = \"image\"\n        else:\n            h, w, bits = self._rgb(im)\n            imagecmd = \"false 3 colorimage\"\n\n        return h, w, bits, imagecmd\n\n    def draw_image(self, gc, x, y, im, dx=None, dy=None, transform=None):\n        \"\"\"\n        Draw the Image instance into the current axes; x is the\n        distance in pixels from the left hand side of the canvas and y\n        is the distance from bottom\n\n        dx, dy is the width and height of the image.  If a transform\n        (which must be an affine transform) is given, x, y, dx, dy are\n        interpreted as the coordinate of the transform.\n        \"\"\"\n\n        h, w, bits, imagecmd = self._get_image_h_w_bits_command(im)\n        hexlines = b'\\n'.join(self._hex_lines(bits)).decode('ascii')\n\n        if dx is None:\n            xscale = w / self.image_magnification\n        else:\n            xscale = dx\n\n        if dy is None:\n            yscale = h/self.image_magnification\n        else:\n            yscale = dy\n\n\n        if transform is None:\n            matrix = \"1 0 0 1 0 0\"\n        else:\n            matrix = \" \".join(map(str, transform.to_values()))\n\n        figh = self.height*72\n        #print 'values', origin, flipud, figh, h, y\n\n        bbox = gc.get_clip_rectangle()\n        clippath, clippath_trans = gc.get_clip_path()\n\n        clip = []\n        if bbox is not None:\n            clipx,clipy,clipw,cliph = bbox.bounds\n            clip.append('%s clipbox' % _nums_to_str(clipw, cliph, clipx, clipy))\n        if clippath is not None:\n            id = self._get_clip_path(clippath, clippath_trans)\n            clip.append('%s' % id)\n        clip = '\\n'.join(clip)\n\n        #y = figh-(y+h)\n        ps = \"\"\"gsave\n%(clip)s\n[%(matrix)s] concat\n%(x)s %(y)s translate\n%(xscale)s %(yscale)s scale\n/DataString %(w)s string def\n%(w)s %(h)s 8 [ %(w)s 0 0 -%(h)s 0 %(h)s ]\n{\ncurrentfile DataString readhexstring pop\n} bind %(imagecmd)s\n%(hexlines)s\ngrestore\n\"\"\" % locals()\n        self._pswriter.write(ps)\n\n    def _convert_path(self, path, transform, clip=False, simplify=None):\n        ps = []\n        last_points = None\n        if clip:\n            clip = (0.0, 0.0, self.width * 72.0,\n                    self.height * 72.0)\n        else:\n            clip = None\n        for points, code in path.iter_segments(transform, clip=clip,\n                                               simplify=simplify):\n            if code == Path.MOVETO:\n                ps.append(\"%g %g m\" % tuple(points))\n            elif code == Path.CLOSEPOLY:\n                ps.append(\"cl\")\n            elif last_points is None:\n                # The other operations require a previous point\n                raise ValueError('Path lacks initial MOVETO')\n            elif code == Path.LINETO:\n                ps.append(\"%g %g l\" % tuple(points))\n            elif code == Path.CURVE3:\n                points = quad2cubic(*(list(last_points[-2:]) + list(points)))\n                ps.append(\"%g %g %g %g %g %g c\" %\n                          tuple(points[2:]))\n            elif code == Path.CURVE4:\n                ps.append(\"%g %g %g %g %g %g c\" % tuple(points))\n            last_points = points\n\n        ps = \"\\n\".join(ps)\n        return ps\n\n    def _get_clip_path(self, clippath, clippath_transform):\n        key = (clippath, id(clippath_transform))\n        pid = self._clip_paths.get(key)\n        if pid is None:\n            pid = 'c%x' % len(self._clip_paths)\n            ps_cmd = ['/%s {' % pid]\n            ps_cmd.append(self._convert_path(clippath, clippath_transform,\n                                             simplify=False))\n            ps_cmd.extend(['clip', 'newpath', '} bind def\\n'])\n            self._pswriter.write('\\n'.join(ps_cmd))\n            self._clip_paths[key] = pid\n        return pid\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        \"\"\"\n        Draws a Path instance using the given affine transform.\n        \"\"\"\n        clip = (rgbFace is None and gc.get_hatch_path() is None)\n        simplify = path.should_simplify and clip\n        ps = self._convert_path(\n            path, transform, clip=clip, simplify=simplify)\n        self._draw_ps(ps, gc, rgbFace)\n\n    def draw_markers(self, gc, marker_path, marker_trans, path, trans, rgbFace=None):\n        \"\"\"\n        Draw the markers defined by path at each of the positions in x\n        and y.  path coordinates are points, x and y coords will be\n        transformed by the transform\n        \"\"\"\n        if debugPS: self._pswriter.write('% draw_markers \\n')\n\n        write = self._pswriter.write\n\n        if rgbFace:\n            if rgbFace[0]==rgbFace[1] and rgbFace[0]==rgbFace[2]:\n                ps_color = '%1.3f setgray' % rgbFace[0]\n            else:\n                ps_color = '%1.3f %1.3f %1.3f setrgbcolor' % rgbFace[:3]\n\n        # construct the generic marker command:\n        ps_cmd = ['/o {', 'gsave', 'newpath', 'translate'] # dont want the translate to be global\n\n        lw = gc.get_linewidth()\n        stroke = lw != 0.0\n        if stroke:\n            ps_cmd.append('%.1f setlinewidth' % lw)\n            jint = gc.get_joinstyle()\n            ps_cmd.append('%d setlinejoin' % jint)\n            cint = gc.get_capstyle()\n            ps_cmd.append('%d setlinecap' % cint)\n\n        ps_cmd.append(self._convert_path(marker_path, marker_trans,\n                                         simplify=False))\n\n        if rgbFace:\n            if stroke:\n                ps_cmd.append('gsave')\n            ps_cmd.extend([ps_color, 'fill'])\n            if stroke:\n                ps_cmd.append('grestore')\n\n        if stroke:\n            ps_cmd.append('stroke')\n        ps_cmd.extend(['grestore', '} bind def'])\n\n        for vertices, code in path.iter_segments(\n                trans,\n                clip=(0, 0, self.width*72, self.height*72),\n                simplify=False):\n            if len(vertices):\n                x, y = vertices[-2:]\n                ps_cmd.append(\"%g %g o\" % (x, y))\n\n        ps = '\\n'.join(ps_cmd)\n        self._draw_ps(ps, gc, rgbFace, fill=False, stroke=False)\n\n    def draw_path_collection(self, gc, master_transform, paths, all_transforms,\n                             offsets, offsetTrans, facecolors, edgecolors,\n                             linewidths, linestyles, antialiaseds, urls,\n                             offset_position):\n        write = self._pswriter.write\n\n        path_codes = []\n        for i, (path, transform) in enumerate(self._iter_collection_raw_paths(\n            master_transform, paths, all_transforms)):\n            name = 'p%x_%x' % (self._path_collection_id, i)\n            ps_cmd = ['/%s {' % name,\n                      'newpath', 'translate']\n            ps_cmd.append(self._convert_path(path, transform, simplify=False))\n            ps_cmd.extend(['} bind def\\n'])\n            write('\\n'.join(ps_cmd))\n            path_codes.append(name)\n\n        for xo, yo, path_id, gc0, rgbFace in self._iter_collection(\n            gc, master_transform, all_transforms, path_codes, offsets,\n            offsetTrans, facecolors, edgecolors, linewidths, linestyles,\n            antialiaseds, urls, offset_position):\n            ps = \"%g %g %s\" % (xo, yo, path_id)\n            self._draw_ps(ps, gc0, rgbFace)\n\n        self._path_collection_id += 1\n\n    def draw_tex(self, gc, x, y, s, prop, angle, ismath='TeX!', mtext=None):\n        \"\"\"\n        draw a Text instance\n        \"\"\"\n        w, h, bl = self.get_text_width_height_descent(s, prop, ismath)\n        fontsize = prop.get_size_in_points()\n        thetext = 'psmarker%d' % self.textcnt\n        color = '%1.3f,%1.3f,%1.3f'% gc.get_rgb()[:3]\n        fontcmd = {'sans-serif' : r'{\\sffamily %s}',\n               'monospace'  : r'{\\ttfamily %s}'}.get(\n                rcParams['font.family'][0], r'{\\rmfamily %s}')\n        s = fontcmd % s\n        tex = r'\\color[rgb]{%s} %s' % (color, s)\n\n        corr = 0#w/2*(fontsize-10)/10\n        if rcParams['text.latex.preview']:\n            # use baseline alignment!\n            pos = _nums_to_str(x-corr, y)\n            self.psfrag.append(r'\\psfrag{%s}[Bl][Bl][1][%f]{\\fontsize{%f}{%f}%s}'%(thetext, angle, fontsize, fontsize*1.25, tex))\n        else:\n            # stick to the bottom alignment, but this may give incorrect baseline some times.\n            pos = _nums_to_str(x-corr, y-bl)\n            self.psfrag.append(r'\\psfrag{%s}[bl][bl][1][%f]{\\fontsize{%f}{%f}%s}'%(thetext, angle, fontsize, fontsize*1.25, tex))\n\n        ps = \"\"\"\\\ngsave\n%(pos)s moveto\n(%(thetext)s)\nshow\ngrestore\n    \"\"\" % locals()\n\n        self._pswriter.write(ps)\n        self.textcnt += 1\n\n    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        \"\"\"\n        draw a Text instance\n        \"\"\"\n        # local to avoid repeated attribute lookups\n        write = self._pswriter.write\n        if debugPS:\n            write(\"% text\\n\")\n\n        if ismath=='TeX':\n            return self.tex(gc, x, y, s, prop, angle)\n\n        elif ismath:\n            return self.draw_mathtext(gc, x, y, s, prop, angle)\n\n        elif rcParams['ps.useafm']:\n            self.set_color(*gc.get_rgb())\n\n            font = self._get_font_afm(prop)\n            fontname = font.get_fontname()\n            fontsize = prop.get_size_in_points()\n            scale = 0.001*fontsize\n\n            thisx = 0\n            thisy = font.get_str_bbox_and_descent(s)[4] * scale\n            last_name = None\n            lines = []\n            for c in s:\n                name = uni2type1.get(ord(c), 'question')\n                try:\n                    width = font.get_width_from_char_name(name)\n                except KeyError:\n                    name = 'question'\n                    width = font.get_width_char('?')\n                if last_name is not None:\n                    kern = font.get_kern_dist_from_name(last_name, name)\n                else:\n                    kern = 0\n                last_name = name\n                thisx += kern * scale\n\n                lines.append('%f %f m /%s glyphshow'%(thisx, thisy, name))\n\n                thisx += width * scale\n\n            thetext = \"\\n\".join(lines)\n            ps = \"\"\"\\\ngsave\n/%(fontname)s findfont\n%(fontsize)s scalefont\nsetfont\n%(x)f %(y)f translate\n%(angle)f rotate\n%(thetext)s\ngrestore\n    \"\"\" % locals()\n            self._pswriter.write(ps)\n\n        else:\n            font = self._get_font_ttf(prop)\n            font.set_text(s, 0, flags=LOAD_NO_HINTING)\n            self.track_characters(font, s)\n\n            self.set_color(*gc.get_rgb())\n            sfnt = font.get_sfnt()\n            try:\n                ps_name = sfnt[(1,0,0,6)].decode('macroman')\n            except KeyError:\n                ps_name = sfnt[(3,1,0x0409,6)].decode(\n                    'utf-16be')\n            ps_name = ps_name.encode('ascii', 'replace').decode('ascii')\n            self.set_font(ps_name, prop.get_size_in_points())\n\n            cmap = font.get_charmap()\n            lastgind = None\n            #print 'text', s\n            lines = []\n            thisx = 0\n            thisy = 0\n            for c in s:\n                ccode = ord(c)\n                gind = cmap.get(ccode)\n                if gind is None:\n                    ccode = ord('?')\n                    name = '.notdef'\n                    gind = 0\n                else:\n                    name = font.get_glyph_name(gind)\n                glyph = font.load_char(ccode, flags=LOAD_NO_HINTING)\n\n                if lastgind is not None:\n                    kern = font.get_kerning(lastgind, gind, KERNING_DEFAULT)\n                else:\n                    kern = 0\n                lastgind = gind\n                thisx += kern/64.0\n\n                lines.append('%f %f m /%s glyphshow'%(thisx, thisy, name))\n                thisx += glyph.linearHoriAdvance/65536.0\n\n\n            thetext = '\\n'.join(lines)\n            ps = \"\"\"gsave\n%(x)f %(y)f translate\n%(angle)f rotate\n%(thetext)s\ngrestore\n\"\"\" % locals()\n            self._pswriter.write(ps)\n\n    def new_gc(self):\n        return GraphicsContextPS()\n\n    def draw_mathtext(self, gc,\n        x, y, s, prop, angle):\n        \"\"\"\n        Draw the math text using matplotlib.mathtext\n        \"\"\"\n        if debugPS:\n            self._pswriter.write(\"% mathtext\\n\")\n\n        width, height, descent, pswriter, used_characters = \\\n            self.mathtext_parser.parse(s, 72, prop)\n        self.merge_used_characters(used_characters)\n        self.set_color(*gc.get_rgb())\n        thetext = pswriter.getvalue()\n        ps = \"\"\"gsave\n%(x)f %(y)f translate\n%(angle)f rotate\n%(thetext)s\ngrestore\n\"\"\" % locals()\n        self._pswriter.write(ps)\n\n    def draw_gouraud_triangle(self, gc, points, colors, trans):\n        self.draw_gouraud_triangles(gc, points.reshape((1, 3, 2)),\n                                    colors.reshape((1, 3, 4)), trans)\n\n    def draw_gouraud_triangles(self, gc, points, colors, trans):\n        assert len(points) == len(colors)\n        assert points.ndim == 3\n        assert points.shape[1] == 3\n        assert points.shape[2] == 2\n        assert colors.ndim == 3\n        assert colors.shape[1] == 3\n        assert colors.shape[2] == 4\n\n        shape = points.shape\n        flat_points = points.reshape((shape[0] * shape[1], 2))\n        flat_points = trans.transform(flat_points)\n        flat_colors = colors.reshape((shape[0] * shape[1], 4))\n        points_min = np.min(flat_points, axis=0) - (1 << 12)\n        points_max = np.max(flat_points, axis=0) + (1 << 12)\n        factor = np.ceil(float(2 ** 32 - 1) / (points_max - points_min))\n\n        xmin, ymin = points_min\n        xmax, ymax = points_max\n\n        streamarr = np.empty(\n            (shape[0] * shape[1],),\n            dtype=[('flags', 'u1'),\n                   ('points', '>u4', (2,)),\n                   ('colors', 'u1', (3,))])\n        streamarr['flags'] = 0\n        streamarr['points'] = (flat_points - points_min) * factor\n        streamarr['colors'] = flat_colors[:, :3] * 255.0\n\n        stream = quote_ps_string(streamarr.tostring())\n\n        self._pswriter.write(\"\"\"\ngsave\n<< /ShadingType 4\n   /ColorSpace [/DeviceRGB]\n   /BitsPerCoordinate 32\n   /BitsPerComponent 8\n   /BitsPerFlag 8\n   /AntiAlias true\n   /Decode [ %(xmin)f %(xmax)f %(ymin)f %(ymax)f 0 1 0 1 0 1 ]\n   /DataSource (%(stream)s)\n>>\nshfill\ngrestore\n\"\"\" % locals())\n\n    def _draw_ps(self, ps, gc, rgbFace, fill=True, stroke=True, command=None):\n        \"\"\"\n        Emit the PostScript sniplet 'ps' with all the attributes from 'gc'\n        applied.  'ps' must consist of PostScript commands to construct a path.\n\n        The fill and/or stroke kwargs can be set to False if the\n        'ps' string already includes filling and/or stroking, in\n        which case _draw_ps is just supplying properties and\n        clipping.\n        \"\"\"\n        # local variable eliminates all repeated attribute lookups\n        write = self._pswriter.write\n        if debugPS and command:\n            write(\"% \"+command+\"\\n\")\n        mightstroke = gc.shouldstroke()\n        stroke = stroke and mightstroke\n        fill = (fill and rgbFace is not None and\n                (len(rgbFace) <= 3 or rgbFace[3] != 0.0))\n\n        if mightstroke:\n            self.set_linewidth(gc.get_linewidth())\n            jint = gc.get_joinstyle()\n            self.set_linejoin(jint)\n            cint = gc.get_capstyle()\n            self.set_linecap(cint)\n            self.set_linedash(*gc.get_dashes())\n            self.set_color(*gc.get_rgb()[:3])\n        write('gsave\\n')\n\n        cliprect = gc.get_clip_rectangle()\n        if cliprect:\n            x,y,w,h=cliprect.bounds\n            write('%1.4g %1.4g %1.4g %1.4g clipbox\\n' % (w,h,x,y))\n        clippath, clippath_trans = gc.get_clip_path()\n        if clippath:\n            id = self._get_clip_path(clippath, clippath_trans)\n            write('%s\\n' % id)\n\n        # Jochen, is the strip necessary? - this could be a honking big string\n        write(ps.strip())\n        write(\"\\n\")\n\n        if fill:\n            if stroke:\n                write(\"gsave\\n\")\n            self.set_color(store=0, *rgbFace[:3])\n            write(\"fill\\n\")\n            if stroke:\n                write(\"grestore\\n\")\n\n        hatch = gc.get_hatch()\n        if hatch:\n            hatch_name = self.create_hatch(hatch)\n            write(\"gsave\\n\")\n            write(\"[/Pattern [/DeviceRGB]] setcolorspace %f %f %f \" % gc.get_rgb()[:3])\n            write(\"%s setcolor fill grestore\\n\" % hatch_name)\n\n        if stroke:\n            write(\"stroke\\n\")\n\n        write(\"grestore\\n\")\n\n\n\nclass GraphicsContextPS(GraphicsContextBase):\n    def get_capstyle(self):\n        return {'butt':0,\n                'round':1,\n                'projecting':2}[GraphicsContextBase.get_capstyle(self)]\n\n    def get_joinstyle(self):\n        return {'miter':0,\n                'round':1,\n                'bevel':2}[GraphicsContextBase.get_joinstyle(self)]\n\n    def shouldstroke(self):\n        return (self.get_linewidth() > 0.0 and\n                (len(self.get_rgb()) <= 3 or self.get_rgb()[3] != 0.0))\n\ndef new_figure_manager(num, *args, **kwargs):\n    FigureClass = kwargs.pop('FigureClass', Figure)\n    thisFig = FigureClass(*args, **kwargs)\n    return new_figure_manager_given_figure(num, thisFig)\n\n\ndef new_figure_manager_given_figure(num, figure):\n    \"\"\"\n    Create a new figure manager instance for the given figure.\n    \"\"\"\n    canvas = FigureCanvasPS(figure)\n    manager = FigureManagerPS(canvas, num)\n    return manager\n\nclass FigureCanvasPS(FigureCanvasBase):\n    _renderer_class = RendererPS\n\n    fixed_dpi = 72\n\n    def draw(self):\n        pass\n\n    filetypes = {'ps'  : 'Postscript',\n                 'eps' : 'Encapsulated Postscript'}\n\n    def get_default_filetype(self):\n        return 'ps'\n\n    def print_ps(self, outfile, *args, **kwargs):\n        return self._print_ps(outfile, 'ps', *args, **kwargs)\n\n    def print_eps(self, outfile, *args, **kwargs):\n        return self._print_ps(outfile, 'eps', *args, **kwargs)\n\n    def _print_ps(self, outfile, format, *args, **kwargs):\n        papertype = kwargs.pop(\"papertype\", rcParams['ps.papersize'])\n        papertype = papertype.lower()\n        if papertype == 'auto':\n            pass\n        elif papertype not in papersize:\n            raise RuntimeError( '%s is not a valid papertype. Use one \\\n                    of %s'% (papertype, ', '.join(six.iterkeys(papersize))))\n\n        orientation = kwargs.pop(\"orientation\", \"portrait\").lower()\n        if orientation == 'landscape': isLandscape = True\n        elif orientation == 'portrait': isLandscape = False\n        else: raise RuntimeError('Orientation must be \"portrait\" or \"landscape\"')\n\n        self.figure.set_dpi(72) # Override the dpi kwarg\n        imagedpi = kwargs.pop(\"dpi\", 72)\n        facecolor = kwargs.pop(\"facecolor\", \"w\")\n        edgecolor = kwargs.pop(\"edgecolor\", \"w\")\n\n        if rcParams['text.usetex']:\n            self._print_figure_tex(outfile, format, imagedpi, facecolor, edgecolor,\n                                   orientation, isLandscape, papertype,\n                                   **kwargs)\n        else:\n            self._print_figure(outfile, format, imagedpi, facecolor, edgecolor,\n                               orientation, isLandscape, papertype,\n                               **kwargs)\n\n    def _print_figure(self, outfile, format, dpi=72, facecolor='w', edgecolor='w',\n                      orientation='portrait', isLandscape=False, papertype=None,\n                      **kwargs):\n        \"\"\"\n        Render the figure to hardcopy.  Set the figure patch face and\n        edge colors.  This is useful because some of the GUIs have a\n        gray figure face color background and you'll probably want to\n        override this on hardcopy\n\n        If outfile is a string, it is interpreted as a file name.\n        If the extension matches .ep* write encapsulated postscript,\n        otherwise write a stand-alone PostScript file.\n\n        If outfile is a file object, a stand-alone PostScript file is\n        written into this file object.\n        \"\"\"\n        isEPSF = format == 'eps'\n        passed_in_file_object = False\n        if is_string_like(outfile):\n            title = outfile\n        elif is_writable_file_like(outfile):\n            title = None\n            passed_in_file_object = True\n        else:\n            raise ValueError(\"outfile must be a path or a file-like object\")\n\n        # find the appropriate papertype\n        width, height = self.figure.get_size_inches()\n        if papertype == 'auto':\n            if isLandscape: papertype = _get_papertype(height, width)\n            else: papertype = _get_papertype(width, height)\n\n        if isLandscape: paperHeight, paperWidth = papersize[papertype]\n        else: paperWidth, paperHeight = papersize[papertype]\n\n        if rcParams['ps.usedistiller'] and not papertype == 'auto':\n            # distillers will improperly clip eps files if the pagesize is\n            # too small\n            if width>paperWidth or height>paperHeight:\n                if isLandscape:\n                    papertype = _get_papertype(height, width)\n                    paperHeight, paperWidth = papersize[papertype]\n                else:\n                    papertype = _get_papertype(width, height)\n                    paperWidth, paperHeight = papersize[papertype]\n\n        # center the figure on the paper\n        xo = 72*0.5*(paperWidth - width)\n        yo = 72*0.5*(paperHeight - height)\n\n        l, b, w, h = self.figure.bbox.bounds\n        llx = xo\n        lly = yo\n        urx = llx + w\n        ury = lly + h\n        rotation = 0\n        if isLandscape:\n            llx, lly, urx, ury = lly, llx, ury, urx\n            xo, yo = 72*paperHeight - yo, xo\n            rotation = 90\n        bbox = (llx, lly, urx, ury)\n\n        # generate PostScript code for the figure and store it in a string\n        origfacecolor = self.figure.get_facecolor()\n        origedgecolor = self.figure.get_edgecolor()\n        self.figure.set_facecolor(facecolor)\n        self.figure.set_edgecolor(edgecolor)\n\n\n        dryrun = kwargs.get(\"dryrun\", False)\n        if dryrun:\n            class NullWriter(object):\n                def write(self, *kl, **kwargs):\n                    pass\n\n            self._pswriter = NullWriter()\n        else:\n            self._pswriter = io.StringIO()\n\n\n        # mixed mode rendering\n        _bbox_inches_restore = kwargs.pop(\"bbox_inches_restore\", None)\n        ps_renderer = self._renderer_class(width, height, self._pswriter,\n                                           imagedpi=dpi)\n        renderer = MixedModeRenderer(self.figure,\n            width, height, dpi, ps_renderer,\n            bbox_inches_restore=_bbox_inches_restore)\n\n        self.figure.draw(renderer)\n\n        if dryrun: # return immediately if dryrun (tightbbox=True)\n            return\n\n        self.figure.set_facecolor(origfacecolor)\n        self.figure.set_edgecolor(origedgecolor)\n\n        def print_figure_impl():\n            # write the PostScript headers\n            if isEPSF: print(\"%!PS-Adobe-3.0 EPSF-3.0\", file=fh)\n            else: print(\"%!PS-Adobe-3.0\", file=fh)\n            if title: print(\"%%Title: \"+title, file=fh)\n            print((\"%%Creator: matplotlib version \"\n                         +__version__+\", http://matplotlib.org/\"), file=fh)\n            print(\"%%CreationDate: \"+time.ctime(time.time()), file=fh)\n            print(\"%%Orientation: \" + orientation, file=fh)\n            if not isEPSF: print(\"%%DocumentPaperSizes: \"+papertype, file=fh)\n            print(\"%%%%BoundingBox: %d %d %d %d\" % bbox, file=fh)\n            if not isEPSF: print(\"%%Pages: 1\", file=fh)\n            print(\"%%EndComments\", file=fh)\n\n            Ndict = len(psDefs)\n            print(\"%%BeginProlog\", file=fh)\n            if not rcParams['ps.useafm']:\n                Ndict += len(ps_renderer.used_characters)\n            print(\"/mpldict %d dict def\"%Ndict, file=fh)\n            print(\"mpldict begin\", file=fh)\n            for d in psDefs:\n                d=d.strip()\n                for l in d.split('\\n'):\n                    print(l.strip(), file=fh)\n            if not rcParams['ps.useafm']:\n                for font_filename, chars in six.itervalues(ps_renderer.used_characters):\n                    if len(chars):\n                        font = FT2Font(font_filename)\n                        cmap = font.get_charmap()\n                        glyph_ids = []\n                        for c in chars:\n                            gind = cmap.get(c) or 0\n                            glyph_ids.append(gind)\n\n                        fonttype = rcParams['ps.fonttype']\n\n                        # Can not use more than 255 characters from a\n                        # single font for Type 3\n                        if len(glyph_ids) > 255:\n                            fonttype = 42\n\n                        # The ttf to ps (subsetting) support doesn't work for\n                        # OpenType fonts that are Postscript inside (like the\n                        # STIX fonts).  This will simply turn that off to avoid\n                        # errors.\n                        if is_opentype_cff_font(font_filename):\n                            raise RuntimeError(\"OpenType CFF fonts can not be saved using the internal Postscript backend at this time.\\nConsider using the Cairo backend.\")\n                        else:\n                            fh.flush()\n                            convert_ttf_to_ps(\n                                font_filename.encode(sys.getfilesystemencoding()),\n                                fh, fonttype, glyph_ids)\n            print(\"end\", file=fh)\n            print(\"%%EndProlog\", file=fh)\n\n            if not isEPSF: print(\"%%Page: 1 1\", file=fh)\n            print(\"mpldict begin\", file=fh)\n            #print >>fh, \"gsave\"\n            print(\"%s translate\"%_nums_to_str(xo, yo), file=fh)\n            if rotation: print(\"%d rotate\"%rotation, file=fh)\n            print(\"%s clipbox\"%_nums_to_str(width*72, height*72, 0, 0), file=fh)\n\n            # write the figure\n            content = self._pswriter.getvalue()\n            if not isinstance(content, six.text_type):\n                content = content.decode('ascii')\n            print(content, file=fh)\n\n            # write the trailer\n            #print >>fh, \"grestore\"\n            print(\"end\", file=fh)\n            print(\"showpage\", file=fh)\n            if not isEPSF: print(\"%%EOF\", file=fh)\n            fh.flush()\n\n        if rcParams['ps.usedistiller']:\n            # We are going to use an external program to process the output.\n            # Write to a temporary file.\n            fd, tmpfile = mkstemp()\n            with io.open(fd, 'w', encoding='latin-1') as fh:\n                print_figure_impl()\n        else:\n            # Write directly to outfile.\n            if passed_in_file_object:\n                requires_unicode = file_requires_unicode(outfile)\n\n                if (not requires_unicode and\n                    (six.PY3 or not isinstance(outfile, StringIO))):\n                    fh = io.TextIOWrapper(outfile, encoding=\"latin-1\")\n                    # Prevent the io.TextIOWrapper from closing the\n                    # underlying file\n                    def do_nothing():\n                        pass\n                    fh.close = do_nothing\n                else:\n                    fh = outfile\n\n                print_figure_impl()\n            else:\n                with io.open(outfile, 'w', encoding='latin-1') as fh:\n                    print_figure_impl()\n\n        if rcParams['ps.usedistiller']:\n            if rcParams['ps.usedistiller'] == 'ghostscript':\n                gs_distill(tmpfile, isEPSF, ptype=papertype, bbox=bbox)\n            elif rcParams['ps.usedistiller'] == 'xpdf':\n                xpdf_distill(tmpfile, isEPSF, ptype=papertype, bbox=bbox)\n\n            if passed_in_file_object:\n                if file_requires_unicode(outfile):\n                    with io.open(tmpfile, 'rb') as fh:\n                        outfile.write(fh.read().decode('latin-1'))\n                else:\n                    with io.open(tmpfile, 'rb') as fh:\n                        outfile.write(fh.read())\n            else:\n                with io.open(outfile, 'w') as fh:\n                    pass\n                mode = os.stat(outfile).st_mode\n                shutil.move(tmpfile, outfile)\n                os.chmod(outfile, mode)\n\n    def _print_figure_tex(self, outfile, format, dpi, facecolor, edgecolor,\n                          orientation, isLandscape, papertype,\n                          **kwargs):\n        \"\"\"\n        If text.usetex is True in rc, a temporary pair of tex/eps files\n        are created to allow tex to manage the text layout via the PSFrags\n        package. These files are processed to yield the final ps or eps file.\n        \"\"\"\n        isEPSF = format == 'eps'\n        if is_string_like(outfile):\n            title = outfile\n        elif is_writable_file_like(outfile):\n            title = None\n        else:\n            raise ValueError(\"outfile must be a path or a file-like object\")\n\n        self.figure.dpi = 72 # ignore the dpi kwarg\n        width, height = self.figure.get_size_inches()\n        xo = 0\n        yo = 0\n\n        l, b, w, h = self.figure.bbox.bounds\n        llx = xo\n        lly = yo\n        urx = llx + w\n        ury = lly + h\n        bbox = (llx, lly, urx, ury)\n\n        # generate PostScript code for the figure and store it in a string\n        origfacecolor = self.figure.get_facecolor()\n        origedgecolor = self.figure.get_edgecolor()\n        self.figure.set_facecolor(facecolor)\n        self.figure.set_edgecolor(edgecolor)\n\n        dryrun = kwargs.get(\"dryrun\", False)\n        if dryrun:\n            class NullWriter(object):\n                def write(self, *kl, **kwargs):\n                    pass\n\n            self._pswriter = NullWriter()\n        else:\n            self._pswriter = io.StringIO()\n\n\n        # mixed mode rendering\n        _bbox_inches_restore = kwargs.pop(\"bbox_inches_restore\", None)\n        ps_renderer = self._renderer_class(width, height,\n                                           self._pswriter, imagedpi=dpi)\n        renderer = MixedModeRenderer(self.figure,\n            width, height, dpi, ps_renderer,\n            bbox_inches_restore=_bbox_inches_restore)\n\n        self.figure.draw(renderer)\n\n        if dryrun: # return immediately if dryrun (tightbbox=True)\n            return\n\n        self.figure.set_facecolor(origfacecolor)\n        self.figure.set_edgecolor(origedgecolor)\n\n        # write to a temp file, we'll move it to outfile when done\n        fd, tmpfile = mkstemp()\n        with io.open(fd, 'w', encoding='latin-1') as fh:\n            # write the Encapsulated PostScript headers\n            print(\"%!PS-Adobe-3.0 EPSF-3.0\", file=fh)\n            if title: print(\"%%Title: \"+title, file=fh)\n            print((\"%%Creator: matplotlib version \"\n                         +__version__+\", http://matplotlib.org/\"), file=fh)\n            print(\"%%CreationDate: \"+time.ctime(time.time()), file=fh)\n            print(\"%%%%BoundingBox: %d %d %d %d\" % bbox, file=fh)\n            print(\"%%EndComments\", file=fh)\n\n            Ndict = len(psDefs)\n            print(\"%%BeginProlog\", file=fh)\n            print(\"/mpldict %d dict def\"%Ndict, file=fh)\n            print(\"mpldict begin\", file=fh)\n            for d in psDefs:\n                d=d.strip()\n                for l in d.split('\\n'):\n                    print(l.strip(), file=fh)\n            print(\"end\", file=fh)\n            print(\"%%EndProlog\", file=fh)\n\n            print(\"mpldict begin\", file=fh)\n            #print >>fh, \"gsave\"\n            print(\"%s translate\"%_nums_to_str(xo, yo), file=fh)\n            print(\"%s clipbox\"%_nums_to_str(width*72, height*72, 0, 0), file=fh)\n\n            # write the figure\n            print(self._pswriter.getvalue(), file=fh)\n\n            # write the trailer\n            #print >>fh, \"grestore\"\n            print(\"end\", file=fh)\n            print(\"showpage\", file=fh)\n            fh.flush()\n\n        if isLandscape: # now we are ready to rotate\n            isLandscape = True\n            width, height = height, width\n            bbox = (lly, llx, ury, urx)\n\n        # set the paper size to the figure size if isEPSF. The\n        # resulting ps file has the given size with correct bounding\n        # box so that there is no need to call 'pstoeps'\n        if isEPSF:\n            paperWidth, paperHeight = self.figure.get_size_inches()\n            if isLandscape:\n                paperWidth, paperHeight = paperHeight, paperWidth\n        else:\n            temp_papertype = _get_papertype(width, height)\n            if papertype=='auto':\n                papertype = temp_papertype\n                paperWidth, paperHeight = papersize[temp_papertype]\n            else:\n                paperWidth, paperHeight = papersize[papertype]\n                if (width>paperWidth or height>paperHeight) and isEPSF:\n                    paperWidth, paperHeight = papersize[temp_papertype]\n                    verbose.report('Your figure is too big to fit on %s paper. %s \\\n    paper will be used to prevent clipping.'%(papertype, temp_papertype), 'helpful')\n\n\n        texmanager = ps_renderer.get_texmanager()\n        font_preamble = texmanager.get_font_preamble()\n        custom_preamble = texmanager.get_custom_preamble()\n\n        psfrag_rotated = convert_psfrags(tmpfile, ps_renderer.psfrag,\n                                         font_preamble,\n                                         custom_preamble, paperWidth, paperHeight,\n                                         orientation)\n\n        if rcParams['ps.usedistiller'] == 'ghostscript':\n            gs_distill(tmpfile, isEPSF, ptype=papertype, bbox=bbox,\n                       rotated=psfrag_rotated)\n        elif rcParams['ps.usedistiller'] == 'xpdf':\n            xpdf_distill(tmpfile, isEPSF, ptype=papertype, bbox=bbox,\n                         rotated=psfrag_rotated)\n        elif rcParams['text.usetex']:\n            if False: pass # for debugging\n            else: gs_distill(tmpfile, isEPSF, ptype=papertype, bbox=bbox,\n                             rotated=psfrag_rotated)\n\n        if is_writable_file_like(outfile):\n            if file_requires_unicode(outfile):\n                with io.open(tmpfile, 'rb') as fh:\n                    outfile.write(fh.read().decode('latin-1'))\n            else:\n                with io.open(tmpfile, 'rb') as fh:\n                    outfile.write(fh.read())\n        else:\n            with io.open(outfile, 'wb') as fh:\n                pass\n            mode = os.stat(outfile).st_mode\n            shutil.move(tmpfile, outfile)\n            os.chmod(outfile, mode)\n\ndef convert_psfrags(tmpfile, psfrags, font_preamble, custom_preamble,\n                    paperWidth, paperHeight, orientation):\n    \"\"\"\n    When we want to use the LaTeX backend with postscript, we write PSFrag tags\n    to a temporary postscript file, each one marking a position for LaTeX to\n    render some text. convert_psfrags generates a LaTeX document containing the\n    commands to convert those tags to text. LaTeX/dvips produces the postscript\n    file that includes the actual text.\n    \"\"\"\n    tmpdir = os.path.split(tmpfile)[0]\n    epsfile = tmpfile+'.eps'\n    shutil.move(tmpfile, epsfile)\n    latexfile = tmpfile+'.tex'\n    outfile = tmpfile+'.output'\n    dvifile = tmpfile+'.dvi'\n    psfile = tmpfile+'.ps'\n\n    if orientation=='landscape': angle = 90\n    else: angle = 0\n\n    if rcParams['text.latex.unicode']:\n        unicode_preamble = \"\"\"\\\\usepackage{ucs}\n\\\\usepackage[utf8x]{inputenc}\"\"\"\n    else:\n        unicode_preamble = ''\n\n    s = \"\"\"\\\\documentclass{article}\n%s\n%s\n%s\n\\\\usepackage[dvips, papersize={%sin,%sin}, body={%sin,%sin}, margin={0in,0in}]{geometry}\n\\\\usepackage{psfrag}\n\\\\usepackage[dvips]{graphicx}\n\\\\usepackage{color}\n\\\\pagestyle{empty}\n\\\\begin{document}\n\\\\begin{figure}\n\\\\centering\n\\\\leavevmode\n%s\n\\\\includegraphics*[angle=%s]{%s}\n\\\\end{figure}\n\\\\end{document}\n\"\"\"% (font_preamble, unicode_preamble, custom_preamble, paperWidth, paperHeight,\n      paperWidth, paperHeight,\n      '\\n'.join(psfrags), angle, os.path.split(epsfile)[-1])\n\n    with io.open(latexfile, 'wb') as latexh:\n        if rcParams['text.latex.unicode']:\n            latexh.write(s.encode('utf8'))\n        else:\n            try:\n                latexh.write(s.encode('ascii'))\n            except UnicodeEncodeError:\n                verbose.report(\"You are using unicode and latex, but have \"\n                               \"not enabled the matplotlib 'text.latex.unicode' \"\n                               \"rcParam.\", 'helpful')\n                raise\n\n    # the split drive part of the command is necessary for windows users with\n    # multiple\n    if sys.platform == 'win32': precmd = '%s &&'% os.path.splitdrive(tmpdir)[0]\n    else: precmd = ''\n    command = '%s cd \"%s\" && latex -interaction=nonstopmode \"%s\" > \"%s\"'\\\n                %(precmd, tmpdir, latexfile, outfile)\n    verbose.report(command, 'debug')\n    exit_status = os.system(command)\n\n    with io.open(outfile, 'rb') as fh:\n        if exit_status:\n            raise RuntimeError('LaTeX was not able to process your file:\\\n    \\nHere is the full report generated by LaTeX: \\n\\n%s'% fh.read())\n        else:\n            verbose.report(fh.read(), 'debug')\n    os.remove(outfile)\n\n    command = '%s cd \"%s\" && dvips -q -R0 -o \"%s\" \"%s\" > \"%s\"'%(precmd, tmpdir,\n                os.path.split(psfile)[-1], os.path.split(dvifile)[-1], outfile)\n    verbose.report(command, 'debug')\n    exit_status = os.system(command)\n\n    with io.open(outfile, 'rb') as fh:\n        if exit_status:\n            raise RuntimeError('dvips was not able to \\\n    process the following file:\\n%s\\nHere is the full report generated by dvips: \\\n    \\n\\n'% dvifile + fh.read())\n        else:\n            verbose.report(fh.read(), 'debug')\n    os.remove(outfile)\n    os.remove(epsfile)\n    shutil.move(psfile, tmpfile)\n\n    # check if the dvips created a ps in landscape paper.  Somehow,\n    # above latex+dvips results in a ps file in a landscape mode for a\n    # certain figure sizes (e.g., 8.3in,5.8in which is a5). And the\n    # bounding box of the final output got messed up. We check see if\n    # the generated ps file is in landscape and return this\n    # information. The return value is used in pstoeps step to recover\n    # the correct bounding box. 2010-06-05 JJL\n    with io.open(tmpfile) as fh:\n        if \"Landscape\" in fh.read(1000):\n            psfrag_rotated = True\n        else:\n            psfrag_rotated = False\n\n    if not debugPS:\n        for fname in glob.glob(tmpfile+'.*'):\n            os.remove(fname)\n\n    return psfrag_rotated\n\ndef gs_distill(tmpfile, eps=False, ptype='letter', bbox=None, rotated=False):\n    \"\"\"\n    Use ghostscript's pswrite or epswrite device to distill a file.\n    This yields smaller files without illegal encapsulated postscript\n    operators. The output is low-level, converting text to outlines.\n    \"\"\"\n\n    if eps: paper_option = \"-dEPSCrop\"\n    else: paper_option = \"-sPAPERSIZE=%s\" % ptype\n\n    psfile = tmpfile + '.ps'\n    outfile = tmpfile + '.output'\n    dpi = rcParams['ps.distiller.res']\n\n\n    gs_exe = ps_backend_helper.gs_exe\n    if ps_backend_helper.supports_ps2write: # gs version >= 9\n        device_name = \"ps2write\"\n    else:\n        device_name = \"pswrite\"\n\n    command = '%s -dBATCH -dNOPAUSE -r%d -sDEVICE=%s %s -sOutputFile=\"%s\" \\\n                \"%s\" > \"%s\"'% (gs_exe, dpi, device_name,\n                               paper_option, psfile, tmpfile, outfile)\n\n    verbose.report(command, 'debug')\n    exit_status = os.system(command)\n\n    with io.open(outfile, 'rb') as fh:\n        if exit_status:\n            raise RuntimeError('ghostscript was not able to process \\\n    your image.\\nHere is the full report generated by ghostscript:\\n\\n' + fh.read())\n        else:\n            verbose.report(fh.read(), 'debug')\n    os.remove(outfile)\n    os.remove(tmpfile)\n    shutil.move(psfile, tmpfile)\n\n\n    # While it is best if above steps preserve the original bounding\n    # box, there seem to be cases when it is not. For those cases,\n    # the original bbox can be restored during the pstoeps step.\n\n    if eps:\n        # For some versions of gs, above steps result in an ps file\n        # where the original bbox is no more correct. Do not adjust\n        # bbox for now.\n        if ps_backend_helper.supports_ps2write:\n            # fo gs version >= 9 w/ ps2write device\n            pstoeps(tmpfile, bbox, rotated=rotated)\n        else:\n            pstoeps(tmpfile)\n\n\ndef xpdf_distill(tmpfile, eps=False, ptype='letter', bbox=None, rotated=False):\n    \"\"\"\n    Use ghostscript's ps2pdf and xpdf's/poppler's pdftops to distill a file.\n    This yields smaller files without illegal encapsulated postscript\n    operators. This distiller is preferred, generating high-level postscript\n    output that treats text as text.\n    \"\"\"\n    pdffile = tmpfile + '.pdf'\n    psfile = tmpfile + '.ps'\n    outfile = tmpfile + '.output'\n\n    if eps: paper_option = \"-dEPSCrop\"\n    else: paper_option = \"-sPAPERSIZE=%s\" % ptype\n\n    command = 'ps2pdf -dAutoFilterColorImages=false \\\n-sColorImageFilter=FlateEncode %s \"%s\" \"%s\" > \"%s\"'% \\\n(paper_option, tmpfile, pdffile, outfile)\n    if sys.platform == 'win32': command = command.replace('=', '#')\n    verbose.report(command, 'debug')\n    exit_status = os.system(command)\n    with io.open(outfile, 'rb') as fh:\n        if exit_status:\n            raise RuntimeError('ps2pdf was not able to process your \\\nimage.\\n\\Here is the report generated by ghostscript:\\n\\n' + fh.read())\n        else:\n            verbose.report(fh.read(), 'debug')\n    os.remove(outfile)\n    command = 'pdftops -paper match -level2 \"%s\" \"%s\" > \"%s\"'% \\\n                (pdffile, psfile, outfile)\n    verbose.report(command, 'debug')\n    exit_status = os.system(command)\n\n    with io.open(outfile, 'rb') as fh:\n        if exit_status:\n            raise RuntimeError('pdftops was not able to process your \\\nimage.\\nHere is the full report generated by pdftops: \\n\\n' + fh.read())\n        else:\n            verbose.report(fh.read(), 'debug')\n    os.remove(outfile)\n    os.remove(tmpfile)\n    shutil.move(psfile, tmpfile)\n\n    if eps:\n        pstoeps(tmpfile)\n\n    for fname in glob.glob(tmpfile+'.*'):\n        os.remove(fname)\n\ndef get_bbox_header(lbrt, rotated=False):\n    \"\"\"\n    return a postscript header stringfor the given bbox lbrt=(l, b, r, t).\n    Optionally, return rotate command.\n    \"\"\"\n\n    l, b, r, t = lbrt\n    if  rotated:\n        rotate = \"%.2f %.2f  translate\\n90 rotate\" % (l+r, 0)\n    else:\n        rotate = \"\"\n    bbox_info = '%%%%BoundingBox: %d %d %d %d' % (l, b, np.ceil(r), np.ceil(t))\n    hires_bbox_info = '%%%%HiResBoundingBox: %.6f %.6f %.6f %.6f' % (l, b, r, t)\n\n    return '\\n'.join([bbox_info, hires_bbox_info]), rotate\n\n\n# get_bbox is deprecated. I don't see any reason to use ghostscript to\n# find the bounding box, as the required bounding box is alread known.\ndef get_bbox(tmpfile, bbox):\n    \"\"\"\n    Use ghostscript's bbox device to find the center of the bounding box. Return\n    an appropriately sized bbox centered around that point. A bit of a hack.\n    \"\"\"\n\n    outfile = tmpfile + '.output'\n    gs_exe = ps_backend_helper.gs_exe\n    command = '%s -dBATCH -dNOPAUSE -sDEVICE=bbox \"%s\"' %\\\n                (gs_exe, tmpfile)\n    verbose.report(command, 'debug')\n    stdin, stdout, stderr = os.popen3(command)\n    verbose.report(stdout.read(), 'debug-annoying')\n    bbox_info = stderr.read()\n    verbose.report(bbox_info, 'helpful')\n    bbox_found = re.search('%%HiResBoundingBox: .*', bbox_info)\n    if bbox_found:\n        bbox_info = bbox_found.group()\n    else:\n        raise RuntimeError('Ghostscript was not able to extract a bounding box.\\\nHere is the Ghostscript output:\\n\\n%s'% bbox_info)\n    l, b, r, t = [float(i) for i in bbox_info.split()[-4:]]\n\n    # this is a hack to deal with the fact that ghostscript does not return the\n    # intended bbox, but a tight bbox. For now, we just center the ink in the\n    # intended bbox. This is not ideal, users may intend the ink to not be\n    # centered.\n    if bbox is None:\n        l, b, r, t = (l-1, b-1, r+1, t+1)\n    else:\n        x = (l+r)/2\n        y = (b+t)/2\n        dx = (bbox[2]-bbox[0])/2\n        dy = (bbox[3]-bbox[1])/2\n        l,b,r,t = (x-dx, y-dy, x+dx, y+dy)\n\n    bbox_info = '%%%%BoundingBox: %d %d %d %d' % (l, b, np.ceil(r), np.ceil(t))\n    hires_bbox_info = '%%%%HiResBoundingBox: %.6f %.6f %.6f %.6f' % (l, b, r, t)\n\n    return '\\n'.join([bbox_info, hires_bbox_info])\n\n\ndef pstoeps(tmpfile, bbox=None, rotated=False):\n    \"\"\"\n    Convert the postscript to encapsulated postscript.  The bbox of\n    the eps file will be replaced with the given *bbox* argument. If\n    None, original bbox will be used.\n    \"\"\"\n\n    # if rotated==True, the output eps file need to be rotated\n    if bbox:\n        bbox_info, rotate = get_bbox_header(bbox, rotated=rotated)\n    else:\n        bbox_info, rotate = None, None\n\n    epsfile = tmpfile + '.eps'\n    with io.open(epsfile, 'wb') as epsh:\n        write = epsh.write\n        with io.open(tmpfile, 'rb') as tmph:\n            line = tmph.readline()\n            # Modify the header:\n            while line:\n                if line.startswith(b'%!PS'):\n                    write(b\"%!PS-Adobe-3.0 EPSF-3.0\\n\")\n                    if bbox:\n                        write(bbox_info.encode('ascii') + b'\\n')\n                elif line.startswith(b'%%EndComments'):\n                    write(line)\n                    write(b'%%BeginProlog\\n')\n                    write(b'save\\n')\n                    write(b'countdictstack\\n')\n                    write(b'mark\\n')\n                    write(b'newpath\\n')\n                    write(b'/showpage {} def\\n')\n                    write(b'/setpagedevice {pop} def\\n')\n                    write(b'%%EndProlog\\n')\n                    write(b'%%Page 1 1\\n')\n                    if rotate:\n                        write(rotate.encode('ascii') + b'\\n')\n                    break\n                elif bbox and (line.startswith(b'%%Bound') \\\n                               or line.startswith(b'%%HiResBound') \\\n                               or line.startswith(b'%%DocumentMedia') \\\n                               or line.startswith(b'%%Pages')):\n                    pass\n                else:\n                    write(line)\n                line = tmph.readline()\n            # Now rewrite the rest of the file, and modify the trailer.\n            # This is done in a second loop such that the header of the embedded\n            # eps file is not modified.\n            line = tmph.readline()\n            while line:\n                if line.startswith(b'%%EOF'):\n                    write(b'cleartomark\\n')\n                    write(b'countdictstack\\n')\n                    write(b'exch sub { end } repeat\\n')\n                    write(b'restore\\n')\n                    write(b'%%EOF\\n')\n                elif line.startswith(b'%%PageBoundingBox'):\n                    pass\n                else:\n                    write(line)\n                line = tmph.readline()\n\n    os.remove(tmpfile)\n    shutil.move(epsfile, tmpfile)\n\n\nclass FigureManagerPS(FigureManagerBase):\n    pass\n\n\n# The following Python dictionary psDefs contains the entries for the\n# PostScript dictionary mpldict.  This dictionary implements most of\n# the matplotlib primitives and some abbreviations.\n#\n# References:\n# http://www.adobe.com/products/postscript/pdfs/PLRM.pdf\n# http://www.mactech.com/articles/mactech/Vol.09/09.04/PostscriptTutorial/\n# http://www.math.ubc.ca/people/faculty/cass/graphics/text/www/\n#\n\n# The usage comments use the notation of the operator summary\n# in the PostScript Language reference manual.\npsDefs = [\n    # x y  *m*  -\n    \"/m { moveto } bind def\",\n    # x y  *l*  -\n    \"/l { lineto } bind def\",\n    # x y  *r*  -\n    \"/r { rlineto } bind def\",\n    # x1 y1 x2 y2 x y *c*  -\n    \"/c { curveto } bind def\",\n    # *closepath*  -\n    \"/cl { closepath } bind def\",\n    # w h x y  *box*  -\n    \"\"\"/box {\n      m\n      1 index 0 r\n      0 exch r\n      neg 0 r\n      cl\n    } bind def\"\"\",\n    # w h x y  *clipbox*  -\n    \"\"\"/clipbox {\n      box\n      clip\n      newpath\n    } bind def\"\"\",\n]\n\nFigureCanvas = FigureCanvasPS\nFigureManager = FigureManagerPS\n", "patch": "@@ -414,13 +414,14 @@ def _rgb(self, im):\n \n         rgba = np.fromstring(s, np.uint8)\n         rgba.shape = (h, w, 4)\n-        rgb = rgba[:,:,:3]\n+        rgb = rgba[::-1,:,:3]\n         return h, w, rgb.tostring()\n \n     def _gray(self, im, rc=0.3, gc=0.59, bc=0.11):\n         rgbat = im.as_rgba_str()\n         rgba = np.fromstring(rgbat[2], np.uint8)\n         rgba.shape = (rgbat[0], rgbat[1], 4)\n+        rgba = rgba[::-1]\n         rgba_f = rgba.astype(np.float32)\n         r = rgba_f[:,:,0]\n         g = rgba_f[:,:,1]\n@@ -472,8 +473,6 @@ def draw_image(self, gc, x, y, im, dx=None, dy=None, transform=None):\n         interpreted as the coordinate of the transform.\n         \"\"\"\n \n-        im.flipud_out()\n-\n         h, w, bits, imagecmd = self._get_image_h_w_bits_command(im)\n         hexlines = b'\\n'.join(self._hex_lines(bits)).decode('ascii')\n \n@@ -524,9 +523,6 @@ def draw_image(self, gc, x, y, im, dx=None, dy=None, transform=None):\n \"\"\" % locals()\n         self._pswriter.write(ps)\n \n-        # unflip\n-        im.flipud_out()\n-\n     def _convert_path(self, path, transform, clip=False, simplify=None):\n         ps = []\n         last_points = None"}
{"patches_id": 2, "files_id": 15, "language": "py", "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Fbackends%2Fbackend_svg.py", "raw_code": "from __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport six\nfrom six.moves import xrange\nfrom six import unichr\n\nimport os, base64, tempfile, gzip, io, sys, codecs, re\n\nimport numpy as np\n\nfrom hashlib import md5\n\nfrom matplotlib import verbose, __version__, rcParams\nfrom matplotlib.backend_bases import RendererBase, GraphicsContextBase,\\\n     FigureManagerBase, FigureCanvasBase\nfrom matplotlib.backends.backend_mixed import MixedModeRenderer\nfrom matplotlib.cbook import is_string_like, is_writable_file_like, maxdict\nfrom matplotlib.colors import rgb2hex\nfrom matplotlib.figure import Figure\nfrom matplotlib.font_manager import findfont, FontProperties\nfrom matplotlib.ft2font import FT2Font, KERNING_DEFAULT, LOAD_NO_HINTING\nfrom matplotlib.mathtext import MathTextParser\nfrom matplotlib.path import Path\nfrom matplotlib import _path\nfrom matplotlib.transforms import Affine2D, Affine2DBase\nfrom matplotlib import _png\n\nfrom xml.sax.saxutils import escape as escape_xml_text\n\nbackend_version = __version__\n\n# ----------------------------------------------------------------------\n# SimpleXMLWriter class\n#\n# Based on an original by Fredrik Lundh, but modified here to:\n#   1. Support modern Python idioms\n#   2. Remove encoding support (it's handled by the file writer instead)\n#   3. Support proper indentation\n#   4. Minify things a little bit\n\n# --------------------------------------------------------------------\n# The SimpleXMLWriter module is\n#\n# Copyright (c) 2001-2004 by Fredrik Lundh\n#\n# By obtaining, using, and/or copying this software and/or its\n# associated documentation, you agree that you have read, understood,\n# and will comply with the following terms and conditions:\n#\n# Permission to use, copy, modify, and distribute this software and\n# its associated documentation for any purpose and without fee is\n# hereby granted, provided that the above copyright notice appears in\n# all copies, and that both that copyright notice and this permission\n# notice appear in supporting documentation, and that the name of\n# Secret Labs AB or the author not be used in advertising or publicity\n# pertaining to distribution of the software without specific, written\n# prior permission.\n#\n# SECRET LABS AB AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD\n# TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANT-\n# ABILITY AND FITNESS.  IN NO EVENT SHALL SECRET LABS AB OR THE AUTHOR\n# BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY\n# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,\n# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS\n# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE\n# OF THIS SOFTWARE.\n# --------------------------------------------------------------------\n\ndef escape_cdata(s):\n    s = s.replace(\"&\", \"&amp;\")\n    s = s.replace(\"<\", \"&lt;\")\n    s = s.replace(\">\", \"&gt;\")\n    return s\n\n_escape_xml_comment = re.compile(r'-(?=-)')\ndef escape_comment(s):\n    s = escape_cdata(s)\n    return _escape_xml_comment.sub('- ', s)\n\ndef escape_attrib(s):\n    s = s.replace(\"&\", \"&amp;\")\n    s = s.replace(\"'\", \"&apos;\")\n    s = s.replace(\"\\\"\", \"&quot;\")\n    s = s.replace(\"<\", \"&lt;\")\n    s = s.replace(\">\", \"&gt;\")\n    return s\n\n##\n# XML writer class.\n#\n# @param file A file or file-like object.  This object must implement\n#    a <b>write</b> method that takes an 8-bit string.\n\nclass XMLWriter:\n    def __init__(self, file):\n        self.__write = file.write\n        if hasattr(file, \"flush\"):\n            self.flush = file.flush\n        self.__open = 0 # true if start tag is open\n        self.__tags = []\n        self.__data = []\n        self.__indentation = \" \" * 64\n\n    def __flush(self, indent=True):\n        # flush internal buffers\n        if self.__open:\n            if indent:\n                self.__write(\">\\n\")\n            else:\n                self.__write(\">\")\n            self.__open = 0\n        if self.__data:\n            data = ''.join(self.__data)\n            self.__write(escape_cdata(data))\n            self.__data = []\n\n    ## Opens a new element.  Attributes can be given as keyword\n    # arguments, or as a string/string dictionary. The method returns\n    # an opaque identifier that can be passed to the <b>close</b>\n    # method, to close all open elements up to and including this one.\n    #\n    # @param tag Element tag.\n    # @param attrib Attribute dictionary.  Alternatively, attributes\n    #    can be given as keyword arguments.\n    # @return An element identifier.\n\n    def start(self, tag, attrib={}, **extra):\n        self.__flush()\n        tag = escape_cdata(tag)\n        self.__data = []\n        self.__tags.append(tag)\n        self.__write(self.__indentation[:len(self.__tags) - 1])\n        self.__write(\"<%s\" % tag)\n        if attrib or extra:\n            attrib = attrib.copy()\n            attrib.update(extra)\n            attrib = list(six.iteritems(attrib))\n            attrib.sort()\n            for k, v in attrib:\n                if not v == '':\n                    k = escape_cdata(k)\n                    v = escape_attrib(v)\n                    self.__write(\" %s=\\\"%s\\\"\" % (k, v))\n        self.__open = 1\n        return len(self.__tags)-1\n\n    ##\n    # Adds a comment to the output stream.\n    #\n    # @param comment Comment text, as a Unicode string.\n\n    def comment(self, comment):\n        self.__flush()\n        self.__write(self.__indentation[:len(self.__tags)])\n        self.__write(\"<!-- %s -->\\n\" % escape_comment(comment))\n\n    ##\n    # Adds character data to the output stream.\n    #\n    # @param text Character data, as a Unicode string.\n\n    def data(self, text):\n        self.__data.append(text)\n\n    ##\n    # Closes the current element (opened by the most recent call to\n    # <b>start</b>).\n    #\n    # @param tag Element tag.  If given, the tag must match the start\n    #    tag.  If omitted, the current element is closed.\n\n    def end(self, tag=None, indent=True):\n        if tag:\n            assert self.__tags, \"unbalanced end(%s)\" % tag\n            assert escape_cdata(tag) == self.__tags[-1],\\\n                   \"expected end(%s), got %s\" % (self.__tags[-1], tag)\n        else:\n            assert self.__tags, \"unbalanced end()\"\n        tag = self.__tags.pop()\n        if self.__data:\n            self.__flush(indent)\n        elif self.__open:\n            self.__open = 0\n            self.__write(\"/>\\n\")\n            return\n        if indent:\n            self.__write(self.__indentation[:len(self.__tags)])\n        self.__write(\"</%s>\\n\" % tag)\n\n    ##\n    # Closes open elements, up to (and including) the element identified\n    # by the given identifier.\n    #\n    # @param id Element identifier, as returned by the <b>start</b> method.\n\n    def close(self, id):\n        while len(self.__tags) > id:\n            self.end()\n\n    ##\n    # Adds an entire element.  This is the same as calling <b>start</b>,\n    # <b>data</b>, and <b>end</b> in sequence. The <b>text</b> argument\n    # can be omitted.\n\n    def element(self, tag, text=None, attrib={}, **extra):\n        self.start(*(tag, attrib), **extra)\n        if text:\n            self.data(text)\n        self.end(indent=False)\n\n    ##\n    # Flushes the output stream.\n\n    def flush(self):\n        pass # replaced by the constructor\n\n# ----------------------------------------------------------------------\n\ndef generate_transform(transform_list=[]):\n    if len(transform_list):\n        output = io.StringIO()\n        for type, value in transform_list:\n            if type == 'scale' and (value == (1.0,) or value == (1.0, 1.0)):\n                continue\n            if type == 'translate' and value == (0.0, 0.0):\n                continue\n            if type == 'rotate' and value == (0.0,):\n                continue\n            if type == 'matrix' and isinstance(value, Affine2DBase):\n                value = value.to_values()\n\n            output.write('%s(%s)' % (type, ' '.join(str(x) for x in value)))\n        return output.getvalue()\n    return ''\n\ndef generate_css(attrib={}):\n    if attrib:\n        output = io.StringIO()\n        attrib = list(six.iteritems(attrib))\n        attrib.sort()\n        for k, v in attrib:\n            k = escape_attrib(k)\n            v = escape_attrib(v)\n            output.write(\"%s:%s;\" % (k, v))\n        return output.getvalue()\n    return ''\n\n_capstyle_d = {'projecting' : 'square', 'butt' : 'butt', 'round': 'round',}\nclass RendererSVG(RendererBase):\n    FONT_SCALE = 100.0\n    fontd = maxdict(50)\n\n    def __init__(self, width, height, svgwriter, basename=None, image_dpi=72):\n        self.width = width\n        self.height = height\n        self.writer = XMLWriter(svgwriter)\n        self.image_dpi = image_dpi # the actual dpi we want to rasterize stuff with\n\n        self._groupd = {}\n        if not rcParams['svg.image_inline']:\n            assert basename is not None\n            self.basename = basename\n            self._imaged = {}\n        self._clipd = {}\n        self._char_defs = {}\n        self._markers = {}\n        self._path_collection_id = 0\n        self._imaged = {}\n        self._hatchd = {}\n        self._has_gouraud = False\n        self._n_gradients = 0\n        self._fonts = {}\n        self.mathtext_parser = MathTextParser('SVG')\n\n        RendererBase.__init__(self)\n        self._glyph_map = dict()\n\n        svgwriter.write(svgProlog)\n        self._start_id = self.writer.start(\n            'svg',\n            width='%ipt' % width, height='%ipt' % height,\n            viewBox='0 0 %i %i' % (width, height),\n            xmlns=\"http://www.w3.org/2000/svg\",\n            version=\"1.1\",\n            attrib={'xmlns:xlink': \"http://www.w3.org/1999/xlink\"})\n        self._write_default_style()\n\n    def finalize(self):\n        self._write_clips()\n        self._write_hatches()\n        self._write_svgfonts()\n        self.writer.close(self._start_id)\n        self.writer.flush()\n\n    def _write_default_style(self):\n        writer = self.writer\n        default_style = generate_css({\n            'stroke-linejoin': 'round',\n            'stroke-linecap': 'butt'})\n        writer.start('defs')\n        writer.start('style', type='text/css')\n        writer.data('*{%s}\\n' % default_style)\n        writer.end('style')\n        writer.end('defs')\n\n    def _make_id(self, type, content):\n        content = str(content)\n        if six.PY3:\n            content = content.encode('utf8')\n        return '%s%s' % (type, md5(content).hexdigest()[:10])\n\n    def _make_flip_transform(self, transform):\n        return (transform +\n                Affine2D()\n                .scale(1.0, -1.0)\n                .translate(0.0, self.height))\n\n    def _get_font(self, prop):\n        key = hash(prop)\n        font = self.fontd.get(key)\n        if font is None:\n            fname = findfont(prop)\n            font = self.fontd.get(fname)\n            if font is None:\n                font = FT2Font(fname)\n                self.fontd[fname] = font\n            self.fontd[key] = font\n        font.clear()\n        size = prop.get_size_in_points()\n        font.set_size(size, 72.0)\n        return font\n\n    def _get_hatch(self, gc, rgbFace):\n        \"\"\"\n        Create a new hatch pattern\n        \"\"\"\n        if rgbFace is not None:\n            rgbFace = tuple(rgbFace)\n        edge = gc.get_rgb()\n        if edge is not None:\n            edge = tuple(edge)\n        dictkey = (gc.get_hatch(), rgbFace, edge)\n        oid = self._hatchd.get(dictkey)\n        if oid is None:\n            oid = self._make_id('h', dictkey)\n            self._hatchd[dictkey] = ((gc.get_hatch_path(), rgbFace, edge), oid)\n        else:\n            _, oid = oid\n        return oid\n\n    def _write_hatches(self):\n        if not len(self._hatchd):\n            return\n        HATCH_SIZE = 72\n        writer = self.writer\n        writer.start('defs')\n        for ((path, face, stroke), oid) in six.itervalues(self._hatchd):\n            writer.start(\n                'pattern',\n                id=oid,\n                patternUnits=\"userSpaceOnUse\",\n                x=\"0\", y=\"0\", width=six.text_type(HATCH_SIZE),\n                height=six.text_type(HATCH_SIZE))\n            path_data = self._convert_path(\n                path,\n                Affine2D().scale(HATCH_SIZE).scale(1.0, -1.0).translate(0, HATCH_SIZE),\n                simplify=False)\n            if face is None:\n                fill = 'none'\n            else:\n                fill = rgb2hex(face)\n            writer.element(\n                'rect',\n                x=\"0\", y=\"0\", width=six.text_type(HATCH_SIZE+1),\n                height=six.text_type(HATCH_SIZE+1),\n                fill=fill)\n            writer.element(\n                'path',\n                d=path_data,\n                style=generate_css({\n                    'fill': rgb2hex(stroke),\n                    'stroke': rgb2hex(stroke),\n                    'stroke-width': '1.0',\n                    'stroke-linecap': 'butt',\n                    'stroke-linejoin': 'miter'\n                    })\n                )\n            writer.end('pattern')\n        writer.end('defs')\n\n    def _get_style_dict(self, gc, rgbFace):\n        \"\"\"\n        return the style string.  style is generated from the\n        GraphicsContext and rgbFace\n        \"\"\"\n        attrib = {}\n\n        forced_alpha = gc.get_forced_alpha()\n\n        if gc.get_hatch() is not None:\n            attrib['fill'] = \"url(#%s)\" % self._get_hatch(gc, rgbFace)\n            if rgbFace is not None and len(rgbFace) == 4 and rgbFace[3] != 1.0 and not forced_alpha:\n                attrib['fill-opacity'] = str(rgbFace[3])\n        else:\n            if rgbFace is None:\n                attrib['fill'] = 'none'\n            else:\n                if tuple(rgbFace[:3]) != (0, 0, 0):\n                    attrib['fill'] = rgb2hex(rgbFace)\n                if len(rgbFace) == 4 and rgbFace[3] != 1.0 and not forced_alpha:\n                    attrib['fill-opacity'] = str(rgbFace[3])\n\n        if forced_alpha and gc.get_alpha() != 1.0:\n            attrib['opacity'] = str(gc.get_alpha())\n\n        offset, seq = gc.get_dashes()\n        if seq is not None:\n            attrib['stroke-dasharray'] = ','.join(['%f' % val for val in seq])\n            attrib['stroke-dashoffset'] = six.text_type(float(offset))\n\n        linewidth = gc.get_linewidth()\n        if linewidth:\n            rgb = gc.get_rgb()\n            attrib['stroke'] = rgb2hex(rgb)\n            if not forced_alpha and rgb[3] != 1.0:\n                attrib['stroke-opacity'] = str(rgb[3])\n            if linewidth != 1.0:\n                attrib['stroke-width'] = str(linewidth)\n            if gc.get_joinstyle() != 'round':\n                attrib['stroke-linejoin'] = gc.get_joinstyle()\n            if gc.get_capstyle() != 'butt':\n                attrib['stroke-linecap'] = _capstyle_d[gc.get_capstyle()]\n\n        return attrib\n\n    def _get_style(self, gc, rgbFace):\n        return generate_css(self._get_style_dict(gc, rgbFace))\n\n    def _get_clip(self, gc):\n        cliprect = gc.get_clip_rectangle()\n        clippath, clippath_trans = gc.get_clip_path()\n        if clippath is not None:\n            clippath_trans = self._make_flip_transform(clippath_trans)\n            dictkey = (id(clippath), str(clippath_trans))\n        elif cliprect is not None:\n            x, y, w, h = cliprect.bounds\n            y = self.height-(y+h)\n            dictkey = (x, y, w, h)\n        else:\n            return None\n\n        clip = self._clipd.get(dictkey)\n        if clip is None:\n            oid = self._make_id('p', dictkey)\n            if clippath is not None:\n                self._clipd[dictkey] = ((clippath, clippath_trans), oid)\n            else:\n                self._clipd[dictkey] = (dictkey, oid)\n        else:\n            clip, oid = clip\n        return oid\n\n    def _write_clips(self):\n        if not len(self._clipd):\n            return\n        writer = self.writer\n        writer.start('defs')\n        for clip, oid in six.itervalues(self._clipd):\n            writer.start('clipPath', id=oid)\n            if len(clip) == 2:\n                clippath, clippath_trans = clip\n                path_data = self._convert_path(clippath, clippath_trans, simplify=False)\n                writer.element('path', d=path_data)\n            else:\n                x, y, w, h = clip\n                writer.element('rect', x=six.text_type(x), y=six.text_type(y),\n                               width=six.text_type(w), height=six.text_type(h))\n            writer.end('clipPath')\n        writer.end('defs')\n\n    def _write_svgfonts(self):\n        if not rcParams['svg.fonttype'] == 'svgfont':\n            return\n\n        writer = self.writer\n        writer.start('defs')\n        for font_fname, chars in six.iteritems(self._fonts):\n            font = FT2Font(font_fname)\n            font.set_size(72, 72)\n            sfnt = font.get_sfnt()\n            writer.start('font', id=sfnt[(1, 0, 0, 4)])\n            writer.element(\n                'font-face',\n                attrib={\n                    'font-family': font.family_name,\n                    'font-style': font.style_name.lower(),\n                    'units-per-em': '72',\n                    'bbox': ' '.join(six.text_type(x / 64.0) for x in font.bbox)})\n            for char in chars:\n                glyph = font.load_char(char, flags=LOAD_NO_HINTING)\n                verts, codes = font.get_path()\n                path = Path(verts, codes)\n                path_data = self._convert_path(path)\n                # name = font.get_glyph_name(char)\n                writer.element(\n                    'glyph',\n                    d=path_data,\n                    attrib={\n                        # 'glyph-name': name,\n                        'unicode': unichr(char),\n                        'horiz-adv-x': six.text_type(glyph.linearHoriAdvance / 65536.0)})\n            writer.end('font')\n        writer.end('defs')\n\n    def open_group(self, s, gid=None):\n        \"\"\"\n        Open a grouping element with label *s*. If *gid* is given, use\n        *gid* as the id of the group.\n        \"\"\"\n        if gid:\n            self.writer.start('g', id=gid)\n        else:\n            self._groupd[s] = self._groupd.get(s, 0) + 1\n            self.writer.start('g', id=\"%s_%d\" % (s, self._groupd[s]))\n\n    def close_group(self, s):\n        self.writer.end('g')\n\n    def option_image_nocomposite(self):\n        \"\"\"\n        if svg.image_noscale is True, compositing multiple images into one is prohibited\n        \"\"\"\n        return rcParams['svg.image_noscale']\n\n    def _convert_path(self, path, transform=None, clip=None, simplify=None):\n        if clip:\n            clip = (0.0, 0.0, self.width, self.height)\n        else:\n            clip = None\n        return _path.convert_to_svg(path, transform, clip, simplify, 6)\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        trans_and_flip = self._make_flip_transform(transform)\n        clip = (rgbFace is None and gc.get_hatch_path() is None)\n        simplify = path.should_simplify and clip\n        path_data = self._convert_path(\n            path, trans_and_flip, clip=clip, simplify=simplify)\n\n        attrib = {}\n        attrib['style'] = self._get_style(gc, rgbFace)\n\n        clipid = self._get_clip(gc)\n        if clipid is not None:\n            attrib['clip-path'] = 'url(#%s)' % clipid\n\n        if gc.get_url() is not None:\n            self.writer.start('a', {'xlink:href': gc.get_url()})\n        self.writer.element('path', d=path_data, attrib=attrib)\n        if gc.get_url() is not None:\n            self.writer.end('a')\n\n    def draw_markers(self, gc, marker_path, marker_trans, path, trans, rgbFace=None):\n        if not len(path.vertices):\n            return\n\n        writer = self.writer\n        path_data = self._convert_path(\n            marker_path,\n            marker_trans + Affine2D().scale(1.0, -1.0),\n            simplify=False)\n        style = self._get_style_dict(gc, rgbFace)\n        dictkey = (path_data, generate_css(style))\n        oid = self._markers.get(dictkey)\n        for key in list(six.iterkeys(style)):\n            if not key.startswith('stroke'):\n                del style[key]\n        style = generate_css(style)\n\n        if oid is None:\n            oid = self._make_id('m', dictkey)\n            writer.start('defs')\n            writer.element('path', id=oid, d=path_data, style=style)\n            writer.end('defs')\n            self._markers[dictkey] = oid\n\n        attrib = {}\n        clipid = self._get_clip(gc)\n        if clipid is not None:\n            attrib['clip-path'] = 'url(#%s)' % clipid\n        writer.start('g', attrib=attrib)\n\n        trans_and_flip = self._make_flip_transform(trans)\n        attrib = {'xlink:href': '#%s' % oid}\n        clip = (0, 0, self.width*72, self.height*72)\n        for vertices, code in path.iter_segments(\n                trans_and_flip, clip=clip, simplify=False):\n            if len(vertices):\n                x, y = vertices[-2:]\n                attrib['x'] = six.text_type(x)\n                attrib['y'] = six.text_type(y)\n                attrib['style'] = self._get_style(gc, rgbFace)\n                writer.element('use', attrib=attrib)\n        writer.end('g')\n\n    def draw_path_collection(self, gc, master_transform, paths, all_transforms,\n                             offsets, offsetTrans, facecolors, edgecolors,\n                             linewidths, linestyles, antialiaseds, urls,\n                             offset_position):\n        writer = self.writer\n        path_codes = []\n        writer.start('defs')\n        for i, (path, transform) in enumerate(self._iter_collection_raw_paths(\n            master_transform, paths, all_transforms)):\n            transform = Affine2D(transform.get_matrix()).scale(1.0, -1.0)\n            d = self._convert_path(path, transform, simplify=False)\n            oid = 'C%x_%x_%s' % (self._path_collection_id, i,\n                                  self._make_id('', d))\n            writer.element('path', id=oid, d=d)\n            path_codes.append(oid)\n        writer.end('defs')\n\n        for xo, yo, path_id, gc0, rgbFace in self._iter_collection(\n            gc, master_transform, all_transforms, path_codes, offsets,\n            offsetTrans, facecolors, edgecolors, linewidths, linestyles,\n            antialiaseds, urls, offset_position):\n            clipid = self._get_clip(gc0)\n            url = gc0.get_url()\n            if url is not None:\n                writer.start('a', attrib={'xlink:href': url})\n            if clipid is not None:\n                writer.start('g', attrib={'clip-path': 'url(#%s)' % clipid})\n            attrib = {\n                'xlink:href': '#%s' % path_id,\n                'x': six.text_type(xo),\n                'y': six.text_type(self.height - yo),\n                'style': self._get_style(gc0, rgbFace)\n                }\n            writer.element('use', attrib=attrib)\n            if clipid is not None:\n                writer.end('g')\n            if url is not None:\n                writer.end('a')\n\n        self._path_collection_id += 1\n\n    def draw_gouraud_triangle(self, gc, points, colors, trans):\n        # This uses a method described here:\n        #\n        #   http://www.svgopen.org/2005/papers/Converting3DFaceToSVG/index.html\n        #\n        # that uses three overlapping linear gradients to simulate a\n        # Gouraud triangle.  Each gradient goes from fully opaque in\n        # one corner to fully transparent along the opposite edge.\n        # The line between the stop points is perpendicular to the\n        # opposite edge.  Underlying these three gradients is a solid\n        # triangle whose color is the average of all three points.\n\n        writer = self.writer\n        if not self._has_gouraud:\n            self._has_gouraud = True\n            writer.start(\n                'filter',\n                id='colorAdd')\n            writer.element(\n                'feComposite',\n                attrib={'in': 'SourceGraphic'},\n                in2='BackgroundImage',\n                operator='arithmetic',\n                k2=\"1\", k3=\"1\")\n            writer.end('filter')\n\n        avg_color = np.sum(colors[:, :], axis=0) / 3.0\n        # Just skip fully-transparent triangles\n        if avg_color[-1] == 0.0:\n            return\n\n        trans_and_flip = self._make_flip_transform(trans)\n        tpoints = trans_and_flip.transform(points)\n\n        writer.start('defs')\n        for i in range(3):\n            x1, y1 = tpoints[i]\n            x2, y2 = tpoints[(i + 1) % 3]\n            x3, y3 = tpoints[(i + 2) % 3]\n            c = colors[i][:]\n\n            if x2 == x3:\n                xb = x2\n                yb = y1\n            elif y2 == y3:\n                xb = x1\n                yb = y2\n            else:\n                m1 = (y2 - y3) / (x2 - x3)\n                b1 = y2 - (m1 * x2)\n                m2 = -(1.0 / m1)\n                b2 = y1 - (m2 * x1)\n                xb = (-b1 + b2) / (m1 - m2)\n                yb = m2 * xb + b2\n\n            writer.start(\n                'linearGradient',\n                id=\"GR%x_%d\" % (self._n_gradients, i),\n                x1=six.text_type(x1), y1=six.text_type(y1),\n                x2=six.text_type(xb), y2=six.text_type(yb))\n            writer.element(\n                'stop',\n                offset='0',\n                style=generate_css({'stop-color': rgb2hex(c),\n                                    'stop-opacity': six.text_type(c[-1])}))\n            writer.element(\n                'stop',\n                offset='1',\n                style=generate_css({'stop-color': rgb2hex(c),\n                                    'stop-opacity': \"0\"}))\n            writer.end('linearGradient')\n\n        writer.element(\n            'polygon',\n            id='GT%x' % self._n_gradients,\n            points=\" \".join([six.text_type(x)\n                             for x in (x1, y1, x2, y2, x3, y3)]))\n        writer.end('defs')\n\n        avg_color = np.sum(colors[:, :], axis=0) / 3.0\n        href = '#GT%x' % self._n_gradients\n        writer.element(\n            'use',\n            attrib={'xlink:href': href,\n                    'fill': rgb2hex(avg_color),\n                    'fill-opacity': str(avg_color[-1])})\n        for i in range(3):\n            writer.element(\n                'use',\n                attrib={'xlink:href': href,\n                        'fill': 'url(#GR%x_%d)' % (self._n_gradients, i),\n                        'fill-opacity': '1',\n                        'filter': 'url(#colorAdd)'})\n\n        self._n_gradients += 1\n\n    def draw_gouraud_triangles(self, gc, triangles_array, colors_array,\n                               transform):\n        attrib = {}\n        clipid = self._get_clip(gc)\n        if clipid is not None:\n            attrib['clip-path'] = 'url(#%s)' % clipid\n\n        self.writer.start('g', attrib=attrib)\n\n        transform = transform.frozen()\n        for tri, col in zip(triangles_array, colors_array):\n            self.draw_gouraud_triangle(gc, tri, col, transform)\n\n        self.writer.end('g')\n\n    def option_scale_image(self):\n        return True\n\n    def get_image_magnification(self):\n        return self.image_dpi / 72.0\n\n    def draw_image(self, gc, x, y, im, dx=None, dy=None, transform=None):\n        attrib = {}\n        clipid = self._get_clip(gc)\n        if clipid is not None:\n            # Can't apply clip-path directly to the image because the\n            # image has a transformation, which would also be applied\n            # to the clip-path\n            self.writer.start('g', attrib={'clip-path': 'url(#%s)' % clipid})\n\n        trans = [1,0,0,1,0,0]\n        if rcParams['svg.image_noscale']:\n            trans = list(im.get_matrix())\n            trans[5] = -trans[5]\n            attrib['transform'] = generate_transform([('matrix', tuple(trans))])\n            assert trans[1] == 0\n            assert trans[2] == 0\n            numrows, numcols = im.get_size()\n            im.reset_matrix()\n            im.set_interpolation(0)\n            im.resize(numcols, numrows)\n\n        h,w = im.get_size_out()\n\n        if dx is None:\n            w = 72.0*w/self.image_dpi\n        else:\n            w = dx\n\n        if dy is None:\n            h = 72.0*h/self.image_dpi\n        else:\n            h = dy\n\n        oid = getattr(im, '_gid', None)\n        url = getattr(im, '_url', None)\n        if url is not None:\n            self.writer.start('a', attrib={'xlink:href': url})\n        if rcParams['svg.image_inline']:\n            bytesio = io.BytesIO()\n            _png.write_png(np.array(im)[::-1], bytesio)\n            oid = oid or self._make_id('image', bytesio)\n            attrib['xlink:href'] = (\n                \"data:image/png;base64,\\n\" +\n                base64.b64encode(bytesio.getvalue()).decode('ascii'))\n        else:\n            self._imaged[self.basename] = self._imaged.get(self.basename,0) + 1\n            filename = '%s.image%d.png'%(self.basename, self._imaged[self.basename])\n            verbose.report( 'Writing image file for inclusion: %s' % filename)\n            _png.write_png(np.array(im)[::-1], filename)\n            oid = oid or 'Im_' + self._make_id('image', filename)\n            attrib['xlink:href'] = filename\n\n        alpha = gc.get_alpha()\n        if alpha != 1.0:\n            attrib['opacity'] = str(alpha)\n\n        attrib['id'] = oid\n\n        if transform is None:\n            self.writer.element(\n                'image',\n                x=six.text_type(x/trans[0]),\n                y=six.text_type((self.height-y)/trans[3]-h),\n                width=six.text_type(w), height=six.text_type(h),\n                attrib=attrib)\n        else:\n            flipped = self._make_flip_transform(transform)\n            flipped = np.array(flipped.to_values())\n            y = y+dy\n            if dy > 0.0:\n                flipped[3] *= -1.0\n                y *= -1.0\n            attrib['transform'] = generate_transform(\n                [('matrix', flipped)])\n            self.writer.element(\n                'image',\n                x=six.text_type(x), y=six.text_type(y),\n                width=six.text_type(dx), height=six.text_type(abs(dy)),\n                attrib=attrib)\n\n        if url is not None:\n            self.writer.end('a')\n        if clipid is not None:\n            self.writer.end('g')\n\n    def _adjust_char_id(self, char_id):\n        return char_id.replace(\"%20\", \"_\")\n\n    def _draw_text_as_path(self, gc, x, y, s, prop, angle, ismath, mtext=None):\n        \"\"\"\n        draw the text by converting them to paths using textpath module.\n\n        *prop*\n          font property\n\n        *s*\n          text to be converted\n\n        *usetex*\n          If True, use matplotlib usetex mode.\n\n        *ismath*\n          If True, use mathtext parser. If \"TeX\", use *usetex* mode.\n        \"\"\"\n        writer = self.writer\n\n        writer.comment(s)\n\n        glyph_map=self._glyph_map\n\n        text2path = self._text2path\n        color = rgb2hex(gc.get_rgb())\n        fontsize = prop.get_size_in_points()\n\n        style = {}\n        if color != '#000000':\n            style['fill'] = color\n        if gc.get_alpha() != 1.0:\n            style['opacity'] = six.text_type(gc.get_alpha())\n\n        if not ismath:\n            font = text2path._get_font(prop)\n            _glyphs = text2path.get_glyphs_with_font(\n                font, s, glyph_map=glyph_map, return_new_glyphs_only=True)\n            glyph_info, glyph_map_new, rects = _glyphs\n\n            if glyph_map_new:\n                writer.start('defs')\n                for char_id, glyph_path in six.iteritems(glyph_map_new):\n                    path = Path(*glyph_path)\n                    path_data = self._convert_path(path, simplify=False)\n                    writer.element('path', id=char_id, d=path_data)\n                writer.end('defs')\n\n                glyph_map.update(glyph_map_new)\n\n            attrib = {}\n            attrib['style'] = generate_css(style)\n            font_scale = fontsize / text2path.FONT_SCALE\n            attrib['transform'] = generate_transform([\n                ('translate', (x, y)),\n                ('rotate', (-angle,)),\n                ('scale', (font_scale, -font_scale))])\n\n            writer.start('g', attrib=attrib)\n            for glyph_id, xposition, yposition, scale in glyph_info:\n                attrib={'xlink:href': '#%s' % glyph_id}\n                if xposition != 0.0:\n                    attrib['x'] = six.text_type(xposition)\n                if yposition != 0.0:\n                    attrib['y'] = six.text_type(yposition)\n                writer.element(\n                    'use',\n                    attrib=attrib)\n\n            writer.end('g')\n        else:\n            if ismath == \"TeX\":\n                _glyphs = text2path.get_glyphs_tex(prop, s, glyph_map=glyph_map,\n                                                   return_new_glyphs_only=True)\n            else:\n                _glyphs = text2path.get_glyphs_mathtext(prop, s, glyph_map=glyph_map,\n                                                        return_new_glyphs_only=True)\n\n            glyph_info, glyph_map_new, rects = _glyphs\n\n            # we store the character glyphs w/o flipping. Instead, the\n            # coordinate will be flipped when this characters are\n            # used.\n            if glyph_map_new:\n                writer.start('defs')\n                for char_id, glyph_path in six.iteritems(glyph_map_new):\n                    char_id = self._adjust_char_id(char_id)\n                    # Some characters are blank\n                    if not len(glyph_path[0]):\n                        path_data = \"\"\n                    else:\n                        path = Path(*glyph_path)\n                        path_data = self._convert_path(path, simplify=False)\n                    writer.element('path', id=char_id, d=path_data)\n                writer.end('defs')\n\n                glyph_map.update(glyph_map_new)\n\n            attrib = {}\n            font_scale = fontsize / text2path.FONT_SCALE\n            attrib['style'] = generate_css(style)\n            attrib['transform'] = generate_transform([\n                ('translate', (x, y)),\n                ('rotate', (-angle,)),\n                ('scale', (font_scale, -font_scale))])\n\n            writer.start('g', attrib=attrib)\n            for char_id, xposition, yposition, scale in glyph_info:\n                char_id = self._adjust_char_id(char_id)\n\n                writer.element(\n                    'use',\n                    transform=generate_transform([\n                        ('translate', (xposition, yposition)),\n                        ('scale', (scale,)),\n                        ]),\n                    attrib={'xlink:href': '#%s' % char_id})\n\n            for verts, codes in rects:\n                path = Path(verts, codes)\n                path_data = self._convert_path(path, simplify=False)\n                writer.element('path', d=path_data)\n\n            writer.end('g')\n\n    def _draw_text_as_text(self, gc, x, y, s, prop, angle, ismath, mtext=None):\n        writer = self.writer\n\n        color = rgb2hex(gc.get_rgb())\n        style = {}\n        if color != '#000000':\n            style['fill'] = color\n        if gc.get_alpha() != 1.0:\n            style['opacity'] = six.text_type(gc.get_alpha())\n\n        if not ismath:\n            font = self._get_font(prop)\n            font.set_text(s, 0.0, flags=LOAD_NO_HINTING)\n\n            fontsize = prop.get_size_in_points()\n\n            fontfamily = font.family_name\n            fontstyle = prop.get_style()\n\n            attrib = {}\n            # Must add \"px\" to workaround a Firefox bug\n            style['font-size'] = six.text_type(fontsize) + 'px'\n            style['font-family'] = six.text_type(fontfamily)\n            style['font-style'] = prop.get_style().lower()\n            attrib['style'] = generate_css(style)\n\n            if mtext and (angle == 0 or mtext.get_rotation_mode() == \"anchor\"):\n                # If text anchoring can be supported, get the original\n                # coordinates and add alignment information.\n\n                # Get anchor coordinates.\n                transform = mtext.get_transform()\n                ax, ay = transform.transform_point(mtext.get_position())\n                ay = self.height - ay\n\n                # Don't do vertical anchor alignment. Most applications do not\n                # support 'alignment-baseline' yet. Apply the vertical layout\n                # to the anchor point manually for now.\n                angle_rad = angle * np.pi / 180.\n                dir_vert = np.array([np.sin(angle_rad), np.cos(angle_rad)])\n                v_offset = np.dot(dir_vert, [(x - ax), (y - ay)])\n                ax = ax + v_offset * dir_vert[0]\n                ay = ay + v_offset * dir_vert[1]\n\n                ha_mpl_to_svg = {'left': 'start', 'right': 'end',\n                                 'center': 'middle'}\n                style['text-anchor'] = ha_mpl_to_svg[mtext.get_ha()]\n\n                attrib['x'] = str(ax)\n                attrib['y'] = str(ay)\n                attrib['style'] = generate_css(style)\n                attrib['transform'] = \"rotate(%f, %f, %f)\" % (-angle, ax, ay)\n                writer.element('text', s, attrib=attrib)\n            else:\n                attrib['transform'] = generate_transform([\n                    ('translate', (x, y)),\n                    ('rotate', (-angle,))])\n\n                writer.element('text', s, attrib=attrib)\n\n            if rcParams['svg.fonttype'] == 'svgfont':\n                fontset = self._fonts.setdefault(font.fname, set())\n                for c in s:\n                    fontset.add(ord(c))\n        else:\n            writer.comment(s)\n\n            width, height, descent, svg_elements, used_characters = \\\n                   self.mathtext_parser.parse(s, 72, prop)\n            svg_glyphs = svg_elements.svg_glyphs\n            svg_rects = svg_elements.svg_rects\n\n            attrib = {}\n            attrib['style'] = generate_css(style)\n            attrib['transform'] = generate_transform([\n                ('translate', (x, y)),\n                ('rotate', (-angle,))])\n\n            # Apply attributes to 'g', not 'text', because we likely\n            # have some rectangles as well with the same style and\n            # transformation\n            writer.start('g', attrib=attrib)\n\n            writer.start('text')\n\n            # Sort the characters by font, and output one tspan for\n            # each\n            spans = {}\n            for font, fontsize, thetext, new_x, new_y, metrics in svg_glyphs:\n                style = generate_css({\n                    'font-size': six.text_type(fontsize) + 'px',\n                    'font-family': font.family_name,\n                    'font-style': font.style_name.lower()})\n                if thetext == 32:\n                    thetext = 0xa0 # non-breaking space\n                spans.setdefault(style, []).append((new_x, -new_y, thetext))\n\n            if rcParams['svg.fonttype'] == 'svgfont':\n                for font, fontsize, thetext, new_x, new_y, metrics in svg_glyphs:\n                    fontset = self._fonts.setdefault(font.fname, set())\n                    fontset.add(thetext)\n\n            for style, chars in list(six.iteritems(spans)):\n                chars.sort()\n\n                same_y = True\n                if len(chars) > 1:\n                    last_y = chars[0][1]\n                    for i in xrange(1, len(chars)):\n                        if chars[i][1] != last_y:\n                            same_y = False\n                            break\n                if same_y:\n                    ys = six.text_type(chars[0][1])\n                else:\n                    ys = ' '.join(six.text_type(c[1]) for c in chars)\n\n                attrib = {\n                    'style': style,\n                    'x': ' '.join(six.text_type(c[0]) for c in chars),\n                    'y': ys\n                    }\n\n                writer.element(\n                    'tspan',\n                    ''.join(unichr(c[2]) for c in chars),\n                    attrib=attrib)\n\n            writer.end('text')\n\n            if len(svg_rects):\n                for x, y, width, height in svg_rects:\n                    writer.element(\n                        'rect',\n                        x=six.text_type(x), y=six.text_type(-y + height),\n                        width=six.text_type(width), height=six.text_type(height)\n                        )\n\n            writer.end('g')\n\n    def draw_tex(self, gc, x, y, s, prop, angle, ismath='TeX!', mtext=None):\n        self._draw_text_as_path(gc, x, y, s, prop, angle, ismath=\"TeX\")\n\n    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        clipid = self._get_clip(gc)\n        if clipid is not None:\n            # Cannot apply clip-path directly to the text, because\n            # is has a transformation\n            self.writer.start(\n                'g', attrib={'clip-path': 'url(#%s)' % clipid})\n\n        if gc.get_url() is not None:\n            self.writer.start('a', {'xlink:href': gc.get_url()})\n\n        if rcParams['svg.fonttype'] == 'path':\n            self._draw_text_as_path(gc, x, y, s, prop, angle, ismath, mtext)\n        else:\n            self._draw_text_as_text(gc, x, y, s, prop, angle, ismath, mtext)\n\n        if gc.get_url() is not None:\n            self.writer.end('a')\n\n        if clipid is not None:\n            self.writer.end('g')\n\n    def flipy(self):\n        return True\n\n    def get_canvas_width_height(self):\n        return self.width, self.height\n\n    def get_text_width_height_descent(self, s, prop, ismath):\n        return self._text2path.get_text_width_height_descent(s, prop, ismath)\n\n\nclass FigureCanvasSVG(FigureCanvasBase):\n    filetypes = {'svg': 'Scalable Vector Graphics',\n                 'svgz': 'Scalable Vector Graphics'}\n\n    fixed_dpi = 72\n\n    def print_svg(self, filename, *args, **kwargs):\n        if is_string_like(filename):\n            fh_to_close = svgwriter = io.open(filename, 'w', encoding='utf-8')\n        elif is_writable_file_like(filename):\n            if not isinstance(filename, io.TextIOBase):\n                if six.PY3:\n                    svgwriter = io.TextIOWrapper(filename, 'utf-8')\n                else:\n                    svgwriter = codecs.getwriter('utf-8')(filename)\n            else:\n                svgwriter = filename\n            fh_to_close = None\n        else:\n            raise ValueError(\"filename must be a path or a file-like object\")\n        return self._print_svg(filename, svgwriter, fh_to_close, **kwargs)\n\n    def print_svgz(self, filename, *args, **kwargs):\n        if is_string_like(filename):\n            fh_to_close = gzipwriter = gzip.GzipFile(filename, 'w')\n            svgwriter = io.TextIOWrapper(gzipwriter, 'utf-8')\n        elif is_writable_file_like(filename):\n            fh_to_close = gzipwriter = gzip.GzipFile(fileobj=filename, mode='w')\n            svgwriter = io.TextIOWrapper(gzipwriter, 'utf-8')\n        else:\n            raise ValueError(\"filename must be a path or a file-like object\")\n        return self._print_svg(filename, svgwriter, fh_to_close)\n\n    def _print_svg(self, filename, svgwriter, fh_to_close=None, **kwargs):\n        try:\n            image_dpi = kwargs.pop(\"dpi\", 72)\n            self.figure.set_dpi(72.0)\n            width, height = self.figure.get_size_inches()\n            w, h = width*72, height*72\n\n            if rcParams['svg.image_noscale']:\n                renderer = RendererSVG(w, h, svgwriter, filename, image_dpi)\n            else:\n                _bbox_inches_restore = kwargs.pop(\"bbox_inches_restore\", None)\n                renderer = MixedModeRenderer(self.figure,\n                    width, height, image_dpi, RendererSVG(w, h, svgwriter, filename, image_dpi),\n                    bbox_inches_restore=_bbox_inches_restore)\n\n            self.figure.draw(renderer)\n            renderer.finalize()\n        finally:\n            if fh_to_close is not None:\n                svgwriter.close()\n\n    def get_default_filetype(self):\n        return 'svg'\n\nclass FigureManagerSVG(FigureManagerBase):\n    pass\n\n\ndef new_figure_manager(num, *args, **kwargs):\n    FigureClass = kwargs.pop('FigureClass', Figure)\n    thisFig = FigureClass(*args, **kwargs)\n    return new_figure_manager_given_figure(num, thisFig)\n\n\ndef new_figure_manager_given_figure(num, figure):\n    \"\"\"\n    Create a new figure manager instance for the given figure.\n    \"\"\"\n    canvas  = FigureCanvasSVG(figure)\n    manager = FigureManagerSVG(canvas, num)\n    return manager\n\n\nsvgProlog = \"\"\"\\\n<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"\n  \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<!-- Created with matplotlib (http://matplotlib.org/) -->\n\"\"\"\n\n\nFigureCanvas = FigureCanvasSVG\nFigureManager = FigureManagerSVG\n", "patch": "@@ -800,10 +800,7 @@ def draw_image(self, gc, x, y, im, dx=None, dy=None, transform=None):\n             self.writer.start('a', attrib={'xlink:href': url})\n         if rcParams['svg.image_inline']:\n             bytesio = io.BytesIO()\n-            im.flipud_out()\n-            rows, cols, buffer = im.as_rgba_str()\n-            _png.write_png(buffer, cols, rows, bytesio)\n-            im.flipud_out()\n+            _png.write_png(np.array(im)[::-1], bytesio)\n             oid = oid or self._make_id('image', bytesio)\n             attrib['xlink:href'] = (\n                 \"data:image/png;base64,\\n\" +\n@@ -812,10 +809,7 @@ def draw_image(self, gc, x, y, im, dx=None, dy=None, transform=None):\n             self._imaged[self.basename] = self._imaged.get(self.basename,0) + 1\n             filename = '%s.image%d.png'%(self.basename, self._imaged[self.basename])\n             verbose.report( 'Writing image file for inclusion: %s' % filename)\n-            im.flipud_out()\n-            rows, cols, buffer = im.as_rgba_str()\n-            _png.write_png(buffer, cols, rows, filename)\n-            im.flipud_out()\n+            _png.write_png(np.array(im)[::-1], filename)\n             oid = oid or 'Im_' + self._make_id('image', filename)\n             attrib['xlink:href'] = filename\n "}
{"patches_id": 2, "files_id": 16, "language": "py", "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Fbackends%2Fbackend_webagg_core.py", "raw_code": "\"\"\"\nDisplays Agg images in the browser, with interactivity\n\"\"\"\n# The WebAgg backend is divided into two modules:\n#\n# - `backend_webagg_core.py` contains code necessary to embed a WebAgg\n#   plot inside of a web application, and communicate in an abstract\n#   way over a web socket.\n#\n# - `backend_webagg.py` contains a concrete implementation of a basic\n#   application, implemented with tornado.\n\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport six\n\nimport io\nimport json\nimport os\nimport time\n\nimport numpy as np\n\nfrom matplotlib.backends import backend_agg\nfrom matplotlib.figure import Figure\nfrom matplotlib import backend_bases\nfrom matplotlib import _png\n\n\ndef new_figure_manager(num, *args, **kwargs):\n    \"\"\"\n    Create a new figure manager instance\n    \"\"\"\n    FigureClass = kwargs.pop('FigureClass', Figure)\n    thisFig = FigureClass(*args, **kwargs)\n    return new_figure_manager_given_figure(num, thisFig)\n\n\ndef new_figure_manager_given_figure(num, figure):\n    \"\"\"\n    Create a new figure manager instance for the given figure.\n    \"\"\"\n    canvas = FigureCanvasWebAggCore(figure)\n    manager = FigureManagerWebAgg(canvas, num)\n    return manager\n\n\nclass FigureCanvasWebAggCore(backend_agg.FigureCanvasAgg):\n    supports_blit = False\n\n    def __init__(self, *args, **kwargs):\n        backend_agg.FigureCanvasAgg.__init__(self, *args, **kwargs)\n\n        # A buffer to hold the PNG data for the last frame.  This is\n        # retained so it can be resent to each client without\n        # regenerating it.\n        self._png_buffer = io.BytesIO()\n\n        # Set to True when the renderer contains data that is newer\n        # than the PNG buffer.\n        self._png_is_old = True\n\n        # Set to True by the `refresh` message so that the next frame\n        # sent to the clients will be a full frame.\n        self._force_full = True\n\n        # Store the current image mode so that at any point, clients can\n        # request the information. This should be changed by calling\n        # self.set_image_mode(mode) so that the notification can be given\n        # to the connected clients.\n        self._current_image_mode = 'full'\n\n    def show(self):\n        # show the figure window\n        from matplotlib.pyplot import show\n        show()\n\n    def draw(self):\n        renderer = self.get_renderer(cleared=True)\n\n        self._png_is_old = True\n\n        backend_agg.RendererAgg.lock.acquire()\n        try:\n            self.figure.draw(renderer)\n        finally:\n            backend_agg.RendererAgg.lock.release()\n            # Swap the frames\n            self.manager.refresh_all()\n\n    def draw_idle(self):\n        self.send_event(\"draw\")\n\n    def set_image_mode(self, mode):\n        \"\"\"\n        Set the image mode for any subsequent images which will be sent\n        to the clients. The modes may currently be either 'full' or 'diff'.\n\n        Note: diff images may not contain transparency, therefore upon\n        draw this mode may be changed if the resulting image has any\n        transparent component.\n\n        \"\"\"\n        if mode not in ['full', 'diff']:\n            raise ValueError('image mode must be either full or diff.')\n        if self._current_image_mode != mode:\n            self._current_image_mode = mode\n            self.handle_send_image_mode(None)\n\n    def get_diff_image(self):\n        if self._png_is_old:\n            renderer = self.get_renderer()\n\n            # The buffer is created as type uint32 so that entire\n            # pixels can be compared in one numpy call, rather than\n            # needing to compare each plane separately.\n            buff = np.frombuffer(renderer.buffer_rgba(), dtype=np.uint32)\n            buff.shape = (renderer.height, renderer.width)\n\n            # If any pixels have transparency, we need to force a full\n            # draw as we cannot overlay new on top of old.\n            pixels = buff.view(dtype=np.uint8).reshape(buff.shape + (4,))\n\n            if self._force_full or np.any(pixels[:, :, 3] != 255):\n                self.set_image_mode('full')\n                output = buff\n            else:\n                self.set_image_mode('diff')\n                last_buffer = np.frombuffer(self._last_renderer.buffer_rgba(),\n                                            dtype=np.uint32)\n                last_buffer.shape = (renderer.height, renderer.width)\n\n                diff = buff != last_buffer\n                output = np.where(diff, buff, 0)\n\n            # Clear out the PNG data buffer rather than recreating it\n            # each time.  This reduces the number of memory\n            # (de)allocations.\n            self._png_buffer.truncate()\n            self._png_buffer.seek(0)\n\n            # TODO: We should write a new version of write_png that\n            # handles the differencing inline\n            _png.write_png(\n                output,\n                self._png_buffer)\n\n            # Swap the renderer frames\n            self._renderer, self._last_renderer = (\n                self._last_renderer, renderer)\n            self._force_full = False\n            self._png_is_old = False\n        return self._png_buffer.getvalue()\n\n    def get_renderer(self, cleared=None):\n        # Mirrors super.get_renderer, but caches the old one\n        # so that we can do things such as produce a diff image\n        # in get_diff_image\n        _, _, w, h = self.figure.bbox.bounds\n        key = w, h, self.figure.dpi\n        try:\n            self._lastKey, self._renderer\n        except AttributeError:\n            need_new_renderer = True\n        else:\n            need_new_renderer = (self._lastKey != key)\n\n        if need_new_renderer:\n            self._renderer = backend_agg.RendererAgg(\n                w, h, self.figure.dpi)\n            self._last_renderer = backend_agg.RendererAgg(\n                w, h, self.figure.dpi)\n            self._lastKey = key\n\n        elif cleared:\n            self._renderer.clear()\n\n        return self._renderer\n\n    def handle_event(self, event):\n        e_type = event['type']\n        if e_type == 'ack':\n            # Network latency tends to decrease if traffic is flowing\n            # in both directions.  Therefore, the browser sends back\n            # an \"ack\" message after each image frame is received.\n            # This could also be used as a simple sanity check in the\n            # future, but for now the performance increase is enough\n            # to justify it, even if the server does nothing with it.\n            pass\n        elif e_type == 'draw':\n            self.draw()\n        elif e_type in ('button_press', 'button_release', 'motion_notify'):\n            x = event['x']\n            y = event['y']\n            y = self.get_renderer().height - y\n\n            # Javascript button numbers and matplotlib button numbers are\n            # off by 1\n            button = event['button'] + 1\n\n            # The right mouse button pops up a context menu, which\n            # doesn't work very well, so use the middle mouse button\n            # instead.  It doesn't seem that it's possible to disable\n            # the context menu in recent versions of Chrome.\n            if button == 2:\n                button = 3\n\n            if e_type == 'button_press':\n                self.button_press_event(x, y, button)\n            elif e_type == 'button_release':\n                self.button_release_event(x, y, button)\n            elif e_type == 'motion_notify':\n                self.motion_notify_event(x, y)\n        elif e_type in ('key_press', 'key_release'):\n            key = event['key']\n\n            if e_type == 'key_press':\n                self.key_press_event(key)\n            elif e_type == 'key_release':\n                self.key_release_event(key)\n        elif e_type == 'toolbar_button':\n            # TODO: Be more suspicious of the input\n            getattr(self.toolbar, event['name'])()\n        elif e_type == 'refresh':\n            figure_label = self.figure.get_label()\n            if not figure_label:\n                figure_label = \"Figure {0}\".format(self.manager.num)\n            self.send_event('figure_label', label=figure_label)\n            self._force_full = True\n            self.draw_idle()\n        else:\n            handler = getattr(self, 'handle_{}'.format(e_type), None)\n            if handler is None:\n                import warnings\n                warnings.warn('Unhandled message type {}. {}'.format(\n                                                        e_type, event))\n            else:\n                return handler(event)\n\n    def handle_resize(self, event):\n        x, y = event.get('width', 800), event.get('height', 800)\n        x, y = int(x), int(y)\n        fig = self.figure\n        # An attempt at approximating the figure size in pixels.\n        fig.set_size_inches(x / fig.dpi, y / fig.dpi)\n\n        _, _, w, h = self.figure.bbox.bounds\n        # Acknowledge the resize, and force the viewer to update the\n        # canvas size to the figure's new size (which is hopefully\n        # identical or within a pixel or so).\n        self._png_is_old = True\n        self.manager.resize(w, h)\n\n    def handle_send_image_mode(self, event):\n        # The client requests notification of what the current image mode is.\n        self.send_event('image_mode', mode=self._current_image_mode)\n\n    def send_event(self, event_type, **kwargs):\n        self.manager._send_event(event_type, **kwargs)\n\n    def start_event_loop(self, timeout):\n        backend_bases.FigureCanvasBase.start_event_loop_default(\n            self, timeout)\n    start_event_loop.__doc__ = \\\n        backend_bases.FigureCanvasBase.start_event_loop_default.__doc__\n\n    def stop_event_loop(self):\n        backend_bases.FigureCanvasBase.stop_event_loop_default(self)\n    stop_event_loop.__doc__ = \\\n        backend_bases.FigureCanvasBase.stop_event_loop_default.__doc__\n\n\n_JQUERY_ICON_CLASSES = {\n    'home': 'ui-icon ui-icon-home',\n    'back': 'ui-icon ui-icon-circle-arrow-w',\n    'forward': 'ui-icon ui-icon-circle-arrow-e',\n    'zoom_to_rect': 'ui-icon ui-icon-search',\n    'move': 'ui-icon ui-icon-arrow-4',\n    'download': 'ui-icon ui-icon-disk',\n    None: None,\n}\n\n\nclass NavigationToolbar2WebAgg(backend_bases.NavigationToolbar2):\n\n    # Use the standard toolbar items + download button\n    toolitems = [(text, tooltip_text, _JQUERY_ICON_CLASSES[image_file],\n                  name_of_method)\n                 for text, tooltip_text, image_file, name_of_method\n                 in (backend_bases.NavigationToolbar2.toolitems +\n                     (('Download', 'Download plot', 'download', 'download'),))\n                 if image_file in _JQUERY_ICON_CLASSES]\n\n    def _init_toolbar(self):\n        self.message = ''\n        self.cursor = 0\n\n    def set_message(self, message):\n        if message != self.message:\n            self.canvas.send_event(\"message\", message=message)\n        self.message = message\n\n    def set_cursor(self, cursor):\n        if cursor != self.cursor:\n            self.canvas.send_event(\"cursor\", cursor=cursor)\n        self.cursor = cursor\n\n    def dynamic_update(self):\n        self.canvas.draw_idle()\n\n    def draw_rubberband(self, event, x0, y0, x1, y1):\n        self.canvas.send_event(\n            \"rubberband\", x0=x0, y0=y0, x1=x1, y1=y1)\n\n    def release_zoom(self, event):\n        backend_bases.NavigationToolbar2.release_zoom(self, event)\n        self.canvas.send_event(\n            \"rubberband\", x0=-1, y0=-1, x1=-1, y1=-1)\n\n\nclass FigureManagerWebAgg(backend_bases.FigureManagerBase):\n    ToolbarCls = NavigationToolbar2WebAgg\n\n    def __init__(self, canvas, num):\n        backend_bases.FigureManagerBase.__init__(self, canvas, num)\n\n        self.web_sockets = set()\n\n        self.toolbar = self._get_toolbar(canvas)\n\n    def show(self):\n        pass\n\n    def _get_toolbar(self, canvas):\n        toolbar = self.ToolbarCls(canvas)\n        return toolbar\n\n    def resize(self, w, h):\n        self._send_event('resize', size=(w, h))\n\n    def set_window_title(self, title):\n        self._send_event('figure_label', label=title)\n\n    # The following methods are specific to FigureManagerWebAgg\n\n    def add_web_socket(self, web_socket):\n        assert hasattr(web_socket, 'send_binary')\n        assert hasattr(web_socket, 'send_json')\n\n        self.web_sockets.add(web_socket)\n\n        _, _, w, h = self.canvas.figure.bbox.bounds\n        self.resize(w, h)\n        self._send_event('refresh')\n\n    def remove_web_socket(self, web_socket):\n        self.web_sockets.remove(web_socket)\n\n    def handle_json(self, content):\n        self.canvas.handle_event(content)\n\n    def refresh_all(self):\n        if self.web_sockets:\n            diff = self.canvas.get_diff_image()\n            for s in self.web_sockets:\n                s.send_binary(diff)\n\n    @classmethod\n    def get_javascript(cls, stream=None):\n        if stream is None:\n            output = io.StringIO()\n        else:\n            output = stream\n\n        with io.open(os.path.join(\n                os.path.dirname(__file__),\n                \"web_backend\",\n                \"mpl.js\"), encoding='utf8') as fd:\n            output.write(fd.read())\n\n        toolitems = []\n        for name, tooltip, image, method in cls.ToolbarCls.toolitems:\n            if name is None:\n                toolitems.append(['', '', '', ''])\n            else:\n                toolitems.append([name, tooltip, image, method])\n        output.write(\"mpl.toolbar_items = {0};\\n\\n\".format(\n            json.dumps(toolitems)))\n\n        extensions = []\n        for filetype, ext in sorted(FigureCanvasWebAggCore.\n                                    get_supported_filetypes_grouped().\n                                    items()):\n            extensions.append(ext[0])\n        output.write(\"mpl.extensions = {0};\\n\\n\".format(\n            json.dumps(extensions)))\n\n        output.write(\"mpl.default_extension = {0};\".format(\n            json.dumps(FigureCanvasWebAggCore.get_default_filetype())))\n\n        if stream is None:\n            return output.getvalue()\n\n    @classmethod\n    def get_static_file_path(cls):\n        return os.path.join(os.path.dirname(__file__), 'web_backend')\n\n    def _send_event(self, event_type, **kwargs):\n        payload = {'type': event_type}\n        payload.update(kwargs)\n        for s in self.web_sockets:\n            s.send_json(payload)\n", "patch": "@@ -143,8 +143,7 @@ def get_diff_image(self):\n             # TODO: We should write a new version of write_png that\n             # handles the differencing inline\n             _png.write_png(\n-                output.tostring(),\n-                output.shape[1], output.shape[0],\n+                output,\n                 self._png_buffer)\n \n             # Swap the renderer frames"}
{"patches_id": 2, "files_id": 17, "language": "py", "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Ffigure.py", "raw_code": "\"\"\"\nThe figure module provides the top-level\n:class:`~matplotlib.artist.Artist`, the :class:`Figure`, which\ncontains all the plot elements.  The following classes are defined\n\n:class:`SubplotParams`\n    control the default spacing of the subplots\n\n:class:`Figure`\n    top level container for all plot elements\n\n\"\"\"\n\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport six\n\nimport warnings\nfrom operator import itemgetter\n\nimport numpy as np\n\nfrom matplotlib import rcParams\nfrom matplotlib import docstring\nfrom matplotlib import __version__ as _mpl_version\n\nimport matplotlib.artist as martist\nfrom matplotlib.artist import Artist, allow_rasterization\n\nimport matplotlib.cbook as cbook\n\nfrom matplotlib.cbook import Stack, iterable\n\nfrom matplotlib import _image\nfrom matplotlib.image import FigureImage\n\nimport matplotlib.colorbar as cbar\n\nfrom matplotlib.axes import Axes, SubplotBase, subplot_class_factory\nfrom matplotlib.blocking_input import BlockingMouseInput, BlockingKeyMouseInput\nfrom matplotlib.legend import Legend\nfrom matplotlib.patches import Rectangle\nfrom matplotlib.projections import (get_projection_names,\n                                    process_projection_requirements)\nfrom matplotlib.text import Text, _process_text_args\nfrom matplotlib.transforms import (Affine2D, Bbox, BboxTransformTo,\n                                   TransformedBbox)\nfrom matplotlib.backend_bases import NonGuiException\n\ndocstring.interpd.update(projection_names=get_projection_names())\n\n\nclass AxesStack(Stack):\n    \"\"\"\n    Specialization of the Stack to handle all tracking of Axes in a Figure.\n    This stack stores ``key, (ind, axes)`` pairs, where:\n\n        * **key** should be a hash of the args and kwargs\n          used in generating the Axes.\n        * **ind** is a serial number for tracking the order\n          in which axes were added.\n\n    The AxesStack is a callable, where ``ax_stack()`` returns\n    the current axes. Alternatively the :meth:`current_key_axes` will\n    return the current key and associated axes.\n\n    \"\"\"\n    def __init__(self):\n        Stack.__init__(self)\n        self._ind = 0\n\n    def as_list(self):\n        \"\"\"\n        Return a list of the Axes instances that have been added to the figure\n        \"\"\"\n        ia_list = [a for k, a in self._elements]\n        ia_list.sort()\n        return [a for i, a in ia_list]\n\n    def get(self, key):\n        \"\"\"\n        Return the Axes instance that was added with *key*.\n        If it is not present, return None.\n        \"\"\"\n        item = dict(self._elements).get(key)\n        if item is None:\n            return None\n        return item[1]\n\n    def _entry_from_axes(self, e):\n        ind, k = dict([(a, (ind, k)) for (k, (ind, a)) in self._elements])[e]\n        return (k, (ind, e))\n\n    def remove(self, a):\n        \"\"\"Remove the axes from the stack.\"\"\"\n        Stack.remove(self, self._entry_from_axes(a))\n\n    def bubble(self, a):\n        \"\"\"\n        Move the given axes, which must already exist in the\n        stack, to the top.\n        \"\"\"\n        return Stack.bubble(self, self._entry_from_axes(a))\n\n    def add(self, key, a):\n        \"\"\"\n        Add Axes *a*, with key *key*, to the stack, and return the stack.\n\n        If *a* is already on the stack, don't add it again, but\n        return *None*.\n        \"\"\"\n        # All the error checking may be unnecessary; but this method\n        # is called so seldom that the overhead is negligible.\n        if not isinstance(a, Axes):\n            raise ValueError(\"second argument, %s, is not an Axes\" % a)\n        try:\n            hash(key)\n        except TypeError:\n            raise ValueError(\"first argument, %s, is not a valid key\" % key)\n\n        a_existing = self.get(key)\n        if a_existing is not None:\n            Stack.remove(self, (key, a_existing))\n            warnings.warn(\n                \"key %s already existed; Axes is being replaced\" % key)\n            # I don't think the above should ever happen.\n\n        if a in self:\n            return None\n        self._ind += 1\n        return Stack.push(self, (key, (self._ind, a)))\n\n    def current_key_axes(self):\n        \"\"\"\n        Return a tuple of ``(key, axes)`` for the active axes.\n\n        If no axes exists on the stack, then returns ``(None, None)``.\n\n        \"\"\"\n        if not len(self._elements):\n            return self._default, self._default\n        else:\n            key, (index, axes) = self._elements[self._pos]\n            return key, axes\n\n    def __call__(self):\n        return self.current_key_axes()[1]\n\n    def __contains__(self, a):\n        return a in self.as_list()\n\n\nclass SubplotParams:\n    \"\"\"\n    A class to hold the parameters for a subplot\n    \"\"\"\n    def __init__(self, left=None, bottom=None, right=None, top=None,\n                 wspace=None, hspace=None):\n        \"\"\"\n        All dimensions are fraction of the figure width or height.\n        All values default to their rc params\n\n        The following attributes are available\n\n        *left*  : 0.125\n            The left side of the subplots of the figure\n\n        *right* : 0.9\n            The right side of the subplots of the figure\n\n        *bottom* : 0.1\n            The bottom of the subplots of the figure\n\n        *top* : 0.9\n            The top of the subplots of the figure\n\n        *wspace* : 0.2\n            The amount of width reserved for blank space between subplots\n\n        *hspace* : 0.2\n            The amount of height reserved for white space between subplots\n        \"\"\"\n\n        self.validate = True\n        self.update(left, bottom, right, top, wspace, hspace)\n\n    def update(self, left=None, bottom=None, right=None, top=None,\n               wspace=None, hspace=None):\n        \"\"\"\n        Update the current values.  If any kwarg is None, default to\n        the current value, if set, otherwise to rc\n\n        \"\"\"\n\n        thisleft = getattr(self, 'left', None)\n        thisright = getattr(self, 'right', None)\n        thistop = getattr(self, 'top', None)\n        thisbottom = getattr(self, 'bottom', None)\n        thiswspace = getattr(self, 'wspace', None)\n        thishspace = getattr(self, 'hspace', None)\n\n        self._update_this('left', left)\n        self._update_this('right', right)\n        self._update_this('bottom', bottom)\n        self._update_this('top', top)\n        self._update_this('wspace', wspace)\n        self._update_this('hspace', hspace)\n\n        def reset():\n            self.left = thisleft\n            self.right = thisright\n            self.top = thistop\n            self.bottom = thisbottom\n            self.wspace = thiswspace\n            self.hspace = thishspace\n\n        if self.validate:\n            if self.left >= self.right:\n                reset()\n                raise ValueError('left cannot be >= right')\n\n            if self.bottom >= self.top:\n                reset()\n                raise ValueError('bottom cannot be >= top')\n\n    def _update_this(self, s, val):\n        if val is None:\n            val = getattr(self, s, None)\n            if val is None:\n                key = 'figure.subplot.' + s\n                val = rcParams[key]\n\n        setattr(self, s, val)\n\n\nclass Figure(Artist):\n\n    \"\"\"\n    The Figure instance supports callbacks through a *callbacks*\n    attribute which is a :class:`matplotlib.cbook.CallbackRegistry`\n    instance.  The events you can connect to are 'dpi_changed', and\n    the callback will be called with ``func(fig)`` where fig is the\n    :class:`Figure` instance.\n\n    *patch*\n       The figure patch is drawn by a\n       :class:`matplotlib.patches.Rectangle` instance\n\n    *suppressComposite*\n       For multiple figure images, the figure will make composite\n       images depending on the renderer option_image_nocomposite\n       function.  If suppressComposite is True|False, this will\n       override the renderer.\n    \"\"\"\n\n    def __str__(self):\n        return \"Figure(%gx%g)\" % tuple(self.bbox.size)\n\n    def __init__(self,\n                 figsize=None,  # defaults to rc figure.figsize\n                 dpi=None,  # defaults to rc figure.dpi\n                 facecolor=None,  # defaults to rc figure.facecolor\n                 edgecolor=None,  # defaults to rc figure.edgecolor\n                 linewidth=0.0,  # the default linewidth of the frame\n                 frameon=None,  # whether or not to draw the figure frame\n                 subplotpars=None,  # default to rc\n                 tight_layout=None,  # default to rc figure.autolayout\n                 ):\n        \"\"\"\n        *figsize*\n            w,h tuple in inches\n\n        *dpi*\n            Dots per inch\n\n        *facecolor*\n            The figure patch facecolor; defaults to rc ``figure.facecolor``\n\n        *edgecolor*\n            The figure patch edge color; defaults to rc ``figure.edgecolor``\n\n        *linewidth*\n            The figure patch edge linewidth; the default linewidth of the frame\n\n        *frameon*\n            If *False*, suppress drawing the figure frame\n\n        *subplotpars*\n            A :class:`SubplotParams` instance, defaults to rc\n\n        *tight_layout*\n            If *False* use *subplotpars*; if *True* adjust subplot\n            parameters using :meth:`tight_layout` with default padding.\n            When providing a dict containing the keys `pad`, `w_pad`, `h_pad`\n            and `rect`, the default :meth:`tight_layout` paddings will be\n            overridden.\n            Defaults to rc ``figure.autolayout``.\n        \"\"\"\n        Artist.__init__(self)\n\n        self.callbacks = cbook.CallbackRegistry()\n\n        if figsize is None:\n            figsize = rcParams['figure.figsize']\n        if dpi is None:\n            dpi = rcParams['figure.dpi']\n        if facecolor is None:\n            facecolor = rcParams['figure.facecolor']\n        if edgecolor is None:\n            edgecolor = rcParams['figure.edgecolor']\n        if frameon is None:\n            frameon = rcParams['figure.frameon']\n\n        self.dpi_scale_trans = Affine2D()\n        self.dpi = dpi\n        self.bbox_inches = Bbox.from_bounds(0, 0, *figsize)\n        self.bbox = TransformedBbox(self.bbox_inches, self.dpi_scale_trans)\n\n        self.frameon = frameon\n\n        self.transFigure = BboxTransformTo(self.bbox)\n\n        # the figurePatch name is deprecated\n        self.patch = self.figurePatch = Rectangle(\n            xy=(0, 0), width=1, height=1,\n            facecolor=facecolor, edgecolor=edgecolor,\n            linewidth=linewidth)\n        self._set_artist_props(self.patch)\n        self.patch.set_aa(False)\n\n        self._hold = rcParams['axes.hold']\n        self.canvas = None\n        self._suptitle = None\n\n        if subplotpars is None:\n            subplotpars = SubplotParams()\n\n        self.subplotpars = subplotpars\n        self.set_tight_layout(tight_layout)\n\n        self._axstack = AxesStack()  # track all figure axes and current axes\n        self.clf()\n        self._cachedRenderer = None\n\n    # TODO: I'd like to dynamically add the _repr_html_ method\n    # to the figure in the right context, but then IPython doesn't\n    # use it, for some reason.\n\n    def _repr_html_(self):\n        # We can't use \"isinstance\" here, because then we'd end up importing\n        # webagg unconditiionally.\n        if (self.canvas is not None and\n            'WebAgg' in self.canvas.__class__.__name__):\n            from matplotlib.backends import backend_webagg\n            return backend_webagg.ipython_inline_display(self)\n\n    def show(self, warn=True):\n        \"\"\"\n        If using a GUI backend with pyplot, display the figure window.\n\n        If the figure was not created using\n        :func:`~matplotlib.pyplot.figure`, it will lack a\n        :class:`~matplotlib.backend_bases.FigureManagerBase`, and\n        will raise an AttributeError.\n\n        For non-GUI backends, this does nothing, in which case\n        a warning will be issued if *warn* is True (default).\n        \"\"\"\n        try:\n            manager = getattr(self.canvas, 'manager')\n        except AttributeError as err:\n            raise AttributeError(\"%s\\n\"\n                                 \"Figure.show works only \"\n                                 \"for figures managed by pyplot, normally \"\n                                 \"created by pyplot.figure().\" % err)\n\n        if manager is not None:\n            try:\n                manager.show()\n                return\n            except NonGuiException:\n                pass\n        if warn:\n            import warnings\n            warnings.warn(\n                \"matplotlib is currently using a non-GUI backend, \"\n                \"so cannot show the figure\")\n\n    def _get_axes(self):\n        return self._axstack.as_list()\n\n    axes = property(fget=_get_axes, doc=\"Read-only: list of axes in Figure\")\n\n    def _get_dpi(self):\n        return self._dpi\n\n    def _set_dpi(self, dpi):\n        self._dpi = dpi\n        self.dpi_scale_trans.clear().scale(dpi, dpi)\n        self.callbacks.process('dpi_changed', self)\n    dpi = property(_get_dpi, _set_dpi)\n\n    def get_tight_layout(self):\n        \"\"\"\n        Return the Boolean flag, True to use :meth`tight_layout` when drawing.\n        \"\"\"\n        return self._tight\n\n    def set_tight_layout(self, tight):\n        \"\"\"\n        Set whether :meth:`tight_layout` is used upon drawing.\n        If None, the rcParams['figure.autolayout'] value will be set.\n\n        When providing a dict containing the keys `pad`, `w_pad`, `h_pad`\n        and `rect`, the default :meth:`tight_layout` paddings will be\n        overridden.\n\n        ACCEPTS: [True | False | dict | None ]\n        \"\"\"\n        if tight is None:\n            tight = rcParams['figure.autolayout']\n        self._tight = bool(tight)\n        self._tight_parameters = tight if isinstance(tight, dict) else {}\n\n    def autofmt_xdate(self, bottom=0.2, rotation=30, ha='right'):\n        \"\"\"\n        Date ticklabels often overlap, so it is useful to rotate them\n        and right align them.  Also, a common use case is a number of\n        subplots with shared xaxes where the x-axis is date data.  The\n        ticklabels are often long, and it helps to rotate them on the\n        bottom subplot and turn them off on other subplots, as well as\n        turn off xlabels.\n\n        *bottom*\n            The bottom of the subplots for :meth:`subplots_adjust`\n\n        *rotation*\n            The rotation of the xtick labels\n\n        *ha*\n            The horizontal alignment of the xticklabels\n        \"\"\"\n        allsubplots = np.alltrue([hasattr(ax, 'is_last_row') for ax\n                                  in self.axes])\n        if len(self.axes) == 1:\n            for label in self.axes[0].get_xticklabels():\n                label.set_ha(ha)\n                label.set_rotation(rotation)\n        else:\n            if allsubplots:\n                for ax in self.get_axes():\n                    if ax.is_last_row():\n                        for label in ax.get_xticklabels():\n                            label.set_ha(ha)\n                            label.set_rotation(rotation)\n                    else:\n                        for label in ax.get_xticklabels():\n                            label.set_visible(False)\n                        ax.set_xlabel('')\n\n        if allsubplots:\n            self.subplots_adjust(bottom=bottom)\n\n    def get_children(self):\n        'get a list of artists contained in the figure'\n        children = [self.patch]\n        children.extend(self.artists)\n        children.extend(self.axes)\n        children.extend(self.lines)\n        children.extend(self.patches)\n        children.extend(self.texts)\n        children.extend(self.images)\n        children.extend(self.legends)\n        return children\n\n    def contains(self, mouseevent):\n        \"\"\"\n        Test whether the mouse event occurred on the figure.\n\n        Returns True,{}\n        \"\"\"\n        if six.callable(self._contains):\n            return self._contains(self, mouseevent)\n        # inside = mouseevent.x >= 0 and mouseevent.y >= 0\n        inside = self.bbox.contains(mouseevent.x, mouseevent.y)\n\n        return inside, {}\n\n    def get_window_extent(self, *args, **kwargs):\n        'get the figure bounding box in display space; kwargs are void'\n        return self.bbox\n\n    def suptitle(self, t, **kwargs):\n        \"\"\"\n        Add a centered title to the figure.\n\n        kwargs are :class:`matplotlib.text.Text` properties.  Using figure\n        coordinates, the defaults are:\n\n          *x* : 0.5\n            The x location of the text in figure coords\n\n          *y* : 0.98\n            The y location of the text in figure coords\n\n          *horizontalalignment* : 'center'\n            The horizontal alignment of the text\n\n          *verticalalignment* : 'top'\n            The vertical alignment of the text\n\n        A :class:`matplotlib.text.Text` instance is returned.\n\n        Example::\n\n          fig.suptitle('this is the figure title', fontsize=12)\n        \"\"\"\n        x = kwargs.pop('x', 0.5)\n        y = kwargs.pop('y', 0.98)\n        if ('horizontalalignment' not in kwargs) and ('ha' not in kwargs):\n            kwargs['horizontalalignment'] = 'center'\n\n        if ('verticalalignment' not in kwargs) and ('va' not in kwargs):\n            kwargs['verticalalignment'] = 'top'\n\n        sup = self.text(x, y, t, **kwargs)\n        if self._suptitle is not None:\n            self._suptitle.set_text(t)\n            self._suptitle.set_position((x, y))\n            self._suptitle.update_from(sup)\n            sup.remove()\n        else:\n            self._suptitle = sup\n        return self._suptitle\n\n    def set_canvas(self, canvas):\n        \"\"\"\n        Set the canvas the contains the figure\n\n        ACCEPTS: a FigureCanvas instance\n        \"\"\"\n        self.canvas = canvas\n\n    def hold(self, b=None):\n        \"\"\"\n        Set the hold state.  If hold is None (default), toggle the\n        hold state.  Else set the hold state to boolean value b.\n\n        e.g.::\n\n            hold()      # toggle hold\n            hold(True)  # hold is on\n            hold(False) # hold is off\n        \"\"\"\n        if b is None:\n            self._hold = not self._hold\n        else:\n            self._hold = b\n\n    def figimage(self, X,\n                 xo=0,\n                 yo=0,\n                 alpha=None,\n                 norm=None,\n                 cmap=None,\n                 vmin=None,\n                 vmax=None,\n                 origin=None,\n                 **kwargs):\n        \"\"\"\n        Adds a non-resampled image to the figure.\n\n        call signatures::\n\n          figimage(X, **kwargs)\n\n        adds a non-resampled array *X* to the figure.\n\n        ::\n\n          figimage(X, xo, yo)\n\n        with pixel offsets *xo*, *yo*,\n\n        *X* must be a float array:\n\n        * If *X* is MxN, assume luminance (grayscale)\n        * If *X* is MxNx3, assume RGB\n        * If *X* is MxNx4, assume RGBA\n\n        Optional keyword arguments:\n\n          =========   =========================================================\n          Keyword     Description\n          =========   =========================================================\n          xo or yo    An integer, the *x* and *y* image offset in pixels\n          cmap        a :class:`matplotlib.colors.Colormap` instance, eg\n                      cm.jet. If *None*, default to the rc ``image.cmap``\n                      value\n          norm        a :class:`matplotlib.colors.Normalize` instance. The\n                      default is normalization().  This scales luminance -> 0-1\n          vmin|vmax   are used to scale a luminance image to 0-1.  If either\n                      is *None*, the min and max of the luminance values will\n                      be used.  Note if you pass a norm instance, the settings\n                      for *vmin* and *vmax* will be ignored.\n          alpha       the alpha blending value, default is *None*\n          origin      [ 'upper' | 'lower' ] Indicates where the [0,0] index of\n                      the array is in the upper left or lower left corner of\n                      the axes. Defaults to the rc image.origin value\n          =========   =========================================================\n\n        figimage complements the axes image\n        (:meth:`~matplotlib.axes.Axes.imshow`) which will be resampled\n        to fit the current axes.  If you want a resampled image to\n        fill the entire figure, you can define an\n        :class:`~matplotlib.axes.Axes` with size [0,1,0,1].\n\n        An :class:`matplotlib.image.FigureImage` instance is returned.\n\n        .. plot:: mpl_examples/pylab_examples/figimage_demo.py\n\n\n        Additional kwargs are Artist kwargs passed on to\n        :class:`~matplotlib.image.FigureImage`\n        \"\"\"\n\n        if not self._hold:\n            self.clf()\n\n        im = FigureImage(self, cmap, norm, xo, yo, origin, **kwargs)\n        im.set_array(X)\n        im.set_alpha(alpha)\n        if norm is None:\n            im.set_clim(vmin, vmax)\n        self.images.append(im)\n        im._remove_method = lambda h: self.images.remove(h)\n        return im\n\n    def set_size_inches(self, *args, **kwargs):\n        \"\"\"\n        set_size_inches(w,h, forward=False)\n\n        Set the figure size in inches (1in == 2.54cm)\n\n        Usage::\n\n             fig.set_size_inches(w,h)  # OR\n             fig.set_size_inches((w,h) )\n\n        optional kwarg *forward=True* will cause the canvas size to be\n        automatically updated; eg you can resize the figure window\n        from the shell\n\n        ACCEPTS: a w,h tuple with w,h in inches\n\n        See Also\n        --------\n\n        matplotlib.Figure.get_size_inches\n        \"\"\"\n\n        forward = kwargs.get('forward', False)\n        if len(args) == 1:\n            w, h = args[0]\n        else:\n            w, h = args\n\n        dpival = self.dpi\n        self.bbox_inches.p1 = w, h\n\n        if forward:\n            dpival = self.dpi\n            canvasw = w * dpival\n            canvash = h * dpival\n            manager = getattr(self.canvas, 'manager', None)\n            if manager is not None:\n                manager.resize(int(canvasw), int(canvash))\n\n    def get_size_inches(self):\n        \"\"\"\n        Returns the current size of the figure in inches (1in == 2.54cm)\n        as an numpy array.\n\n        Returns\n        -------\n        size : ndarray\n           The size of the figure in inches\n\n        See Also\n        --------\n\n        matplotlib.Figure.set_size_inches\n        \"\"\"\n        return np.array(self.bbox_inches.p1)\n\n    def get_edgecolor(self):\n        'Get the edge color of the Figure rectangle'\n        return self.patch.get_edgecolor()\n\n    def get_facecolor(self):\n        'Get the face color of the Figure rectangle'\n        return self.patch.get_facecolor()\n\n    def get_figwidth(self):\n        'Return the figwidth as a float'\n        return self.bbox_inches.width\n\n    def get_figheight(self):\n        'Return the figheight as a float'\n        return self.bbox_inches.height\n\n    def get_dpi(self):\n        'Return the dpi as a float'\n        return self.dpi\n\n    def get_frameon(self):\n        'get the boolean indicating frameon'\n        return self.frameon\n\n    def set_edgecolor(self, color):\n        \"\"\"\n        Set the edge color of the Figure rectangle\n\n        ACCEPTS: any matplotlib color - see help(colors)\n        \"\"\"\n        self.patch.set_edgecolor(color)\n\n    def set_facecolor(self, color):\n        \"\"\"\n        Set the face color of the Figure rectangle\n\n        ACCEPTS: any matplotlib color - see help(colors)\n        \"\"\"\n        self.patch.set_facecolor(color)\n\n    def set_dpi(self, val):\n        \"\"\"\n        Set the dots-per-inch of the figure\n\n        ACCEPTS: float\n        \"\"\"\n        self.dpi = val\n\n    def set_figwidth(self, val):\n        \"\"\"\n        Set the width of the figure in inches\n\n        ACCEPTS: float\n        \"\"\"\n        self.bbox_inches.x1 = val\n\n    def set_figheight(self, val):\n        \"\"\"\n        Set the height of the figure in inches\n\n        ACCEPTS: float\n        \"\"\"\n        self.bbox_inches.y1 = val\n\n    def set_frameon(self, b):\n        \"\"\"\n        Set whether the figure frame (background) is displayed or invisible\n\n        ACCEPTS: boolean\n        \"\"\"\n        self.frameon = b\n\n    def delaxes(self, a):\n        'remove a from the figure and update the current axes'\n        self._axstack.remove(a)\n        for func in self._axobservers:\n            func(self)\n\n    def _make_key(self, *args, **kwargs):\n        'make a hashable key out of args and kwargs'\n\n        def fixitems(items):\n            #items may have arrays and lists in them, so convert them\n            # to tuples for the key\n            ret = []\n            for k, v in items:\n                if iterable(v):\n                    v = tuple(v)\n                ret.append((k, v))\n            return tuple(ret)\n\n        def fixlist(args):\n            ret = []\n            for a in args:\n                if iterable(a):\n                    a = tuple(a)\n                ret.append(a)\n            return tuple(ret)\n\n        key = fixlist(args), fixitems(six.iteritems(kwargs))\n        return key\n\n    @docstring.dedent_interpd\n    def add_axes(self, *args, **kwargs):\n        \"\"\"\n        Add an axes at position *rect* [*left*, *bottom*, *width*,\n        *height*] where all quantities are in fractions of figure\n        width and height.  kwargs are legal\n        :class:`~matplotlib.axes.Axes` kwargs plus *projection* which\n        sets the projection type of the axes.  (For backward\n        compatibility, ``polar=True`` may also be provided, which is\n        equivalent to ``projection='polar'``).  Valid values for\n        *projection* are: %(projection_names)s.  Some of these\n        projections support  additional kwargs, which may be provided\n        to :meth:`add_axes`. Typical usage::\n\n            rect = l,b,w,h\n            fig.add_axes(rect)\n            fig.add_axes(rect, frameon=False, axisbg='g')\n            fig.add_axes(rect, polar=True)\n            fig.add_axes(rect, projection='polar')\n            fig.add_axes(ax)\n\n        If the figure already has an axes with the same parameters,\n        then it will simply make that axes current and return it.  If\n        you do not want this behavior, e.g., you want to force the\n        creation of a new Axes, you must use a unique set of args and\n        kwargs.  The axes :attr:`~matplotlib.axes.Axes.label`\n        attribute has been exposed for this purpose.  e.g., if you want\n        two axes that are otherwise identical to be added to the\n        figure, make sure you give them unique labels::\n\n            fig.add_axes(rect, label='axes1')\n            fig.add_axes(rect, label='axes2')\n\n        In rare circumstances, add_axes may be called with a single\n        argument, an Axes instance already created in the present\n        figure but not in the figure's list of axes.  For example,\n        if an axes has been removed with :meth:`delaxes`, it can\n        be restored with::\n\n            fig.add_axes(ax)\n\n        In all cases, the :class:`~matplotlib.axes.Axes` instance\n        will be returned.\n\n        In addition to *projection*, the following kwargs are supported:\n\n        %(Axes)s\n        \"\"\"\n        if not len(args):\n            return\n\n        # shortcut the projection \"key\" modifications later on, if an axes\n        # with the exact args/kwargs exists, return it immediately.\n        key = self._make_key(*args, **kwargs)\n        ax = self._axstack.get(key)\n        if ax is not None:\n            self.sca(ax)\n            return ax\n\n        if isinstance(args[0], Axes):\n            a = args[0]\n            assert(a.get_figure() is self)\n        else:\n            rect = args[0]\n            projection_class, kwargs, key = process_projection_requirements(\n                self, *args, **kwargs)\n\n            # check that an axes of this type doesn't already exist, if it\n            # does, set it as active and return it\n            ax = self._axstack.get(key)\n            if ax is not None and isinstance(ax, projection_class):\n                self.sca(ax)\n                return ax\n\n            # create the new axes using the axes class given\n            a = projection_class(self, rect, **kwargs)\n\n        self._axstack.add(key, a)\n        self.sca(a)\n        return a\n\n    @docstring.dedent_interpd\n    def add_subplot(self, *args, **kwargs):\n        \"\"\"\n        Add a subplot.  Examples::\n\n            fig.add_subplot(111)\n\n            # equivalent but more general\n            fig.add_subplot(1,1,1)\n\n            # add subplot with red background\n            fig.add_subplot(212, axisbg='r')\n\n            # add a polar subplot\n            fig.add_subplot(111, projection='polar')\n\n            # add Subplot instance sub\n            fig.add_subplot(sub)\n\n        *kwargs* are legal :class:`~matplotlib.axes.Axes` kwargs plus\n        *projection*, which chooses a projection type for the axes.\n        (For backward compatibility, *polar=True* may also be\n        provided, which is equivalent to *projection='polar'*). Valid\n        values for *projection* are: %(projection_names)s.  Some of\n        these projections\n        support additional *kwargs*, which may be provided to\n        :meth:`add_axes`.\n\n        The :class:`~matplotlib.axes.Axes` instance will be returned.\n\n        If the figure already has a subplot with key (*args*,\n        *kwargs*) then it will simply make that subplot current and\n        return it.\n\n        .. seealso:: :meth:`~matplotlib.pyplot.subplot` for an\n           explanation of the args.\n\n        The following kwargs are supported:\n\n        %(Axes)s\n        \"\"\"\n        if not len(args):\n            return\n\n        if len(args) == 1 and isinstance(args[0], int):\n            args = tuple([int(c) for c in str(args[0])])\n            if len(args) != 3:\n                raise ValueError(\"Integer subplot specification must \" +\n                                 \"be a three digit number.  \" +\n                                 \"Not {n:d}\".format(n=len(args)))\n\n        if isinstance(args[0], SubplotBase):\n\n            a = args[0]\n            assert(a.get_figure() is self)\n            # make a key for the subplot (which includes the axes object id\n            # in the hash)\n            key = self._make_key(*args, **kwargs)\n        else:\n            projection_class, kwargs, key = process_projection_requirements(\n                self, *args, **kwargs)\n\n            # try to find the axes with this key in the stack\n            ax = self._axstack.get(key)\n\n            if ax is not None:\n                if isinstance(ax, projection_class):\n                    # the axes already existed, so set it as active & return\n                    self.sca(ax)\n                    return ax\n                else:\n                    # Undocumented convenience behavior:\n                    # subplot(111); subplot(111, projection='polar')\n                    # will replace the first with the second.\n                    # Without this, add_subplot would be simpler and\n                    # more similar to add_axes.\n                    self._axstack.remove(ax)\n\n            a = subplot_class_factory(projection_class)(self, *args, **kwargs)\n\n        self._axstack.add(key, a)\n        self.sca(a)\n        return a\n\n    def clf(self, keep_observers=False):\n        \"\"\"\n        Clear the figure.\n\n        Set *keep_observers* to True if, for example,\n        a gui widget is tracking the axes in the figure.\n        \"\"\"\n        self.suppressComposite = None\n        self.callbacks = cbook.CallbackRegistry()\n\n        for ax in tuple(self.axes):  # Iterate over the copy.\n            ax.cla()\n            self.delaxes(ax)         # removes ax from self._axstack\n\n        toolbar = getattr(self.canvas, 'toolbar', None)\n        if toolbar is not None:\n            toolbar.update()\n        self._axstack.clear()\n        self.artists = []\n        self.lines = []\n        self.patches = []\n        self.texts = []\n        self.images = []\n        self.legends = []\n        if not keep_observers:\n            self._axobservers = []\n        self._suptitle = None\n\n    def clear(self):\n        \"\"\"\n        Clear the figure -- synonym for :meth:`clf`.\n        \"\"\"\n        self.clf()\n\n    @allow_rasterization\n    def draw(self, renderer):\n        \"\"\"\n        Render the figure using :class:`matplotlib.backend_bases.RendererBase`\n        instance *renderer*.\n        \"\"\"\n        # draw the figure bounding box, perhaps none for white figure\n        if not self.get_visible():\n            return\n        renderer.open_group('figure')\n\n        if self.get_tight_layout() and self.axes:\n            try:\n                self.tight_layout(renderer, **self._tight_parameters)\n            except ValueError:\n                pass\n                # ValueError can occur when resizing a window.\n\n        if self.frameon:\n            self.patch.draw(renderer)\n\n        # a list of (zorder, func_to_call, list_of_args)\n        dsu = []\n\n        for a in self.patches:\n            dsu.append((a.get_zorder(), a, a.draw, [renderer]))\n\n        for a in self.lines:\n            dsu.append((a.get_zorder(), a, a.draw, [renderer]))\n\n        for a in self.artists:\n            dsu.append((a.get_zorder(), a, a.draw, [renderer]))\n\n        # override the renderer default if self.suppressComposite\n        # is not None\n        not_composite = renderer.option_image_nocomposite()\n        if self.suppressComposite is not None:\n            not_composite = self.suppressComposite\n\n        if (len(self.images) <= 1 or not_composite or\n                not cbook.allequal([im.origin for im in self.images])):\n            for a in self.images:\n                dsu.append((a.get_zorder(), a, a.draw, [renderer]))\n        else:\n            # make a composite image blending alpha\n            # list of (_image.Image, ox, oy)\n            mag = renderer.get_image_magnification()\n            ims = [(im.make_image(mag), im.ox, im.oy, im.get_alpha())\n                   for im in self.images]\n\n            im = _image.from_images(int(self.bbox.height * mag),\n                                    int(self.bbox.width * mag),\n                                    ims)\n\n            im.is_grayscale = False\n            l, b, w, h = self.bbox.bounds\n\n            def draw_composite():\n                gc = renderer.new_gc()\n                gc.set_clip_rectangle(self.bbox)\n                gc.set_clip_path(self.get_clip_path())\n                renderer.draw_image(gc, l, b, im)\n                gc.restore()\n\n            dsu.append((self.images[0].get_zorder(), self.images[0],\n                        draw_composite, []))\n\n        # render the axes\n        for a in self.axes:\n            dsu.append((a.get_zorder(), a, a.draw, [renderer]))\n\n        # render the figure text\n        for a in self.texts:\n            dsu.append((a.get_zorder(), a, a.draw, [renderer]))\n\n        for a in self.legends:\n            dsu.append((a.get_zorder(), a, a.draw, [renderer]))\n\n        dsu = [row for row in dsu if not row[1].get_animated()]\n        dsu.sort(key=itemgetter(0))\n        for zorder, a, func, args in dsu:\n            func(*args)\n\n        renderer.close_group('figure')\n\n        self._cachedRenderer = renderer\n\n        self.canvas.draw_event(renderer)\n\n    def draw_artist(self, a):\n        \"\"\"\n        draw :class:`matplotlib.artist.Artist` instance *a* only --\n        this is available only after the figure is drawn\n        \"\"\"\n        assert self._cachedRenderer is not None\n        a.draw(self._cachedRenderer)\n\n    def get_axes(self):\n        return self.axes\n\n    def legend(self, handles, labels, *args, **kwargs):\n        \"\"\"\n        Place a legend in the figure.  Labels are a sequence of\n        strings, handles is a sequence of\n        :class:`~matplotlib.lines.Line2D` or\n        :class:`~matplotlib.patches.Patch` instances, and loc can be a\n        string or an integer specifying the legend location\n\n        USAGE::\n\n          legend( (line1, line2, line3),\n                  ('label1', 'label2', 'label3'),\n                  'upper right')\n\n        The *loc* location codes are::\n\n          'best' : 0,          (currently not supported for figure legends)\n          'upper right'  : 1,\n          'upper left'   : 2,\n          'lower left'   : 3,\n          'lower right'  : 4,\n          'right'        : 5,\n          'center left'  : 6,\n          'center right' : 7,\n          'lower center' : 8,\n          'upper center' : 9,\n          'center'       : 10,\n\n        *loc* can also be an (x,y) tuple in figure coords, which\n        specifies the lower left of the legend box.  figure coords are\n        (0,0) is the left, bottom of the figure and 1,1 is the right,\n        top.\n\n        Keyword arguments:\n\n          *prop*: [ *None* | FontProperties | dict ]\n            A :class:`matplotlib.font_manager.FontProperties`\n            instance. If *prop* is a dictionary, a new instance will be\n            created with *prop*. If *None*, use rc settings.\n\n          *numpoints*: integer\n            The number of points in the legend line, default is 4\n\n          *scatterpoints*: integer\n            The number of points in the legend line, default is 4\n\n          *scatteryoffsets*: list of floats\n            a list of yoffsets for scatter symbols in legend\n\n          *markerscale*: [ *None* | scalar ]\n            The relative size of legend markers vs. original. If *None*, use rc\n            settings.\n\n          *fancybox*: [ *None* | *False* | *True* ]\n            if *True*, draw a frame with a round fancybox.  If *None*, use rc\n\n          *shadow*: [ *None* | *False* | *True* ]\n            If *True*, draw a shadow behind legend. If *None*, use rc settings.\n\n          *ncol* : integer\n            number of columns. default is 1\n\n          *mode* : [ \"expand\" | *None* ]\n            if mode is \"expand\", the legend will be horizontally expanded\n            to fill the axes area (or *bbox_to_anchor*)\n\n          *title* : string\n            the legend title\n\n        Padding and spacing between various elements use following keywords\n        parameters. The dimensions of these values are given as a fraction\n        of the fontsize. Values from rcParams will be used if None.\n\n        ================   ====================================================\n        Keyword            Description\n        ================   ====================================================\n        borderpad          the fractional whitespace inside the legend border\n        labelspacing       the vertical space between the legend entries\n        handlelength       the length of the legend handles\n        handletextpad      the pad between the legend handle and text\n        borderaxespad      the pad between the axes and legend border\n        columnspacing      the spacing between columns\n        ================   ====================================================\n\n        .. Note:: Not all kinds of artist are supported by the legend.\n                  See LINK (FIXME) for details.\n\n        **Example:**\n\n        .. plot:: mpl_examples/pylab_examples/figlegend_demo.py\n        \"\"\"\n        l = Legend(self, handles, labels, *args, **kwargs)\n        self.legends.append(l)\n        l._remove_method = lambda h: self.legends.remove(h)\n        return l\n\n    @docstring.dedent_interpd\n    def text(self, x, y, s, *args, **kwargs):\n        \"\"\"\n        Add text to figure.\n\n        Call signature::\n\n          text(x, y, s, fontdict=None, **kwargs)\n\n        Add text to figure at location *x*, *y* (relative 0-1\n        coords). See :func:`~matplotlib.pyplot.text` for the meaning\n        of the other arguments.\n\n        kwargs control the :class:`~matplotlib.text.Text` properties:\n\n        %(Text)s\n        \"\"\"\n\n        override = _process_text_args({}, *args, **kwargs)\n        t = Text(x=x, y=y, text=s)\n\n        t.update(override)\n        self._set_artist_props(t)\n        self.texts.append(t)\n        t._remove_method = lambda h: self.texts.remove(h)\n        return t\n\n    def _set_artist_props(self, a):\n        if a != self:\n            a.set_figure(self)\n        a.set_transform(self.transFigure)\n\n    @docstring.dedent_interpd\n    def gca(self, **kwargs):\n        \"\"\"\n        Return the current axes, creating one if necessary\n\n        The following kwargs are supported for ensuring the returned axes\n        adheres to the given projection etc., and for axes creation if\n        the active axes does not exist:\n\n        %(Axes)s\n\n        \"\"\"\n        ckey, cax = self._axstack.current_key_axes()\n        # if there exists an axes on the stack see if it maches\n        # the desired axes configuration\n        if cax is not None:\n\n            # if no kwargs are given just return the current axes\n            # this is a convenience for gca() on axes such as polar etc.\n            if not kwargs:\n                return cax\n\n            # if the user has specified particular projection detail\n            # then build up a key which can represent this\n            else:\n                # we don't want to modify the original kwargs\n                # so take a copy so that we can do what we like to it\n                kwargs_copy = kwargs.copy()\n                projection_class, _, key = process_projection_requirements(\n                    self, **kwargs_copy)\n\n                # let the returned axes have any gridspec by removing it from\n                # the key\n                ckey = ckey[1:]\n                key = key[1:]\n\n                # if the cax matches this key then return the axes, otherwise\n                # continue and a new axes will be created\n                if key == ckey and isinstance(cax, projection_class):\n                    return cax\n\n        # no axes found, so create one which spans the figure\n        return self.add_subplot(1, 1, 1, **kwargs)\n\n    def sca(self, a):\n        'Set the current axes to be a and return a'\n        self._axstack.bubble(a)\n        for func in self._axobservers:\n            func(self)\n        return a\n\n    def _gci(self):\n        \"\"\"\n        helper for :func:`~matplotlib.pyplot.gci`;\n        do not use elsewhere.\n        \"\"\"\n        # Look first for an image in the current Axes:\n        cax = self._axstack.current_key_axes()[1]\n        if cax is None:\n            return None\n        im = cax._gci()\n        if im is not None:\n            return im\n\n        # If there is no image in the current Axes, search for\n        # one in a previously created Axes.  Whether this makes\n        # sense is debatable, but it is the documented behavior.\n        for ax in reversed(self.axes):\n            im = ax._gci()\n            if im is not None:\n                return im\n        return None\n\n    def __getstate__(self):\n        state = self.__dict__.copy()\n        # the axobservers cannot currently be pickled.\n        # Additionally, the canvas cannot currently be pickled, but this has\n        # the benefit of meaning that a figure can be detached from one canvas,\n        # and re-attached to another.\n        for attr_to_pop in ('_axobservers', 'show',\n                            'canvas', '_cachedRenderer'):\n            state.pop(attr_to_pop, None)\n\n        # add version information to the state\n        state['__mpl_version__'] = _mpl_version\n\n        # check to see if the figure has a manager and whether it is registered\n        # with pyplot\n        if getattr(self.canvas, 'manager', None) is not None:\n            manager = self.canvas.manager\n            import matplotlib._pylab_helpers\n            if manager in list(six.itervalues(\n                    matplotlib._pylab_helpers.Gcf.figs)):\n                state['_restore_to_pylab'] = True\n\n        return state\n\n    def __setstate__(self, state):\n        version = state.pop('__mpl_version__')\n        restore_to_pylab = state.pop('_restore_to_pylab', False)\n\n        if version != _mpl_version:\n            import warnings\n            warnings.warn(\"This figure was saved with matplotlib version %s \"\n                          \"and is unlikely to function correctly.\" %\n                          (version, ))\n\n        self.__dict__ = state\n\n        # re-initialise some of the unstored state information\n        self._axobservers = []\n        self.canvas = None\n\n        if restore_to_pylab:\n            # lazy import to avoid circularity\n            import matplotlib.pyplot as plt\n            import matplotlib._pylab_helpers as pylab_helpers\n            allnums = plt.get_fignums()\n            num = max(allnums) + 1 if allnums else 1\n            mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)\n\n            # XXX The following is a copy and paste from pyplot. Consider\n            # factoring to pylab_helpers\n\n            if self.get_label():\n                mgr.set_window_title(self.get_label())\n\n            # make this figure current on button press event\n            def make_active(event):\n                pylab_helpers.Gcf.set_active(mgr)\n\n            mgr._cidgcf = mgr.canvas.mpl_connect('button_press_event',\n                                                 make_active)\n\n            pylab_helpers.Gcf.set_active(mgr)\n            self.number = num\n\n            plt.draw_if_interactive()\n\n    def add_axobserver(self, func):\n        'whenever the axes state change, ``func(self)`` will be called'\n        self._axobservers.append(func)\n\n    def savefig(self, *args, **kwargs):\n        \"\"\"\n        Save the current figure.\n\n        Call signature::\n\n          savefig(fname, dpi=None, facecolor='w', edgecolor='w',\n                  orientation='portrait', papertype=None, format=None,\n                  transparent=False, bbox_inches=None, pad_inches=0.1,\n                  frameon=None)\n\n        The output formats available depend on the backend being used.\n\n        Arguments:\n\n          *fname*:\n            A string containing a path to a filename, or a Python\n            file-like object, or possibly some backend-dependent object\n            such as :class:`~matplotlib.backends.backend_pdf.PdfPages`.\n\n            If *format* is *None* and *fname* is a string, the output\n            format is deduced from the extension of the filename. If\n            the filename has no extension, the value of the rc parameter\n            ``savefig.format`` is used.\n\n            If *fname* is not a string, remember to specify *format* to\n            ensure that the correct backend is used.\n\n        Keyword arguments:\n\n          *dpi*: [ *None* | ``scalar > 0`` ]\n            The resolution in dots per inch.  If *None* it will default to\n            the value ``savefig.dpi`` in the matplotlibrc file.\n\n          *facecolor*, *edgecolor*:\n            the colors of the figure rectangle\n\n          *orientation*: [ 'landscape' | 'portrait' ]\n            not supported on all backends; currently only on postscript output\n\n          *papertype*:\n            One of 'letter', 'legal', 'executive', 'ledger', 'a0' through\n            'a10', 'b0' through 'b10'. Only supported for postscript\n            output.\n\n          *format*:\n            One of the file extensions supported by the active\n            backend.  Most backends support png, pdf, ps, eps and svg.\n\n          *transparent*:\n            If *True*, the axes patches will all be transparent; the\n            figure patch will also be transparent unless facecolor\n            and/or edgecolor are specified via kwargs.\n            This is useful, for example, for displaying\n            a plot on top of a colored background on a web page.  The\n            transparency of these patches will be restored to their\n            original values upon exit of this function.\n\n          *frameon*:\n            If *True*, the figure patch will be colored, if *False*, the\n            figure background will be transparent.  If not provided, the\n            rcParam 'savefig.frameon' will be used.\n\n          *bbox_inches*:\n            Bbox in inches. Only the given portion of the figure is\n            saved. If 'tight', try to figure out the tight bbox of\n            the figure.\n\n          *pad_inches*:\n            Amount of padding around the figure when bbox_inches is\n            'tight'.\n\n          *bbox_extra_artists*:\n            A list of extra artists that will be considered when the\n            tight bbox is calculated.\n\n        \"\"\"\n\n        kwargs.setdefault('dpi', rcParams['savefig.dpi'])\n        frameon = kwargs.pop('frameon', rcParams['savefig.frameon'])\n        transparent = kwargs.pop('transparent',\n                                 rcParams['savefig.transparent'])\n\n        if transparent:\n            kwargs.setdefault('facecolor', 'none')\n            kwargs.setdefault('edgecolor', 'none')\n            original_axes_colors = []\n            for ax in self.axes:\n                patch = ax.patch\n                original_axes_colors.append((patch.get_facecolor(),\n                                             patch.get_edgecolor()))\n                patch.set_facecolor('none')\n                patch.set_edgecolor('none')\n        else:\n            kwargs.setdefault('facecolor', rcParams['savefig.facecolor'])\n            kwargs.setdefault('edgecolor', rcParams['savefig.edgecolor'])\n\n        if frameon:\n            original_frameon = self.get_frameon()\n            self.set_frameon(frameon)\n\n        self.canvas.print_figure(*args, **kwargs)\n\n        if frameon:\n            self.set_frameon(original_frameon)\n\n        if transparent:\n            for ax, cc in zip(self.axes, original_axes_colors):\n                ax.patch.set_facecolor(cc[0])\n                ax.patch.set_edgecolor(cc[1])\n\n    @docstring.dedent_interpd\n    def colorbar(self, mappable, cax=None, ax=None, use_gridspec=True, **kw):\n        \"\"\"\n        Create a colorbar for a ScalarMappable instance, *mappable*.\n\n        Documentation for the pylab thin wrapper:\n        %(colorbar_doc)s\n        \"\"\"\n        if ax is None:\n            ax = self.gca()\n\n        # Store the value of gca so that we can set it back later on.\n        current_ax = self.gca()\n\n        if cax is None:\n            if use_gridspec and isinstance(ax, SubplotBase):\n                cax, kw = cbar.make_axes_gridspec(ax, **kw)\n            else:\n                cax, kw = cbar.make_axes(ax, **kw)\n        cax.hold(True)\n        cb = cbar.colorbar_factory(cax, mappable, **kw)\n\n        self.sca(current_ax)\n        return cb\n\n    def subplots_adjust(self, *args, **kwargs):\n        \"\"\"\n        Call signature::\n\n          subplots_adjust(left=None, bottom=None, right=None, top=None,\n                              wspace=None, hspace=None)\n\n        Update the :class:`SubplotParams` with *kwargs* (defaulting to rc when\n        *None*) and update the subplot locations\n\n        \"\"\"\n        self.subplotpars.update(*args, **kwargs)\n        for ax in self.axes:\n            if not isinstance(ax, SubplotBase):\n                # Check if sharing a subplots axis\n                if (ax._sharex is not None and\n                    isinstance(ax._sharex, SubplotBase)):\n                    ax._sharex.update_params()\n                    ax.set_position(ax._sharex.figbox)\n                elif (ax._sharey is not None and\n                      isinstance(ax._sharey, SubplotBase)):\n                    ax._sharey.update_params()\n                    ax.set_position(ax._sharey.figbox)\n            else:\n                ax.update_params()\n                ax.set_position(ax.figbox)\n\n    def ginput(self, n=1, timeout=30, show_clicks=True, mouse_add=1,\n               mouse_pop=3, mouse_stop=2):\n        \"\"\"\n        Call signature::\n\n          ginput(self, n=1, timeout=30, show_clicks=True,\n                 mouse_add=1, mouse_pop=3, mouse_stop=2)\n\n        Blocking call to interact with the figure.\n\n        This will wait for *n* clicks from the user and return a list of the\n        coordinates of each click.\n\n        If *timeout* is zero or negative, does not timeout.\n\n        If *n* is zero or negative, accumulate clicks until a middle click\n        (or potentially both mouse buttons at once) terminates the input.\n\n        Right clicking cancels last input.\n\n        The buttons used for the various actions (adding points, removing\n        points, terminating the inputs) can be overriden via the\n        arguments *mouse_add*, *mouse_pop* and *mouse_stop*, that give\n        the associated mouse button: 1 for left, 2 for middle, 3 for\n        right.\n\n        The keyboard can also be used to select points in case your mouse\n        does not have one or more of the buttons.  The delete and backspace\n        keys act like right clicking (i.e., remove last point), the enter key\n        terminates input and any other key (not already used by the window\n        manager) selects a point.\n        \"\"\"\n\n        blocking_mouse_input = BlockingMouseInput(self,\n                                                  mouse_add=mouse_add,\n                                                  mouse_pop=mouse_pop,\n                                                  mouse_stop=mouse_stop)\n        return blocking_mouse_input(n=n, timeout=timeout,\n                                    show_clicks=show_clicks)\n\n    def waitforbuttonpress(self, timeout=-1):\n        \"\"\"\n        Call signature::\n\n          waitforbuttonpress(self, timeout=-1)\n\n        Blocking call to interact with the figure.\n\n        This will return True is a key was pressed, False if a mouse\n        button was pressed and None if *timeout* was reached without\n        either being pressed.\n\n        If *timeout* is negative, does not timeout.\n        \"\"\"\n\n        blocking_input = BlockingKeyMouseInput(self)\n        return blocking_input(timeout=timeout)\n\n    def get_default_bbox_extra_artists(self):\n        bbox_artists = [artist for artist in self.get_children()\n                        if artist.get_visible()]\n        for ax in self.axes:\n            if ax.get_visible():\n                bbox_artists.extend(ax.get_default_bbox_extra_artists())\n        # we don't want the figure's patch to influence the bbox calculation\n        bbox_artists.remove(self.patch)\n        return bbox_artists\n\n    def get_tightbbox(self, renderer):\n        \"\"\"\n        Return a (tight) bounding box of the figure in inches.\n\n        It only accounts axes title, axis labels, and axis\n        ticklabels. Needs improvement.\n        \"\"\"\n\n        bb = []\n        for ax in self.axes:\n            if ax.get_visible():\n                bb.append(ax.get_tightbbox(renderer))\n\n        _bbox = Bbox.union([b for b in bb if b.width != 0 or b.height != 0])\n\n        bbox_inches = TransformedBbox(_bbox,\n                                      Affine2D().scale(1. / self.dpi))\n\n        return bbox_inches\n\n    def tight_layout(self, renderer=None, pad=1.08, h_pad=None,\n                     w_pad=None, rect=None):\n        \"\"\"\n        Adjust subplot parameters to give specified padding.\n\n        Parameters:\n\n          *pad* : float\n            padding between the figure edge and the edges of subplots,\n            as a fraction of the font-size.\n          *h_pad*, *w_pad* : float\n            padding (height/width) between edges of adjacent subplots.\n            Defaults to `pad_inches`.\n          *rect* : if rect is given, it is interpreted as a rectangle\n            (left, bottom, right, top) in the normalized figure\n            coordinate that the whole subplots area (including\n            labels) will fit into. Default is (0, 0, 1, 1).\n        \"\"\"\n\n        from .tight_layout import (get_renderer, get_tight_layout_figure,\n                                   get_subplotspec_list)\n\n        subplotspec_list = get_subplotspec_list(self.axes)\n        if None in subplotspec_list:\n            warnings.warn(\"This figure includes Axes that are not \"\n                          \"compatible with tight_layout, so its \"\n                          \"results might be incorrect.\")\n\n        if renderer is None:\n            renderer = get_renderer(self)\n\n        kwargs = get_tight_layout_figure(self, self.axes, subplotspec_list,\n                                         renderer,\n                                         pad=pad, h_pad=h_pad, w_pad=w_pad,\n                                         rect=rect)\n\n        self.subplots_adjust(**kwargs)\n\n\ndef figaspect(arg):\n    \"\"\"\n    Create a figure with specified aspect ratio.  If *arg* is a number,\n    use that aspect ratio.  If *arg* is an array, figaspect will\n    determine the width and height for a figure that would fit array\n    preserving aspect ratio.  The figure width, height in inches are\n    returned.  Be sure to create an axes with equal with and height,\n    eg\n\n    Example usage::\n\n      # make a figure twice as tall as it is wide\n      w, h = figaspect(2.)\n      fig = Figure(figsize=(w,h))\n      ax = fig.add_axes([0.1, 0.1, 0.8, 0.8])\n      ax.imshow(A, **kwargs)\n\n\n      # make a figure with the proper aspect for an array\n      A = rand(5,3)\n      w, h = figaspect(A)\n      fig = Figure(figsize=(w,h))\n      ax = fig.add_axes([0.1, 0.1, 0.8, 0.8])\n      ax.imshow(A, **kwargs)\n\n    Thanks to Fernando Perez for this function\n    \"\"\"\n\n    isarray = hasattr(arg, 'shape')\n\n    # min/max sizes to respect when autoscaling.  If John likes the idea, they\n    # could become rc parameters, for now they're hardwired.\n    figsize_min = np.array((4.0, 2.0))  # min length for width/height\n    figsize_max = np.array((16.0, 16.0))  # max length for width/height\n    #figsize_min = rcParams['figure.figsize_min']\n    #figsize_max = rcParams['figure.figsize_max']\n\n    # Extract the aspect ratio of the array\n    if isarray:\n        nr, nc = arg.shape[:2]\n        arr_ratio = float(nr) / nc\n    else:\n        arr_ratio = float(arg)\n\n    # Height of user figure defaults\n    fig_height = rcParams['figure.figsize'][1]\n\n    # New size for the figure, keeping the aspect ratio of the caller\n    newsize = np.array((fig_height / arr_ratio, fig_height))\n\n    # Sanity checks, don't drop either dimension below figsize_min\n    newsize /= min(1.0, *(newsize / figsize_min))\n\n    # Avoid humongous windows as well\n    newsize /= max(1.0, *(newsize / figsize_max))\n\n    # Finally, if we have a really funky aspect ratio, break it but respect\n    # the min/max dimensions (we don't want figures 10 feet tall!)\n    newsize = np.clip(newsize, figsize_min, figsize_max)\n    return newsize\n\ndocstring.interpd.update(Figure=martist.kwdoc(Figure))\n", "patch": "@@ -1045,8 +1045,8 @@ def draw(self, renderer):\n             ims = [(im.make_image(mag), im.ox, im.oy, im.get_alpha())\n                    for im in self.images]\n \n-            im = _image.from_images(self.bbox.height * mag,\n-                                    self.bbox.width * mag,\n+            im = _image.from_images(int(self.bbox.height * mag),\n+                                    int(self.bbox.width * mag),\n                                     ims)\n \n             im.is_grayscale = False"}
{"patches_id": 2, "files_id": 18, "language": "py", "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Fimage.py", "raw_code": "\"\"\"\nThe image module supports basic image loading, rescaling and display\noperations.\n\n\"\"\"\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport six\n\nimport os\nimport warnings\n\nimport numpy as np\n\nfrom matplotlib import rcParams\nimport matplotlib.artist as martist\nfrom matplotlib.artist import allow_rasterization\nimport matplotlib.colors as mcolors\nimport matplotlib.cm as cm\nimport matplotlib.cbook as cbook\n\n# For clarity, names from _image are given explicitly in this module:\nimport matplotlib._image as _image\nimport matplotlib._png as _png\n\n# For user convenience, the names from _image are also imported into\n# the image namespace:\nfrom matplotlib._image import *\n\nfrom matplotlib.transforms import BboxBase, Bbox, IdentityTransform\nimport matplotlib.transforms as mtransforms\n\n\nclass _AxesImageBase(martist.Artist, cm.ScalarMappable):\n    zorder = 0\n    # map interpolation strings to module constants\n    _interpd = {\n        'none': _image.NEAREST,  # fall back to nearest when not supported\n        'nearest': _image.NEAREST,\n        'bilinear': _image.BILINEAR,\n        'bicubic': _image.BICUBIC,\n        'spline16': _image.SPLINE16,\n        'spline36': _image.SPLINE36,\n        'hanning': _image.HANNING,\n        'hamming': _image.HAMMING,\n        'hermite': _image.HERMITE,\n        'kaiser': _image.KAISER,\n        'quadric': _image.QUADRIC,\n        'catrom': _image.CATROM,\n        'gaussian': _image.GAUSSIAN,\n        'bessel': _image.BESSEL,\n        'mitchell': _image.MITCHELL,\n        'sinc': _image.SINC,\n        'lanczos': _image.LANCZOS,\n        'blackman': _image.BLACKMAN,\n    }\n\n    # reverse interp dict\n    _interpdr = dict([(v, k) for k, v in six.iteritems(_interpd)])\n\n    interpnames = list(six.iterkeys(_interpd))\n\n    def __str__(self):\n        return \"AxesImage(%g,%g;%gx%g)\" % tuple(self.axes.bbox.bounds)\n\n    def __init__(self, ax,\n                 cmap=None,\n                 norm=None,\n                 interpolation=None,\n                 origin=None,\n                 filternorm=1,\n                 filterrad=4.0,\n                 resample=False,\n                 **kwargs\n                 ):\n        \"\"\"\n        interpolation and cmap default to their rc settings\n\n        cmap is a colors.Colormap instance\n        norm is a colors.Normalize instance to map luminance to 0-1\n\n        extent is data axes (left, right, bottom, top) for making image plots\n        registered with data plots.  Default is to label the pixel\n        centers with the zero-based row and column indices.\n\n        Additional kwargs are matplotlib.artist properties\n\n        \"\"\"\n        martist.Artist.__init__(self)\n        cm.ScalarMappable.__init__(self, norm, cmap)\n\n        if origin is None:\n            origin = rcParams['image.origin']\n        self.origin = origin\n        self.set_filternorm(filternorm)\n        self.set_filterrad(filterrad)\n        self._filterrad = filterrad\n\n        self.set_interpolation(interpolation)\n        self.set_resample(resample)\n        self.axes = ax\n\n        self._imcache = None\n\n        # this is an experimental attribute, if True, unsampled image\n        # will be drawn using the affine transform that are\n        # appropriately skewed so that the given position\n        # corresponds to the actual position in the coordinate. -JJL\n        self._image_skew_coordinate = None\n\n        self.update(kwargs)\n\n    def __getstate__(self):\n        state = super(_AxesImageBase, self).__getstate__()\n        # We can't pickle the C Image cached object.\n        state.pop('_imcache', None)\n        return state\n\n    def get_size(self):\n        \"\"\"Get the numrows, numcols of the input image\"\"\"\n        if self._A is None:\n            raise RuntimeError('You must first set the image array')\n\n        return self._A.shape[:2]\n\n    def set_alpha(self, alpha):\n        \"\"\"\n        Set the alpha value used for blending - not supported on\n        all backends\n\n        ACCEPTS: float\n        \"\"\"\n        martist.Artist.set_alpha(self, alpha)\n        self._imcache = None\n\n    def changed(self):\n        \"\"\"\n        Call this whenever the mappable is changed so observers can\n        update state\n        \"\"\"\n        self._imcache = None\n        self._rgbacache = None\n        cm.ScalarMappable.changed(self)\n\n    def make_image(self, magnification=1.0):\n        raise RuntimeError('The make_image method must be overridden.')\n\n    def _get_unsampled_image(self, A, image_extents, viewlim):\n        \"\"\"\n        convert numpy array A with given extents ([x1, x2, y1, y2] in\n        data coordinate) into the Image, given the viewlim (should be a\n        bbox instance).  Image will be clipped if the extents is\n        significantly larger than the viewlim.\n        \"\"\"\n        xmin, xmax, ymin, ymax = image_extents\n        dxintv = xmax-xmin\n        dyintv = ymax-ymin\n\n        # the viewport scale factor\n        if viewlim.width == 0.0 and dxintv == 0.0:\n            sx = 1.0\n        else:\n            sx = dxintv/viewlim.width\n        if viewlim.height == 0.0 and dyintv == 0.0:\n            sy = 1.0\n        else:\n            sy = dyintv/viewlim.height\n        numrows, numcols = A.shape[:2]\n        if sx > 2:\n            x0 = (viewlim.x0-xmin)/dxintv * numcols\n            ix0 = max(0, int(x0 - self._filterrad))\n            x1 = (viewlim.x1-xmin)/dxintv * numcols\n            ix1 = min(numcols, int(x1 + self._filterrad))\n            xslice = slice(ix0, ix1)\n            xmin_old = xmin\n            xmin = xmin_old + ix0*dxintv/numcols\n            xmax = xmin_old + ix1*dxintv/numcols\n            dxintv = xmax - xmin\n            sx = dxintv/viewlim.width\n        else:\n            xslice = slice(0, numcols)\n\n        if sy > 2:\n            y0 = (viewlim.y0-ymin)/dyintv * numrows\n            iy0 = max(0, int(y0 - self._filterrad))\n            y1 = (viewlim.y1-ymin)/dyintv * numrows\n            iy1 = min(numrows, int(y1 + self._filterrad))\n            if self.origin == 'upper':\n                yslice = slice(numrows-iy1, numrows-iy0)\n            else:\n                yslice = slice(iy0, iy1)\n            ymin_old = ymin\n            ymin = ymin_old + iy0*dyintv/numrows\n            ymax = ymin_old + iy1*dyintv/numrows\n            dyintv = ymax - ymin\n            sy = dyintv/viewlim.height\n        else:\n            yslice = slice(0, numrows)\n\n        if xslice != self._oldxslice or yslice != self._oldyslice:\n            self._imcache = None\n            self._oldxslice = xslice\n            self._oldyslice = yslice\n\n        if self._imcache is None:\n            A = self._A\n            if self.origin == 'upper':\n                A = A[::-1]\n\n            if A.dtype == np.uint8 and A.ndim == 3:\n                im = _image.frombyte(A[yslice, xslice, :], 0)\n                im.is_grayscale = False\n            else:\n                if self._rgbacache is None:\n                    x = self.to_rgba(A, bytes=False)\n                    # Avoid side effects: to_rgba can return its argument\n                    # unchanged.\n                    if np.may_share_memory(x, A):\n                        x = x.copy()\n                    # premultiply the colors\n                    x[..., 0:3] *= x[..., 3:4]\n                    x = (x * 255).astype(np.uint8)\n                    self._rgbacache = x\n                else:\n                    x = self._rgbacache\n                im = _image.frombyte(x[yslice, xslice, :], 0)\n                if self._A.ndim == 2:\n                    im.is_grayscale = self.cmap.is_gray()\n                else:\n                    im.is_grayscale = False\n            self._imcache = im\n        else:\n            im = self._imcache\n\n        return im, xmin, ymin, dxintv, dyintv, sx, sy\n\n    @staticmethod\n    def _get_rotate_and_skew_transform(x1, y1, x2, y2, x3, y3):\n        \"\"\"\n        Retuen a transform that does\n         (x1, y1) -> (x1, y1)\n         (x2, y2) -> (x2, y2)\n         (x2, y1) -> (x3, y3)\n\n        It was intended to derive a skew transform that preserve the\n        lower-left corner (x1, y1) and top-right corner(x2,y2), but\n        change the the lower-right-corner(x2, y1) to a new position\n        (x3, y3).\n        \"\"\"\n        tr1 = mtransforms.Affine2D()\n        tr1.translate(-x1, -y1)\n        x2a, y2a = tr1.transform_point((x2, y2))\n        x3a, y3a = tr1.transform_point((x3, y3))\n\n        inv_mat = 1. / (x2a*y3a-y2a*x3a) * np.mat([[y3a, -y2a], [-x3a, x2a]])\n\n        a, b = (inv_mat * np.mat([[x2a], [x2a]])).flat\n        c, d = (inv_mat * np.mat([[y2a], [0]])).flat\n\n        tr2 = mtransforms.Affine2D.from_values(a, c, b, d, 0, 0)\n\n        tr = (tr1 + tr2 +\n              mtransforms.Affine2D().translate(x1, y1)).inverted().get_affine()\n\n        return tr\n\n    def _draw_unsampled_image(self, renderer, gc):\n        \"\"\"\n        draw unsampled image. The renderer should support a draw_image method\n        with scale parameter.\n        \"\"\"\n        trans = self.get_transform()  # axes.transData\n\n        # convert the coordinates to the intermediate coordinate (ic).\n        # The transformation from the ic to the canvas is a pure\n        # affine transform.\n\n        # A straight-forward way is to use the non-affine part of the\n        # original transform for conversion to the ic.\n\n        # firs, convert the image extent to the ic\n        x_llc, x_trc, y_llc, y_trc = self.get_extent()\n\n        xy = trans.transform(np.array([(x_llc, y_llc),\n                                       (x_trc, y_trc)]))\n\n        _xx1, _yy1 = xy[0]\n        _xx2, _yy2 = xy[1]\n\n        extent_in_ic = _xx1, _xx2, _yy1, _yy2\n\n        # define trans_ic_to_canvas : unless _image_skew_coordinate is\n        # set, it is simply a affine part of the original transform.\n        if self._image_skew_coordinate:\n            # skew the image when required.\n            x_lrc, y_lrc = self._image_skew_coordinate\n            xy2 = trans.transform(np.array([(x_lrc, y_lrc)]))\n            _xx3, _yy3 = xy2[0]\n\n            tr_rotate_skew = self._get_rotate_and_skew_transform(_xx1, _yy1,\n                                                                 _xx2, _yy2,\n                                                                 _xx3, _yy3)\n            trans_ic_to_canvas = tr_rotate_skew\n        else:\n            trans_ic_to_canvas = IdentityTransform()\n\n        # Now, viewLim in the ic.  It can be rotated and can be\n        # skewed. Make it big enough.\n        x1, y1, x2, y2 = self.axes.bbox.extents\n        trans_canvas_to_ic = trans_ic_to_canvas.inverted()\n        xy_ = trans_canvas_to_ic.transform(np.array([(x1, y1),\n                                                     (x2, y1),\n                                                     (x2, y2),\n                                                     (x1, y2)]))\n        x1_, x2_ = min(xy_[:, 0]), max(xy_[:, 0])\n        y1_, y2_ = min(xy_[:, 1]), max(xy_[:, 1])\n        viewLim_in_ic = Bbox.from_extents(x1_, y1_, x2_, y2_)\n\n        # get the image, sliced if necessary. This is done in the ic.\n        im, xmin, ymin, dxintv, dyintv, sx, sy = \\\n            self._get_unsampled_image(self._A, extent_in_ic, viewLim_in_ic)\n\n        if im is None:\n            return  # I'm not if this check is required. -JJL\n\n        fc = self.axes.patch.get_facecolor()\n        bg = mcolors.colorConverter.to_rgba(fc, 0)\n        im.set_bg(*bg)\n\n        # image input dimensions\n        im.reset_matrix()\n        numrows, numcols = im.get_size()\n\n        if numrows <= 0 or numcols <= 0:\n            return\n        im.resize(numcols, numrows)  # just to create im.bufOut that\n                                     # is required by backends. There\n                                     # may be better solution -JJL\n\n        im._url = self.get_url()\n        im._gid = self.get_gid()\n\n        renderer.draw_image(gc, xmin, ymin, im, dxintv, dyintv,\n                            trans_ic_to_canvas)\n\n    def _check_unsampled_image(self, renderer):\n        \"\"\"\n        return True if the image is better to be drawn unsampled.\n        The derived class needs to override it.\n        \"\"\"\n        return False\n\n    @allow_rasterization\n    def draw(self, renderer, *args, **kwargs):\n        if not self.get_visible():\n            return\n        if (self.axes.get_xscale() != 'linear' or\n            self.axes.get_yscale() != 'linear'):\n            warnings.warn(\"Images are not supported on non-linear axes.\")\n\n        l, b, widthDisplay, heightDisplay = self.axes.bbox.bounds\n        gc = renderer.new_gc()\n        self._set_gc_clip(gc)\n        gc.set_alpha(self.get_alpha())\n\n        if self._check_unsampled_image(renderer):\n            self._draw_unsampled_image(renderer, gc)\n        else:\n            if self._image_skew_coordinate is not None:\n                warnings.warn(\"Image will not be shown\"\n                              \" correctly with this backend.\")\n\n            im = self.make_image(renderer.get_image_magnification())\n            if im is None:\n                return\n            im._url = self.get_url()\n            im._gid = self.get_gid()\n            renderer.draw_image(gc, l, b, im)\n        gc.restore()\n\n    def contains(self, mouseevent):\n        \"\"\"\n        Test whether the mouse event occured within the image.\n        \"\"\"\n        if six.callable(self._contains):\n            return self._contains(self, mouseevent)\n        # TODO: make sure this is consistent with patch and patch\n        # collection on nonlinear transformed coordinates.\n        # TODO: consider returning image coordinates (shouldn't\n        # be too difficult given that the image is rectilinear\n        x, y = mouseevent.xdata, mouseevent.ydata\n        xmin, xmax, ymin, ymax = self.get_extent()\n        if xmin > xmax:\n            xmin, xmax = xmax, xmin\n        if ymin > ymax:\n            ymin, ymax = ymax, ymin\n        #print x, y, xmin, xmax, ymin, ymax\n        if x is not None and y is not None:\n            inside = ((x >= xmin) and (x <= xmax) and\n                      (y >= ymin) and (y <= ymax))\n        else:\n            inside = False\n\n        return inside, {}\n\n    def write_png(self, fname, noscale=False):\n        \"\"\"Write the image to png file with fname\"\"\"\n        im = self.make_image()\n        if im is None:\n            return\n        if noscale:\n            numrows, numcols = im.get_size()\n            im.reset_matrix()\n            im.set_interpolation(0)\n            im.resize(numcols, numrows)\n        _png.write_png(im, fname)\n\n    def set_data(self, A):\n        \"\"\"\n        Set the image array\n\n        ACCEPTS: numpy/PIL Image A\n        \"\"\"\n        # check if data is PIL Image without importing Image\n        if hasattr(A, 'getpixel'):\n            self._A = pil_to_array(A)\n        else:\n            self._A = cbook.safe_masked_invalid(A)\n\n        if (self._A.dtype != np.uint8 and\n            not np.can_cast(self._A.dtype, np.float)):\n            raise TypeError(\"Image data can not convert to float\")\n\n        if (self._A.ndim not in (2, 3) or\n            (self._A.ndim == 3 and self._A.shape[-1] not in (3, 4))):\n            raise TypeError(\"Invalid dimensions for image data\")\n\n        self._imcache = None\n        self._rgbacache = None\n        self._oldxslice = None\n        self._oldyslice = None\n\n    def set_array(self, A):\n        \"\"\"\n        Retained for backwards compatibility - use set_data instead\n\n        ACCEPTS: numpy array A or PIL Image\"\"\"\n        # This also needs to be here to override the inherited\n        # cm.ScalarMappable.set_array method so it is not invoked\n        # by mistake.\n\n        self.set_data(A)\n\n    def get_interpolation(self):\n        \"\"\"\n        Return the interpolation method the image uses when resizing.\n\n        One of 'nearest', 'bilinear', 'bicubic', 'spline16', 'spline36',\n        'hanning', 'hamming', 'hermite', 'kaiser', 'quadric', 'catrom',\n        'gaussian', 'bessel', 'mitchell', 'sinc', 'lanczos', or 'none'.\n\n        \"\"\"\n        return self._interpolation\n\n    def set_interpolation(self, s):\n        \"\"\"\n        Set the interpolation method the image uses when resizing.\n\n        if None, use a value from rc setting. If 'none', the image is\n        shown as is without interpolating. 'none' is only supported in\n        agg, ps and pdf backends and will fall back to 'nearest' mode\n        for other backends.\n\n        ACCEPTS: ['nearest' | 'bilinear' | 'bicubic' | 'spline16' |\n          'spline36' | 'hanning' | 'hamming' | 'hermite' | 'kaiser' |\n          'quadric' | 'catrom' | 'gaussian' | 'bessel' | 'mitchell' |\n          'sinc' | 'lanczos' | 'none' |]\n\n        \"\"\"\n        if s is None:\n            s = rcParams['image.interpolation']\n        s = s.lower()\n        if s not in self._interpd:\n            raise ValueError('Illegal interpolation string')\n        self._interpolation = s\n\n    def set_resample(self, v):\n        \"\"\"\n        Set whether or not image resampling is used\n\n        ACCEPTS: True|False\n        \"\"\"\n        if v is None:\n            v = rcParams['image.resample']\n        self._resample = v\n\n    def get_resample(self):\n        \"\"\"Return the image resample boolean\"\"\"\n        return self._resample\n\n    def set_filternorm(self, filternorm):\n        \"\"\"\n        Set whether the resize filter norms the weights -- see\n        help for imshow\n\n        ACCEPTS: 0 or 1\n        \"\"\"\n        if filternorm:\n            self._filternorm = 1\n        else:\n            self._filternorm = 0\n\n    def get_filternorm(self):\n        \"\"\"Return the filternorm setting\"\"\"\n        return self._filternorm\n\n    def set_filterrad(self, filterrad):\n        \"\"\"\n        Set the resize filter radius only applicable to some\n        interpolation schemes -- see help for imshow\n\n        ACCEPTS: positive float\n        \"\"\"\n        r = float(filterrad)\n        assert(r > 0)\n        self._filterrad = r\n\n    def get_filterrad(self):\n        \"\"\"return the filterrad setting\"\"\"\n        return self._filterrad\n\n\nclass AxesImage(_AxesImageBase):\n    def __str__(self):\n        return \"AxesImage(%g,%g;%gx%g)\" % tuple(self.axes.bbox.bounds)\n\n    def __init__(self, ax,\n                 cmap=None,\n                 norm=None,\n                 interpolation=None,\n                 origin=None,\n                 extent=None,\n                 filternorm=1,\n                 filterrad=4.0,\n                 resample=False,\n                 **kwargs\n                 ):\n\n        \"\"\"\n        interpolation and cmap default to their rc settings\n\n        cmap is a colors.Colormap instance\n        norm is a colors.Normalize instance to map luminance to 0-1\n\n        extent is data axes (left, right, bottom, top) for making image plots\n        registered with data plots.  Default is to label the pixel\n        centers with the zero-based row and column indices.\n\n        Additional kwargs are matplotlib.artist properties\n\n        \"\"\"\n\n        self._extent = extent\n\n        _AxesImageBase.__init__(self, ax,\n                                cmap=cmap,\n                                norm=norm,\n                                interpolation=interpolation,\n                                origin=origin,\n                                filternorm=filternorm,\n                                filterrad=filterrad,\n                                resample=resample,\n                                **kwargs\n                                )\n\n    def make_image(self, magnification=1.0):\n        if self._A is None:\n            raise RuntimeError('You must first set the image'\n                               ' array or the image attribute')\n\n        # image is created in the canvas coordinate.\n        x1, x2, y1, y2 = self.get_extent()\n        trans = self.get_transform()\n        xy = trans.transform(np.array([(x1, y1),\n                                       (x2, y2),\n                                       ]))\n        _x1, _y1 = xy[0]\n        _x2, _y2 = xy[1]\n\n        transformed_viewLim = mtransforms.TransformedBbox(self.axes.viewLim,\n                                                          trans)\n\n        im, xmin, ymin, dxintv, dyintv, sx, sy = \\\n            self._get_unsampled_image(self._A, [_x1, _x2, _y1, _y2],\n                                      transformed_viewLim)\n\n        fc = self.axes.patch.get_facecolor()\n        bg = mcolors.colorConverter.to_rgba(fc, 0)\n        im.set_bg(*bg)\n\n        # image input dimensions\n        im.reset_matrix()\n        numrows, numcols = im.get_size()\n        if numrows < 1 or numcols < 1:   # out of range\n            return None\n        im.set_interpolation(self._interpd[self._interpolation])\n\n        im.set_resample(self._resample)\n\n        # the viewport translation\n        if dxintv == 0.0:\n            tx = 0.0\n        else:\n            tx = (xmin-transformed_viewLim.x0)/dxintv * numcols\n        if dyintv == 0.0:\n            ty = 0.0\n        else:\n            ty = (ymin-transformed_viewLim.y0)/dyintv * numrows\n\n        im.apply_translation(tx, ty)\n\n        l, b, r, t = self.axes.bbox.extents\n        widthDisplay = ((round(r*magnification) + 0.5) -\n                        (round(l*magnification) - 0.5))\n        heightDisplay = ((round(t*magnification) + 0.5) -\n                         (round(b*magnification) - 0.5))\n\n        # resize viewport to display\n        rx = widthDisplay / numcols\n        ry = heightDisplay / numrows\n        im.apply_scaling(rx*sx, ry*sy)\n        im.resize(int(widthDisplay+0.5), int(heightDisplay+0.5),\n                  norm=self._filternorm, radius=self._filterrad)\n        return im\n\n    def _check_unsampled_image(self, renderer):\n        \"\"\"\n        return True if the image is better to be drawn unsampled.\n        \"\"\"\n        if self.get_interpolation() == \"none\":\n            if renderer.option_scale_image():\n                return True\n            else:\n                warnings.warn(\"The backend (%s) does not support \"\n                              \"interpolation='none'. The image will be \"\n                              \"interpolated with 'nearest` \"\n                              \"mode.\" % renderer.__class__)\n\n        return False\n\n    def set_extent(self, extent):\n        \"\"\"\n        extent is data axes (left, right, bottom, top) for making image plots\n\n        This updates ax.dataLim, and, if autoscaling, sets viewLim\n        to tightly fit the image, regardless of dataLim.  Autoscaling\n        state is not changed, so following this with ax.autoscale_view\n        will redo the autoscaling in accord with dataLim.\n\n        \"\"\"\n        self._extent = extent\n\n        xmin, xmax, ymin, ymax = extent\n        corners = (xmin, ymin), (xmax, ymax)\n        self.axes.update_datalim(corners)\n        if self.axes._autoscaleXon:\n            self.axes.set_xlim((xmin, xmax), auto=None)\n        if self.axes._autoscaleYon:\n            self.axes.set_ylim((ymin, ymax), auto=None)\n\n    def get_extent(self):\n        \"\"\"Get the image extent: left, right, bottom, top\"\"\"\n        if self._extent is not None:\n            return self._extent\n        else:\n            sz = self.get_size()\n            #print 'sz', sz\n            numrows, numcols = sz\n            if self.origin == 'upper':\n                return (-0.5, numcols-0.5, numrows-0.5, -0.5)\n            else:\n                return (-0.5, numcols-0.5, -0.5, numrows-0.5)\n\n\nclass NonUniformImage(AxesImage):\n    def __init__(self, ax, **kwargs):\n        \"\"\"\n        kwargs are identical to those for AxesImage, except\n        that 'interpolation' defaults to 'nearest', and 'bilinear'\n        is the only alternative.\n        \"\"\"\n        interp = kwargs.pop('interpolation', 'nearest')\n        AxesImage.__init__(self, ax,\n                           **kwargs)\n        self.set_interpolation(interp)\n\n    def _check_unsampled_image(self, renderer):\n        \"\"\"\n        return False. Do not use unsampled image.\n        \"\"\"\n        return False\n\n    def make_image(self, magnification=1.0):\n        if self._A is None:\n            raise RuntimeError('You must first set the image array')\n\n        A = self._A\n        if len(A.shape) == 2:\n            if A.dtype != np.uint8:\n                A = self.to_rgba(A, bytes=True)\n                self.is_grayscale = self.cmap.is_gray()\n            else:\n                A = np.repeat(A[:, :, np.newaxis], 4, 2)\n                A[:, :, 3] = 255\n                self.is_grayscale = True\n        else:\n            if A.dtype != np.uint8:\n                A = (255*A).astype(np.uint8)\n            if A.shape[2] == 3:\n                B = np.zeros(tuple(list(A.shape[0:2]) + [4]), np.uint8)\n                B[:, :, 0:3] = A\n                B[:, :, 3] = 255\n                A = B\n            self.is_grayscale = False\n\n        x0, y0, v_width, v_height = self.axes.viewLim.bounds\n        l, b, r, t = self.axes.bbox.extents\n        width = (round(r) + 0.5) - (round(l) - 0.5)\n        height = (round(t) + 0.5) - (round(b) - 0.5)\n        width *= magnification\n        height *= magnification\n        im = _image.pcolor(self._Ax, self._Ay, A,\n                           int(height), int(width),\n                           (x0, x0+v_width, y0, y0+v_height),\n                           self._interpd[self._interpolation])\n\n        fc = self.axes.patch.get_facecolor()\n        bg = mcolors.colorConverter.to_rgba(fc, 0)\n        im.set_bg(*bg)\n        im.is_grayscale = self.is_grayscale\n        return im\n\n    def set_data(self, x, y, A):\n        \"\"\"\n        Set the grid for the pixel centers, and the pixel values.\n\n          *x* and *y* are 1-D ndarrays of lengths N and M, respectively,\n             specifying pixel centers\n\n          *A* is an (M,N) ndarray or masked array of values to be\n            colormapped, or a (M,N,3) RGB array, or a (M,N,4) RGBA\n            array.\n        \"\"\"\n        x = np.asarray(x, np.float32)\n        y = np.asarray(y, np.float32)\n        A = cbook.safe_masked_invalid(A)\n        if len(x.shape) != 1 or len(y.shape) != 1\\\n           or A.shape[0:2] != (y.shape[0], x.shape[0]):\n            raise TypeError(\"Axes don't match array shape\")\n        if len(A.shape) not in [2, 3]:\n            raise TypeError(\"Can only plot 2D or 3D data\")\n        if len(A.shape) == 3 and A.shape[2] not in [1, 3, 4]:\n            raise TypeError(\"3D arrays must have three (RGB) \"\n                            \"or four (RGBA) color components\")\n        if len(A.shape) == 3 and A.shape[2] == 1:\n            A.shape = A.shape[0:2]\n        self._A = A\n        self._Ax = x\n        self._Ay = y\n        self._imcache = None\n\n        # I am adding this in accor with _AxesImageBase.set_data --\n        # examples/pylab_examples/image_nonuniform.py was breaking on\n        # the call to _get_unsampled_image when the oldxslice attr was\n        # accessed - JDH 3/3/2010\n        self._oldxslice = None\n        self._oldyslice = None\n\n    def set_array(self, *args):\n        raise NotImplementedError('Method not supported')\n\n    def set_interpolation(self, s):\n        if s is not None and s not in ('nearest', 'bilinear'):\n            raise NotImplementedError('Only nearest neighbor and '\n                                      'bilinear interpolations are supported')\n        AxesImage.set_interpolation(self, s)\n\n    def get_extent(self):\n        if self._A is None:\n            raise RuntimeError('Must set data first')\n        return self._Ax[0], self._Ax[-1], self._Ay[0], self._Ay[-1]\n\n    def set_filternorm(self, s):\n        pass\n\n    def set_filterrad(self, s):\n        pass\n\n    def set_norm(self, norm):\n        if self._A is not None:\n            raise RuntimeError('Cannot change colors after loading data')\n        cm.ScalarMappable.set_norm(self, norm)\n\n    def set_cmap(self, cmap):\n        if self._A is not None:\n            raise RuntimeError('Cannot change colors after loading data')\n        cm.ScalarMappable.set_cmap(self, cmap)\n\n\nclass PcolorImage(martist.Artist, cm.ScalarMappable):\n    \"\"\"\n    Make a pcolor-style plot with an irregular rectangular grid.\n\n    This uses a variation of the original irregular image code,\n    and it is used by pcolorfast for the corresponding grid type.\n    \"\"\"\n    def __init__(self, ax,\n                 x=None,\n                 y=None,\n                 A=None,\n                 cmap=None,\n                 norm=None,\n                 **kwargs\n                 ):\n        \"\"\"\n        cmap defaults to its rc setting\n\n        cmap is a colors.Colormap instance\n        norm is a colors.Normalize instance to map luminance to 0-1\n\n        Additional kwargs are matplotlib.artist properties\n\n        \"\"\"\n        martist.Artist.__init__(self)\n        cm.ScalarMappable.__init__(self, norm, cmap)\n        self.axes = ax\n        self._rgbacache = None\n        # There is little point in caching the image itself because\n        # it needs to be remade if the bbox or viewlim change,\n        # so caching does help with zoom/pan/resize.\n        self.update(kwargs)\n        self.set_data(x, y, A)\n\n    def make_image(self, magnification=1.0):\n        if self._A is None:\n            raise RuntimeError('You must first set the image array')\n        fc = self.axes.patch.get_facecolor()\n        bg = mcolors.colorConverter.to_rgba(fc, 0)\n        bg = (np.array(bg)*255).astype(np.uint8)\n        l, b, r, t = self.axes.bbox.extents\n        width = (round(r) + 0.5) - (round(l) - 0.5)\n        height = (round(t) + 0.5) - (round(b) - 0.5)\n        width = width * magnification\n        height = height * magnification\n        if self._rgbacache is None:\n            A = self.to_rgba(self._A, bytes=True)\n            self._rgbacache = A\n            if self._A.ndim == 2:\n                self.is_grayscale = self.cmap.is_gray()\n        else:\n            A = self._rgbacache\n        vl = self.axes.viewLim\n        im = _image.pcolor2(self._Ax, self._Ay, A,\n                            height,\n                            width,\n                            (vl.x0, vl.x1, vl.y0, vl.y1),\n                            bg)\n        im.is_grayscale = self.is_grayscale\n        return im\n\n    def changed(self):\n        self._rgbacache = None\n        cm.ScalarMappable.changed(self)\n\n    @allow_rasterization\n    def draw(self, renderer, *args, **kwargs):\n        if not self.get_visible():\n            return\n        im = self.make_image(renderer.get_image_magnification())\n        gc = renderer.new_gc()\n        gc.set_clip_rectangle(self.axes.bbox.frozen())\n        gc.set_clip_path(self.get_clip_path())\n        gc.set_alpha(self.get_alpha())\n        renderer.draw_image(gc,\n                            round(self.axes.bbox.xmin),\n                            round(self.axes.bbox.ymin),\n                            im)\n        gc.restore()\n\n    def set_data(self, x, y, A):\n        A = cbook.safe_masked_invalid(A)\n        if x is None:\n            x = np.arange(0, A.shape[1]+1, dtype=np.float64)\n        else:\n            x = np.asarray(x, np.float64).ravel()\n        if y is None:\n            y = np.arange(0, A.shape[0]+1, dtype=np.float64)\n        else:\n            y = np.asarray(y, np.float64).ravel()\n\n        if A.shape[:2] != (y.size-1, x.size-1):\n            print(A.shape)\n            print(y.size)\n            print(x.size)\n            raise ValueError(\"Axes don't match array shape\")\n        if A.ndim not in [2, 3]:\n            raise ValueError(\"A must be 2D or 3D\")\n        if A.ndim == 3 and A.shape[2] == 1:\n            A.shape = A.shape[:2]\n        self.is_grayscale = False\n        if A.ndim == 3:\n            if A.shape[2] in [3, 4]:\n                if ((A[:, :, 0] == A[:, :, 1]).all() and\n                    (A[:, :, 0] == A[:, :, 2]).all()):\n                    self.is_grayscale = True\n            else:\n                raise ValueError(\"3D arrays must have RGB or RGBA as last dim\")\n        self._A = A\n        self._Ax = x\n        self._Ay = y\n        self._rgbacache = None\n\n    def set_array(self, *args):\n        raise NotImplementedError('Method not supported')\n\n    def set_alpha(self, alpha):\n        \"\"\"\n        Set the alpha value used for blending - not supported on\n        all backends\n\n        ACCEPTS: float\n        \"\"\"\n        martist.Artist.set_alpha(self, alpha)\n        self.update_dict['array'] = True\n\n\nclass FigureImage(martist.Artist, cm.ScalarMappable):\n    zorder = 0\n\n    def __init__(self, fig,\n                 cmap=None,\n                 norm=None,\n                 offsetx=0,\n                 offsety=0,\n                 origin=None,\n                 **kwargs\n                 ):\n\n        \"\"\"\n        cmap is a colors.Colormap instance\n        norm is a colors.Normalize instance to map luminance to 0-1\n\n        kwargs are an optional list of Artist keyword args\n        \"\"\"\n        martist.Artist.__init__(self)\n        cm.ScalarMappable.__init__(self, norm, cmap)\n        if origin is None:\n            origin = rcParams['image.origin']\n        self.origin = origin\n        self.figure = fig\n        self.ox = offsetx\n        self.oy = offsety\n        self.update(kwargs)\n        self.magnification = 1.0\n\n    def contains(self, mouseevent):\n        \"\"\"Test whether the mouse event occured within the image.\"\"\"\n        if six.callable(self._contains):\n            return self._contains(self, mouseevent)\n        xmin, xmax, ymin, ymax = self.get_extent()\n        xdata, ydata = mouseevent.x, mouseevent.y\n        #print xdata, ydata, xmin, xmax, ymin, ymax\n        if xdata is not None and ydata is not None:\n            inside = ((xdata >= xmin) and (xdata <= xmax) and\n                      (ydata >= ymin) and (ydata <= ymax))\n        else:\n            inside = False\n\n        return inside, {}\n\n    def get_size(self):\n        \"\"\"Get the numrows, numcols of the input image\"\"\"\n        if self._A is None:\n            raise RuntimeError('You must first set the image array')\n\n        return self._A.shape[:2]\n\n    def get_extent(self):\n        \"\"\"Get the image extent: left, right, bottom, top\"\"\"\n        numrows, numcols = self.get_size()\n        return (-0.5+self.ox, numcols-0.5+self.ox,\n                -0.5+self.oy, numrows-0.5+self.oy)\n\n    def set_data(self, A):\n        \"\"\"Set the image array.\"\"\"\n        cm.ScalarMappable.set_array(self, cbook.safe_masked_invalid(A))\n\n    def set_array(self, A):\n        \"\"\"Deprecated; use set_data for consistency with other image types.\"\"\"\n        self.set_data(A)\n\n    def make_image(self, magnification=1.0):\n        if self._A is None:\n            raise RuntimeError('You must first set the image array')\n\n        A = self._A\n        if self.origin == 'upper':\n            A = A[::-1]\n\n        x = self.to_rgba(A, bytes=True)\n        self.magnification = magnification\n        # if magnification is not one, we need to resize\n        ismag = magnification != 1\n        #if ismag: raise RuntimeError\n        if ismag:\n            isoutput = 0\n        else:\n            isoutput = 1\n        im = _image.frombyte(x, isoutput)\n        fc = self.figure.get_facecolor()\n        im.set_bg(*mcolors.colorConverter.to_rgba(fc, 0))\n        im.is_grayscale = (self.cmap.name == \"gray\" and\n                           len(A.shape) == 2)\n\n        if ismag:\n            numrows, numcols = self.get_size()\n            numrows *= magnification\n            numcols *= magnification\n            im.set_interpolation(_image.NEAREST)\n            im.resize(numcols, numrows)\n\n        return im\n\n    @allow_rasterization\n    def draw(self, renderer, *args, **kwargs):\n        if not self.get_visible():\n            return\n        # todo: we should be able to do some cacheing here\n        im = self.make_image(renderer.get_image_magnification())\n        gc = renderer.new_gc()\n        gc.set_clip_rectangle(self.figure.bbox)\n        gc.set_clip_path(self.get_clip_path())\n        gc.set_alpha(self.get_alpha())\n        renderer.draw_image(gc, round(self.ox), round(self.oy), im)\n        gc.restore()\n\n    def write_png(self, fname):\n        \"\"\"Write the image to png file with fname\"\"\"\n        im = self.make_image()\n        _png.write_png(im, fname)\n\n\nclass BboxImage(_AxesImageBase):\n    \"\"\"The Image class whose size is determined by the given bbox.\"\"\"\n    def __init__(self, bbox,\n                 cmap=None,\n                 norm=None,\n                 interpolation=None,\n                 origin=None,\n                 filternorm=1,\n                 filterrad=4.0,\n                 resample=False,\n                 interp_at_native=True,\n                 **kwargs\n                 ):\n\n        \"\"\"\n        cmap is a colors.Colormap instance\n        norm is a colors.Normalize instance to map luminance to 0-1\n\n        interp_at_native is a flag that determines whether or not\n        interpolation should still be applied when the image is\n        displayed at its native resolution.  A common use case for this\n        is when displaying an image for annotational purposes; it is\n        treated similarly to Photoshop (interpolation is only used when\n        displaying the image at non-native resolutions).\n\n\n        kwargs are an optional list of Artist keyword args\n\n        \"\"\"\n        _AxesImageBase.__init__(self, ax=None,\n                                cmap=cmap,\n                                norm=norm,\n                                interpolation=interpolation,\n                                origin=origin,\n                                filternorm=filternorm,\n                                filterrad=filterrad,\n                                resample=resample,\n                                **kwargs\n                                )\n\n        self.bbox = bbox\n        self.interp_at_native = interp_at_native\n\n    def get_window_extent(self, renderer=None):\n        if renderer is None:\n            renderer = self.get_figure()._cachedRenderer\n\n        if isinstance(self.bbox, BboxBase):\n            return self.bbox\n        elif six.callable(self.bbox):\n            return self.bbox(renderer)\n        else:\n            raise ValueError(\"unknown type of bbox\")\n\n    def contains(self, mouseevent):\n        \"\"\"Test whether the mouse event occured within the image.\"\"\"\n        if six.callable(self._contains):\n            return self._contains(self, mouseevent)\n\n        if not self.get_visible():  # or self.get_figure()._renderer is None:\n            return False, {}\n\n        x, y = mouseevent.x, mouseevent.y\n        inside = self.get_window_extent().contains(x, y)\n\n        return inside, {}\n\n    def get_size(self):\n        \"\"\"Get the numrows, numcols of the input image\"\"\"\n        if self._A is None:\n            raise RuntimeError('You must first set the image array')\n\n        return self._A.shape[:2]\n\n    def make_image(self, renderer, magnification=1.0):\n        if self._A is None:\n            raise RuntimeError('You must first set the image '\n                               'array or the image attribute')\n\n        if self._imcache is None:\n            A = self._A\n            if self.origin == 'upper':\n                A = A[::-1]\n            if A.dtype == np.uint8 and len(A.shape) == 3:\n                im = _image.frombyte(A, 0)\n                im.is_grayscale = False\n            else:\n                if self._rgbacache is None:\n                    x = self.to_rgba(A, bytes=True)\n                    self._rgbacache = x\n                else:\n                    x = self._rgbacache\n                im = _image.frombyte(x, 0)\n                if len(A.shape) == 2:\n                    im.is_grayscale = self.cmap.is_gray()\n                else:\n                    im.is_grayscale = False\n            self._imcache = im\n        else:\n            im = self._imcache\n\n        # image input dimensions\n        im.reset_matrix()\n\n        im.set_interpolation(self._interpd[self._interpolation])\n\n        im.set_resample(self._resample)\n\n        l, b, r, t = self.get_window_extent(renderer).extents  # bbox.extents\n        widthDisplay = abs(round(r) - round(l))\n        heightDisplay = abs(round(t) - round(b))\n        widthDisplay *= magnification\n        heightDisplay *= magnification\n\n        numrows, numcols = self._A.shape[:2]\n\n        if (not self.interp_at_native and\n            widthDisplay == numcols and heightDisplay == numrows):\n            im.set_interpolation(0)\n\n        # resize viewport to display\n        rx = widthDisplay / numcols\n        ry = heightDisplay / numrows\n        #im.apply_scaling(rx*sx, ry*sy)\n        im.apply_scaling(rx, ry)\n        #im.resize(int(widthDisplay+0.5), int(heightDisplay+0.5),\n        #          norm=self._filternorm, radius=self._filterrad)\n        im.resize(int(widthDisplay), int(heightDisplay),\n                  norm=self._filternorm, radius=self._filterrad)\n        return im\n\n    @allow_rasterization\n    def draw(self, renderer, *args, **kwargs):\n        if not self.get_visible():\n            return\n        # todo: we should be able to do some cacheing here\n        image_mag = renderer.get_image_magnification()\n        im = self.make_image(renderer, image_mag)\n        x0, y0, x1, y1 = self.get_window_extent(renderer).extents\n        gc = renderer.new_gc()\n        self._set_gc_clip(gc)\n        gc.set_alpha(self.get_alpha())\n        #gc.set_clip_path(self.get_clip_path())\n\n        l = np.min([x0, x1])\n        b = np.min([y0, y1])\n        renderer.draw_image(gc, round(l), round(b), im)\n        gc.restore()\n\n\ndef imread(fname, format=None):\n    \"\"\"\n    Read an image from a file into an array.\n\n    *fname* may be a string path or a Python file-like object.  If\n    using a file object, it must be opened in binary mode.\n\n    If *format* is provided, will try to read file of that type,\n    otherwise the format is deduced from the filename.  If nothing can\n    be deduced, PNG is tried.\n\n    Return value is a :class:`numpy.array`.  For grayscale images, the\n    return array is MxN.  For RGB images, the return value is MxNx3.\n    For RGBA images the return value is MxNx4.\n\n    matplotlib can only read PNGs natively, but if `PIL\n    <http://www.pythonware.com/products/pil/>`_ is installed, it will\n    use it to load the image and return an array (if possible) which\n    can be used with :func:`~matplotlib.pyplot.imshow`.\n    \"\"\"\n\n    def pilread(fname):\n        \"\"\"try to load the image with PIL or return None\"\"\"\n        try:\n            from PIL import Image\n        except ImportError:\n            return None\n        if cbook.is_string_like(fname):\n            # force close the file after reading the image\n            with open(fname, \"rb\") as fh:\n                image = Image.open(fh)\n                return pil_to_array(image)\n        else:\n            image = Image.open(fname)\n            return pil_to_array(image)\n\n    handlers = {'png': _png.read_png, }\n    if format is None:\n        if cbook.is_string_like(fname):\n            basename, ext = os.path.splitext(fname)\n            ext = ext.lower()[1:]\n        elif hasattr(fname, 'name'):\n            basename, ext = os.path.splitext(fname.name)\n            ext = ext.lower()[1:]\n        else:\n            ext = 'png'\n    else:\n        ext = format\n\n    if ext not in handlers:\n        im = pilread(fname)\n        if im is None:\n            raise ValueError('Only know how to handle extensions: %s; '\n                             'with PIL installed matplotlib can handle '\n                             'more images' % list(six.iterkeys(handlers.keys)))\n        return im\n\n    handler = handlers[ext]\n\n    # To handle Unicode filenames, we pass a file object to the PNG\n    # reader extension, since Python handles them quite well, but it's\n    # tricky in C.\n    if cbook.is_string_like(fname):\n        with open(fname, 'rb') as fd:\n            return handler(fd)\n    else:\n        return handler(fname)\n\n\ndef imsave(fname, arr, vmin=None, vmax=None, cmap=None, format=None,\n           origin=None, dpi=100):\n    \"\"\"\n    Save an array as in image file.\n\n    The output formats available depend on the backend being used.\n\n    Arguments:\n      *fname*:\n        A string containing a path to a filename, or a Python file-like object.\n        If *format* is *None* and *fname* is a string, the output\n        format is deduced from the extension of the filename.\n      *arr*:\n        An MxN (luminance), MxNx3 (RGB) or MxNx4 (RGBA) array.\n    Keyword arguments:\n      *vmin*/*vmax*: [ None | scalar ]\n        *vmin* and *vmax* set the color scaling for the image by fixing the\n        values that map to the colormap color limits. If either *vmin*\n        or *vmax* is None, that limit is determined from the *arr*\n        min/max value.\n      *cmap*:\n        cmap is a colors.Colormap instance, eg cm.jet.\n        If None, default to the rc image.cmap value.\n      *format*:\n        One of the file extensions supported by the active\n        backend.  Most backends support png, pdf, ps, eps and svg.\n      *origin*\n        [ 'upper' | 'lower' ] Indicates where the [0,0] index of\n        the array is in the upper left or lower left corner of\n        the axes. Defaults to the rc image.origin value.\n      *dpi*\n        The DPI to store in the metadata of the file.  This does not affect the\n        resolution of the output image.\n    \"\"\"\n    from matplotlib.backends.backend_agg import FigureCanvasAgg as FigureCanvas\n    from matplotlib.figure import Figure\n\n    figsize = [x / float(dpi) for x in (arr.shape[1], arr.shape[0])]\n    fig = Figure(figsize=figsize, dpi=dpi, frameon=False)\n    canvas = FigureCanvas(fig)\n    im = fig.figimage(arr, cmap=cmap, vmin=vmin, vmax=vmax, origin=origin)\n    fig.savefig(fname, dpi=dpi, format=format, transparent=True)\n\n\ndef pil_to_array(pilImage):\n    \"\"\"\n    Load a PIL image and return it as a numpy array.  For grayscale\n    images, the return array is MxN.  For RGB images, the return value\n    is MxNx3.  For RGBA images the return value is MxNx4\n    \"\"\"\n    def toarray(im, dtype=np.uint8):\n        \"\"\"Return a 1D array of dtype.\"\"\"\n        # Pillow wants us to use \"tobytes\"\n        if hasattr(im, 'tobytes'):\n            x_str = im.tobytes('raw', im.mode)\n        else:\n            x_str = im.tostring('raw', im.mode)\n        x = np.fromstring(x_str, dtype)\n        return x\n\n    if pilImage.mode in ('RGBA', 'RGBX'):\n        im = pilImage  # no need to convert images\n    elif pilImage.mode == 'L':\n        im = pilImage  # no need to luminance images\n        # return MxN luminance array\n        x = toarray(im)\n        x.shape = im.size[1], im.size[0]\n        return x\n    elif pilImage.mode == 'RGB':\n        #return MxNx3 RGB array\n        im = pilImage  # no need to RGB images\n        x = toarray(im)\n        x.shape = im.size[1], im.size[0], 3\n        return x\n    elif pilImage.mode.startswith('I;16'):\n        # return MxN luminance array of uint16\n        im = pilImage\n        if im.mode.endswith('B'):\n            x = toarray(im, '>u2')\n        else:\n            x = toarray(im, '<u2')\n        x.shape = im.size[1], im.size[0]\n        return x.astype('=u2')\n    else:  # try to convert to an rgba image\n        try:\n            im = pilImage.convert('RGBA')\n        except ValueError:\n            raise RuntimeError('Unknown image mode')\n\n    # return MxNx4 RGBA array\n    x = toarray(im)\n    x.shape = im.size[1], im.size[0], 4\n    return x\n\n\ndef thumbnail(infile, thumbfile, scale=0.1, interpolation='bilinear',\n              preview=False):\n    \"\"\"\n    make a thumbnail of image in *infile* with output filename\n    *thumbfile*.\n\n      *infile* the image file -- must be PNG or PIL readable if you\n         have `PIL <http://www.pythonware.com/products/pil/>`_ installed\n\n      *thumbfile*\n        the thumbnail filename\n\n      *scale*\n        the scale factor for the thumbnail\n\n      *interpolation*\n        the interpolation scheme used in the resampling\n\n\n      *preview*\n        if True, the default backend (presumably a user interface\n        backend) will be used which will cause a figure to be raised\n        if :func:`~matplotlib.pyplot.show` is called.  If it is False,\n        a pure image backend will be used depending on the extension,\n        'png'->FigureCanvasAgg, 'pdf'->FigureCanvasPdf,\n        'svg'->FigureCanvasSVG\n\n\n    See examples/misc/image_thumbnail.py.\n\n    .. htmlonly::\n\n        :ref:`misc-image_thumbnail`\n\n    Return value is the figure instance containing the thumbnail\n\n    \"\"\"\n    basedir, basename = os.path.split(infile)\n    baseout, extout = os.path.splitext(thumbfile)\n\n    im = imread(infile)\n    rows, cols, depth = im.shape\n\n    # this doesn't really matter, it will cancel in the end, but we\n    # need it for the mpl API\n    dpi = 100\n\n    height = float(rows)/dpi*scale\n    width = float(cols)/dpi*scale\n\n    extension = extout.lower()\n\n    if preview:\n        # let the UI backend do everything\n        import matplotlib.pyplot as plt\n        fig = plt.figure(figsize=(width, height), dpi=dpi)\n    else:\n        if extension == '.png':\n            from matplotlib.backends.backend_agg \\\n                import FigureCanvasAgg as FigureCanvas\n        elif extension == '.pdf':\n            from matplotlib.backends.backend_pdf \\\n                import FigureCanvasPdf as FigureCanvas\n        elif extension == '.svg':\n            from matplotlib.backends.backend_svg \\\n                import FigureCanvasSVG as FigureCanvas\n        else:\n            raise ValueError(\"Can only handle \"\n                             \"extensions 'png', 'svg' or 'pdf'\")\n\n        from matplotlib.figure import Figure\n        fig = Figure(figsize=(width, height), dpi=dpi)\n        canvas = FigureCanvas(fig)\n\n    ax = fig.add_axes([0, 0, 1, 1], aspect='auto',\n                      frameon=False, xticks=[], yticks=[])\n\n    basename, ext = os.path.splitext(basename)\n    ax.imshow(im, aspect='auto', resample=True, interpolation=interpolation)\n    fig.savefig(thumbfile, dpi=dpi)\n    return fig\n", "patch": "@@ -204,15 +204,19 @@ def _get_unsampled_image(self, A, image_extents, viewlim):\n             self._oldyslice = yslice\n \n         if self._imcache is None:\n-            if self._A.dtype == np.uint8 and self._A.ndim == 3:\n-                im = _image.frombyte(self._A[yslice, xslice, :], 0)\n+            A = self._A\n+            if self.origin == 'upper':\n+                A = A[::-1]\n+\n+            if A.dtype == np.uint8 and A.ndim == 3:\n+                im = _image.frombyte(A[yslice, xslice, :], 0)\n                 im.is_grayscale = False\n             else:\n                 if self._rgbacache is None:\n-                    x = self.to_rgba(self._A, bytes=False)\n+                    x = self.to_rgba(A, bytes=False)\n                     # Avoid side effects: to_rgba can return its argument\n                     # unchanged.\n-                    if np.may_share_memory(x, self._A):\n+                    if np.may_share_memory(x, A):\n                         x = x.copy()\n                     # premultiply the colors\n                     x[..., 0:3] *= x[..., 3:4]\n@@ -226,9 +230,6 @@ def _get_unsampled_image(self, A, image_extents, viewlim):\n                 else:\n                     im.is_grayscale = False\n             self._imcache = im\n-\n-            if self.origin == 'upper':\n-                im.flipud_in()\n         else:\n             im = self._imcache\n \n@@ -413,9 +414,7 @@ def write_png(self, fname, noscale=False):\n             im.reset_matrix()\n             im.set_interpolation(0)\n             im.resize(numcols, numrows)\n-        im.flipud_out()\n-        rows, cols, buffer = im.as_rgba_str()\n-        _png.write_png(buffer, cols, rows, fname)\n+        _png.write_png(im, fname)\n \n     def set_data(self, A):\n         \"\"\"\n@@ -732,7 +731,7 @@ def make_image(self, magnification=1.0):\n         width *= magnification\n         height *= magnification\n         im = _image.pcolor(self._Ax, self._Ay, A,\n-                           height, width,\n+                           int(height), int(width),\n                            (x0, x0+v_width, y0, y0+v_height),\n                            self._interpd[self._interpolation])\n \n@@ -1005,7 +1004,11 @@ def make_image(self, magnification=1.0):\n         if self._A is None:\n             raise RuntimeError('You must first set the image array')\n \n-        x = self.to_rgba(self._A, bytes=True)\n+        A = self._A\n+        if self.origin == 'upper':\n+            A = A[::-1]\n+\n+        x = self.to_rgba(A, bytes=True)\n         self.magnification = magnification\n         # if magnification is not one, we need to resize\n         ismag = magnification != 1\n@@ -1018,16 +1021,14 @@ def make_image(self, magnification=1.0):\n         fc = self.figure.get_facecolor()\n         im.set_bg(*mcolors.colorConverter.to_rgba(fc, 0))\n         im.is_grayscale = (self.cmap.name == \"gray\" and\n-                           len(self._A.shape) == 2)\n+                           len(A.shape) == 2)\n \n         if ismag:\n             numrows, numcols = self.get_size()\n             numrows *= magnification\n             numcols *= magnification\n             im.set_interpolation(_image.NEAREST)\n             im.resize(numcols, numrows)\n-        if self.origin == 'upper':\n-            im.flipud_out()\n \n         return im\n \n@@ -1047,8 +1048,7 @@ def draw(self, renderer, *args, **kwargs):\n     def write_png(self, fname):\n         \"\"\"Write the image to png file with fname\"\"\"\n         im = self.make_image()\n-        rows, cols, buffer = im.as_rgba_str()\n-        _png.write_png(buffer, cols, rows, fname)\n+        _png.write_png(im, fname)\n \n \n class BboxImage(_AxesImageBase):\n@@ -1131,24 +1131,24 @@ def make_image(self, renderer, magnification=1.0):\n                                'array or the image attribute')\n \n         if self._imcache is None:\n-            if self._A.dtype == np.uint8 and len(self._A.shape) == 3:\n-                im = _image.frombyte(self._A, 0)\n+            A = self._A\n+            if self.origin == 'upper':\n+                A = A[::-1]\n+            if A.dtype == np.uint8 and len(A.shape) == 3:\n+                im = _image.frombyte(A, 0)\n                 im.is_grayscale = False\n             else:\n                 if self._rgbacache is None:\n-                    x = self.to_rgba(self._A, bytes=True)\n+                    x = self.to_rgba(A, bytes=True)\n                     self._rgbacache = x\n                 else:\n                     x = self._rgbacache\n                 im = _image.frombyte(x, 0)\n-                if len(self._A.shape) == 2:\n+                if len(A.shape) == 2:\n                     im.is_grayscale = self.cmap.is_gray()\n                 else:\n                     im.is_grayscale = False\n             self._imcache = im\n-\n-            if self.origin == 'upper':\n-                im.flipud_in()\n         else:\n             im = self._imcache\n "}
{"patches_id": 2, "files_id": 19, "language": "py", "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Fmathtext.py", "raw_code": "r\"\"\"\n:mod:`~matplotlib.mathtext` is a module for parsing a subset of the\nTeX math syntax and drawing them to a matplotlib backend.\n\nFor a tutorial of its usage see :ref:`mathtext-tutorial`.  This\ndocument is primarily concerned with implementation details.\n\nThe module uses pyparsing_ to parse the TeX expression.\n\n.. _pyparsing: http://pyparsing.wikispaces.com/\n\nThe Bakoma distribution of the TeX Computer Modern fonts, and STIX\nfonts are supported.  There is experimental support for using\narbitrary fonts, but results may vary without proper tweaking and\nmetrics for those fonts.\n\nIf you find TeX expressions that don't parse or render properly,\nplease email mdroe@stsci.edu, but please check KNOWN ISSUES below first.\n\"\"\"\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport six\n\nimport os, sys\nfrom six import unichr\nfrom math import ceil\ntry:\n    set\nexcept NameError:\n    from sets import Set as set\nimport unicodedata\nfrom warnings import warn\n\nfrom numpy import inf, isinf\nimport numpy as np\n\nimport pyparsing\nfrom pyparsing import Combine, Group, Optional, Forward, \\\n     Literal, OneOrMore, ZeroOrMore, ParseException, Empty, \\\n     ParseResults, Suppress, oneOf, StringEnd, ParseFatalException, \\\n     FollowedBy, Regex, ParserElement, QuotedString, ParseBaseException\n\n# Enable packrat parsing\nif (six.PY3 and\n    [int(x) for x in pyparsing.__version__.split('.')] < [2, 0, 0]):\n    warn(\"Due to a bug in pyparsing <= 2.0.0 on Python 3.x, packrat parsing \"\n         \"has been disabled.  Mathtext rendering will be much slower as a \"\n         \"result.  Install pyparsing 2.0.0 or later to improve performance.\")\nelse:\n    ParserElement.enablePackrat()\n\nfrom matplotlib.afm import AFM\nfrom matplotlib.cbook import Bunch, get_realpath_and_stat, \\\n    is_string_like, maxdict\nfrom matplotlib.ft2font import FT2Font, FT2Image, KERNING_DEFAULT, LOAD_FORCE_AUTOHINT, LOAD_NO_HINTING\nfrom matplotlib.font_manager import findfont, FontProperties\nfrom matplotlib._mathtext_data import latex_to_bakoma, \\\n        latex_to_standard, tex2uni, latex_to_cmex, stix_virtual_fonts\nfrom matplotlib import get_data_path, rcParams\n\nimport matplotlib.colors as mcolors\nimport matplotlib._png as _png\n####################\n\n\n\n##############################################################################\n# FONTS\n\ndef get_unicode_index(symbol):\n    \"\"\"get_unicode_index(symbol) -> integer\n\nReturn the integer index (from the Unicode table) of symbol.  *symbol*\ncan be a single unicode character, a TeX command (i.e. r'\\pi'), or a\nType1 symbol name (i.e. 'phi').\n\"\"\"\n    # From UTF #25: U+2212 minus sign is the preferred\n    # representation of the unary and binary minus sign rather than\n    # the ASCII-derived U+002D hyphen-minus, because minus sign is\n    # unambiguous and because it is rendered with a more desirable\n    # length, usually longer than a hyphen.\n    if symbol == '-':\n        return 0x2212\n    try:# This will succeed if symbol is a single unicode char\n        return ord(symbol)\n    except TypeError:\n        pass\n    try:# Is symbol a TeX symbol (i.e. \\alpha)\n        return tex2uni[symbol.strip(\"\\\\\")]\n    except KeyError:\n        message = \"\"\"'%(symbol)s' is not a valid Unicode character or\nTeX/Type1 symbol\"\"\"%locals()\n        raise ValueError(message)\n\ndef unichr_safe(index):\n    \"\"\"Return the Unicode character corresponding to the index,\nor the replacement character if this is a narrow build of Python\nand the requested character is outside the BMP.\"\"\"\n    try:\n        return unichr(index)\n    except ValueError:\n        return unichr(0xFFFD)\n\nclass MathtextBackend(object):\n    \"\"\"\n    The base class for the mathtext backend-specific code.  The\n    purpose of :class:`MathtextBackend` subclasses is to interface\n    between mathtext and a specific matplotlib graphics backend.\n\n    Subclasses need to override the following:\n\n      - :meth:`render_glyph`\n      - :meth:`render_filled_rect`\n      - :meth:`get_results`\n\n    And optionally, if you need to use a Freetype hinting style:\n\n      - :meth:`get_hinting_type`\n    \"\"\"\n    def __init__(self):\n        self.width = 0\n        self.height = 0\n        self.depth = 0\n\n    def set_canvas_size(self, w, h, d):\n        'Dimension the drawing canvas'\n        self.width  = w\n        self.height = h\n        self.depth  = d\n\n    def render_glyph(self, ox, oy, info):\n        \"\"\"\n        Draw a glyph described by *info* to the reference point (*ox*,\n        *oy*).\n        \"\"\"\n        raise NotImplementedError()\n\n    def render_filled_rect(self, x1, y1, x2, y2):\n        \"\"\"\n        Draw a filled black rectangle from (*x1*, *y1*) to (*x2*, *y2*).\n        \"\"\"\n        raise NotImplementedError()\n\n    def get_results(self, box):\n        \"\"\"\n        Return a backend-specific tuple to return to the backend after\n        all processing is done.\n        \"\"\"\n        raise NotImplementedError()\n\n    def get_hinting_type(self):\n        \"\"\"\n        Get the Freetype hinting type to use with this particular\n        backend.\n        \"\"\"\n        return LOAD_NO_HINTING\n\nclass MathtextBackendAgg(MathtextBackend):\n    \"\"\"\n    Render glyphs and rectangles to an FTImage buffer, which is later\n    transferred to the Agg image by the Agg backend.\n    \"\"\"\n    def __init__(self):\n        self.ox = 0\n        self.oy = 0\n        self.image = None\n        self.mode = 'bbox'\n        self.bbox = [0, 0, 0, 0]\n        MathtextBackend.__init__(self)\n\n    def _update_bbox(self, x1, y1, x2, y2):\n        self.bbox = [min(self.bbox[0], x1),\n                     min(self.bbox[1], y1),\n                     max(self.bbox[2], x2),\n                     max(self.bbox[3], y2)]\n\n    def set_canvas_size(self, w, h, d):\n        MathtextBackend.set_canvas_size(self, w, h, d)\n        if self.mode != 'bbox':\n            self.image = FT2Image(ceil(w), ceil(h + d))\n\n    def render_glyph(self, ox, oy, info):\n        if self.mode == 'bbox':\n            self._update_bbox(ox + info.metrics.xmin,\n                              oy - info.metrics.ymax,\n                              ox + info.metrics.xmax,\n                              oy - info.metrics.ymin)\n        else:\n            info.font.draw_glyph_to_bitmap(\n                self.image, ox, oy - info.metrics.iceberg, info.glyph,\n                antialiased=rcParams['text.antialiased'])\n\n    def render_rect_filled(self, x1, y1, x2, y2):\n        if self.mode == 'bbox':\n            self._update_bbox(x1, y1, x2, y2)\n        else:\n            height = max(int(y2 - y1) - 1, 0)\n            if height == 0:\n                center = (y2 + y1) / 2.0\n                y = int(center - (height + 1) / 2.0)\n            else:\n                y = int(y1)\n            self.image.draw_rect_filled(int(x1), y, ceil(x2), y + height)\n\n    def get_results(self, box, used_characters):\n        self.mode = 'bbox'\n        orig_height = box.height\n        orig_depth  = box.depth\n        ship(0, 0, box)\n        bbox = self.bbox\n        bbox = [bbox[0] - 1, bbox[1] - 1, bbox[2] + 1, bbox[3] + 1]\n        self.mode = 'render'\n        self.set_canvas_size(\n            bbox[2] - bbox[0],\n            (bbox[3] - bbox[1]) - orig_depth,\n            (bbox[3] - bbox[1]) - orig_height)\n        ship(-bbox[0], -bbox[1], box)\n        result = (self.ox,\n                  self.oy,\n                  self.width,\n                  self.height + self.depth,\n                  self.depth,\n                  self.image,\n                  used_characters)\n        self.image = None\n        return result\n\n    def get_hinting_type(self):\n        from matplotlib.backends import backend_agg\n        return backend_agg.get_hinting_flag()\n\nclass MathtextBackendBitmap(MathtextBackendAgg):\n    def get_results(self, box, used_characters):\n        ox, oy, width, height, depth, image, characters = \\\n            MathtextBackendAgg.get_results(self, box, used_characters)\n        return image, depth\n\nclass MathtextBackendPs(MathtextBackend):\n    \"\"\"\n    Store information to write a mathtext rendering to the PostScript\n    backend.\n    \"\"\"\n    def __init__(self):\n        self.pswriter = six.moves.cStringIO()\n        self.lastfont = None\n\n    def render_glyph(self, ox, oy, info):\n        oy = self.height - oy + info.offset\n        postscript_name = info.postscript_name\n        fontsize        = info.fontsize\n        symbol_name     = info.symbol_name\n\n        if (postscript_name, fontsize) != self.lastfont:\n            ps = \"\"\"/%(postscript_name)s findfont\n%(fontsize)s scalefont\nsetfont\n\"\"\" % locals()\n            self.lastfont = postscript_name, fontsize\n            self.pswriter.write(ps)\n\n        ps = \"\"\"%(ox)f %(oy)f moveto\n/%(symbol_name)s glyphshow\\n\n\"\"\" % locals()\n        self.pswriter.write(ps)\n\n    def render_rect_filled(self, x1, y1, x2, y2):\n        ps = \"%f %f %f %f rectfill\\n\" % (x1, self.height - y2, x2 - x1, y2 - y1)\n        self.pswriter.write(ps)\n\n    def get_results(self, box, used_characters):\n        ship(0, 0, box)\n        return (self.width,\n                self.height + self.depth,\n                self.depth,\n                self.pswriter,\n                used_characters)\n\nclass MathtextBackendPdf(MathtextBackend):\n    \"\"\"\n    Store information to write a mathtext rendering to the PDF\n    backend.\n    \"\"\"\n    def __init__(self):\n        self.glyphs = []\n        self.rects = []\n\n    def render_glyph(self, ox, oy, info):\n        filename = info.font.fname\n        oy = self.height - oy + info.offset\n        self.glyphs.append(\n            (ox, oy, filename, info.fontsize,\n             info.num, info.symbol_name))\n\n    def render_rect_filled(self, x1, y1, x2, y2):\n        self.rects.append((x1, self.height - y2, x2 - x1, y2 - y1))\n\n    def get_results(self, box, used_characters):\n        ship(0, 0, box)\n        return (self.width,\n                self.height + self.depth,\n                self.depth,\n                self.glyphs,\n                self.rects,\n                used_characters)\n\nclass MathtextBackendSvg(MathtextBackend):\n    \"\"\"\n    Store information to write a mathtext rendering to the SVG\n    backend.\n    \"\"\"\n    def __init__(self):\n        self.svg_glyphs = []\n        self.svg_rects = []\n\n    def render_glyph(self, ox, oy, info):\n        oy = self.height - oy + info.offset\n\n        self.svg_glyphs.append(\n            (info.font, info.fontsize, info.num, ox, oy, info.metrics))\n\n    def render_rect_filled(self, x1, y1, x2, y2):\n        self.svg_rects.append(\n            (x1, self.height - y1 + 1, x2 - x1, y2 - y1))\n\n    def get_results(self, box, used_characters):\n        ship(0, 0, box)\n        svg_elements = Bunch(svg_glyphs = self.svg_glyphs,\n                             svg_rects = self.svg_rects)\n        return (self.width,\n                self.height + self.depth,\n                self.depth,\n                svg_elements,\n                used_characters)\n\nclass MathtextBackendPath(MathtextBackend):\n    \"\"\"\n    Store information to write a mathtext rendering to the text path\n    machinery.\n    \"\"\"\n\n    def __init__(self):\n        self.glyphs = []\n        self.rects = []\n\n    def render_glyph(self, ox, oy, info):\n        oy = self.height - oy + info.offset\n        thetext = info.num\n        self.glyphs.append(\n            (info.font, info.fontsize, thetext, ox, oy))\n\n    def render_rect_filled(self, x1, y1, x2, y2):\n        self.rects.append(\n            (x1, self.height-y2 , x2 - x1, y2 - y1))\n\n    def get_results(self, box, used_characters):\n        ship(0, 0, box)\n        return (self.width,\n                self.height + self.depth,\n                self.depth,\n                self.glyphs,\n                self.rects)\n\nclass MathtextBackendCairo(MathtextBackend):\n    \"\"\"\n    Store information to write a mathtext rendering to the Cairo\n    backend.\n    \"\"\"\n\n    def __init__(self):\n        self.glyphs = []\n        self.rects = []\n\n    def render_glyph(self, ox, oy, info):\n        oy = oy - info.offset - self.height\n        thetext = unichr_safe(info.num)\n        self.glyphs.append(\n            (info.font, info.fontsize, thetext, ox, oy))\n\n    def render_rect_filled(self, x1, y1, x2, y2):\n        self.rects.append(\n            (x1, y1 - self.height, x2 - x1, y2 - y1))\n\n    def get_results(self, box, used_characters):\n        ship(0, 0, box)\n        return (self.width,\n                self.height + self.depth,\n                self.depth,\n                self.glyphs,\n                self.rects)\n\nclass Fonts(object):\n    \"\"\"\n    An abstract base class for a system of fonts to use for mathtext.\n\n    The class must be able to take symbol keys and font file names and\n    return the character metrics.  It also delegates to a backend class\n    to do the actual drawing.\n    \"\"\"\n\n    def __init__(self, default_font_prop, mathtext_backend):\n        \"\"\"\n        *default_font_prop*: A\n        :class:`~matplotlib.font_manager.FontProperties` object to use\n        for the default non-math font, or the base font for Unicode\n        (generic) font rendering.\n\n        *mathtext_backend*: A subclass of :class:`MathTextBackend`\n        used to delegate the actual rendering.\n        \"\"\"\n        self.default_font_prop = default_font_prop\n        self.mathtext_backend = mathtext_backend\n        self.used_characters = {}\n\n    def destroy(self):\n        \"\"\"\n        Fix any cyclical references before the object is about\n        to be destroyed.\n        \"\"\"\n        self.used_characters = None\n\n    def get_kern(self, font1, fontclass1, sym1, fontsize1,\n                 font2, fontclass2, sym2, fontsize2, dpi):\n        \"\"\"\n        Get the kerning distance for font between *sym1* and *sym2*.\n\n        *fontX*: one of the TeX font names::\n\n          tt, it, rm, cal, sf, bf or default/regular (non-math)\n\n        *fontclassX*: TODO\n\n        *symX*: a symbol in raw TeX form. e.g., '1', 'x' or '\\sigma'\n\n        *fontsizeX*: the fontsize in points\n\n        *dpi*: the current dots-per-inch\n        \"\"\"\n        return 0.\n\n    def get_metrics(self, font, font_class, sym, fontsize, dpi):\n        \"\"\"\n        *font*: one of the TeX font names::\n\n          tt, it, rm, cal, sf, bf or default/regular (non-math)\n\n        *font_class*: TODO\n\n        *sym*:  a symbol in raw TeX form. e.g., '1', 'x' or '\\sigma'\n\n        *fontsize*: font size in points\n\n        *dpi*: current dots-per-inch\n\n        Returns an object with the following attributes:\n\n          - *advance*: The advance distance (in points) of the glyph.\n\n          - *height*: The height of the glyph in points.\n\n          - *width*: The width of the glyph in points.\n\n          - *xmin*, *xmax*, *ymin*, *ymax* - the ink rectangle of the glyph\n\n          - *iceberg* - the distance from the baseline to the top of\n            the glyph.  This corresponds to TeX's definition of\n            \"height\".\n        \"\"\"\n        info = self._get_info(font, font_class, sym, fontsize, dpi)\n        return info.metrics\n\n    def set_canvas_size(self, w, h, d):\n        \"\"\"\n        Set the size of the buffer used to render the math expression.\n        Only really necessary for the bitmap backends.\n        \"\"\"\n        self.width, self.height, self.depth = ceil(w), ceil(h), ceil(d)\n        self.mathtext_backend.set_canvas_size(self.width, self.height, self.depth)\n\n    def render_glyph(self, ox, oy, facename, font_class, sym, fontsize, dpi):\n        \"\"\"\n        Draw a glyph at\n\n          - *ox*, *oy*: position\n\n          - *facename*: One of the TeX face names\n\n          - *font_class*:\n\n          - *sym*: TeX symbol name or single character\n\n          - *fontsize*: fontsize in points\n\n          - *dpi*: The dpi to draw at.\n        \"\"\"\n        info = self._get_info(facename, font_class, sym, fontsize, dpi)\n        realpath, stat_key = get_realpath_and_stat(info.font.fname)\n        used_characters = self.used_characters.setdefault(\n            stat_key, (realpath, set()))\n        used_characters[1].add(info.num)\n        self.mathtext_backend.render_glyph(ox, oy, info)\n\n    def render_rect_filled(self, x1, y1, x2, y2):\n        \"\"\"\n        Draw a filled rectangle from (*x1*, *y1*) to (*x2*, *y2*).\n        \"\"\"\n        self.mathtext_backend.render_rect_filled(x1, y1, x2, y2)\n\n    def get_xheight(self, font, fontsize, dpi):\n        \"\"\"\n        Get the xheight for the given *font* and *fontsize*.\n        \"\"\"\n        raise NotImplementedError()\n\n    def get_underline_thickness(self, font, fontsize, dpi):\n        \"\"\"\n        Get the line thickness that matches the given font.  Used as a\n        base unit for drawing lines such as in a fraction or radical.\n        \"\"\"\n        raise NotImplementedError()\n\n    def get_used_characters(self):\n        \"\"\"\n        Get the set of characters that were used in the math\n        expression.  Used by backends that need to subset fonts so\n        they know which glyphs to include.\n        \"\"\"\n        return self.used_characters\n\n    def get_results(self, box):\n        \"\"\"\n        Get the data needed by the backend to render the math\n        expression.  The return value is backend-specific.\n        \"\"\"\n        result = self.mathtext_backend.get_results(box, self.get_used_characters())\n        self.destroy()\n        return result\n\n    def get_sized_alternatives_for_symbol(self, fontname, sym):\n        \"\"\"\n        Override if your font provides multiple sizes of the same\n        symbol.  Should return a list of symbols matching *sym* in\n        various sizes.  The expression renderer will select the most\n        appropriate size for a given situation from this list.\n        \"\"\"\n        return [(fontname, sym)]\n\nclass TruetypeFonts(Fonts):\n    \"\"\"\n    A generic base class for all font setups that use Truetype fonts\n    (through FT2Font).\n    \"\"\"\n    class CachedFont:\n        def __init__(self, font):\n            self.font     = font\n            self.charmap  = font.get_charmap()\n            self.glyphmap = dict(\n                [(glyphind, ccode) for ccode, glyphind in six.iteritems(self.charmap)])\n\n        def __repr__(self):\n            return repr(self.font)\n\n    def __init__(self, default_font_prop, mathtext_backend):\n        Fonts.__init__(self, default_font_prop, mathtext_backend)\n        self.glyphd = {}\n        self._fonts = {}\n\n        filename = findfont(default_font_prop)\n        default_font = self.CachedFont(FT2Font(filename))\n        self._fonts['default'] = default_font\n        self._fonts['regular'] = default_font\n\n    def destroy(self):\n        self.glyphd = None\n        Fonts.destroy(self)\n\n    def _get_font(self, font):\n        if font in self.fontmap:\n            basename = self.fontmap[font]\n        else:\n            basename = font\n\n        cached_font = self._fonts.get(basename)\n        if cached_font is None and os.path.exists(basename):\n            font = FT2Font(basename)\n            cached_font = self.CachedFont(font)\n            self._fonts[basename] = cached_font\n            self._fonts[font.postscript_name] = cached_font\n            self._fonts[font.postscript_name.lower()] = cached_font\n        return cached_font\n\n    def _get_offset(self, cached_font, glyph, fontsize, dpi):\n        if cached_font.font.postscript_name == 'Cmex10':\n            return ((glyph.height/64.0/2.0) + (fontsize/3.0 * dpi/72.0))\n        return 0.\n\n    def _get_info(self, fontname, font_class, sym, fontsize, dpi):\n        key = fontname, font_class, sym, fontsize, dpi\n        bunch = self.glyphd.get(key)\n        if bunch is not None:\n            return bunch\n\n        cached_font, num, symbol_name, fontsize, slanted = \\\n            self._get_glyph(fontname, font_class, sym, fontsize)\n\n        font = cached_font.font\n        font.set_size(fontsize, dpi)\n        glyph = font.load_char(\n            num,\n            flags=self.mathtext_backend.get_hinting_type())\n\n        xmin, ymin, xmax, ymax = [val/64.0 for val in glyph.bbox]\n        offset = self._get_offset(cached_font, glyph, fontsize, dpi)\n        metrics = Bunch(\n            advance = glyph.linearHoriAdvance/65536.0,\n            height  = glyph.height/64.0,\n            width   = glyph.width/64.0,\n            xmin    = xmin,\n            xmax    = xmax,\n            ymin    = ymin+offset,\n            ymax    = ymax+offset,\n            # iceberg is the equivalent of TeX's \"height\"\n            iceberg = glyph.horiBearingY/64.0 + offset,\n            slanted = slanted\n            )\n\n        result = self.glyphd[key] = Bunch(\n            font            = font,\n            fontsize        = fontsize,\n            postscript_name = font.postscript_name,\n            metrics         = metrics,\n            symbol_name     = symbol_name,\n            num             = num,\n            glyph           = glyph,\n            offset          = offset\n            )\n        return result\n\n    def get_xheight(self, font, fontsize, dpi):\n        cached_font = self._get_font(font)\n        cached_font.font.set_size(fontsize, dpi)\n        pclt = cached_font.font.get_sfnt_table('pclt')\n        if pclt is None:\n            # Some fonts don't store the xHeight, so we do a poor man's xHeight\n            metrics = self.get_metrics(font, rcParams['mathtext.default'], 'x', fontsize, dpi)\n            return metrics.iceberg\n        xHeight = (pclt['xHeight'] / 64.0) * (fontsize / 12.0) * (dpi / 100.0)\n        return xHeight\n\n    def get_underline_thickness(self, font, fontsize, dpi):\n        # This function used to grab underline thickness from the font\n        # metrics, but that information is just too un-reliable, so it\n        # is now hardcoded.\n        return ((0.75 / 12.0) * fontsize * dpi) / 72.0\n\n    def get_kern(self, font1, fontclass1, sym1, fontsize1,\n                 font2, fontclass2, sym2, fontsize2, dpi):\n        if font1 == font2 and fontsize1 == fontsize2:\n            info1 = self._get_info(font1, fontclass1, sym1, fontsize1, dpi)\n            info2 = self._get_info(font2, fontclass2, sym2, fontsize2, dpi)\n            font = info1.font\n            return font.get_kerning(info1.num, info2.num, KERNING_DEFAULT) / 64.0\n        return Fonts.get_kern(self, font1, fontclass1, sym1, fontsize1,\n                              font2, fontclass2, sym2, fontsize2, dpi)\n\nclass BakomaFonts(TruetypeFonts):\n    \"\"\"\n    Use the Bakoma TrueType fonts for rendering.\n\n    Symbols are strewn about a number of font files, each of which has\n    its own proprietary 8-bit encoding.\n    \"\"\"\n    _fontmap = { 'cal' : 'cmsy10',\n                 'rm'  : 'cmr10',\n                 'tt'  : 'cmtt10',\n                 'it'  : 'cmmi10',\n                 'bf'  : 'cmb10',\n                 'sf'  : 'cmss10',\n                 'ex'  : 'cmex10'\n                 }\n\n    def __init__(self, *args, **kwargs):\n        self._stix_fallback = StixFonts(*args, **kwargs)\n\n        TruetypeFonts.__init__(self, *args, **kwargs)\n        self.fontmap = {}\n        for key, val in six.iteritems(self._fontmap):\n            fullpath = findfont(val)\n            self.fontmap[key] = fullpath\n            self.fontmap[val] = fullpath\n\n\n    _slanted_symbols = set(r\"\\int \\oint\".split())\n\n    def _get_glyph(self, fontname, font_class, sym, fontsize):\n        symbol_name = None\n        if fontname in self.fontmap and sym in latex_to_bakoma:\n            basename, num = latex_to_bakoma[sym]\n            slanted = (basename == \"cmmi10\") or sym in self._slanted_symbols\n            cached_font = self._get_font(basename)\n            if cached_font is not None:\n                symbol_name = cached_font.font.get_glyph_name(num)\n                num = cached_font.glyphmap[num]\n        elif len(sym) == 1:\n            slanted = (fontname == \"it\")\n            cached_font = self._get_font(fontname)\n            if cached_font is not None:\n                num = ord(sym)\n                gid = cached_font.charmap.get(num)\n                if gid is not None:\n                    symbol_name = cached_font.font.get_glyph_name(\n                        cached_font.charmap[num])\n\n        if symbol_name is None:\n            return self._stix_fallback._get_glyph(\n                fontname, font_class, sym, fontsize)\n\n        return cached_font, num, symbol_name, fontsize, slanted\n\n    # The Bakoma fonts contain many pre-sized alternatives for the\n    # delimiters.  The AutoSizedChar class will use these alternatives\n    # and select the best (closest sized) glyph.\n    _size_alternatives = {\n        '('          : [('rm', '('), ('ex', '\\xa1'), ('ex', '\\xb3'),\n                        ('ex', '\\xb5'), ('ex', '\\xc3')],\n        ')'          : [('rm', ')'), ('ex', '\\xa2'), ('ex', '\\xb4'),\n                        ('ex', '\\xb6'), ('ex', '\\x21')],\n        '{'          : [('cal', '{'), ('ex', '\\xa9'), ('ex', '\\x6e'),\n                        ('ex', '\\xbd'), ('ex', '\\x28')],\n        '}'          : [('cal', '}'), ('ex', '\\xaa'), ('ex', '\\x6f'),\n                        ('ex', '\\xbe'), ('ex', '\\x29')],\n        # The fourth size of '[' is mysteriously missing from the BaKoMa\n        # font, so I've ommitted it for both '[' and ']'\n        '['          : [('rm', '['), ('ex', '\\xa3'), ('ex', '\\x68'),\n                        ('ex', '\\x22')],\n        ']'          : [('rm', ']'), ('ex', '\\xa4'), ('ex', '\\x69'),\n                        ('ex', '\\x23')],\n        r'\\lfloor'   : [('ex', '\\xa5'), ('ex', '\\x6a'),\n                        ('ex', '\\xb9'), ('ex', '\\x24')],\n        r'\\rfloor'   : [('ex', '\\xa6'), ('ex', '\\x6b'),\n                        ('ex', '\\xba'), ('ex', '\\x25')],\n        r'\\lceil'    : [('ex', '\\xa7'), ('ex', '\\x6c'),\n                        ('ex', '\\xbb'), ('ex', '\\x26')],\n        r'\\rceil'    : [('ex', '\\xa8'), ('ex', '\\x6d'),\n                        ('ex', '\\xbc'), ('ex', '\\x27')],\n        r'\\langle'   : [('ex', '\\xad'), ('ex', '\\x44'),\n                        ('ex', '\\xbf'), ('ex', '\\x2a')],\n        r'\\rangle'   : [('ex', '\\xae'), ('ex', '\\x45'),\n                        ('ex', '\\xc0'), ('ex', '\\x2b')],\n        r'\\__sqrt__' : [('ex', '\\x70'), ('ex', '\\x71'),\n                        ('ex', '\\x72'), ('ex', '\\x73')],\n        r'\\backslash': [('ex', '\\xb2'), ('ex', '\\x2f'),\n                        ('ex', '\\xc2'), ('ex', '\\x2d')],\n        r'/'         : [('rm', '/'), ('ex', '\\xb1'), ('ex', '\\x2e'),\n                        ('ex', '\\xcb'), ('ex', '\\x2c')],\n        r'\\widehat'  : [('rm', '\\x5e'), ('ex', '\\x62'), ('ex', '\\x63'),\n                        ('ex', '\\x64')],\n        r'\\widetilde': [('rm', '\\x7e'), ('ex', '\\x65'), ('ex', '\\x66'),\n                        ('ex', '\\x67')],\n        r'<'         : [('cal', 'h'), ('ex', 'D')],\n        r'>'         : [('cal', 'i'), ('ex', 'E')]\n        }\n\n    for alias, target in [('\\leftparen', '('),\n                          ('\\rightparent', ')'),\n                          ('\\leftbrace', '{'),\n                          ('\\rightbrace', '}'),\n                          ('\\leftbracket', '['),\n                          ('\\rightbracket', ']'),\n                          (r'\\{', '{'),\n                          (r'\\}', '}'),\n                          (r'\\[', '['),\n                          (r'\\]', ']')]:\n        _size_alternatives[alias] = _size_alternatives[target]\n\n    def get_sized_alternatives_for_symbol(self, fontname, sym):\n        return self._size_alternatives.get(sym, [(fontname, sym)])\n\nclass UnicodeFonts(TruetypeFonts):\n    \"\"\"\n    An abstract base class for handling Unicode fonts.\n\n    While some reasonably complete Unicode fonts (such as DejaVu) may\n    work in some situations, the only Unicode font I'm aware of with a\n    complete set of math symbols is STIX.\n\n    This class will \"fallback\" on the Bakoma fonts when a required\n    symbol can not be found in the font.\n    \"\"\"\n    use_cmex = True\n\n    def __init__(self, *args, **kwargs):\n        # This must come first so the backend's owner is set correctly\n        if rcParams['mathtext.fallback_to_cm']:\n            self.cm_fallback = BakomaFonts(*args, **kwargs)\n        else:\n            self.cm_fallback = None\n        TruetypeFonts.__init__(self, *args, **kwargs)\n        self.fontmap = {}\n        for texfont in \"cal rm tt it bf sf\".split():\n            prop = rcParams['mathtext.' + texfont]\n            font = findfont(prop)\n            self.fontmap[texfont] = font\n        prop = FontProperties('cmex10')\n        font = findfont(prop)\n        self.fontmap['ex'] = font\n\n    _slanted_symbols = set(r\"\\int \\oint\".split())\n\n    def _map_virtual_font(self, fontname, font_class, uniindex):\n        return fontname, uniindex\n\n    def _get_glyph(self, fontname, font_class, sym, fontsize):\n        found_symbol = False\n\n        if self.use_cmex:\n            uniindex = latex_to_cmex.get(sym)\n            if uniindex is not None:\n                fontname = 'ex'\n                found_symbol = True\n\n        if not found_symbol:\n            try:\n                uniindex = get_unicode_index(sym)\n                found_symbol = True\n            except ValueError:\n                uniindex = ord('?')\n                warn(\"No TeX to unicode mapping for '%s'\" %\n                     sym.encode('ascii', 'backslashreplace'),\n                     MathTextWarning)\n\n        fontname, uniindex = self._map_virtual_font(\n            fontname, font_class, uniindex)\n\n        new_fontname = fontname\n\n        # Only characters in the \"Letter\" class should be italicized in 'it'\n        # mode.  Greek capital letters should be Roman.\n        if found_symbol:\n            if fontname == 'it':\n                if uniindex < 0x10000:\n                    unistring = unichr(uniindex)\n                    if (not unicodedata.category(unistring)[0] == \"L\"\n                        or unicodedata.name(unistring).startswith(\"GREEK CAPITAL\")):\n                        new_fontname = 'rm'\n\n            slanted = (new_fontname == 'it') or sym in self._slanted_symbols\n            found_symbol = False\n            cached_font = self._get_font(new_fontname)\n            if cached_font is not None:\n                try:\n                    glyphindex = cached_font.charmap[uniindex]\n                    found_symbol = True\n                except KeyError:\n                    pass\n\n        if not found_symbol:\n            if self.cm_fallback:\n                warn(\"Substituting with a symbol from Computer Modern.\",\n                     MathTextWarning)\n                return self.cm_fallback._get_glyph(\n                    fontname, 'it', sym, fontsize)\n            else:\n                if fontname in ('it', 'regular') and isinstance(self, StixFonts):\n                    return self._get_glyph('rm', font_class, sym, fontsize)\n                warn(\"Font '%s' does not have a glyph for '%s' [U%x]\" %\n                     (new_fontname, sym.encode('ascii', 'backslashreplace'), uniindex),\n                     MathTextWarning)\n                warn(\"Substituting with a dummy symbol.\", MathTextWarning)\n                fontname = 'rm'\n                new_fontname = fontname\n                cached_font = self._get_font(fontname)\n                uniindex = 0xA4 # currency character, for lack of anything better\n                glyphindex = cached_font.charmap[uniindex]\n                slanted = False\n\n        symbol_name = cached_font.font.get_glyph_name(glyphindex)\n        return cached_font, uniindex, symbol_name, fontsize, slanted\n\n    def get_sized_alternatives_for_symbol(self, fontname, sym):\n        if self.cm_fallback:\n            return self.cm_fallback.get_sized_alternatives_for_symbol(\n                fontname, sym)\n        return [(fontname, sym)]\n\nclass StixFonts(UnicodeFonts):\n    \"\"\"\n    A font handling class for the STIX fonts.\n\n    In addition to what UnicodeFonts provides, this class:\n\n    - supports \"virtual fonts\" which are complete alpha numeric\n      character sets with different font styles at special Unicode\n      code points, such as \"Blackboard\".\n\n    - handles sized alternative characters for the STIXSizeX fonts.\n    \"\"\"\n    _fontmap = { 'rm'  : 'STIXGeneral',\n                 'it'  : 'STIXGeneral:italic',\n                 'bf'  : 'STIXGeneral:weight=bold',\n                 'nonunirm' : 'STIXNonUnicode',\n                 'nonuniit' : 'STIXNonUnicode:italic',\n                 'nonunibf' : 'STIXNonUnicode:weight=bold',\n\n                 0 : 'STIXGeneral',\n                 1 : 'STIXSizeOneSym',\n                 2 : 'STIXSizeTwoSym',\n                 3 : 'STIXSizeThreeSym',\n                 4 : 'STIXSizeFourSym',\n                 5 : 'STIXSizeFiveSym'\n                 }\n    use_cmex = False\n    cm_fallback = False\n    _sans = False\n\n    def __init__(self, *args, **kwargs):\n        TruetypeFonts.__init__(self, *args, **kwargs)\n        self.fontmap = {}\n        for key, name in six.iteritems(self._fontmap):\n            fullpath = findfont(name)\n            self.fontmap[key] = fullpath\n            self.fontmap[name] = fullpath\n\n    def _map_virtual_font(self, fontname, font_class, uniindex):\n        # Handle these \"fonts\" that are actually embedded in\n        # other fonts.\n        mapping = stix_virtual_fonts.get(fontname)\n        if (self._sans and mapping is None and\n            fontname not in ('regular', 'default')):\n            mapping = stix_virtual_fonts['sf']\n            doing_sans_conversion = True\n        else:\n            doing_sans_conversion = False\n\n        if mapping is not None:\n            if isinstance(mapping, dict):\n                mapping = mapping.get(font_class, 'rm')\n\n            # Binary search for the source glyph\n            lo = 0\n            hi = len(mapping)\n            while lo < hi:\n                mid = (lo+hi)//2\n                range = mapping[mid]\n                if uniindex < range[0]:\n                    hi = mid\n                elif uniindex <= range[1]:\n                    break\n                else:\n                    lo = mid + 1\n\n            if uniindex >= range[0] and uniindex <= range[1]:\n                uniindex = uniindex - range[0] + range[3]\n                fontname = range[2]\n            elif not doing_sans_conversion:\n                # This will generate a dummy character\n                uniindex = 0x1\n                fontname = rcParams['mathtext.default']\n\n        # Handle private use area glyphs\n        if (fontname in ('it', 'rm', 'bf') and\n            uniindex >= 0xe000 and uniindex <= 0xf8ff):\n            fontname = 'nonuni' + fontname\n\n        return fontname, uniindex\n\n    _size_alternatives = {}\n    def get_sized_alternatives_for_symbol(self, fontname, sym):\n        fixes = {'\\{': '{', '\\}': '}', '\\[': '[', '\\]': ']'}\n        sym = fixes.get(sym, sym)\n\n        alternatives = self._size_alternatives.get(sym)\n        if alternatives:\n            return alternatives\n\n        alternatives = []\n        try:\n            uniindex = get_unicode_index(sym)\n        except ValueError:\n            return [(fontname, sym)]\n\n        fix_ups = {\n            ord('<'): 0x27e8,\n            ord('>'): 0x27e9 }\n\n        uniindex = fix_ups.get(uniindex, uniindex)\n\n        for i in range(6):\n            cached_font = self._get_font(i)\n            glyphindex = cached_font.charmap.get(uniindex)\n            if glyphindex is not None:\n                alternatives.append((i, unichr_safe(uniindex)))\n\n        # The largest size of the radical symbol in STIX has incorrect\n        # metrics that cause it to be disconnected from the stem.\n        if sym == r'\\__sqrt__':\n            alternatives = alternatives[:-1]\n\n        self._size_alternatives[sym] = alternatives\n        return alternatives\n\nclass StixSansFonts(StixFonts):\n    \"\"\"\n    A font handling class for the STIX fonts (that uses sans-serif\n    characters by default).\n    \"\"\"\n    _sans = True\n\nclass StandardPsFonts(Fonts):\n    \"\"\"\n    Use the standard postscript fonts for rendering to backend_ps\n\n    Unlike the other font classes, BakomaFont and UnicodeFont, this\n    one requires the Ps backend.\n    \"\"\"\n    basepath = os.path.join( get_data_path(), 'fonts', 'afm' )\n\n    fontmap = { 'cal' : 'pzcmi8a',  # Zapf Chancery\n                'rm'  : 'pncr8a',   # New Century Schoolbook\n                'tt'  : 'pcrr8a',   # Courier\n                'it'  : 'pncri8a',  # New Century Schoolbook Italic\n                'sf'  : 'phvr8a',   # Helvetica\n                'bf'  : 'pncb8a',   # New Century Schoolbook Bold\n                None  : 'psyr'      # Symbol\n                }\n\n    def __init__(self, default_font_prop):\n        Fonts.__init__(self, default_font_prop, MathtextBackendPs())\n        self.glyphd = {}\n        self.fonts = {}\n\n        filename = findfont(default_font_prop, fontext='afm',\n                            directory=self.basepath)\n        if filename is None:\n            filename = findfont('Helvetica', fontext='afm',\n                                directory=self.basepath)\n        with open(filename, 'r') as fd:\n            default_font = AFM(fd)\n        default_font.fname = filename\n\n        self.fonts['default'] = default_font\n        self.fonts['regular'] = default_font\n        self.pswriter = six.moves.cStringIO()\n\n    def _get_font(self, font):\n        if font in self.fontmap:\n            basename = self.fontmap[font]\n        else:\n            basename = font\n\n        cached_font = self.fonts.get(basename)\n        if cached_font is None:\n            fname = os.path.join(self.basepath, basename + \".afm\")\n            with open(fname, 'r') as fd:\n                cached_font = AFM(fd)\n            cached_font.fname = fname\n            self.fonts[basename] = cached_font\n            self.fonts[cached_font.get_fontname()] = cached_font\n        return cached_font\n\n    def _get_info (self, fontname, font_class, sym, fontsize, dpi):\n        'load the cmfont, metrics and glyph with caching'\n        key = fontname, sym, fontsize, dpi\n        tup = self.glyphd.get(key)\n\n        if tup is not None:\n            return tup\n\n        # Only characters in the \"Letter\" class should really be italicized.\n        # This class includes greek letters, so we're ok\n        if (fontname == 'it' and\n            (len(sym) > 1 or\n             not unicodedata.category(six.text_type(sym)).startswith(\"L\"))):\n            fontname = 'rm'\n\n        found_symbol = False\n\n        if sym in latex_to_standard:\n            fontname, num = latex_to_standard[sym]\n            glyph = chr(num)\n            found_symbol = True\n        elif len(sym) == 1:\n            glyph = sym\n            num = ord(glyph)\n            found_symbol = True\n        else:\n            warn(\"No TeX to built-in Postscript mapping for '%s'\" % sym,\n                 MathTextWarning)\n\n        slanted = (fontname == 'it')\n        font = self._get_font(fontname)\n\n        if found_symbol:\n            try:\n                symbol_name = font.get_name_char(glyph)\n            except KeyError:\n                warn(\"No glyph in standard Postscript font '%s' for '%s'\" %\n                     (font.postscript_name, sym),\n                     MathTextWarning)\n                found_symbol = False\n\n        if not found_symbol:\n            glyph = sym = '?'\n            num = ord(glyph)\n            symbol_name = font.get_name_char(glyph)\n\n        offset = 0\n\n        scale = 0.001 * fontsize\n\n        xmin, ymin, xmax, ymax = [val * scale\n                                  for val in font.get_bbox_char(glyph)]\n        metrics = Bunch(\n            advance  = font.get_width_char(glyph) * scale,\n            width    = font.get_width_char(glyph) * scale,\n            height   = font.get_height_char(glyph) * scale,\n            xmin = xmin,\n            xmax = xmax,\n            ymin = ymin+offset,\n            ymax = ymax+offset,\n            # iceberg is the equivalent of TeX's \"height\"\n            iceberg = ymax + offset,\n            slanted = slanted\n            )\n\n        self.glyphd[key] = Bunch(\n            font            = font,\n            fontsize        = fontsize,\n            postscript_name = font.get_fontname(),\n            metrics         = metrics,\n            symbol_name     = symbol_name,\n            num             = num,\n            glyph           = glyph,\n            offset          = offset\n            )\n\n        return self.glyphd[key]\n\n    def get_kern(self, font1, fontclass1, sym1, fontsize1,\n                 font2, fontclass2, sym2, fontsize2, dpi):\n        if font1 == font2 and fontsize1 == fontsize2:\n            info1 = self._get_info(font1, fontclass1, sym1, fontsize1, dpi)\n            info2 = self._get_info(font2, fontclass2, sym2, fontsize2, dpi)\n            font = info1.font\n            return (font.get_kern_dist(info1.glyph, info2.glyph)\n                    * 0.001 * fontsize1)\n        return Fonts.get_kern(self, font1, fontclass1, sym1, fontsize1,\n                              font2, fontclass2, sym2, fontsize2, dpi)\n\n    def get_xheight(self, font, fontsize, dpi):\n        cached_font = self._get_font(font)\n        return cached_font.get_xheight() * 0.001 * fontsize\n\n    def get_underline_thickness(self, font, fontsize, dpi):\n        cached_font = self._get_font(font)\n        return cached_font.get_underline_thickness() * 0.001 * fontsize\n\n##############################################################################\n# TeX-LIKE BOX MODEL\n\n# The following is based directly on the document 'woven' from the\n# TeX82 source code.  This information is also available in printed\n# form:\n#\n#    Knuth, Donald E.. 1986.  Computers and Typesetting, Volume B:\n#    TeX: The Program.  Addison-Wesley Professional.\n#\n# The most relevant \"chapters\" are:\n#    Data structures for boxes and their friends\n#    Shipping pages out (Ship class)\n#    Packaging (hpack and vpack)\n#    Data structures for math mode\n#    Subroutines for math mode\n#    Typesetting math formulas\n#\n# Many of the docstrings below refer to a numbered \"node\" in that\n# book, e.g., node123\n#\n# Note that (as TeX) y increases downward, unlike many other parts of\n# matplotlib.\n\n# How much text shrinks when going to the next-smallest level.  GROW_FACTOR\n# must be the inverse of SHRINK_FACTOR.\nSHRINK_FACTOR   = 0.7\nGROW_FACTOR     = 1.0 / SHRINK_FACTOR\n# The number of different sizes of chars to use, beyond which they will not\n# get any smaller\nNUM_SIZE_LEVELS = 6\n# Percentage of x-height of additional horiz. space after sub/superscripts\nSCRIPT_SPACE    = 0.2\n# Percentage of x-height that sub/superscripts drop below the baseline\nSUBDROP         = 0.3\n# Percentage of x-height that superscripts drop below the baseline\nSUP1            = 0.5\n# Percentage of x-height that subscripts drop below the baseline\nSUB1            = 0.0\n# Percentage of x-height that superscripts are offset relative to the subscript\nDELTA           = 0.18\n\nclass MathTextWarning(Warning):\n    pass\n\nclass Node(object):\n    \"\"\"\n    A node in the TeX box model\n    \"\"\"\n    def __init__(self):\n        self.size = 0\n\n    def __repr__(self):\n        return self.__internal_repr__()\n\n    def __internal_repr__(self):\n        return self.__class__.__name__\n\n    def get_kerning(self, next):\n        return 0.0\n\n    def shrink(self):\n        \"\"\"\n        Shrinks one level smaller.  There are only three levels of\n        sizes, after which things will no longer get smaller.\n        \"\"\"\n        self.size += 1\n\n    def grow(self):\n        \"\"\"\n        Grows one level larger.  There is no limit to how big\n        something can get.\n        \"\"\"\n        self.size -= 1\n\n    def render(self, x, y):\n        pass\n\nclass Box(Node):\n    \"\"\"\n    Represents any node with a physical location.\n    \"\"\"\n    def __init__(self, width, height, depth):\n        Node.__init__(self)\n        self.width  = width\n        self.height = height\n        self.depth  = depth\n\n    def shrink(self):\n        Node.shrink(self)\n        if self.size < NUM_SIZE_LEVELS:\n            self.width  *= SHRINK_FACTOR\n            self.height *= SHRINK_FACTOR\n            self.depth  *= SHRINK_FACTOR\n\n    def grow(self):\n        Node.grow(self)\n        self.width  *= GROW_FACTOR\n        self.height *= GROW_FACTOR\n        self.depth  *= GROW_FACTOR\n\n    def render(self, x1, y1, x2, y2):\n        pass\n\nclass Vbox(Box):\n    \"\"\"\n    A box with only height (zero width).\n    \"\"\"\n    def __init__(self, height, depth):\n        Box.__init__(self, 0., height, depth)\n\nclass Hbox(Box):\n    \"\"\"\n    A box with only width (zero height and depth).\n    \"\"\"\n    def __init__(self, width):\n        Box.__init__(self, width, 0., 0.)\n\nclass Char(Node):\n    \"\"\"\n    Represents a single character.  Unlike TeX, the font information\n    and metrics are stored with each :class:`Char` to make it easier\n    to lookup the font metrics when needed.  Note that TeX boxes have\n    a width, height, and depth, unlike Type1 and Truetype which use a\n    full bounding box and an advance in the x-direction.  The metrics\n    must be converted to the TeX way, and the advance (if different\n    from width) must be converted into a :class:`Kern` node when the\n    :class:`Char` is added to its parent :class:`Hlist`.\n    \"\"\"\n    def __init__(self, c, state):\n        Node.__init__(self)\n        self.c = c\n        self.font_output = state.font_output\n        assert isinstance(state.font, (six.string_types, int))\n        self.font = state.font\n        self.font_class = state.font_class\n        self.fontsize = state.fontsize\n        self.dpi = state.dpi\n        # The real width, height and depth will be set during the\n        # pack phase, after we know the real fontsize\n        self._update_metrics()\n\n    def __internal_repr__(self):\n        return '`%s`' % self.c\n\n    def _update_metrics(self):\n        metrics = self._metrics = self.font_output.get_metrics(\n            self.font, self.font_class, self.c, self.fontsize, self.dpi)\n        if self.c == ' ':\n            self.width = metrics.advance\n        else:\n            self.width = metrics.width\n        self.height = metrics.iceberg\n        self.depth = -(metrics.iceberg - metrics.height)\n\n    def is_slanted(self):\n        return self._metrics.slanted\n\n    def get_kerning(self, next):\n        \"\"\"\n        Return the amount of kerning between this and the given\n        character.  Called when characters are strung together into\n        :class:`Hlist` to create :class:`Kern` nodes.\n        \"\"\"\n        advance = self._metrics.advance - self.width\n        kern = 0.\n        if isinstance(next, Char):\n            kern = self.font_output.get_kern(\n                self.font, self.font_class, self.c, self.fontsize,\n                next.font, next.font_class, next.c, next.fontsize,\n                self.dpi)\n        return advance + kern\n\n    def render(self, x, y):\n        \"\"\"\n        Render the character to the canvas\n        \"\"\"\n        self.font_output.render_glyph(\n            x, y,\n            self.font, self.font_class, self.c, self.fontsize, self.dpi)\n\n    def shrink(self):\n        Node.shrink(self)\n        if self.size < NUM_SIZE_LEVELS:\n            self.fontsize *= SHRINK_FACTOR\n            self.width    *= SHRINK_FACTOR\n            self.height   *= SHRINK_FACTOR\n            self.depth    *= SHRINK_FACTOR\n\n    def grow(self):\n        Node.grow(self)\n        self.fontsize *= GROW_FACTOR\n        self.width    *= GROW_FACTOR\n        self.height   *= GROW_FACTOR\n        self.depth    *= GROW_FACTOR\n\nclass Accent(Char):\n    \"\"\"\n    The font metrics need to be dealt with differently for accents,\n    since they are already offset correctly from the baseline in\n    TrueType fonts.\n    \"\"\"\n    def _update_metrics(self):\n        metrics = self._metrics = self.font_output.get_metrics(\n            self.font, self.font_class, self.c, self.fontsize, self.dpi)\n        self.width = metrics.xmax - metrics.xmin\n        self.height = metrics.ymax - metrics.ymin\n        self.depth = 0\n\n    def shrink(self):\n        Char.shrink(self)\n        self._update_metrics()\n\n    def grow(self):\n        Char.grow(self)\n        self._update_metrics()\n\n    def render(self, x, y):\n        \"\"\"\n        Render the character to the canvas.\n        \"\"\"\n        self.font_output.render_glyph(\n            x - self._metrics.xmin, y + self._metrics.ymin,\n            self.font, self.font_class, self.c, self.fontsize, self.dpi)\n\nclass List(Box):\n    \"\"\"\n    A list of nodes (either horizontal or vertical).\n    \"\"\"\n    def __init__(self, elements):\n        Box.__init__(self, 0., 0., 0.)\n        self.shift_amount = 0.   # An arbitrary offset\n        self.children     = elements # The child nodes of this list\n        # The following parameters are set in the vpack and hpack functions\n        self.glue_set     = 0.   # The glue setting of this list\n        self.glue_sign    = 0    # 0: normal, -1: shrinking, 1: stretching\n        self.glue_order   = 0    # The order of infinity (0 - 3) for the glue\n\n    def __repr__(self):\n        return '[%s <%.02f %.02f %.02f %.02f> %s]' % (\n            self.__internal_repr__(),\n            self.width, self.height,\n            self.depth, self.shift_amount,\n            ' '.join([repr(x) for x in self.children]))\n\n    def _determine_order(self, totals):\n        \"\"\"\n        A helper function to determine the highest order of glue\n        used by the members of this list.  Used by vpack and hpack.\n        \"\"\"\n        o = 0\n        for i in range(len(totals) - 1, 0, -1):\n            if totals[i] != 0.0:\n                o = i\n                break\n        return o\n\n    def _set_glue(self, x, sign, totals, error_type):\n        o = self._determine_order(totals)\n        self.glue_order = o\n        self.glue_sign = sign\n        if totals[o] != 0.:\n            self.glue_set = x / totals[o]\n        else:\n            self.glue_sign = 0\n            self.glue_ratio = 0.\n        if o == 0:\n            if len(self.children):\n                warn(\"%s %s: %r\" % (error_type, self.__class__.__name__, self),\n                     MathTextWarning)\n\n    def shrink(self):\n        for child in self.children:\n            child.shrink()\n        Box.shrink(self)\n        if self.size < NUM_SIZE_LEVELS:\n            self.shift_amount *= SHRINK_FACTOR\n            self.glue_set     *= SHRINK_FACTOR\n\n    def grow(self):\n        for child in self.children:\n            child.grow()\n        Box.grow(self)\n        self.shift_amount *= GROW_FACTOR\n        self.glue_set     *= GROW_FACTOR\n\nclass Hlist(List):\n    \"\"\"\n    A horizontal list of boxes.\n    \"\"\"\n    def __init__(self, elements, w=0., m='additional', do_kern=True):\n        List.__init__(self, elements)\n        if do_kern:\n            self.kern()\n        self.hpack()\n\n    def kern(self):\n        \"\"\"\n        Insert :class:`Kern` nodes between :class:`Char` nodes to set\n        kerning.  The :class:`Char` nodes themselves determine the\n        amount of kerning they need (in :meth:`~Char.get_kerning`),\n        and this function just creates the linked list in the correct\n        way.\n        \"\"\"\n        new_children = []\n        num_children = len(self.children)\n        if num_children:\n            for i in range(num_children):\n                elem = self.children[i]\n                if i < num_children - 1:\n                    next = self.children[i + 1]\n                else:\n                    next = None\n\n                new_children.append(elem)\n                kerning_distance = elem.get_kerning(next)\n                if kerning_distance != 0.:\n                    kern = Kern(kerning_distance)\n                    new_children.append(kern)\n            self.children = new_children\n\n    # This is a failed experiment to fake cross-font kerning.\n#     def get_kerning(self, next):\n#         if len(self.children) >= 2 and isinstance(self.children[-2], Char):\n#             if isinstance(next, Char):\n#                 print \"CASE A\"\n#                 return self.children[-2].get_kerning(next)\n#             elif isinstance(next, Hlist) and len(next.children) and isinstance(next.children[0], Char):\n#                 print \"CASE B\"\n#                 result = self.children[-2].get_kerning(next.children[0])\n#                 print result\n#                 return result\n#         return 0.0\n\n    def hpack(self, w=0., m='additional'):\n        \"\"\"\n        The main duty of :meth:`hpack` is to compute the dimensions of\n        the resulting boxes, and to adjust the glue if one of those\n        dimensions is pre-specified.  The computed sizes normally\n        enclose all of the material inside the new box; but some items\n        may stick out if negative glue is used, if the box is\n        overfull, or if a ``\\\\vbox`` includes other boxes that have\n        been shifted left.\n\n          - *w*: specifies a width\n\n          - *m*: is either 'exactly' or 'additional'.\n\n        Thus, ``hpack(w, 'exactly')`` produces a box whose width is\n        exactly *w*, while ``hpack(w, 'additional')`` yields a box\n        whose width is the natural width plus *w*.  The default values\n        produce a box with the natural width.\n        \"\"\"\n        # I don't know why these get reset in TeX.  Shift_amount is pretty\n        # much useless if we do.\n        #self.shift_amount = 0.\n        h = 0.\n        d = 0.\n        x = 0.\n        total_stretch = [0.] * 4\n        total_shrink = [0.] * 4\n        for p in self.children:\n            if isinstance(p, Char):\n                x += p.width\n                h = max(h, p.height)\n                d = max(d, p.depth)\n            elif isinstance(p, Box):\n                x += p.width\n                if not isinf(p.height) and not isinf(p.depth):\n                    s = getattr(p, 'shift_amount', 0.)\n                    h = max(h, p.height - s)\n                    d = max(d, p.depth + s)\n            elif isinstance(p, Glue):\n                glue_spec = p.glue_spec\n                x += glue_spec.width\n                total_stretch[glue_spec.stretch_order] += glue_spec.stretch\n                total_shrink[glue_spec.shrink_order] += glue_spec.shrink\n            elif isinstance(p, Kern):\n                x += p.width\n        self.height = h\n        self.depth = d\n\n        if m == 'additional':\n            w += x\n        self.width = w\n        x = w - x\n\n        if x == 0.:\n            self.glue_sign = 0\n            self.glue_order = 0\n            self.glue_ratio = 0.\n            return\n        if x > 0.:\n            self._set_glue(x, 1, total_stretch, \"Overfull\")\n        else:\n            self._set_glue(x, -1, total_shrink, \"Underfull\")\n\nclass Vlist(List):\n    \"\"\"\n    A vertical list of boxes.\n    \"\"\"\n    def __init__(self, elements, h=0., m='additional'):\n        List.__init__(self, elements)\n        self.vpack()\n\n    def vpack(self, h=0., m='additional', l=float(inf)):\n        \"\"\"\n        The main duty of :meth:`vpack` is to compute the dimensions of\n        the resulting boxes, and to adjust the glue if one of those\n        dimensions is pre-specified.\n\n          - *h*: specifies a height\n          - *m*: is either 'exactly' or 'additional'.\n          - *l*: a maximum height\n\n        Thus, ``vpack(h, 'exactly')`` produces a box whose height is\n        exactly *h*, while ``vpack(h, 'additional')`` yields a box\n        whose height is the natural height plus *h*.  The default\n        values produce a box with the natural width.\n        \"\"\"\n        # I don't know why these get reset in TeX.  Shift_amount is pretty\n        # much useless if we do.\n        # self.shift_amount = 0.\n        w = 0.\n        d = 0.\n        x = 0.\n        total_stretch = [0.] * 4\n        total_shrink = [0.] * 4\n        for p in self.children:\n            if isinstance(p, Box):\n                x += d + p.height\n                d = p.depth\n                if not isinf(p.width):\n                    s = getattr(p, 'shift_amount', 0.)\n                    w = max(w, p.width + s)\n            elif isinstance(p, Glue):\n                x += d\n                d = 0.\n                glue_spec = p.glue_spec\n                x += glue_spec.width\n                total_stretch[glue_spec.stretch_order] += glue_spec.stretch\n                total_shrink[glue_spec.shrink_order] += glue_spec.shrink\n            elif isinstance(p, Kern):\n                x += d + p.width\n                d = 0.\n            elif isinstance(p, Char):\n                raise RuntimeError(\"Internal mathtext error: Char node found in Vlist.\")\n\n        self.width = w\n        if d > l:\n            x += d - l\n            self.depth = l\n        else:\n            self.depth = d\n\n        if m == 'additional':\n            h += x\n        self.height = h\n        x = h - x\n\n        if x == 0:\n            self.glue_sign = 0\n            self.glue_order = 0\n            self.glue_ratio = 0.\n            return\n\n        if x > 0.:\n            self._set_glue(x, 1, total_stretch, \"Overfull\")\n        else:\n            self._set_glue(x, -1, total_shrink, \"Underfull\")\n\nclass Rule(Box):\n    \"\"\"\n    A :class:`Rule` node stands for a solid black rectangle; it has\n    *width*, *depth*, and *height* fields just as in an\n    :class:`Hlist`. However, if any of these dimensions is inf, the\n    actual value will be determined by running the rule up to the\n    boundary of the innermost enclosing box. This is called a \"running\n    dimension.\" The width is never running in an :class:`Hlist`; the\n    height and depth are never running in a :class:`Vlist`.\n    \"\"\"\n    def __init__(self, width, height, depth, state):\n        Box.__init__(self, width, height, depth)\n        self.font_output = state.font_output\n\n    def render(self, x, y, w, h):\n        self.font_output.render_rect_filled(x, y, x + w, y + h)\n\nclass Hrule(Rule):\n    \"\"\"\n    Convenience class to create a horizontal rule.\n    \"\"\"\n    def __init__(self, state, thickness=None):\n        if thickness is None:\n            thickness = state.font_output.get_underline_thickness(\n                state.font, state.fontsize, state.dpi)\n        height = depth = thickness * 0.5\n        Rule.__init__(self, inf, height, depth, state)\n\nclass Vrule(Rule):\n    \"\"\"\n    Convenience class to create a vertical rule.\n    \"\"\"\n    def __init__(self, state):\n        thickness = state.font_output.get_underline_thickness(\n            state.font, state.fontsize, state.dpi)\n        Rule.__init__(self, thickness, inf, inf, state)\n\nclass Glue(Node):\n    \"\"\"\n    Most of the information in this object is stored in the underlying\n    :class:`GlueSpec` class, which is shared between multiple glue objects.  (This\n    is a memory optimization which probably doesn't matter anymore, but it's\n    easier to stick to what TeX does.)\n    \"\"\"\n    def __init__(self, glue_type, copy=False):\n        Node.__init__(self)\n        self.glue_subtype   = 'normal'\n        if is_string_like(glue_type):\n            glue_spec = GlueSpec.factory(glue_type)\n        elif isinstance(glue_type, GlueSpec):\n            glue_spec = glue_type\n        else:\n            raise ArgumentError(\"glue_type must be a glue spec name or instance.\")\n        if copy:\n            glue_spec = glue_spec.copy()\n        self.glue_spec      = glue_spec\n\n    def shrink(self):\n        Node.shrink(self)\n        if self.size < NUM_SIZE_LEVELS:\n            if self.glue_spec.width != 0.:\n                self.glue_spec = self.glue_spec.copy()\n                self.glue_spec.width *= SHRINK_FACTOR\n\n    def grow(self):\n        Node.grow(self)\n        if self.glue_spec.width != 0.:\n            self.glue_spec = self.glue_spec.copy()\n            self.glue_spec.width *= GROW_FACTOR\n\nclass GlueSpec(object):\n    \"\"\"\n    See :class:`Glue`.\n    \"\"\"\n    def __init__(self, width=0., stretch=0., stretch_order=0, shrink=0., shrink_order=0):\n        self.width         = width\n        self.stretch       = stretch\n        self.stretch_order = stretch_order\n        self.shrink        = shrink\n        self.shrink_order  = shrink_order\n\n    def copy(self):\n        return GlueSpec(\n            self.width,\n            self.stretch,\n            self.stretch_order,\n            self.shrink,\n            self.shrink_order)\n\n    def factory(cls, glue_type):\n        return cls._types[glue_type]\n    factory = classmethod(factory)\n\nGlueSpec._types = {\n    'fil':         GlueSpec(0., 1., 1, 0., 0),\n    'fill':        GlueSpec(0., 1., 2, 0., 0),\n    'filll':       GlueSpec(0., 1., 3, 0., 0),\n    'neg_fil':     GlueSpec(0., 0., 0, 1., 1),\n    'neg_fill':    GlueSpec(0., 0., 0, 1., 2),\n    'neg_filll':   GlueSpec(0., 0., 0, 1., 3),\n    'empty':       GlueSpec(0., 0., 0, 0., 0),\n    'ss':          GlueSpec(0., 1., 1, -1., 1)\n}\n\n# Some convenient ways to get common kinds of glue\n\nclass Fil(Glue):\n    def __init__(self):\n        Glue.__init__(self, 'fil')\n\nclass Fill(Glue):\n    def __init__(self):\n        Glue.__init__(self, 'fill')\n\nclass Filll(Glue):\n    def __init__(self):\n        Glue.__init__(self, 'filll')\n\nclass NegFil(Glue):\n    def __init__(self):\n        Glue.__init__(self, 'neg_fil')\n\nclass NegFill(Glue):\n    def __init__(self):\n        Glue.__init__(self, 'neg_fill')\n\nclass NegFilll(Glue):\n    def __init__(self):\n        Glue.__init__(self, 'neg_filll')\n\nclass SsGlue(Glue):\n    def __init__(self):\n        Glue.__init__(self, 'ss')\n\nclass HCentered(Hlist):\n    \"\"\"\n    A convenience class to create an :class:`Hlist` whose contents are\n    centered within its enclosing box.\n    \"\"\"\n    def __init__(self, elements):\n        Hlist.__init__(self, [SsGlue()] + elements + [SsGlue()],\n                       do_kern=False)\n\nclass VCentered(Hlist):\n    \"\"\"\n    A convenience class to create a :class:`Vlist` whose contents are\n    centered within its enclosing box.\n    \"\"\"\n    def __init__(self, elements):\n        Vlist.__init__(self, [SsGlue()] + elements + [SsGlue()])\n\nclass Kern(Node):\n    \"\"\"\n    A :class:`Kern` node has a width field to specify a (normally\n    negative) amount of spacing. This spacing correction appears in\n    horizontal lists between letters like A and V when the font\n    designer said that it looks better to move them closer together or\n    further apart. A kern node can also appear in a vertical list,\n    when its *width* denotes additional spacing in the vertical\n    direction.\n    \"\"\"\n    height = 0\n    depth = 0\n\n    def __init__(self, width):\n        Node.__init__(self)\n        self.width = width\n\n    def __repr__(self):\n        return \"k%.02f\" % self.width\n\n    def shrink(self):\n        Node.shrink(self)\n        if self.size < NUM_SIZE_LEVELS:\n            self.width *= SHRINK_FACTOR\n\n    def grow(self):\n        Node.grow(self)\n        self.width *= GROW_FACTOR\n\nclass SubSuperCluster(Hlist):\n    \"\"\"\n    :class:`SubSuperCluster` is a sort of hack to get around that fact\n    that this code do a two-pass parse like TeX.  This lets us store\n    enough information in the hlist itself, namely the nucleus, sub-\n    and super-script, such that if another script follows that needs\n    to be attached, it can be reconfigured on the fly.\n    \"\"\"\n    def __init__(self):\n        self.nucleus = None\n        self.sub = None\n        self.super = None\n        Hlist.__init__(self, [])\n\nclass AutoHeightChar(Hlist):\n    \"\"\"\n    :class:`AutoHeightChar` will create a character as close to the\n    given height and depth as possible.  When using a font with\n    multiple height versions of some characters (such as the BaKoMa\n    fonts), the correct glyph will be selected, otherwise this will\n    always just return a scaled version of the glyph.\n    \"\"\"\n    def __init__(self, c, height, depth, state, always=False, factor=None):\n        alternatives = state.font_output.get_sized_alternatives_for_symbol(\n            state.font, c)\n\n        state = state.copy()\n        target_total = height + depth\n        for fontname, sym in alternatives:\n            state.font = fontname\n            char = Char(sym, state)\n            if char.height + char.depth >= target_total:\n                break\n\n        if factor is None:\n            factor = target_total / (char.height + char.depth)\n        state.fontsize *= factor\n        char = Char(sym, state)\n\n        shift = (depth - char.depth)\n        Hlist.__init__(self, [char])\n        self.shift_amount = shift\n\nclass AutoWidthChar(Hlist):\n    \"\"\"\n    :class:`AutoWidthChar` will create a character as close to the\n    given width as possible.  When using a font with multiple width\n    versions of some characters (such as the BaKoMa fonts), the\n    correct glyph will be selected, otherwise this will always just\n    return a scaled version of the glyph.\n    \"\"\"\n    def __init__(self, c, width, state, always=False, char_class=Char):\n        alternatives = state.font_output.get_sized_alternatives_for_symbol(\n            state.font, c)\n\n        state = state.copy()\n        for fontname, sym in alternatives:\n            state.font = fontname\n            char = char_class(sym, state)\n            if char.width >= width:\n                break\n\n        factor = width / char.width\n        state.fontsize *= factor\n        char = char_class(sym, state)\n\n        Hlist.__init__(self, [char])\n        self.width = char.width\n\nclass Ship(object):\n    \"\"\"\n    Once the boxes have been set up, this sends them to output.  Since\n    boxes can be inside of boxes inside of boxes, the main work of\n    :class:`Ship` is done by two mutually recursive routines,\n    :meth:`hlist_out` and :meth:`vlist_out`, which traverse the\n    :class:`Hlist` nodes and :class:`Vlist` nodes inside of horizontal\n    and vertical boxes.  The global variables used in TeX to store\n    state as it processes have become member variables here.\n    \"\"\"\n    def __call__(self, ox, oy, box):\n        self.max_push    = 0 # Deepest nesting of push commands so far\n        self.cur_s       = 0\n        self.cur_v       = 0.\n        self.cur_h       = 0.\n        self.off_h       = ox\n        self.off_v       = oy + box.height\n        self.hlist_out(box)\n\n    def clamp(value):\n        if value < -1000000000.:\n            return -1000000000.\n        if value > 1000000000.:\n            return 1000000000.\n        return value\n    clamp = staticmethod(clamp)\n\n    def hlist_out(self, box):\n        cur_g         = 0\n        cur_glue      = 0.\n        glue_order    = box.glue_order\n        glue_sign     = box.glue_sign\n        base_line     = self.cur_v\n        left_edge     = self.cur_h\n        self.cur_s    += 1\n        self.max_push = max(self.cur_s, self.max_push)\n        clamp         = self.clamp\n\n        for p in box.children:\n            if isinstance(p, Char):\n                p.render(self.cur_h + self.off_h, self.cur_v + self.off_v)\n                self.cur_h += p.width\n            elif isinstance(p, Kern):\n                self.cur_h += p.width\n            elif isinstance(p, List):\n                # node623\n                if len(p.children) == 0:\n                    self.cur_h += p.width\n                else:\n                    edge = self.cur_h\n                    self.cur_v = base_line + p.shift_amount\n                    if isinstance(p, Hlist):\n                        self.hlist_out(p)\n                    else:\n                        # p.vpack(box.height + box.depth, 'exactly')\n                        self.vlist_out(p)\n                    self.cur_h = edge + p.width\n                    self.cur_v = base_line\n            elif isinstance(p, Box):\n                # node624\n                rule_height = p.height\n                rule_depth  = p.depth\n                rule_width  = p.width\n                if isinf(rule_height):\n                    rule_height = box.height\n                if isinf(rule_depth):\n                    rule_depth = box.depth\n                if rule_height > 0 and rule_width > 0:\n                    self.cur_v = baseline + rule_depth\n                    p.render(self.cur_h + self.off_h,\n                             self.cur_v + self.off_v,\n                             rule_width, rule_height)\n                    self.cur_v = baseline\n                self.cur_h += rule_width\n            elif isinstance(p, Glue):\n                # node625\n                glue_spec = p.glue_spec\n                rule_width = glue_spec.width - cur_g\n                if glue_sign != 0: # normal\n                    if glue_sign == 1: # stretching\n                        if glue_spec.stretch_order == glue_order:\n                            cur_glue += glue_spec.stretch\n                            cur_g = round(clamp(float(box.glue_set) * cur_glue))\n                    elif glue_spec.shrink_order == glue_order:\n                        cur_glue += glue_spec.shrink\n                        cur_g = round(clamp(float(box.glue_set) * cur_glue))\n                rule_width += cur_g\n                self.cur_h += rule_width\n        self.cur_s -= 1\n\n    def vlist_out(self, box):\n        cur_g         = 0\n        cur_glue      = 0.\n        glue_order    = box.glue_order\n        glue_sign     = box.glue_sign\n        self.cur_s    += 1\n        self.max_push = max(self.max_push, self.cur_s)\n        left_edge     = self.cur_h\n        self.cur_v    -= box.height\n        top_edge      = self.cur_v\n        clamp         = self.clamp\n\n        for p in box.children:\n            if isinstance(p, Kern):\n                self.cur_v += p.width\n            elif isinstance(p, List):\n                if len(p.children) == 0:\n                    self.cur_v += p.height + p.depth\n                else:\n                    self.cur_v += p.height\n                    self.cur_h = left_edge + p.shift_amount\n                    save_v = self.cur_v\n                    p.width = box.width\n                    if isinstance(p, Hlist):\n                        self.hlist_out(p)\n                    else:\n                        self.vlist_out(p)\n                    self.cur_v = save_v + p.depth\n                    self.cur_h = left_edge\n            elif isinstance(p, Box):\n                rule_height = p.height\n                rule_depth = p.depth\n                rule_width = p.width\n                if isinf(rule_width):\n                    rule_width = box.width\n                rule_height += rule_depth\n                if rule_height > 0 and rule_depth > 0:\n                    self.cur_v += rule_height\n                    p.render(self.cur_h + self.off_h,\n                             self.cur_v + self.off_v,\n                             rule_width, rule_height)\n            elif isinstance(p, Glue):\n                glue_spec = p.glue_spec\n                rule_height = glue_spec.width - cur_g\n                if glue_sign != 0: # normal\n                    if glue_sign == 1: # stretching\n                        if glue_spec.stretch_order == glue_order:\n                            cur_glue += glue_spec.stretch\n                            cur_g = round(clamp(float(box.glue_set) * cur_glue))\n                    elif glue_spec.shrink_order == glue_order: # shrinking\n                        cur_glue += glue_spec.shrink\n                        cur_g = round(clamp(float(box.glue_set) * cur_glue))\n                rule_height += cur_g\n                self.cur_v += rule_height\n            elif isinstance(p, Char):\n                raise RuntimeError(\"Internal mathtext error: Char node found in vlist\")\n        self.cur_s -= 1\n\nship = Ship()\n\n##############################################################################\n# PARSER\n\ndef Error(msg):\n    \"\"\"\n    Helper class to raise parser errors.\n    \"\"\"\n    def raise_error(s, loc, toks):\n        raise ParseFatalException(s, loc, msg)\n\n    empty = Empty()\n    empty.setParseAction(raise_error)\n    return empty\n\nclass Parser(object):\n    \"\"\"\n    This is the pyparsing-based parser for math expressions.  It\n    actually parses full strings *containing* math expressions, in\n    that raw text may also appear outside of pairs of ``$``.\n\n    The grammar is based directly on that in TeX, though it cuts a few\n    corners.\n    \"\"\"\n    _binary_operators = set('''\n      + *\n      \\\\pm             \\\\sqcap                   \\\\rhd\n      \\\\mp             \\\\sqcup                   \\\\unlhd\n      \\\\times          \\\\vee                     \\\\unrhd\n      \\\\div            \\\\wedge                   \\\\oplus\n      \\\\ast            \\\\setminus                \\\\ominus\n      \\\\star           \\\\wr                      \\\\otimes\n      \\\\circ           \\\\diamond                 \\\\oslash\n      \\\\bullet         \\\\bigtriangleup           \\\\odot\n      \\\\cdot           \\\\bigtriangledown         \\\\bigcirc\n      \\\\cap            \\\\triangleleft            \\\\dagger\n      \\\\cup            \\\\triangleright           \\\\ddagger\n      \\\\uplus          \\\\lhd                     \\\\amalg'''.split())\n\n    _relation_symbols = set('''\n      = < > :\n      \\\\leq            \\\\geq             \\\\equiv           \\\\models\n      \\\\prec           \\\\succ            \\\\sim             \\\\perp\n      \\\\preceq         \\\\succeq          \\\\simeq           \\\\mid\n      \\\\ll             \\\\gg              \\\\asymp           \\\\parallel\n      \\\\subset         \\\\supset          \\\\approx          \\\\bowtie\n      \\\\subseteq       \\\\supseteq        \\\\cong            \\\\Join\n      \\\\sqsubset       \\\\sqsupset        \\\\neq             \\\\smile\n      \\\\sqsubseteq     \\\\sqsupseteq      \\\\doteq           \\\\frown\n      \\\\in             \\\\ni              \\\\propto\n      \\\\vdash          \\\\dashv           \\\\dots'''.split())\n\n    _arrow_symbols = set('''\n      \\\\leftarrow              \\\\longleftarrow           \\\\uparrow\n      \\\\Leftarrow              \\\\Longleftarrow           \\\\Uparrow\n      \\\\rightarrow             \\\\longrightarrow          \\\\downarrow\n      \\\\Rightarrow             \\\\Longrightarrow          \\\\Downarrow\n      \\\\leftrightarrow         \\\\longleftrightarrow      \\\\updownarrow\n      \\\\Leftrightarrow         \\\\Longleftrightarrow      \\\\Updownarrow\n      \\\\mapsto                 \\\\longmapsto              \\\\nearrow\n      \\\\hookleftarrow          \\\\hookrightarrow          \\\\searrow\n      \\\\leftharpoonup          \\\\rightharpoonup          \\\\swarrow\n      \\\\leftharpoondown        \\\\rightharpoondown        \\\\nwarrow\n      \\\\rightleftharpoons      \\\\leadsto'''.split())\n\n    _spaced_symbols = _binary_operators | _relation_symbols | _arrow_symbols\n\n    _punctuation_symbols = set(r', ; . ! \\ldotp \\cdotp'.split())\n\n    _overunder_symbols = set(r'''\n       \\sum \\prod \\coprod \\bigcap \\bigcup \\bigsqcup \\bigvee\n       \\bigwedge \\bigodot \\bigotimes \\bigoplus \\biguplus\n       '''.split())\n\n    _overunder_functions = set(\n        r\"lim liminf limsup sup max min\".split())\n\n    _dropsub_symbols = set(r'''\\int \\oint'''.split())\n\n    _fontnames = set(\"rm cal it tt sf bf default bb frak circled scr regular\".split())\n\n    _function_names = set(\"\"\"\n      arccos csc ker min arcsin deg lg Pr arctan det lim sec arg dim\n      liminf sin cos exp limsup sinh cosh gcd ln sup cot hom log tan\n      coth inf max tanh\"\"\".split())\n\n    _ambi_delim = set(\"\"\"\n      | \\\\| / \\\\backslash \\\\uparrow \\\\downarrow \\\\updownarrow \\\\Uparrow\n      \\\\Downarrow \\\\Updownarrow .\"\"\".split())\n\n    _left_delim = set(r\"( [ \\{ < \\lfloor \\langle \\lceil\".split())\n\n    _right_delim = set(r\") ] \\} > \\rfloor \\rangle \\rceil\".split())\n\n    def __init__(self):\n        p = Bunch()\n        # All forward declarations are here\n        p.accent           = Forward()\n        p.ambi_delim       = Forward()\n        p.apostrophe       = Forward()\n        p.auto_delim       = Forward()\n        p.binom            = Forward()\n        p.bslash           = Forward()\n        p.c_over_c         = Forward()\n        p.customspace      = Forward()\n        p.end_group        = Forward()\n        p.float_literal    = Forward()\n        p.font             = Forward()\n        p.frac             = Forward()\n        p.function         = Forward()\n        p.genfrac          = Forward()\n        p.group            = Forward()\n        p.int_literal      = Forward()\n        p.latexfont        = Forward()\n        p.lbracket         = Forward()\n        p.left_delim       = Forward()\n        p.lbrace           = Forward()\n        p.main             = Forward()\n        p.math             = Forward()\n        p.math_string      = Forward()\n        p.non_math         = Forward()\n        p.operatorname     = Forward()\n        p.overline         = Forward()\n        p.placeable        = Forward()\n        p.rbrace           = Forward()\n        p.rbracket         = Forward()\n        p.required_group   = Forward()\n        p.right_delim      = Forward()\n        p.right_delim_safe = Forward()\n        p.simple           = Forward()\n        p.simple_group     = Forward()\n        p.single_symbol    = Forward()\n        p.space            = Forward()\n        p.sqrt             = Forward()\n        p.stackrel         = Forward()\n        p.start_group      = Forward()\n        p.subsuper         = Forward()\n        p.subsuperop       = Forward()\n        p.symbol           = Forward()\n        p.symbol_name      = Forward()\n        p.token            = Forward()\n        p.unknown_symbol   = Forward()\n\n        # Set names on everything -- very useful for debugging\n        for key, val in vars(p).items():\n            if not key.startswith('_'):\n                val.setName(key)\n\n        p.float_literal <<= Regex(r\"[-+]?([0-9]+\\.?[0-9]*|\\.[0-9]+)\")\n        p.int_literal   <<= Regex(\"[-+]?[0-9]+\")\n\n        p.lbrace        <<= Literal('{').suppress()\n        p.rbrace        <<= Literal('}').suppress()\n        p.lbracket      <<= Literal('[').suppress()\n        p.rbracket      <<= Literal(']').suppress()\n        p.bslash        <<= Literal('\\\\')\n\n        p.space         <<= oneOf(list(six.iterkeys(self._space_widths)))\n        p.customspace   <<= (Suppress(Literal(r'\\hspace'))\n                          - ((p.lbrace + p.float_literal + p.rbrace)\n                            | Error(r\"Expected \\hspace{n}\")))\n\n        unicode_range =  \"\\U00000080-\\U0001ffff\"\n        p.single_symbol <<= Regex(r\"([a-zA-Z0-9 +\\-*/<>=:,.;!\\?&'@()\\[\\]|%s])|(\\\\[%%${}\\[\\]_|])\" %\n                               unicode_range)\n        p.symbol_name   <<= (Combine(p.bslash + oneOf(list(six.iterkeys(tex2uni)))) +\n                          FollowedBy(Regex(\"[^A-Za-z]\").leaveWhitespace() | StringEnd()))\n        p.symbol        <<= (p.single_symbol | p.symbol_name).leaveWhitespace()\n\n        p.apostrophe    <<= Regex(\"'+\")\n\n        p.c_over_c      <<= Suppress(p.bslash) + oneOf(list(six.iterkeys(self._char_over_chars)))\n\n        p.accent        <<= Group(\n                             Suppress(p.bslash)\n                           + oneOf(list(six.iterkeys(self._accent_map)) + list(self._wide_accents))\n                           - p.placeable\n                         )\n\n        p.function      <<= Suppress(p.bslash) + oneOf(list(self._function_names))\n\n        p.start_group   <<= Optional(p.latexfont) + p.lbrace\n        p.end_group     <<= p.rbrace.copy()\n        p.simple_group  <<= Group(p.lbrace + ZeroOrMore(p.token) + p.rbrace)\n        p.required_group<<= Group(p.lbrace + OneOrMore(p.token) + p.rbrace)\n        p.group         <<= Group(p.start_group + ZeroOrMore(p.token) + p.end_group)\n\n        p.font          <<= Suppress(p.bslash) + oneOf(list(self._fontnames))\n        p.latexfont     <<= Suppress(p.bslash) + oneOf(['math' + x for x in self._fontnames])\n\n        p.frac          <<= Group(\n                             Suppress(Literal(r\"\\frac\"))\n                           - ((p.required_group + p.required_group) | Error(r\"Expected \\frac{num}{den}\"))\n                         )\n\n        p.stackrel      <<= Group(\n                             Suppress(Literal(r\"\\stackrel\"))\n                           - ((p.required_group + p.required_group) | Error(r\"Expected \\stackrel{num}{den}\"))\n                         )\n\n        p.binom         <<= Group(\n                             Suppress(Literal(r\"\\binom\"))\n                           - ((p.required_group + p.required_group) | Error(r\"Expected \\binom{num}{den}\"))\n                         )\n\n        p.ambi_delim    <<= oneOf(list(self._ambi_delim))\n        p.left_delim    <<= oneOf(list(self._left_delim))\n        p.right_delim   <<= oneOf(list(self._right_delim))\n        p.right_delim_safe <<= oneOf(list(self._right_delim - set(['}'])) + [r'\\}'])\n\n        p.genfrac       <<= Group(\n                             Suppress(Literal(r\"\\genfrac\"))\n                           - (((p.lbrace + Optional(p.ambi_delim | p.left_delim, default='') + p.rbrace)\n                           +   (p.lbrace + Optional(p.ambi_delim | p.right_delim_safe, default='') + p.rbrace)\n                           +   (p.lbrace + p.float_literal + p.rbrace)\n                           +   p.simple_group + p.required_group + p.required_group)\n                           | Error(r\"Expected \\genfrac{ldelim}{rdelim}{rulesize}{style}{num}{den}\"))\n                         )\n\n        p.sqrt          <<= Group(\n                             Suppress(Literal(r\"\\sqrt\"))\n                           - ((Optional(p.lbracket + p.int_literal + p.rbracket, default=None)\n                              + p.required_group)\n                           | Error(\"Expected \\sqrt{value}\"))\n                         )\n\n        p.overline      <<= Group(\n                             Suppress(Literal(r\"\\overline\"))\n                           - (p.required_group | Error(\"Expected \\overline{value}\"))\n                         )\n\n        p.unknown_symbol<<= Combine(p.bslash + Regex(\"[A-Za-z]*\"))\n\n        p.operatorname  <<= Group(\n                             Suppress(Literal(r\"\\operatorname\"))\n                           - ((p.lbrace + ZeroOrMore(p.simple | p.unknown_symbol) + p.rbrace)\n                              | Error(\"Expected \\operatorname{value}\"))\n                         )\n\n        p.placeable     <<= ( p.accent # Must be first\n                         | p.symbol # Must be second\n                         | p.c_over_c\n                         | p.function\n                         | p.group\n                         | p.frac\n                         | p.stackrel\n                         | p.binom\n                         | p.genfrac\n                         | p.sqrt\n                         | p.overline\n                         | p.operatorname\n                         )\n\n        p.simple        <<= ( p.space\n                         | p.customspace\n                         | p.font\n                         | p.subsuper\n                         )\n\n        p.subsuperop    <<= oneOf([\"_\", \"^\"])\n\n        p.subsuper      <<= Group(\n                             (Optional(p.placeable) + OneOrMore(p.subsuperop - p.placeable) + Optional(p.apostrophe))\n                           | (p.placeable + Optional(p.apostrophe))\n                           | p.apostrophe\n                         )\n\n        p.token         <<= ( p.simple\n                         | p.auto_delim\n                         | p.unknown_symbol # Must be last\n                         )\n\n        p.auto_delim    <<= (Suppress(Literal(r\"\\left\"))\n                          - ((p.left_delim | p.ambi_delim) | Error(\"Expected a delimiter\"))\n                          + Group(ZeroOrMore(p.simple | p.auto_delim))\n                          + Suppress(Literal(r\"\\right\"))\n                          - ((p.right_delim | p.ambi_delim) | Error(\"Expected a delimiter\"))\n                         )\n\n        p.math          <<= OneOrMore(p.token)\n\n        p.math_string   <<= QuotedString('$', '\\\\', unquoteResults=False)\n\n        p.non_math      <<= Regex(r\"(?:(?:\\\\[$])|[^$])*\").leaveWhitespace()\n\n        p.main          <<= (p.non_math + ZeroOrMore(p.math_string + p.non_math)) + StringEnd()\n\n        # Set actions\n        for key, val in vars(p).items():\n            if not key.startswith('_'):\n                if hasattr(self, key):\n                    val.setParseAction(getattr(self, key))\n\n        self._expression = p.main\n        self._math_expression = p.math\n\n    def parse(self, s, fonts_object, fontsize, dpi):\n        \"\"\"\n        Parse expression *s* using the given *fonts_object* for\n        output, at the given *fontsize* and *dpi*.\n\n        Returns the parse tree of :class:`Node` instances.\n        \"\"\"\n        self._state_stack = [self.State(fonts_object, 'default', 'rm', fontsize, dpi)]\n        self._em_width_cache = {}\n        try:\n            result = self._expression.parseString(s)\n        except ParseBaseException as err:\n            raise ValueError(\"\\n\".join([\n                        \"\",\n                        err.line,\n                        \" \" * (err.column - 1) + \"^\",\n                        six.text_type(err)]))\n        self._state_stack = None\n        self._em_width_cache = {}\n        self._expression.resetCache()\n        return result[0]\n\n    # The state of the parser is maintained in a stack.  Upon\n    # entering and leaving a group { } or math/non-math, the stack\n    # is pushed and popped accordingly.  The current state always\n    # exists in the top element of the stack.\n    class State(object):\n        \"\"\"\n        Stores the state of the parser.\n\n        States are pushed and popped from a stack as necessary, and\n        the \"current\" state is always at the top of the stack.\n        \"\"\"\n        def __init__(self, font_output, font, font_class, fontsize, dpi):\n            self.font_output = font_output\n            self._font = font\n            self.font_class = font_class\n            self.fontsize = fontsize\n            self.dpi = dpi\n\n        def copy(self):\n            return Parser.State(\n                self.font_output,\n                self.font,\n                self.font_class,\n                self.fontsize,\n                self.dpi)\n\n        def _get_font(self):\n            return self._font\n        def _set_font(self, name):\n            if name in ('rm', 'it', 'bf'):\n                self.font_class = name\n            self._font = name\n        font = property(_get_font, _set_font)\n\n    def get_state(self):\n        \"\"\"\n        Get the current :class:`State` of the parser.\n        \"\"\"\n        return self._state_stack[-1]\n\n    def pop_state(self):\n        \"\"\"\n        Pop a :class:`State` off of the stack.\n        \"\"\"\n        self._state_stack.pop()\n\n    def push_state(self):\n        \"\"\"\n        Push a new :class:`State` onto the stack which is just a copy\n        of the current state.\n        \"\"\"\n        self._state_stack.append(self.get_state().copy())\n\n    def main(self, s, loc, toks):\n        #~ print \"finish\", toks\n        return [Hlist(toks)]\n\n    def math_string(self, s, loc, toks):\n        # print \"math_string\", toks[0][1:-1]\n        return self._math_expression.parseString(toks[0][1:-1])\n\n    def math(self, s, loc, toks):\n        #~ print \"math\", toks\n        hlist = Hlist(toks)\n        self.pop_state()\n        return [hlist]\n\n    def non_math(self, s, loc, toks):\n        #~ print \"non_math\", toks\n        s = toks[0].replace(r'\\$', '$')\n        symbols = [Char(c, self.get_state()) for c in s]\n        hlist = Hlist(symbols)\n        # We're going into math now, so set font to 'it'\n        self.push_state()\n        self.get_state().font = rcParams['mathtext.default']\n        return [hlist]\n\n    def _make_space(self, percentage):\n        # All spaces are relative to em width\n        state = self.get_state()\n        key = (state.font, state.fontsize, state.dpi)\n        width = self._em_width_cache.get(key)\n        if width is None:\n            metrics = state.font_output.get_metrics(\n                state.font, rcParams['mathtext.default'], 'm', state.fontsize, state.dpi)\n            width = metrics.advance\n            self._em_width_cache[key] = width\n        return Kern(width * percentage)\n\n    _space_widths = { r'\\ '      : 0.3,\n                      r'\\,'      : 0.4,\n                      r'\\;'      : 0.8,\n                      r'\\quad'   : 1.6,\n                      r'\\qquad'  : 3.2,\n                      r'\\!'      : -0.4,\n                      r'\\/'      : 0.4 }\n    def space(self, s, loc, toks):\n        assert(len(toks)==1)\n        num = self._space_widths[toks[0]]\n        box = self._make_space(num)\n        return [box]\n\n    def customspace(self, s, loc, toks):\n        return [self._make_space(float(toks[0]))]\n\n    def symbol(self, s, loc, toks):\n        # print \"symbol\", toks\n        c = toks[0]\n        try:\n            char = Char(c, self.get_state())\n        except ValueError:\n            raise ParseFatalException(s, loc, \"Unknown symbol: %s\" % c)\n\n        if c in self._spaced_symbols:\n            return [Hlist( [self._make_space(0.2),\n                            char,\n                            self._make_space(0.2)] ,\n                           do_kern = False)]\n        elif c in self._punctuation_symbols:\n            return [Hlist( [char,\n                            self._make_space(0.2)] ,\n                           do_kern = False)]\n        return [char]\n\n    def unknown_symbol(self, s, loc, toks):\n        # print \"symbol\", toks\n        c = toks[0]\n        raise ParseFatalException(s, loc, \"Unknown symbol: %s\" % c)\n\n    _char_over_chars = {\n        # The first 2 entires in the tuple are (font, char, sizescale) for\n        # the two symbols under and over.  The third element is the space\n        # (in multiples of underline height)\n        r'AA' : (  ('rm', 'A', 1.0), (None, '\\circ', 0.5), 0.0),\n    }\n\n    def c_over_c(self, s, loc, toks):\n        sym = toks[0]\n        state = self.get_state()\n        thickness = state.font_output.get_underline_thickness(\n            state.font, state.fontsize, state.dpi)\n\n        under_desc, over_desc, space = \\\n            self._char_over_chars.get(sym, (None, None, 0.0))\n        if under_desc is None:\n            raise ParseFatalException(\"Error parsing symbol\")\n\n        over_state = state.copy()\n        if over_desc[0] is not None:\n            over_state.font = over_desc[0]\n        over_state.fontsize *= over_desc[2]\n        over = Accent(over_desc[1], over_state)\n\n        under_state = state.copy()\n        if under_desc[0] is not None:\n            under_state.font = under_desc[0]\n        under_state.fontsize *= under_desc[2]\n        under = Char(under_desc[1], under_state)\n\n        width = max(over.width, under.width)\n\n        over_centered = HCentered([over])\n        over_centered.hpack(width, 'exactly')\n\n        under_centered = HCentered([under])\n        under_centered.hpack(width, 'exactly')\n\n        return Vlist([\n                over_centered,\n                Vbox(0., thickness * space),\n                under_centered\n                ])\n\n    _accent_map = {\n        r'hat'   : r'\\circumflexaccent',\n        r'breve' : r'\\combiningbreve',\n        r'bar'   : r'\\combiningoverline',\n        r'grave' : r'\\combininggraveaccent',\n        r'acute' : r'\\combiningacuteaccent',\n        r'ddot'  : r'\\combiningdiaeresis',\n        r'tilde' : r'\\combiningtilde',\n        r'dot'   : r'\\combiningdotabove',\n        r'vec'   : r'\\combiningrightarrowabove',\n        r'\"'     : r'\\combiningdiaeresis',\n        r\"`\"     : r'\\combininggraveaccent',\n        r\"'\"     : r'\\combiningacuteaccent',\n        r'~'     : r'\\combiningtilde',\n        r'.'     : r'\\combiningdotabove',\n        r'^'     : r'\\circumflexaccent',\n        r'overrightarrow' : r'\\rightarrow',\n        r'overleftarrow'  : r'\\leftarrow'\n        }\n\n    _wide_accents = set(r\"widehat widetilde widebar\".split())\n\n    def accent(self, s, loc, toks):\n        assert(len(toks)==1)\n        state = self.get_state()\n        thickness = state.font_output.get_underline_thickness(\n            state.font, state.fontsize, state.dpi)\n        if len(toks[0]) != 2:\n            raise ParseFatalException(\"Error parsing accent\")\n        accent, sym = toks[0]\n        if accent in self._wide_accents:\n            accent = AutoWidthChar(\n                '\\\\' + accent, sym.width, state, char_class=Accent)\n        else:\n            accent = Accent(self._accent_map[accent], state)\n        centered = HCentered([accent])\n        centered.hpack(sym.width, 'exactly')\n        return Vlist([\n                centered,\n                Vbox(0., thickness * 2.0),\n                Hlist([sym])\n                ])\n\n    def function(self, s, loc, toks):\n        #~ print \"function\", toks\n        self.push_state()\n        state = self.get_state()\n        state.font = 'rm'\n        hlist = Hlist([Char(c, state) for c in toks[0]])\n        self.pop_state()\n        hlist.function_name = toks[0]\n        return hlist\n\n    def operatorname(self, s, loc, toks):\n        self.push_state()\n        state = self.get_state()\n        state.font = 'rm'\n        # Change the font of Chars, but leave Kerns alone\n        for c in toks[0]:\n            if isinstance(c, Char):\n                c.font = 'rm'\n                c._update_metrics()\n        self.pop_state()\n        return Hlist(toks[0])\n\n    def start_group(self, s, loc, toks):\n        self.push_state()\n        # Deal with LaTeX-style font tokens\n        if len(toks):\n            self.get_state().font = toks[0][4:]\n        return []\n\n    def group(self, s, loc, toks):\n        grp = Hlist(toks[0])\n        return [grp]\n    required_group = simple_group = group\n\n    def end_group(self, s, loc, toks):\n        self.pop_state()\n        return []\n\n    def font(self, s, loc, toks):\n        assert(len(toks)==1)\n        name = toks[0]\n        self.get_state().font = name\n        return []\n\n    def is_overunder(self, nucleus):\n        if isinstance(nucleus, Char):\n            return nucleus.c in self._overunder_symbols\n        elif isinstance(nucleus, Hlist) and hasattr(nucleus, 'function_name'):\n            return nucleus.function_name in self._overunder_functions\n        return False\n\n    def is_dropsub(self, nucleus):\n        if isinstance(nucleus, Char):\n            return nucleus.c in self._dropsub_symbols\n        return False\n\n    def is_slanted(self, nucleus):\n        if isinstance(nucleus, Char):\n            return nucleus.is_slanted()\n        return False\n\n    def subsuper(self, s, loc, toks):\n        assert(len(toks)==1)\n        # print 'subsuper', toks\n\n        nucleus = None\n        sub = None\n        super = None\n\n        # Pick all of the apostrophe's out\n        napostrophes = 0\n        new_toks = []\n        for tok in toks[0]:\n            if isinstance(tok, six.string_types) and tok not in ('^', '_'):\n                napostrophes += len(tok)\n            else:\n                new_toks.append(tok)\n        toks = new_toks\n\n        if len(toks) == 0:\n            assert napostrophes\n            nucleus = Hbox(0.0)\n        elif len(toks) == 1:\n            if not napostrophes:\n                return toks[0] # .asList()\n            else:\n                nucleus = toks[0]\n        elif len(toks) == 2:\n            op, next = toks\n            nucleus = Hbox(0.0)\n            if op == '_':\n                sub = next\n            else:\n                super = next\n        elif len(toks) == 3:\n            nucleus, op, next = toks\n            if op == '_':\n                sub = next\n            else:\n                super = next\n        elif len(toks) == 5:\n            nucleus, op1, next1, op2, next2 = toks\n            if op1 == op2:\n                if op1 == '_':\n                    raise ParseFatalException(\"Double subscript\")\n                else:\n                    raise ParseFatalException(\"Double superscript\")\n            if op1 == '_':\n                sub = next1\n                super = next2\n            else:\n                super = next1\n                sub = next2\n        else:\n            raise ParseFatalException(\n                \"Subscript/superscript sequence is too long. \"\n                \"Use braces { } to remove ambiguity.\")\n\n        state = self.get_state()\n        rule_thickness = state.font_output.get_underline_thickness(\n            state.font, state.fontsize, state.dpi)\n        xHeight = state.font_output.get_xheight(\n            state.font, state.fontsize, state.dpi)\n\n        if napostrophes:\n            if super is None:\n                super = Hlist([])\n            for i in range(napostrophes):\n                super.children.extend(self.symbol(s, loc, ['\\prime']))\n\n        # Handle over/under symbols, such as sum or integral\n        if self.is_overunder(nucleus):\n            vlist = []\n            shift = 0.\n            width = nucleus.width\n            if super is not None:\n                super.shrink()\n                width = max(width, super.width)\n            if sub is not None:\n                sub.shrink()\n                width = max(width, sub.width)\n\n            if super is not None:\n                hlist = HCentered([super])\n                hlist.hpack(width, 'exactly')\n                vlist.extend([hlist, Kern(rule_thickness * 3.0)])\n            hlist = HCentered([nucleus])\n            hlist.hpack(width, 'exactly')\n            vlist.append(hlist)\n            if sub is not None:\n                hlist = HCentered([sub])\n                hlist.hpack(width, 'exactly')\n                vlist.extend([Kern(rule_thickness * 3.0), hlist])\n                shift = hlist.height\n            vlist = Vlist(vlist)\n            vlist.shift_amount = shift + nucleus.depth\n            result = Hlist([vlist])\n            return [result]\n\n        # Handle regular sub/superscripts\n        shift_up = nucleus.height - SUBDROP * xHeight\n        if self.is_dropsub(nucleus):\n            shift_down = nucleus.depth + SUBDROP * xHeight\n        else:\n            shift_down = SUBDROP * xHeight\n        if super is None:\n            # node757\n            sub.shrink()\n            x = Hlist([sub])\n            # x.width += SCRIPT_SPACE * xHeight\n            shift_down = max(shift_down, SUB1)\n            clr = x.height - (abs(xHeight * 4.0) / 5.0)\n            shift_down = max(shift_down, clr)\n            x.shift_amount = shift_down\n        else:\n            super.shrink()\n            x = Hlist([super, Kern(SCRIPT_SPACE * xHeight)])\n            # x.width += SCRIPT_SPACE * xHeight\n            clr = SUP1 * xHeight\n            shift_up = max(shift_up, clr)\n            clr = x.depth + (abs(xHeight) / 4.0)\n            shift_up = max(shift_up, clr)\n            if sub is None:\n                x.shift_amount = -shift_up\n            else: # Both sub and superscript\n                sub.shrink()\n                y = Hlist([sub])\n                # y.width += SCRIPT_SPACE * xHeight\n                shift_down = max(shift_down, SUB1 * xHeight)\n                clr = (2.0 * rule_thickness -\n                       ((shift_up - x.depth) - (y.height - shift_down)))\n                if clr > 0.:\n                    shift_up += clr\n                    shift_down += clr\n                if self.is_slanted(nucleus):\n                    x.shift_amount = DELTA * (shift_up + shift_down)\n                x = Vlist([x,\n                           Kern((shift_up - x.depth) - (y.height - shift_down)),\n                           y])\n                x.shift_amount = shift_down\n\n        result = Hlist([nucleus, x])\n        return [result]\n\n    def _genfrac(self, ldelim, rdelim, rule, style, num, den):\n        state = self.get_state()\n        thickness = state.font_output.get_underline_thickness(\n            state.font, state.fontsize, state.dpi)\n\n        rule = float(rule)\n        num.shrink()\n        den.shrink()\n        cnum = HCentered([num])\n        cden = HCentered([den])\n        width = max(num.width, den.width)\n        cnum.hpack(width, 'exactly')\n        cden.hpack(width, 'exactly')\n        vlist = Vlist([cnum,                      # numerator\n                       Vbox(0, thickness * 2.0),  # space\n                       Hrule(state, rule),        # rule\n                       Vbox(0, thickness * 2.0),  # space\n                       cden                       # denominator\n                       ])\n\n        # Shift so the fraction line sits in the middle of the\n        # equals sign\n        metrics = state.font_output.get_metrics(\n            state.font, rcParams['mathtext.default'],\n            '=', state.fontsize, state.dpi)\n        shift = (cden.height -\n                 ((metrics.ymax + metrics.ymin) / 2 -\n                  thickness * 3.0))\n        vlist.shift_amount = shift\n\n        result = [Hlist([vlist, Hbox(thickness * 2.)])]\n        if ldelim or rdelim:\n            if ldelim == '':\n                ldelim = '.'\n            if rdelim == '':\n                rdelim = '.'\n            return self._auto_sized_delimiter(ldelim, result, rdelim)\n        return result\n\n    def genfrac(self, s, loc, toks):\n        assert(len(toks)==1)\n        assert(len(toks[0])==6)\n\n        return self._genfrac(*tuple(toks[0]))\n\n    def frac(self, s, loc, toks):\n        assert(len(toks)==1)\n        assert(len(toks[0])==2)\n        state = self.get_state()\n\n        thickness = state.font_output.get_underline_thickness(\n            state.font, state.fontsize, state.dpi)\n        num, den = toks[0]\n\n        return self._genfrac('', '', thickness, '', num, den)\n\n    def stackrel(self, s, loc, toks):\n        assert(len(toks)==1)\n        assert(len(toks[0])==2)\n        num, den = toks[0]\n\n        return self._genfrac('', '', 0.0, '', num, den)\n\n    def binom(self, s, loc, toks):\n        assert(len(toks)==1)\n        assert(len(toks[0])==2)\n        num, den = toks[0]\n\n        return self._genfrac('(', ')', 0.0, '', num, den)\n\n    def sqrt(self, s, loc, toks):\n        #~ print \"sqrt\", toks\n        root, body = toks[0]\n        state = self.get_state()\n        thickness = state.font_output.get_underline_thickness(\n            state.font, state.fontsize, state.dpi)\n\n        # Determine the height of the body, and add a little extra to\n        # the height so it doesn't seem cramped\n        height = body.height - body.shift_amount + thickness * 5.0\n        depth = body.depth + body.shift_amount\n        check = AutoHeightChar(r'\\__sqrt__', height, depth, state, always=True)\n        height = check.height - check.shift_amount\n        depth = check.depth + check.shift_amount\n\n        # Put a little extra space to the left and right of the body\n        padded_body = Hlist([Hbox(thickness * 2.0),\n                             body,\n                             Hbox(thickness * 2.0)])\n        rightside = Vlist([Hrule(state),\n                           Fill(),\n                           padded_body])\n        # Stretch the glue between the hrule and the body\n        rightside.vpack(height + (state.fontsize * state.dpi) / (100.0 * 12.0),\n                        'exactly', depth)\n\n        # Add the root and shift it upward so it is above the tick.\n        # The value of 0.6 is a hard-coded hack ;)\n        if root is None:\n            root = Box(check.width * 0.5, 0., 0.)\n        else:\n            root = Hlist([Char(x, state) for x in root])\n            root.shrink()\n            root.shrink()\n\n        root_vlist = Vlist([Hlist([root])])\n        root_vlist.shift_amount = -height * 0.6\n\n        hlist = Hlist([root_vlist,               # Root\n                       # Negative kerning to put root over tick\n                       Kern(-check.width * 0.5),\n                       check,                    # Check\n                       rightside])               # Body\n        return [hlist]\n\n    def overline(self, s, loc, toks):\n        assert(len(toks)==1)\n        assert(len(toks[0])==1)\n\n        body = toks[0][0]\n\n        state = self.get_state()\n        thickness = state.font_output.get_underline_thickness(\n            state.font, state.fontsize, state.dpi)\n\n        height = body.height - body.shift_amount + thickness * 3.0\n        depth = body.depth + body.shift_amount\n\n        # Place overline above body\n        rightside = Vlist([Hrule(state),\n                           Fill(),\n                           Hlist([body])])\n\n        # Stretch the glue between the hrule and the body\n        rightside.vpack(height + (state.fontsize * state.dpi) / (100.0 * 12.0),\n                        'exactly', depth)\n\n        hlist = Hlist([rightside])\n        return [hlist]\n\n    def _auto_sized_delimiter(self, front, middle, back):\n        state = self.get_state()\n        if len(middle):\n            height = max([x.height for x in middle])\n            depth = max([x.depth for x in middle])\n            factor = None\n        else:\n            height = 0\n            depth = 0\n            factor = 1.0\n        parts = []\n        # \\left. and \\right. aren't supposed to produce any symbols\n        if front != '.':\n            parts.append(AutoHeightChar(front, height, depth, state, factor=factor))\n        parts.extend(middle)\n        if back != '.':\n            parts.append(AutoHeightChar(back, height, depth, state, factor=factor))\n        hlist = Hlist(parts)\n        return hlist\n\n    def auto_delim(self, s, loc, toks):\n        #~ print \"auto_delim\", toks\n        front, middle, back = toks\n\n        return self._auto_sized_delimiter(front, middle.asList(), back)\n\n###\n\n##############################################################################\n# MAIN\n\nclass MathTextParser(object):\n    _parser = None\n\n    _backend_mapping = {\n        'bitmap': MathtextBackendBitmap,\n        'agg'   : MathtextBackendAgg,\n        'ps'    : MathtextBackendPs,\n        'pdf'   : MathtextBackendPdf,\n        'svg'   : MathtextBackendSvg,\n        'path'  : MathtextBackendPath,\n        'cairo' : MathtextBackendCairo,\n        'macosx': MathtextBackendAgg,\n        }\n\n    _font_type_mapping = {\n        'cm'       : BakomaFonts,\n        'stix'     : StixFonts,\n        'stixsans' : StixSansFonts,\n        'custom'   : UnicodeFonts\n        }\n\n    def __init__(self, output):\n        \"\"\"\n        Create a MathTextParser for the given backend *output*.\n        \"\"\"\n        self._output = output.lower()\n        self._cache = maxdict(50)\n\n    def parse(self, s, dpi = 72, prop = None):\n        \"\"\"\n        Parse the given math expression *s* at the given *dpi*.  If\n        *prop* is provided, it is a\n        :class:`~matplotlib.font_manager.FontProperties` object\n        specifying the \"default\" font to use in the math expression,\n        used for all non-math text.\n\n        The results are cached, so multiple calls to :meth:`parse`\n        with the same expression should be fast.\n        \"\"\"\n        # There is a bug in Python 3.x where it leaks frame references,\n        # and therefore can't handle this caching\n        if prop is None:\n            prop = FontProperties()\n\n        cacheKey = (s, dpi, hash(prop))\n        result = self._cache.get(cacheKey)\n        if result is not None:\n            return result\n\n        if self._output == 'ps' and rcParams['ps.useafm']:\n            font_output = StandardPsFonts(prop)\n        else:\n            backend = self._backend_mapping[self._output]()\n            fontset = rcParams['mathtext.fontset']\n            fontset_class = self._font_type_mapping.get(fontset.lower())\n            if fontset_class is not None:\n                font_output = fontset_class(prop, backend)\n            else:\n                raise ValueError(\n                    \"mathtext.fontset must be either 'cm', 'stix', \"\n                    \"'stixsans', or 'custom'\")\n\n        fontsize = prop.get_size_in_points()\n\n        # This is a class variable so we don't rebuild the parser\n        # with each request.\n        if self._parser is None:\n            self.__class__._parser = Parser()\n\n        box = self._parser.parse(s, font_output, fontsize, dpi)\n        font_output.set_canvas_size(box.width, box.height, box.depth)\n        result = font_output.get_results(box)\n        self._cache[cacheKey] = result\n        return result\n\n    def to_mask(self, texstr, dpi=120, fontsize=14):\n        \"\"\"\n        *texstr*\n            A valid mathtext string, eg r'IQ: $\\sigma_i=15$'\n\n        *dpi*\n            The dots-per-inch to render the text\n\n        *fontsize*\n            The font size in points\n\n        Returns a tuple (*array*, *depth*)\n\n          - *array* is an NxM uint8 alpha ubyte mask array of\n            rasterized tex.\n\n          - depth is the offset of the baseline from the bottom of the\n            image in pixels.\n        \"\"\"\n        assert(self._output==\"bitmap\")\n        prop = FontProperties(size=fontsize)\n        ftimage, depth = self.parse(texstr, dpi=dpi, prop=prop)\n\n        x = ftimage.as_array()\n        return x, depth\n\n    def to_rgba(self, texstr, color='black', dpi=120, fontsize=14):\n        \"\"\"\n        *texstr*\n            A valid mathtext string, eg r'IQ: $\\sigma_i=15$'\n\n        *color*\n            Any matplotlib color argument\n\n        *dpi*\n            The dots-per-inch to render the text\n\n        *fontsize*\n            The font size in points\n\n        Returns a tuple (*array*, *depth*)\n\n          - *array* is an NxM uint8 alpha ubyte mask array of\n            rasterized tex.\n\n          - depth is the offset of the baseline from the bottom of the\n            image in pixels.\n        \"\"\"\n        x, depth = self.to_mask(texstr, dpi=dpi, fontsize=fontsize)\n\n        r, g, b = mcolors.colorConverter.to_rgb(color)\n        RGBA = np.zeros((x.shape[0], x.shape[1], 4), dtype=np.uint8)\n        RGBA[:,:,0] = int(255*r)\n        RGBA[:,:,1] = int(255*g)\n        RGBA[:,:,2] = int(255*b)\n        RGBA[:,:,3] = x\n        return RGBA, depth\n\n    def to_png(self, filename, texstr, color='black', dpi=120, fontsize=14):\n        \"\"\"\n        Writes a tex expression to a PNG file.\n\n        Returns the offset of the baseline from the bottom of the\n        image in pixels.\n\n        *filename*\n            A writable filename or fileobject\n\n        *texstr*\n            A valid mathtext string, eg r'IQ: $\\sigma_i=15$'\n\n        *color*\n            A valid matplotlib color argument\n\n        *dpi*\n            The dots-per-inch to render the text\n\n        *fontsize*\n            The font size in points\n\n        Returns the offset of the baseline from the bottom of the\n        image in pixels.\n        \"\"\"\n        rgba, depth = self.to_rgba(texstr, color=color, dpi=dpi, fontsize=fontsize)\n        _png.write_png(rgba, filename)\n        return depth\n\n    def get_depth(self, texstr, dpi=120, fontsize=14):\n        \"\"\"\n        Returns the offset of the baseline from the bottom of the\n        image in pixels.\n\n        *texstr*\n            A valid mathtext string, eg r'IQ: $\\sigma_i=15$'\n\n        *dpi*\n            The dots-per-inch to render the text\n\n        *fontsize*\n            The font size in points\n        \"\"\"\n        assert(self._output==\"bitmap\")\n        prop = FontProperties(size=fontsize)\n        ftimage, depth = self.parse(texstr, dpi=dpi, prop=prop)\n        return depth\n\ndef math_to_image(s, filename_or_obj, prop=None, dpi=None, format=None):\n    \"\"\"\n    Given a math expression, renders it in a closely-clipped bounding\n    box to an image file.\n\n    *s*\n       A math expression.  The math portion should be enclosed in\n       dollar signs.\n\n    *filename_or_obj*\n       A filepath or writable file-like object to write the image data\n       to.\n\n    *prop*\n       If provided, a FontProperties() object describing the size and\n       style of the text.\n\n    *dpi*\n       Override the output dpi, otherwise use the default associated\n       with the output format.\n\n    *format*\n       The output format, e.g., 'svg', 'pdf', 'ps' or 'png'.  If not\n       provided, will be deduced from the filename.\n    \"\"\"\n    from matplotlib import figure\n    # backend_agg supports all of the core output formats\n    from matplotlib.backends import backend_agg\n\n    if prop is None:\n        prop = FontProperties()\n\n    parser = MathTextParser('path')\n    width, height, depth, _, _ = parser.parse(s, dpi=72, prop=prop)\n\n    fig = figure.Figure(figsize=(width / 72.0, height / 72.0))\n    fig.text(0, depth/height, s, fontproperties=prop)\n    backend_agg.FigureCanvasAgg(fig)\n    fig.savefig(filename_or_obj, dpi=dpi, format=format)\n\n    return depth\n", "patch": "@@ -3092,8 +3092,7 @@ def to_png(self, filename, texstr, color='black', dpi=120, fontsize=14):\n         image in pixels.\n         \"\"\"\n         rgba, depth = self.to_rgba(texstr, color=color, dpi=dpi, fontsize=fontsize)\n-        numrows, numcols, tmp = rgba.shape\n-        _png.write_png(rgba.tostring(), numcols, numrows, filename)\n+        _png.write_png(rgba, filename)\n         return depth\n \n     def get_depth(self, texstr, dpi=120, fontsize=14):"}
{"patches_id": 2, "files_id": 20, "language": "py", "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Ftesting%2Fcompare.py", "raw_code": "\"\"\"\nProvides a collection of utilities for comparing (image) results.\n\n\"\"\"\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport six\n\nimport hashlib\nimport os\nimport shutil\n\nimport numpy as np\n\nimport matplotlib\nfrom matplotlib.compat import subprocess\nfrom matplotlib.testing.noseclasses import ImageComparisonFailure\nfrom matplotlib import _png\nfrom matplotlib import _get_cachedir\nfrom matplotlib import cbook\nfrom distutils import version\n\n__all__ = ['compare_float', 'compare_images', 'comparable_formats']\n\n\ndef make_test_filename(fname, purpose):\n    \"\"\"\n    Make a new filename by inserting `purpose` before the file's\n    extension.\n    \"\"\"\n    base, ext = os.path.splitext(fname)\n    return '%s-%s%s' % (base, purpose, ext)\n\n\ndef compare_float(expected, actual, relTol=None, absTol=None):\n    \"\"\"\n    Fail if the floating point values are not close enough, with\n    the given message.\n\n    You can specify a relative tolerance, absolute tolerance, or both.\n\n    \"\"\"\n    if relTol is None and absTol is None:\n        raise ValueError(\"You haven't specified a 'relTol' relative \"\n                         \"tolerance or a 'absTol' absolute tolerance \"\n                         \"function argument. You must specify one.\")\n    msg = \"\"\n\n    if absTol is not None:\n        absDiff = abs(expected - actual)\n        if absTol < absDiff:\n            template = ['',\n                        'Expected: {expected}',\n                        'Actual:   {actual}',\n                        'Abs diff: {absDiff}',\n                        'Abs tol:  {absTol}']\n            msg += '\\n  '.join([line.format(**locals()) for line in template])\n\n    if relTol is not None:\n        # The relative difference of the two values.  If the expected value is\n        # zero, then return the absolute value of the difference.\n        relDiff = abs(expected - actual)\n        if expected:\n            relDiff = relDiff / abs(expected)\n\n        if relTol < relDiff:\n            # The relative difference is a ratio, so it's always unit-less.\n            template = ['',\n                        'Expected: {expected}',\n                        'Actual:   {actual}',\n                        'Rel diff: {relDiff}',\n                        'Rel tol:  {relTol}']\n            msg += '\\n  '.join([line.format(**locals()) for line in template])\n\n    return msg or None\n\n\ndef get_cache_dir():\n    cachedir = _get_cachedir()\n    if cachedir is None:\n        raise RuntimeError('Could not find a suitable configuration directory')\n    cache_dir = os.path.join(cachedir, 'test_cache')\n    if not os.path.exists(cache_dir):\n        try:\n            cbook.mkdirs(cache_dir)\n        except IOError:\n            return None\n    if not os.access(cache_dir, os.W_OK):\n        return None\n    return cache_dir\n\n\ndef get_file_hash(path, block_size=2 ** 20):\n    md5 = hashlib.md5()\n    with open(path, 'rb') as fd:\n        while True:\n            data = fd.read(block_size)\n            if not data:\n                break\n            md5.update(data)\n    return md5.hexdigest()\n\n\ndef make_external_conversion_command(cmd):\n    def convert(old, new):\n        cmdline = cmd(old, new)\n        pipe = subprocess.Popen(\n            cmdline, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        stdout, stderr = pipe.communicate()\n        errcode = pipe.wait()\n        if not os.path.exists(new) or errcode:\n            msg = \"Conversion command failed:\\n%s\\n\" % ' '.join(cmdline)\n            if stdout:\n                msg += \"Standard output:\\n%s\\n\" % stdout\n            if stderr:\n                msg += \"Standard error:\\n%s\\n\" % stderr\n            raise IOError(msg)\n\n    return convert\n\n\ndef _update_converter():\n    gs, gs_v = matplotlib.checkdep_ghostscript()\n    if gs_v is not None:\n        cmd = lambda old, new: \\\n            [gs, '-q', '-sDEVICE=png16m', '-dNOPAUSE', '-dBATCH',\n             '-sOutputFile=' + new, old]\n        converter['pdf'] = make_external_conversion_command(cmd)\n        converter['eps'] = make_external_conversion_command(cmd)\n\n    if matplotlib.checkdep_inkscape() is not None:\n        cmd = lambda old, new: \\\n            ['inkscape', '-z', old, '--export-png', new]\n        converter['svg'] = make_external_conversion_command(cmd)\n\n\n#: A dictionary that maps filename extensions to functions which\n#: themselves map arguments `old` and `new` (filenames) to a list of strings.\n#: The list can then be passed to Popen to convert files with that\n#: extension to png format.\nconverter = {}\n_update_converter()\n\n\ndef comparable_formats():\n    \"\"\"\n    Returns the list of file formats that compare_images can compare\n    on this system.\n\n    \"\"\"\n    return ['png'] + list(six.iterkeys(converter))\n\n\ndef convert(filename, cache):\n    \"\"\"\n    Convert the named file into a png file.  Returns the name of the\n    created file.\n\n    If *cache* is True, the result of the conversion is cached in\n    `matplotlib._get_cachedir() + '/test_cache/'`.  The caching is based\n    on a hash of the exact contents of the input file.  The is no limit\n    on the size of the cache, so it may need to be manually cleared\n    periodically.\n\n    \"\"\"\n    base, extension = filename.rsplit('.', 1)\n    if extension not in converter:\n        raise ImageComparisonFailure(\n            \"Don't know how to convert %s files to png\" % extension)\n    newname = base + '_' + extension + '.png'\n    if not os.path.exists(filename):\n        raise IOError(\"'%s' does not exist\" % filename)\n\n    # Only convert the file if the destination doesn't already exist or\n    # is out of date.\n    if (not os.path.exists(newname) or\n            os.stat(newname).st_mtime < os.stat(filename).st_mtime):\n        if cache:\n            cache_dir = get_cache_dir()\n        else:\n            cache_dir = None\n\n        if cache_dir is not None:\n            hash_value = get_file_hash(filename)\n            new_ext = os.path.splitext(newname)[1]\n            cached_file = os.path.join(cache_dir, hash_value + new_ext)\n            if os.path.exists(cached_file):\n                shutil.copyfile(cached_file, newname)\n                return newname\n\n        converter[extension](filename, newname)\n\n        if cache_dir is not None:\n            shutil.copyfile(newname, cached_file)\n\n    return newname\n\n#: Maps file extensions to a function which takes a filename as its\n#: only argument to return a list suitable for execution with Popen.\n#: The purpose of this is so that the result file (with the given\n#: extension) can be verified with tools such as xmllint for svg.\nverifiers = {}\n\n# Turning this off, because it seems to cause multiprocessing issues\nif matplotlib.checkdep_xmllint() and False:\n    verifiers['svg'] = lambda filename: [\n        'xmllint', '--valid', '--nowarning', '--noout', filename]\n\n\ndef verify(filename):\n    \"\"\"Verify the file through some sort of verification tool.\"\"\"\n    if not os.path.exists(filename):\n        raise IOError(\"'%s' does not exist\" % filename)\n    base, extension = filename.rsplit('.', 1)\n    verifier = verifiers.get(extension, None)\n    if verifier is not None:\n        cmd = verifier(filename)\n        pipe = subprocess.Popen(\n            cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        stdout, stderr = pipe.communicate()\n        errcode = pipe.wait()\n        if errcode != 0:\n            msg = \"File verification command failed:\\n%s\\n\" % ' '.join(cmd)\n            if stdout:\n                msg += \"Standard output:\\n%s\\n\" % stdout\n            if stderr:\n                msg += \"Standard error:\\n%s\\n\" % stderr\n            raise IOError(msg)\n\n\ndef crop_to_same(actual_path, actual_image, expected_path, expected_image):\n    # clip the images to the same size -- this is useful only when\n    # comparing eps to pdf\n    if actual_path[-7:-4] == 'eps' and expected_path[-7:-4] == 'pdf':\n        aw, ah = actual_image.shape\n        ew, eh = expected_image.shape\n        actual_image = actual_image[int(aw / 2 - ew / 2):int(\n            aw / 2 + ew / 2), int(ah / 2 - eh / 2):int(ah / 2 + eh / 2)]\n    return actual_image, expected_image\n\n\ndef calculate_rms(expectedImage, actualImage):\n    \"Calculate the per-pixel errors, then compute the root mean square error.\"\n    num_values = np.prod(expectedImage.shape)\n    abs_diff_image = abs(expectedImage - actualImage)\n\n    # On Numpy 1.6, we can use bincount with minlength, which is much\n    # faster than using histogram\n    expected_version = version.LooseVersion(\"1.6\")\n    found_version = version.LooseVersion(np.__version__)\n    if found_version >= expected_version:\n        histogram = np.bincount(abs_diff_image.ravel(), minlength=256)\n    else:\n        histogram = np.histogram(abs_diff_image, bins=np.arange(257))[0]\n\n    sum_of_squares = np.sum(histogram * np.arange(len(histogram)) ** 2)\n    rms = np.sqrt(float(sum_of_squares) / num_values)\n\n    return rms\n\n\ndef compare_images(expected, actual, tol, in_decorator=False):\n    \"\"\"\n    Compare two \"image\" files checking differences within a tolerance.\n\n    The two given filenames may point to files which are convertible to\n    PNG via the `.converter` dictionary. The underlying RMS is calculated\n    with the `.calculate_rms` function.\n\n    Parameters\n    ----------\n    expected : str\n        The filename of the expected image.\n    actual :str\n        The filename of the actual image.\n    tol : float\n        The tolerance (a color value difference, where 255 is the\n        maximal difference).  The test fails if the average pixel\n        difference is greater than this value.\n    in_decorator : bool\n        If called from image_comparison decorator, this should be\n        True. (default=False)\n\n    Example\n    -------\n    img1 = \"./baseline/plot.png\"\n    img2 = \"./output/plot.png\"\n    compare_images( img1, img2, 0.001 ):\n\n    \"\"\"\n    if not os.path.exists(actual):\n        msg = \"Output image %s does not exist.\" % actual\n        raise Exception(msg)\n\n    if os.stat(actual).st_size == 0:\n        msg = \"Output image file %s is empty.\" % actual\n        raise Exception(msg)\n\n    verify(actual)\n\n    # Convert the image to png\n    extension = expected.split('.')[-1]\n\n    if not os.path.exists(expected):\n        raise IOError('Baseline image %r does not exist.' % expected)\n\n    if extension != 'png':\n        actual = convert(actual, False)\n        expected = convert(expected, True)\n\n    # open the image files and remove the alpha channel (if it exists)\n    expectedImage = _png.read_png_int(expected)\n    actualImage = _png.read_png_int(actual)\n    expectedImage = expectedImage[:, :, :3]\n    actualImage = actualImage[:, :, :3]\n\n    actualImage, expectedImage = crop_to_same(\n        actual, actualImage, expected, expectedImage)\n\n    # convert to signed integers, so that the images can be subtracted without\n    # overflow\n    expectedImage = expectedImage.astype(np.int16)\n    actualImage = actualImage.astype(np.int16)\n\n    rms = calculate_rms(expectedImage, actualImage)\n\n    diff_image = make_test_filename(actual, 'failed-diff')\n\n    if rms <= tol:\n        if os.path.exists(diff_image):\n            os.unlink(diff_image)\n        return None\n\n    save_diff_image(expected, actual, diff_image)\n\n    results = dict(rms=rms, expected=str(expected),\n                   actual=str(actual), diff=str(diff_image), tol=tol)\n\n    if not in_decorator:\n        # Then the results should be a string suitable for stdout.\n        template = ['Error: Image files did not match.',\n                    'RMS Value: {rms}',\n                    'Expected:  \\n    {expected}',\n                    'Actual:    \\n    {actual}',\n                    'Difference:\\n    {diff}',\n                    'Tolerance: \\n    {tol}', ]\n        results = '\\n  '.join([line.format(**results) for line in template])\n    return results\n\n\ndef save_diff_image(expected, actual, output):\n    expectedImage = _png.read_png(expected)\n    actualImage = _png.read_png(actual)\n    actualImage, expectedImage = crop_to_same(\n        actual, actualImage, expected, expectedImage)\n    expectedImage = np.array(expectedImage).astype(np.float)\n    actualImage = np.array(actualImage).astype(np.float)\n    assert expectedImage.ndim == actualImage.ndim\n    assert expectedImage.shape == actualImage.shape\n    absDiffImage = abs(expectedImage - actualImage)\n\n    # expand differences in luminance domain\n    absDiffImage *= 255 * 10\n    save_image_np = np.clip(absDiffImage, 0, 255).astype(np.uint8)\n    height, width, depth = save_image_np.shape\n\n    # The PDF renderer doesn't produce an alpha channel, but the\n    # matplotlib PNG writer requires one, so expand the array\n    if depth == 3:\n        with_alpha = np.empty((height, width, 4), dtype=np.uint8)\n        with_alpha[:, :, 0:3] = save_image_np\n        save_image_np = with_alpha\n\n    # Hard-code the alpha channel to fully solid\n    save_image_np[:, :, 3] = 255\n\n    _png.write_png(save_image_np, output)\n", "patch": "@@ -375,4 +375,4 @@ def save_diff_image(expected, actual, output):\n     # Hard-code the alpha channel to fully solid\n     save_image_np[:, :, 3] = 255\n \n-    _png.write_png(save_image_np.tostring(), width, height, output)\n+    _png.write_png(save_image_np, output)"}
{"patches_id": 2, "files_id": 22, "language": "svg", "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Ftests%2Fbaseline_images%2Ftest_image%2Frasterize_10dpi.svg", "raw_code": "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"\n  \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<!-- Created with matplotlib (http://matplotlib.org/) -->\n<svg height=\"72pt\" version=\"1.1\" viewBox=\"0 0 216 72\" width=\"216pt\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n <defs>\n  <style type=\"text/css\">\n*{stroke-linecap:butt;stroke-linejoin:round;}\n  </style>\n </defs>\n <g id=\"figure_1\">\n  <g id=\"patch_1\">\n   <path d=\"\nM0 72\nL216 72\nL216 0\nL0 0\nz\n\" style=\"fill:#ffffff;\"/>\n  </g>\n  <g id=\"axes_1\">\n   <g id=\"patch_2\">\n    <path d=\"\nM27 60.6176\nL76.2353 60.6176\nL76.2353 11.3824\nL27 11.3824\nz\n\" style=\"fill:#ffffff;\"/>\n   </g>\n   <g clip-path=\"url(#pc31db6f15f)\">\n    <image height=\"50.4\" id=\"image4a0f195e76\" width=\"57.6\" x=\"27.0\" xlink:href=\"data:image/png;base64,\niVBORw0KGgoAAAANSUhEUgAAAAgAAAAHCAYAAAA1WQxeAAAABHNCSVQICAgIfAhkiAAAAIZJREFUCJmFzjkOQWEAReHPkDyFsUVhCSIhap1VWZRFWIBWPBGiIX7zEDzFK5Rucpqbk5ubYZSARo1u60e9ArL+JN9rr8GrevQsPT2uZ494570rpsJwMAO3pCB8Ng7HWJhW3ZMIZCbjZgKnfc4mjlLmkXPIpwv9zgqEJYst5QvRnJDW/09+AWTgMQoHvFOEAAAAAElFTkSuQmCC\" y=\"10.2176470588\"/>\n   </g>\n   <g id=\"matplotlib.axis_1\"/>\n   <g id=\"matplotlib.axis_2\"/>\n  </g>\n  <g id=\"axes_2\">\n   <g id=\"patch_3\">\n    <path d=\"\nM86.0824 64.8\nL135.318 64.8\nL135.318 7.2\nL86.0824 7.2\nz\n\" style=\"fill:#ffffff;\"/>\n   </g>\n   <image height=\"64.8\" id=\"image9000a8cf24\" width=\"136.8\" x=\"79.2\" xlink:href=\"data:image/png;base64,\niVBORw0KGgoAAAANSUhEUgAAABMAAAAJCAYAAADQHRcxAAAABHNCSVQICAgIfAhkiAAAAHNJREFUKJG10kENwlAQBuH5OVQBImoBAzVQA1hABxoQUAUYqIWaqIRepqdHmoaE9AGbzGU3+U4blV/N6d0yoUnoE56HNPUV2IJ3cAYF3d4/VZArOBZgWw22RxZwALtvsAm8gecjyB57gBcwNUgpf3+N2lkBB3gBDVzLDTYAAAAASUVORK5CYII=\" y=\"7.2\"/>\n   <g id=\"matplotlib.axis_3\"/>\n   <g id=\"matplotlib.axis_4\"/>\n  </g>\n  <g id=\"axes_3\">\n   <g id=\"patch_4\">\n    <path d=\"\nM145.165 64.8\nL194.4 64.8\nL194.4 7.2\nL145.165 7.2\nz\n\" style=\"fill:#ffffff;\"/>\n   </g>\n   <g id=\"line2d_1\">\n    <path clip-path=\"url(#p19b1e86336)\" d=\"\nM145.165 45.6\nL194.4 26.4\" style=\"fill:none;stroke:#0000ff;stroke-linecap:square;stroke-width:20.0;\"/>\n   </g>\n   <g id=\"matplotlib.axis_5\"/>\n   <g id=\"matplotlib.axis_6\"/>\n  </g>\n </g>\n <defs>\n  <clipPath id=\"p19b1e86336\">\n   <rect height=\"57.6\" width=\"49.2352941176\" x=\"145.164705882\" y=\"7.2\"/>\n  </clipPath>\n  <clipPath id=\"pc31db6f15f\">\n   <rect height=\"49.2352941176\" width=\"49.2352941176\" x=\"27.0\" y=\"11.3823529412\"/>\n  </clipPath>\n </defs>\n</svg>\n", "patch": "@@ -29,7 +29,7 @@ z\n \" style=\"fill:#ffffff;\"/>\n    </g>\n    <g clip-path=\"url(#pc31db6f15f)\">\n-    <image height=\"50.4\" id=\"image6e276badb5\" width=\"57.6\" x=\"27.0\" xlink:href=\"data:image/png;base64,\n+    <image height=\"50.4\" id=\"image4a0f195e76\" width=\"57.6\" x=\"27.0\" xlink:href=\"data:image/png;base64,\n iVBORw0KGgoAAAANSUhEUgAAAAgAAAAHCAYAAAA1WQxeAAAABHNCSVQICAgIfAhkiAAAAIZJREFUCJmFzjkOQWEAReHPkDyFsUVhCSIhap1VWZRFWIBWPBGiIX7zEDzFK5Rucpqbk5ubYZSARo1u60e9ArL+JN9rr8GrevQsPT2uZ494570rpsJwMAO3pCB8Ng7HWJhW3ZMIZCbjZgKnfc4mjlLmkXPIpwv9zgqEJYst5QvRnJDW/09+AWTgMQoHvFOEAAAAAElFTkSuQmCC\" y=\"10.2176470588\"/>\n    </g>\n    <g id=\"matplotlib.axis_1\"/>\n@@ -45,8 +45,8 @@ L86.0824 7.2\n z\n \" style=\"fill:#ffffff;\"/>\n    </g>\n-   <image height=\"43.2\" id=\"imagea9b52b76c7\" width=\"50.4\" x=\"79.2\" xlink:href=\"data:image/png;base64,\n-iVBORw0KGgoAAAANSUhEUgAAAAcAAAAGCAYAAAAPDoR2AAAABHNCSVQICAgIfAhkiAAAAE5JREFUCJl1jUENgEAAw7qEoAARmMEDFtCBGExgARNY4NF7HRByLOmn2bKo/KVryYQemFBvwBFcwRMeOYM76JuoJHyPL2Cry9o+wAUcVApQADT0Nho0cQAAAABJRU5ErkJggg==\" y=\"7.2\"/>\n+   <image height=\"64.8\" id=\"image9000a8cf24\" width=\"136.8\" x=\"79.2\" xlink:href=\"data:image/png;base64,\n+iVBORw0KGgoAAAANSUhEUgAAABMAAAAJCAYAAADQHRcxAAAABHNCSVQICAgIfAhkiAAAAHNJREFUKJG10kENwlAQBuH5OVQBImoBAzVQA1hABxoQUAUYqIWaqIRepqdHmoaE9AGbzGU3+U4blV/N6d0yoUnoE56HNPUV2IJ3cAYF3d4/VZArOBZgWw22RxZwALtvsAm8gecjyB57gBcwNUgpf3+N2lkBB3gBDVzLDTYAAAAASUVORK5CYII=\" y=\"7.2\"/>\n    <g id=\"matplotlib.axis_3\"/>\n    <g id=\"matplotlib.axis_4\"/>\n   </g>"}
{"patches_id": 2, "files_id": 23, "language": "py", "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Ftests%2Ftest_axes.py", "raw_code": "from __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport six\nfrom six.moves import xrange\n\nimport io\n\nfrom nose.tools import assert_equal, assert_raises\nimport datetime\n\nimport numpy as np\nfrom numpy import ma\n\nimport matplotlib\nfrom matplotlib.testing.decorators import image_comparison, cleanup\nimport matplotlib.pyplot as plt\nfrom numpy.testing import assert_array_equal\nimport warnings\n\n\n@image_comparison(baseline_images=['formatter_ticker_001',\n                                   'formatter_ticker_002',\n                                   'formatter_ticker_003',\n                                   'formatter_ticker_004',\n                                   'formatter_ticker_005',\n                                   ])\ndef test_formatter_ticker():\n    import matplotlib.testing.jpl_units as units\n    units.register()\n\n    # This should affect the tick size.  (Tests issue #543)\n    matplotlib.rcParams['lines.markeredgewidth'] = 30\n\n    # This essentially test to see if user specified labels get overwritten\n    # by the auto labeler functionality of the axes.\n    xdata = [x*units.sec for x in range(10)]\n    ydata1 = [(1.5*y - 0.5)*units.km for y in range(10)]\n    ydata2 = [(1.75*y - 1.0)*units.km for y in range(10)]\n\n    fig = plt.figure()\n    ax = plt.subplot(111)\n    ax.set_xlabel(\"x-label 001\")\n\n    fig = plt.figure()\n    ax = plt.subplot(111)\n    ax.set_xlabel(\"x-label 001\")\n    ax.plot(xdata, ydata1, color='blue', xunits=\"sec\")\n\n    fig = plt.figure()\n    ax = plt.subplot(111)\n    ax.set_xlabel(\"x-label 001\")\n    ax.plot(xdata, ydata1, color='blue', xunits=\"sec\")\n    ax.set_xlabel(\"x-label 003\")\n\n    fig = plt.figure()\n    ax = plt.subplot(111)\n    ax.plot(xdata, ydata1, color='blue', xunits=\"sec\")\n    ax.plot(xdata, ydata2, color='green', xunits=\"hour\")\n    ax.set_xlabel(\"x-label 004\")\n\n    # See SF bug 2846058\n    # https://sourceforge.net/tracker/?func=detail&aid=2846058&group_id=80706&atid=560720\n    fig = plt.figure()\n    ax = plt.subplot(111)\n    ax.plot(xdata, ydata1, color='blue', xunits=\"sec\")\n    ax.plot(xdata, ydata2, color='green', xunits=\"hour\")\n    ax.set_xlabel(\"x-label 005\")\n    ax.autoscale_view()\n\n\n@image_comparison(baseline_images=[\"formatter_large_small\"])\ndef test_formatter_large_small():\n    # github issue #617, pull #619\n    fig, ax = plt.subplots(1)\n    x = [0.500000001, 0.500000002]\n    y = [1e64, 1.1e64]\n    ax.plot(x, y)\n\n\n@image_comparison(baseline_images=[\"twin_axis_locaters_formatters\"])\ndef test_twin_axis_locaters_formatters():\n    vals = np.linspace(0, 1, num=5, endpoint=True)\n    locs = np.sin(np.pi * vals / 2.0)\n\n    majl = plt.FixedLocator(locs)\n    minl = plt.FixedLocator([0.1, 0.2, 0.3])\n\n    fig = plt.figure()\n    ax1 = fig.add_subplot(1, 1, 1)\n    ax1.plot([0.1, 100], [0, 1])\n    ax1.yaxis.set_major_locator(majl)\n    ax1.yaxis.set_minor_locator(minl)\n    ax1.yaxis.set_major_formatter(plt.FormatStrFormatter('%08.2lf'))\n    ax1.yaxis.set_minor_formatter(plt.FixedFormatter(['tricks', 'mind', 'jedi']))\n\n    ax1.xaxis.set_major_locator(plt.LinearLocator())\n    ax1.xaxis.set_minor_locator(plt.FixedLocator([15, 35, 55, 75]))\n    ax1.xaxis.set_major_formatter(plt.FormatStrFormatter('%05.2lf'))\n    ax1.xaxis.set_minor_formatter(plt.FixedFormatter(['c', '3', 'p', 'o']))\n    ax2 = ax1.twiny()\n    ax3 = ax1.twinx()\n\n\n@image_comparison(baseline_images=[\"autoscale_tiny_range\"], remove_text=True)\ndef test_autoscale_tiny_range():\n    # github pull #904\n    fig, ax = plt.subplots(2, 2)\n    ax = ax.flatten()\n    for i in xrange(4):\n        y1 = 10**(-11 - i)\n        ax[i].plot([0, 1], [1, 1 + y1])\n\n\n@image_comparison(baseline_images=['offset_points'],\n                  remove_text=True)\ndef test_basic_annotate():\n    # Setup some data\n    t = np.arange(0.0, 5.0, 0.01)\n    s = np.cos(2.0*np.pi * t)\n\n    # Offset Points\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111, autoscale_on=False, xlim=(-1, 5), ylim=(-3, 5))\n    line, = ax.plot(t, s, lw=3, color='purple')\n\n    ax.annotate('local max', xy=(3, 1), xycoords='data',\n                xytext=(3, 3), textcoords='offset points')\n\n\n@image_comparison(baseline_images=['polar_axes'])\ndef test_polar_annotations():\n    # you can specify the xypoint and the xytext in different\n    # positions and coordinate systems, and optionally turn on a\n    # connecting line and mark the point with a marker.  Annotations\n    # work on polar axes too.  In the example below, the xy point is\n    # in native coordinates (xycoords defaults to 'data').  For a\n    # polar axes, this is in (theta, radius) space.  The text in this\n    # example is placed in the fractional figure coordinate system.\n    # Text keyword args like horizontal and vertical alignment are\n    # respected\n\n    # Setup some data\n    r = np.arange(0.0, 1.0, 0.001)\n    theta = 2.0 * 2.0 * np.pi * r\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111, polar=True)\n    line, = ax.plot(theta, r, color='#ee8d18', lw=3)\n    line, = ax.plot((0, 0), (0, 1), color=\"#0000ff\", lw=1)\n\n    ind = 800\n    thisr, thistheta = r[ind], theta[ind]\n    ax.plot([thistheta], [thisr], 'o')\n    ax.annotate('a polar annotation',\n                xy=(thistheta, thisr),  # theta, radius\n                xytext=(0.05, 0.05),    # fraction, fraction\n                textcoords='figure fraction',\n                arrowprops=dict(facecolor='black', shrink=0.05),\n                horizontalalignment='left',\n                verticalalignment='baseline',\n                )\n\n\n@image_comparison(baseline_images=['polar_coords'],\n                  remove_text=True)\ndef test_polar_coord_annotations():\n    # You can also use polar notation on a catesian axes.  Here the\n    # native coordinate system ('data') is cartesian, so you need to\n    # specify the xycoords and textcoords as 'polar' if you want to\n    # use (theta, radius)\n    from matplotlib.patches import Ellipse\n    el = Ellipse((0, 0), 10, 20, facecolor='r', alpha=0.5)\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111, aspect='equal')\n\n    ax.add_artist(el)\n    el.set_clip_box(ax.bbox)\n\n    ax.annotate('the top',\n                xy=(np.pi/2., 10.),      # theta, radius\n                xytext=(np.pi/3, 20.),   # theta, radius\n                xycoords='polar',\n                textcoords='polar',\n                arrowprops=dict(facecolor='black', shrink=0.05),\n                horizontalalignment='left',\n                verticalalignment='baseline',\n                clip_on=True,  # clip to the axes bounding box\n                )\n\n    ax.set_xlim(-20, 20)\n    ax.set_ylim(-20, 20)\n\n\n@image_comparison(baseline_images=['fill_units'], tol=18, extensions=['png'],\n                  savefig_kwarg={'dpi': 60})\ndef test_fill_units():\n    from datetime import datetime\n    import matplotlib.testing.jpl_units as units\n    units.register()\n\n    # generate some data\n    t = units.Epoch(\"ET\", dt=datetime(2009, 4, 27))\n    value = 10.0 * units.deg\n    day = units.Duration(\"ET\", 24.0 * 60.0 * 60.0)\n\n    fig = plt.figure()\n\n    # Top-Left\n    ax1 = fig.add_subplot(221)\n    ax1.plot([t], [value], yunits='deg', color='red')\n    ax1.fill([733525.0, 733525.0, 733526.0, 733526.0],\n             [0.0, 0.0, 90.0, 0.0], 'b')\n\n    # Top-Right\n    ax2 = fig.add_subplot(222)\n    ax2.plot([t], [value], yunits='deg', color='red')\n    ax2.fill([t,      t,      t+day,     t+day],\n             [0.0,  0.0,  90.0,    0.0], 'b')\n\n    # Bottom-Left\n    ax3 = fig.add_subplot(223)\n    ax3.plot([t], [value], yunits='deg', color='red')\n    ax3.fill([733525.0, 733525.0, 733526.0, 733526.0],\n             [0*units.deg,  0*units.deg,  90*units.deg,    0*units.deg], 'b')\n\n    # Bottom-Right\n    ax4 = fig.add_subplot(224)\n    ax4.plot([t], [value], yunits='deg', color='red')\n    ax4.fill([t,      t,      t+day,     t+day],\n             [0*units.deg,  0*units.deg,  90*units.deg,    0*units.deg],\n             facecolor=\"blue\")\n\n    fig.autofmt_xdate()\n\n\n@image_comparison(baseline_images=['single_point'])\ndef test_single_point():\n    # Issue #1796: don't let lines.marker affect the grid\n    matplotlib.rcParams['lines.marker'] = 'o'\n    matplotlib.rcParams['axes.grid'] = True\n\n    fig = plt.figure()\n    plt.subplot(211)\n    plt.plot([0], [0], 'o')\n\n    plt.subplot(212)\n    plt.plot([1], [1], 'o')\n\n\n@image_comparison(baseline_images=['single_date'])\ndef test_single_date():\n    time1 = [721964.0]\n    data1 = [-65.54]\n\n    fig = plt.figure()\n    plt.subplot(211)\n    plt.plot_date(time1, data1, 'o', color='r')\n\n    plt.subplot(212)\n    plt.plot(time1, data1, 'o', color='r')\n\n\n@image_comparison(baseline_images=['shaped_data'])\ndef test_shaped_data():\n    xdata = np.array([[0.53295185,  0.23052951,  0.19057629,  0.66724975,  0.96577916,\n                       0.73136095,  0.60823287,  0.01792100,  0.29744742,  0.27164665],\n                      [0.27980120,  0.25814229,  0.02818193,  0.12966456,  0.57446277,\n                       0.58167607,  0.71028245,  0.69112737,  0.89923072,  0.99072476],\n                      [0.81218578,  0.80464528,  0.76071809,  0.85616314,  0.12757994,\n                       0.94324936,  0.73078663,  0.09658102,  0.60703967,  0.77664978],\n                      [0.28332265,  0.81479711,  0.86985333,  0.43797066,  0.32540082,\n                       0.43819229,  0.92230363,  0.49414252,  0.68168256,  0.05922372],\n                      [0.10721335,  0.93904142,  0.79163075,  0.73232848,  0.90283839,\n                       0.68408046,  0.25502302,  0.95976614,  0.59214115,  0.13663711],\n                      [0.28087456,  0.33127607,  0.15530412,  0.76558121,  0.83389773,\n                       0.03735974,  0.98717738,  0.71432229,  0.54881366,  0.86893953],\n                      [0.77995937,  0.99555600,  0.29688434,  0.15646162,  0.05184800,\n                       0.37161935,  0.12998491,  0.09377296,  0.36882507,  0.36583435],\n                      [0.37851836,  0.05315792,  0.63144617,  0.25003433,  0.69586032,\n                       0.11393988,  0.92362096,  0.88045438,  0.93530252,  0.68275072],\n                      [0.86486596,  0.83236675,  0.82960664,  0.57796630,  0.25724233,\n                       0.84841095,  0.90862812,  0.64414887,  0.35652720,  0.71026066],\n                      [0.01383268,  0.34060930,  0.76084285,  0.70800694,  0.87634056,\n                       0.08213693,  0.54655021,  0.98123181,  0.44080053,  0.86815815]])\n\n    y1 = np.arange(10)\n    y1.shape = 1, 10\n\n    y2 = np.arange(10)\n    y2.shape = 10, 1\n\n    fig = plt.figure()\n    plt.subplot(411)\n    plt.plot(y1)\n    plt.subplot(412)\n    plt.plot(y2)\n\n    plt.subplot(413)\n    assert_raises(ValueError, plt.plot, (y1, y2))\n\n    plt.subplot(414)\n    plt.plot(xdata[:, 1], xdata[1, :], 'o')\n\n\n@image_comparison(baseline_images=['const_xy'])\ndef test_const_xy():\n    fig = plt.figure()\n\n    plt.subplot(311)\n    plt.plot(np.arange(10), np.ones((10,)))\n\n    plt.subplot(312)\n    plt.plot(np.ones((10,)), np.arange(10))\n\n    plt.subplot(313)\n    plt.plot(np.ones((10,)), np.ones((10,)), 'o')\n\n\n@image_comparison(baseline_images=['polar_wrap_180',\n                                   'polar_wrap_360',\n                                   ])\ndef test_polar_wrap():\n    D2R = np.pi / 180.0\n\n    fig = plt.figure()\n\n    plt.subplot(111, polar=True)\n\n    plt.polar([179*D2R, -179*D2R], [0.2, 0.1], \"b.-\")\n    plt.polar([179*D2R,  181*D2R], [0.2, 0.1], \"g.-\")\n    plt.rgrids([0.05, 0.1, 0.15, 0.2, 0.25, 0.3])\n    assert len(fig.axes) == 1, 'More than one polar axes created.'\n    fig = plt.figure()\n\n    plt.subplot(111, polar=True)\n    plt.polar([2*D2R, -2*D2R], [0.2, 0.1], \"b.-\")\n    plt.polar([2*D2R,  358*D2R], [0.2, 0.1], \"g.-\")\n    plt.polar([358*D2R,  2*D2R], [0.2, 0.1], \"r.-\")\n    plt.rgrids([0.05, 0.1, 0.15, 0.2, 0.25, 0.3])\n\n\n@image_comparison(baseline_images=['polar_units', 'polar_units_2'])\ndef test_polar_units():\n    import matplotlib.testing.jpl_units as units\n    from nose.tools import assert_true\n    units.register()\n\n    pi = np.pi\n    deg = units.UnitDbl(1.0, \"deg\")\n    km = units.UnitDbl(1.0, \"km\")\n\n    x1 = [pi/6.0, pi/4.0, pi/3.0, pi/2.0]\n    x2 = [30.0*deg, 45.0*deg, 60.0*deg, 90.0*deg]\n\n    y1 = [1.0, 2.0, 3.0, 4.0]\n    y2 = [4.0, 3.0, 2.0, 1.0]\n\n    fig = plt.figure()\n\n    plt.polar(x2, y1, color=\"blue\")\n\n    # polar(x2, y1, color = \"red\", xunits=\"rad\")\n    # polar(x2, y2, color = \"green\")\n\n    fig = plt.figure()\n\n    # make sure runits and theta units work\n    y1 = [y*km for y in y1]\n    plt.polar(x2, y1, color=\"blue\", thetaunits=\"rad\", runits=\"km\")\n    assert_true(isinstance(plt.gca().get_xaxis().get_major_formatter(), units.UnitDblFormatter))\n\n\n@image_comparison(baseline_images=['polar_rmin'])\ndef test_polar_rmin():\n    r = np.arange(0, 3.0, 0.01)\n    theta = 2*np.pi*r\n\n    fig = plt.figure()\n    ax = fig.add_axes([0.1, 0.1, 0.8, 0.8], polar=True)\n    ax.plot(theta, r)\n    ax.set_rmax(2.0)\n    ax.set_rmin(0.5)\n\n\n@image_comparison(baseline_images=['polar_theta_position'])\ndef test_polar_theta_position():\n    r = np.arange(0, 3.0, 0.01)\n    theta = 2*np.pi*r\n\n    fig = plt.figure()\n    ax = fig.add_axes([0.1, 0.1, 0.8, 0.8], polar=True)\n    ax.plot(theta, r)\n    ax.set_theta_zero_location(\"NW\")\n    ax.set_theta_direction('clockwise')\n\n\n@image_comparison(baseline_images=['polar_rlabel_position'])\ndef test_polar_rlabel_position():\n    fig = plt.figure()\n    ax = fig.add_subplot(111, projection='polar')\n    ax.set_rlabel_position(315)\n\n\n@image_comparison(baseline_images=['axvspan_epoch'])\ndef test_axvspan_epoch():\n    from datetime import datetime\n    import matplotlib.testing.jpl_units as units\n    units.register()\n\n    # generate some data\n    t0 = units.Epoch(\"ET\", dt=datetime(2009, 1, 20))\n    tf = units.Epoch(\"ET\", dt=datetime(2009, 1, 21))\n\n    dt = units.Duration(\"ET\", units.day.convert(\"sec\"))\n\n    fig = plt.figure()\n\n    plt.axvspan(t0, tf, facecolor=\"blue\", alpha=0.25)\n\n    ax = plt.gca()\n    ax.set_xlim(t0 - 5.0*dt, tf + 5.0*dt)\n\n\n@image_comparison(baseline_images=['axhspan_epoch'])\ndef test_axhspan_epoch():\n    from datetime import datetime\n    import matplotlib.testing.jpl_units as units\n    units.register()\n\n    # generate some data\n    t0 = units.Epoch(\"ET\", dt=datetime(2009, 1, 20))\n    tf = units.Epoch(\"ET\", dt=datetime(2009, 1, 21))\n\n    dt = units.Duration(\"ET\", units.day.convert(\"sec\"))\n\n    fig = plt.figure()\n\n    plt.axhspan(t0, tf, facecolor=\"blue\", alpha=0.25)\n\n    ax = plt.gca()\n    ax.set_ylim(t0 - 5.0*dt, tf + 5.0*dt)\n\n\n@image_comparison(baseline_images=['hexbin_extent'],\n                  remove_text=True, extensions=['png'])\ndef test_hexbin_extent():\n    # this test exposes sf bug 2856228\n    fig = plt.figure()\n\n    ax = fig.add_subplot(111)\n    data = np.arange(2000.)/2000.\n    data.shape = 2, 1000\n    x, y = data\n\n    ax.hexbin(x, y, extent=[.1, .3, .6, .7])\n\n\n@cleanup\ndef test_hexbin_pickable():\n    # From #1973: Test that picking a hexbin collection works\n    class FauxMouseEvent:\n        def __init__(self, x, y):\n            self.x = x\n            self.y = y\n\n    fig = plt.figure()\n\n    ax = fig.add_subplot(111)\n    data = np.arange(200.)/200.\n    data.shape = 2, 100\n    x, y = data\n    hb = ax.hexbin(x, y, extent=[.1, .3, .6, .7], picker=1)\n\n    assert hb.contains(FauxMouseEvent(400, 300))[0]\n\n\n@image_comparison(baseline_images=['hexbin_log'],\n                  remove_text=True,\n                  extensions=['png'])\ndef test_hexbin_log():\n    # Issue #1636\n    fig = plt.figure()\n\n    np.random.seed(0)\n    n = 100000\n    x = np.random.standard_normal(n)\n    y = 2.0 + 3.0 * x + 4.0 * np.random.standard_normal(n)\n    y = np.power(2, y * 0.5)\n    ax = fig.add_subplot(111)\n    ax.hexbin(x, y, yscale='log')\n\n\n@cleanup\ndef test_inverted_limits():\n    # Test gh:1553\n    # Calling invert_xaxis prior to plotting should not disable autoscaling\n    # while still maintaining the inverted direction\n    fig = plt.figure()\n    ax = fig.gca()\n    ax.invert_xaxis()\n    ax.plot([-5, -3, 2, 4], [1, 2, -3, 5])\n\n    assert ax.get_xlim() == (4, -5)\n    assert ax.get_ylim() == (-3, 5)\n    plt.close()\n\n    fig = plt.figure()\n    ax = fig.gca()\n    ax.invert_yaxis()\n    ax.plot([-5, -3, 2, 4], [1, 2, -3, 5])\n\n    assert ax.get_xlim() == (-5, 4)\n    assert ax.get_ylim() == (5, -3)\n    plt.close()\n\n\n@image_comparison(baseline_images=['nonfinite_limits'])\ndef test_nonfinite_limits():\n    x = np.arange(0., np.e, 0.01)\n    olderr = np.seterr(divide='ignore')  # silence divide by zero warning from log(0)\n    try:\n        y = np.log(x)\n    finally:\n        np.seterr(**olderr)\n    x[len(x)//2] = np.nan\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.plot(x, y)\n\n\n@image_comparison(baseline_images=['imshow'],\n                  remove_text=True)\ndef test_imshow():\n    # Create a NxN image\n    N = 100\n    (x, y) = np.indices((N, N))\n    x -= N//2\n    y -= N//2\n    r = np.sqrt(x**2+y**2-x*y)\n\n    # Create a contour plot at N/4 and extract both the clip path and transform\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n\n    ax.imshow(r)\n\n\n@image_comparison(baseline_images=['imshow_clip'])\ndef test_imshow_clip():\n    # As originally reported by Gellule Xg <gellule.xg@free.fr>\n\n    # Create a NxN image\n    N = 100\n    (x, y) = np.indices((N, N))\n    x -= N//2\n    y -= N//2\n    r = np.sqrt(x**2+y**2-x*y)\n\n    # Create a contour plot at N/4 and extract both the clip path and transform\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n\n    c = ax.contour(r, [N/4])\n    x = c.collections[0]\n    clipPath = x.get_paths()[0]\n    clipTransform = x.get_transform()\n\n    from matplotlib.transforms import TransformedPath\n    clip_path = TransformedPath(clipPath, clipTransform)\n\n    # Plot the image clipped by the contour\n    ax.imshow(r, clip_path=clip_path)\n\n\n@image_comparison(baseline_images=['polycollection_joinstyle'],\n                  remove_text=True)\ndef test_polycollection_joinstyle():\n    # Bug #2890979 reported by Matthew West\n\n    from matplotlib import collections as mcoll\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    verts = np.array([[1, 1], [1, 2], [2, 2], [2, 1]])\n    c = mcoll.PolyCollection([verts], linewidths=40)\n    ax.add_collection(c)\n    ax.set_xbound(0, 3)\n    ax.set_ybound(0, 3)\n\n\n@image_comparison(baseline_images=['fill_between_interpolate'],\n                  remove_text=True)\ndef test_fill_between_interpolate():\n    x = np.arange(0.0, 2, 0.02)\n    y1 = np.sin(2*np.pi*x)\n    y2 = 1.2*np.sin(4*np.pi*x)\n\n    fig = plt.figure()\n    ax = fig.add_subplot(211)\n    ax.plot(x, y1, x, y2, color='black')\n    ax.fill_between(x, y1, y2, where=y2 >= y1, facecolor='white', hatch='/', interpolate=True)\n    ax.fill_between(x, y1, y2, where=y2 <= y1, facecolor='red', interpolate=True)\n\n    # Test support for masked arrays.\n    y2 = np.ma.masked_greater(y2, 1.0)\n    # Test that plotting works for masked arrays with the first element masked\n    y2[0] = np.ma.masked\n    ax1 = fig.add_subplot(212, sharex=ax)\n    ax1.plot(x, y1, x, y2, color='black')\n    ax1.fill_between(x, y1, y2, where=y2 >= y1, facecolor='green', interpolate=True)\n    ax1.fill_between(x, y1, y2, where=y2 <= y1, facecolor='red', interpolate=True)\n\n\n@image_comparison(baseline_images=['symlog'])\ndef test_symlog():\n    x = np.array([0, 1, 2, 4, 6, 9, 12, 24])\n    y = np.array([1000000, 500000, 100000, 100, 5, 0, 0, 0])\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.plot(x, y)\n    ax.set_yscale('symlog')\n    ax.set_xscale = ('linear')\n    ax.set_ylim(-1, 10000000)\n\n\n@image_comparison(baseline_images=['symlog2'],\n                  remove_text=True)\ndef test_symlog2():\n    # Numbers from -50 to 50, with 0.1 as step\n    x = np.arange(-50, 50, 0.001)\n\n    fig = plt.figure()\n    ax = fig.add_subplot(511)\n    # Plots a simple linear function 'f(x) = x'\n    ax.plot(x, x)\n    ax.set_xscale('symlog', linthreshx=20.0)\n    ax.grid(True)\n\n    ax = fig.add_subplot(512)\n    # Plots a simple linear function 'f(x) = x'\n    ax.plot(x, x)\n    ax.set_xscale('symlog', linthreshx=2.0)\n    ax.grid(True)\n\n    ax = fig.add_subplot(513)\n    # Plots a simple linear function 'f(x) = x'\n    ax.plot(x, x)\n    ax.set_xscale('symlog', linthreshx=1.0)\n    ax.grid(True)\n\n    ax = fig.add_subplot(514)\n    # Plots a simple linear function 'f(x) = x'\n    ax.plot(x, x)\n    ax.set_xscale('symlog', linthreshx=0.1)\n    ax.grid(True)\n\n    ax = fig.add_subplot(515)\n    # Plots a simple linear function 'f(x) = x'\n    ax.plot(x, x)\n    ax.set_xscale('symlog', linthreshx=0.01)\n    ax.grid(True)\n    ax.set_ylim(-0.1, 0.1)\n\n\n@image_comparison(baseline_images=['pcolormesh'], remove_text=True)\ndef test_pcolormesh():\n    n = 12\n    x = np.linspace(-1.5, 1.5, n)\n    y = np.linspace(-1.5, 1.5, n*2)\n    X, Y = np.meshgrid(x, y)\n    Qx = np.cos(Y) - np.cos(X)\n    Qz = np.sin(Y) + np.sin(X)\n    Qx = (Qx + 1.1)\n    Z = np.sqrt(X**2 + Y**2)/5\n    Z = (Z - Z.min()) / (Z.max() - Z.min())\n\n    # The color array can include masked values:\n    Zm = ma.masked_where(np.fabs(Qz) < 0.5*np.amax(Qz), Z)\n\n    fig = plt.figure()\n    ax = fig.add_subplot(131)\n    ax.pcolormesh(Qx, Qz, Z, lw=0.5, edgecolors='k')\n\n    ax = fig.add_subplot(132)\n    ax.pcolormesh(Qx, Qz, Z, lw=2, edgecolors=['b', 'w'])\n\n    ax = fig.add_subplot(133)\n    ax.pcolormesh(Qx, Qz, Z, shading=\"gouraud\")\n\n\n@image_comparison(baseline_images=['pcolormesh_datetime_axis'],\n                  extensions=['png'], remove_text=False)\ndef test_pcolormesh_datetime_axis():\n    fig = plt.figure()\n    fig.subplots_adjust(hspace=0.4, top=0.98, bottom=.15)\n    base = datetime.datetime(2013, 1, 1)\n    x = np.array([base + datetime.timedelta(days=d) for d in range(21)])\n    y = np.arange(21)\n    z1, z2 = np.meshgrid(np.arange(20), np.arange(20))\n    z = z1 * z2\n    plt.subplot(221)\n    plt.pcolormesh(x[:-1], y[:-1], z)\n    plt.subplot(222)\n    plt.pcolormesh(x, y, z)\n    x = np.repeat(x[np.newaxis], 21, axis=0)\n    y = np.repeat(y[:, np.newaxis], 21, axis=1)\n    plt.subplot(223)\n    plt.pcolormesh(x[:-1, :-1], y[:-1, :-1], z)\n    plt.subplot(224)\n    plt.pcolormesh(x, y, z)\n    for ax in fig.get_axes():\n        for label in ax.get_xticklabels():\n            label.set_ha('right')\n            label.set_rotation(30)\n\n\n@image_comparison(baseline_images=['pcolor_datetime_axis'],\n                  extensions=['png'], remove_text=False)\ndef test_pcolor_datetime_axis():\n    fig = plt.figure()\n    fig.subplots_adjust(hspace=0.4, top=0.98, bottom=.15)\n    base = datetime.datetime(2013, 1, 1)\n    x = np.array([base + datetime.timedelta(days=d) for d in range(21)])\n    y = np.arange(21)\n    z1, z2 = np.meshgrid(np.arange(20), np.arange(20))\n    z = z1 * z2\n    plt.subplot(221)\n    plt.pcolor(x[:-1], y[:-1], z)\n    plt.subplot(222)\n    plt.pcolor(x, y, z)\n    x = np.repeat(x[np.newaxis], 21, axis=0)\n    y = np.repeat(y[:, np.newaxis], 21, axis=1)\n    plt.subplot(223)\n    plt.pcolor(x[:-1, :-1], y[:-1, :-1], z)\n    plt.subplot(224)\n    plt.pcolor(x, y, z)\n    for ax in fig.get_axes():\n        for label in ax.get_xticklabels():\n            label.set_ha('right')\n            label.set_rotation(30)\n\n\n@cleanup\ndef test_pcolorargs():\n    n = 12\n    x = np.linspace(-1.5, 1.5, n)\n    y = np.linspace(-1.5, 1.5, n*2)\n    X, Y = np.meshgrid(x, y)\n    Z = np.sqrt(X**2 + Y**2)/5\n\n    _, ax = plt.subplots()\n    assert_raises(TypeError, ax.pcolormesh, y, x, Z)\n    assert_raises(TypeError, ax.pcolormesh, X, Y, Z.T)\n    assert_raises(TypeError, ax.pcolormesh, x, y, Z[:-1, :-1],\n                  shading=\"gouraud\")\n    assert_raises(TypeError, ax.pcolormesh, X, Y, Z[:-1, :-1],\n                  shading=\"gouraud\")\n\n\n@image_comparison(baseline_images=['canonical'])\ndef test_canonical():\n    fig, ax = plt.subplots()\n    ax.plot([1, 2, 3])\n\n\n@image_comparison(baseline_images=['arc_ellipse'],\n                  remove_text=True)\ndef test_arc_ellipse():\n    from matplotlib import patches\n    xcenter, ycenter = 0.38, 0.52\n    width, height = 1e-1, 3e-1\n    angle = -30\n\n    theta = np.arange(0.0, 360.0, 1.0)*np.pi/180.0\n    x = width/2. * np.cos(theta)\n    y = height/2. * np.sin(theta)\n\n    rtheta = angle*np.pi/180.\n    R = np.array([\n        [np.cos(rtheta),  -np.sin(rtheta)],\n        [np.sin(rtheta), np.cos(rtheta)],\n        ])\n\n    x, y = np.dot(R, np.array([x, y]))\n    x += xcenter\n    y += ycenter\n\n    fig = plt.figure()\n    ax = fig.add_subplot(211, aspect='auto')\n    ax.fill(x, y, alpha=0.2, facecolor='yellow', edgecolor='yellow', linewidth=1, zorder=1)\n\n    e1 = patches.Arc((xcenter, ycenter), width, height,\n                     angle=angle, linewidth=2, fill=False, zorder=2)\n\n    ax.add_patch(e1)\n\n    ax = fig.add_subplot(212, aspect='equal')\n    ax.fill(x, y, alpha=0.2, facecolor='green', edgecolor='green', zorder=1)\n    e2 = patches.Arc((xcenter, ycenter), width, height,\n                     angle=angle, linewidth=2, fill=False, zorder=2)\n\n    ax.add_patch(e2)\n\n\n@image_comparison(baseline_images=['units_strings'])\ndef test_units_strings():\n    # Make sure passing in sequences of strings doesn't cause the unit\n    # conversion registry to recurse infinitely\n    Id = ['50', '100', '150', '200', '250']\n    pout = ['0', '7.4', '11.4', '14.2', '16.3']\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.plot(Id, pout)\n\n\n@image_comparison(baseline_images=['markevery'],\n                  remove_text=True)\ndef test_markevery():\n    x = np.linspace(0, 10, 100)\n    y = np.sin(x) * np.sqrt(x/10 + 0.5)\n\n    # check marker only plot\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.plot(x, y, 'o', label='default')\n    ax.plot(x, y, 'd', markevery=None, label='mark all')\n    ax.plot(x, y, 's', markevery=10, label='mark every 10')\n    ax.plot(x, y, '+', markevery=(5, 20), label='mark every 5 starting at 10')\n    ax.legend()\n\n\n@image_comparison(baseline_images=['markevery_line'],\n                  remove_text=True)\ndef test_markevery_line():\n    x = np.linspace(0, 10, 100)\n    y = np.sin(x) * np.sqrt(x/10 + 0.5)\n\n    # check line/marker combos\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.plot(x, y, '-o', label='default')\n    ax.plot(x, y, '-d', markevery=None, label='mark all')\n    ax.plot(x, y, '-s', markevery=10, label='mark every 10')\n    ax.plot(x, y, '-+', markevery=(5, 20), label='mark every 5 starting at 10')\n    ax.legend()\n\n\n@image_comparison(baseline_images=['markevery_linear_scales'],\n                  remove_text=True)\ndef test_markevery_linear_scales():\n    cases = [None,\n             8,\n             (30, 8),\n             [16, 24, 30], [0, -1],\n             slice(100, 200, 3),\n             0.1, 0.3, 1.5,\n             (0.0, 0.1), (0.45, 0.1)]\n\n    cols = 3\n    gs = matplotlib.gridspec.GridSpec(len(cases) // cols + 1, cols)\n\n    delta = 0.11\n    x = np.linspace(0, 10 - 2 * delta, 200) + delta\n    y = np.sin(x) + 1.0 + delta\n\n    for i, case in enumerate(cases):\n        row = (i // cols)\n        col = i % cols\n        plt.subplot(gs[row, col])\n        plt.title('markevery=%s' % str(case))\n        plt.plot(x, y, 'o', ls='-', ms=4,  markevery=case)\n\n\n@image_comparison(baseline_images=['markevery_linear_scales_zoomed'],\n                  remove_text=True)\ndef test_markevery_linear_scales_zoomed():\n    cases = [None,\n             8,\n             (30, 8),\n             [16, 24, 30], [0, -1],\n             slice(100, 200, 3),\n             0.1, 0.3, 1.5,\n             (0.0, 0.1), (0.45, 0.1)]\n\n    cols = 3\n    gs = matplotlib.gridspec.GridSpec(len(cases) // cols + 1, cols)\n\n    delta = 0.11\n    x = np.linspace(0, 10 - 2 * delta, 200) + delta\n    y = np.sin(x) + 1.0 + delta\n\n    for i, case in enumerate(cases):\n        row = (i // cols)\n        col = i % cols\n        plt.subplot(gs[row, col])\n        plt.title('markevery=%s' % str(case))\n        plt.plot(x, y, 'o', ls='-', ms=4,  markevery=case)\n        plt.xlim((6, 6.7))\n        plt.ylim((1.1, 1.7))\n\n\n@image_comparison(baseline_images=['markevery_log_scales'],\n                  remove_text=True)\ndef test_markevery_log_scales():\n    cases = [None,\n             8,\n             (30, 8),\n             [16, 24, 30], [0, -1],\n             slice(100, 200, 3),\n             0.1, 0.3, 1.5,\n             (0.0, 0.1), (0.45, 0.1)]\n\n    cols = 3\n    gs = matplotlib.gridspec.GridSpec(len(cases) // cols + 1, cols)\n\n    delta = 0.11\n    x = np.linspace(0, 10 - 2 * delta, 200) + delta\n    y = np.sin(x) + 1.0 + delta\n\n    for i, case in enumerate(cases):\n        row = (i // cols)\n        col = i % cols\n        plt.subplot(gs[row, col])\n        plt.title('markevery=%s' % str(case))\n        plt.xscale('log')\n        plt.yscale('log')\n        plt.plot(x, y, 'o', ls='-', ms=4,  markevery=case)\n\n\n@image_comparison(baseline_images=['markevery_polar'],\n                  remove_text=True)\ndef test_markevery_polar():\n    cases = [None,\n             8,\n             (30, 8),\n             [16, 24, 30], [0, -1],\n             slice(100, 200, 3),\n             0.1, 0.3, 1.5,\n             (0.0, 0.1), (0.45, 0.1)]\n\n    cols = 3\n    gs = matplotlib.gridspec.GridSpec(len(cases) // cols + 1, cols)\n\n    r = np.linspace(0, 3.0, 200)\n    theta = 2 * np.pi * r\n\n    for i, case in enumerate(cases):\n        row = (i // cols)\n        col = i % cols\n        plt.subplot(gs[row, col], polar=True)\n        plt.title('markevery=%s' % str(case))\n        plt.plot(theta, r, 'o', ls='-', ms=4,  markevery=case)\n\n\n@image_comparison(baseline_images=['marker_edges'],\n                  remove_text=True)\ndef test_marker_edges():\n    x = np.linspace(0, 1, 10)\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.plot(x, np.sin(x), 'y.', ms=30.0, mew=0, mec='r')\n    ax.plot(x+0.1, np.sin(x), 'y.', ms=30.0, mew=1, mec='r')\n    ax.plot(x+0.2, np.sin(x), 'y.', ms=30.0, mew=2, mec='b')\n\n\n@image_comparison(baseline_images=['hist_log'],\n                  remove_text=True)\ndef test_hist_log():\n    data0 = np.linspace(0, 1, 200)**3\n    data = np.r_[1-data0, 1+data0]\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist(data, fill=False, log=True)\n\n\n@image_comparison(baseline_images=['hist_steplog'], remove_text=True)\ndef test_hist_steplog():\n    np.random.seed(0)\n    data = np.random.standard_normal(2000)\n    data += -2.0 - np.min(data)\n    data_pos = data + 2.1\n    data_big = data_pos + 30\n    weights = np.ones_like(data) * 1.e-5\n\n    ax = plt.subplot(4, 1, 1)\n    plt.hist(data, 100, histtype='stepfilled', log=True)\n\n    ax = plt.subplot(4, 1, 2)\n    plt.hist(data_pos, 100, histtype='stepfilled', log=True)\n\n    ax = plt.subplot(4, 1, 3)\n    plt.hist(data, 100, weights=weights, histtype='stepfilled', log=True)\n\n    ax = plt.subplot(4, 1, 4)\n    plt.hist(data_big, 100, histtype='stepfilled', log=True, orientation='horizontal')\n\n\ndef contour_dat():\n    x = np.linspace(-3, 5, 150)\n    y = np.linspace(-3, 5, 120)\n    z = np.cos(x) + np.sin(y[:, np.newaxis])\n    return x, y, z\n\n\n@image_comparison(baseline_images=['contour_hatching'])\ndef test_contour_hatching():\n    x, y, z = contour_dat()\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    cs = ax.contourf(x, y, z, hatches=['-', '/', '\\\\', '//'],\n                     cmap=plt.get_cmap('gray'),\n                     extend='both', alpha=0.5)\n\n\n@image_comparison(baseline_images=['contour_colorbar'])\ndef test_contour_colorbar():\n    x, y, z = contour_dat()\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    cs = ax.contourf(x, y, z, levels=np.arange(-1.8, 1.801, 0.2),\n                     cmap=plt.get_cmap('RdBu'),\n                     vmin=-0.6,\n                     vmax=0.6,\n                     extend='both')\n    cs1 = ax.contour(x, y, z, levels=np.arange(-2.2, -0.599, 0.2),\n                     colors=['y'],\n                     linestyles='solid',\n                     linewidths=2)\n    cs2 = ax.contour(x, y, z, levels=np.arange(0.6, 2.2, 0.2),\n                     colors=['c'],\n                     linewidths=2)\n    cbar = fig.colorbar(cs, ax=ax)\n    cbar.add_lines(cs1)\n    cbar.add_lines(cs2, erase=False)\n\n\n@image_comparison(baseline_images=['hist2d'])\ndef test_hist2d():\n    np.random.seed(0)\n    # make it not symetric in case we switch x and y axis\n    x = np.random.randn(100)*2+5\n    y = np.random.randn(100)-2\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist2d(x, y, bins=10)\n\n\n@image_comparison(baseline_images=['hist2d_transpose'])\ndef test_hist2d_transpose():\n    np.random.seed(0)\n    # make sure the the output from np.histogram is transposed before\n    # passing to pcolorfast\n    x = np.array([5]*100)\n    y = np.random.randn(100)-2\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist2d(x, y, bins=10)\n\n\n@image_comparison(baseline_images=['scatter'])\ndef test_scatter_plot():\n    ax = plt.axes()\n    ax.scatter([3, 4, 2, 6], [2, 5, 2, 3], c=['r', 'y', 'b', 'lime'], s=[24, 15, 19, 29])\n\n\n@cleanup\ndef test_as_mpl_axes_api():\n    # tests the _as_mpl_axes api\n    from matplotlib.projections.polar import PolarAxes\n    import matplotlib.axes as maxes\n\n    class Polar(object):\n        def __init__(self):\n            self.theta_offset = 0\n\n        def _as_mpl_axes(self):\n            # implement the matplotlib axes interface\n            return PolarAxes, {'theta_offset': self.theta_offset}\n    prj = Polar()\n    prj2 = Polar()\n    prj2.theta_offset = np.pi\n    prj3 = Polar()\n\n    # testing axes creation with plt.axes\n    ax = plt.axes([0, 0, 1, 1], projection=prj)\n    assert type(ax) == PolarAxes, \\\n        'Expected a PolarAxes, got %s' % type(ax)\n    ax_via_gca = plt.gca(projection=prj)\n    assert ax_via_gca is ax\n    plt.close()\n\n    # testing axes creation with gca\n    ax = plt.gca(projection=prj)\n    assert type(ax) == maxes._subplots._subplot_classes[PolarAxes], \\\n        'Expected a PolarAxesSubplot, got %s' % type(ax)\n    ax_via_gca = plt.gca(projection=prj)\n    assert ax_via_gca is ax\n    # try getting the axes given a different polar projection\n    ax_via_gca = plt.gca(projection=prj2)\n    assert ax_via_gca is not ax\n    assert ax.get_theta_offset() == 0, ax.get_theta_offset()\n    assert ax_via_gca.get_theta_offset() == np.pi, ax_via_gca.get_theta_offset()\n    # try getting the axes given an == (not is) polar projection\n    ax_via_gca = plt.gca(projection=prj3)\n    assert ax_via_gca is ax\n    plt.close()\n\n    # testing axes creation with subplot\n    ax = plt.subplot(121, projection=prj)\n    assert type(ax) == maxes._subplots._subplot_classes[PolarAxes], \\\n        'Expected a PolarAxesSubplot, got %s' % type(ax)\n    plt.close()\n\n\n@image_comparison(baseline_images=['log_scales'])\ndef test_log_scales():\n    fig = plt.figure()\n    ax = plt.gca()\n    plt.plot(np.log(np.linspace(0.1, 100)))\n    ax.set_yscale('log', basey=5.5)\n    ax.invert_yaxis()\n    ax.set_xscale('log', basex=9.0)\n\n\n@image_comparison(baseline_images=['stackplot_test_image'])\ndef test_stackplot():\n    fig = plt.figure()\n    x = np.linspace(0, 10, 10)\n    y1 = 1.0 * x\n    y2 = 2.0 * x + 1\n    y3 = 3.0 * x + 2\n    ax = fig.add_subplot(1, 1, 1)\n    ax.stackplot(x, y1, y2, y3)\n    ax.set_xlim((0, 10))\n    ax.set_ylim((0, 70))\n\n\n@image_comparison(baseline_images=['stackplot_test_baseline'],\n                  remove_text=True)\ndef test_stackplot_baseline():\n    np.random.seed(0)\n\n    def layers(n, m):\n        def bump(a):\n            x = 1 / (.1 + np.random.random())\n            y = 2 * np.random.random() - .5\n            z = 10 / (.1 + np.random.random())\n            for i in range(m):\n                w = (i / float(m) - y) * z\n                a[i] += x * np.exp(-w * w)\n        a = np.zeros((m, n))\n        for i in range(n):\n            for j in range(5):\n                bump(a[:, i])\n        return a\n\n    d = layers(3, 100)\n\n    fig = plt.figure()\n\n    plt.subplot(2, 2, 1)\n    plt.stackplot(list(xrange(100)), d.T, baseline='zero')\n\n    plt.subplot(2, 2, 2)\n    plt.stackplot(list(xrange(100)), d.T, baseline='sym')\n\n    plt.subplot(2, 2, 3)\n    plt.stackplot(list(xrange(100)), d.T, baseline='wiggle')\n\n    plt.subplot(2, 2, 4)\n    plt.stackplot(list(xrange(100)), d.T, baseline='weighted_wiggle')\n\n\n@image_comparison(baseline_images=['bxp_baseline'],\n                  extensions=['png'],\n                  savefig_kwarg={'dpi': 40})\ndef test_bxp_baseline():\n    np.random.seed(937)\n    logstats = matplotlib.cbook.boxplot_stats(\n        np.random.lognormal(mean=1.25, sigma=1., size=(37, 4))\n    )\n\n    fig, ax = plt.subplots()\n    ax.set_yscale('log')\n    ax.bxp(logstats)\n\n\n@image_comparison(baseline_images=['bxp_rangewhis'],\n                  extensions=['png'],\n                  savefig_kwarg={'dpi': 40})\ndef test_bxp_rangewhis():\n    np.random.seed(937)\n    logstats = matplotlib.cbook.boxplot_stats(\n        np.random.lognormal(mean=1.25, sigma=1., size=(37, 4)),\n        whis='range'\n    )\n\n    fig, ax = plt.subplots()\n    ax.set_yscale('log')\n    ax.bxp(logstats)\n\n\n@image_comparison(baseline_images=['bxp_precentilewhis'],\n                  extensions=['png'],\n                  savefig_kwarg={'dpi': 40})\ndef test_bxp_precentilewhis():\n    np.random.seed(937)\n    logstats = matplotlib.cbook.boxplot_stats(\n        np.random.lognormal(mean=1.25, sigma=1., size=(37, 4)),\n        whis=[5, 95]\n    )\n\n    fig, ax = plt.subplots()\n    ax.set_yscale('log')\n    ax.bxp(logstats)\n\n\n@image_comparison(baseline_images=['bxp_with_xlabels'],\n                  extensions=['png'],\n                  savefig_kwarg={'dpi': 40})\ndef test_bxp_with_xlabels():\n    np.random.seed(937)\n    logstats = matplotlib.cbook.boxplot_stats(\n        np.random.lognormal(mean=1.25, sigma=1., size=(37, 4))\n    )\n    for stats, label in zip(logstats, list('ABCD')):\n        stats['label'] = label\n\n    fig, ax = plt.subplots()\n    ax.set_yscale('log')\n    ax.bxp(logstats)\n\n\n@image_comparison(baseline_images=['bxp_horizontal'],\n                  remove_text=True, extensions=['png'],\n                  savefig_kwarg={'dpi': 40})\ndef test_bxp_horizontal():\n    np.random.seed(937)\n    logstats = matplotlib.cbook.boxplot_stats(\n        np.random.lognormal(mean=1.25, sigma=1., size=(37, 4))\n    )\n\n    fig, ax = plt.subplots()\n    ax.set_xscale('log')\n    ax.bxp(logstats, vert=False)\n\n\n@image_comparison(baseline_images=['bxp_with_ylabels'],\n                  extensions=['png'],\n                  savefig_kwarg={'dpi': 40})\ndef test_bxp_with_ylabels():\n    np.random.seed(937)\n    logstats = matplotlib.cbook.boxplot_stats(\n        np.random.lognormal(mean=1.25, sigma=1., size=(37, 4))\n    )\n    for stats, label in zip(logstats, list('ABCD')):\n        stats['label'] = label\n\n    fig, ax = plt.subplots()\n    ax.set_xscale('log')\n    ax.bxp(logstats, vert=False)\n\n\n@image_comparison(baseline_images=['bxp_patchartist'],\n                  remove_text=True, extensions=['png'],\n                  savefig_kwarg={'dpi': 40})\ndef test_bxp_patchartist():\n    np.random.seed(937)\n    logstats = matplotlib.cbook.boxplot_stats(\n        np.random.lognormal(mean=1.25, sigma=1., size=(37, 4))\n    )\n\n    fig, ax = plt.subplots()\n    ax.set_yscale('log')\n    ax.bxp(logstats, patch_artist=True)\n\n\n@image_comparison(baseline_images=['bxp_custompatchartist'],\n                  remove_text=True, extensions=['png'],\n                  savefig_kwarg={'dpi': 40})\ndef test_bxp_custompatchartist():\n    np.random.seed(937)\n    logstats = matplotlib.cbook.boxplot_stats(\n        np.random.lognormal(mean=1.25, sigma=1., size=(37, 4))\n    )\n\n    fig, ax = plt.subplots()\n    ax.set_yscale('log')\n    boxprops = dict(facecolor='yellow', edgecolor='green', linestyle='dotted')\n    ax.bxp(logstats, patch_artist=True, boxprops=boxprops)\n\n\n@image_comparison(baseline_images=['bxp_customoutlier'],\n                  remove_text=True, extensions=['png'],\n                  savefig_kwarg={'dpi': 40})\ndef test_bxp_customoutlier():\n    np.random.seed(937)\n    logstats = matplotlib.cbook.boxplot_stats(\n        np.random.lognormal(mean=1.25, sigma=1., size=(37, 4))\n    )\n\n    fig, ax = plt.subplots()\n    ax.set_yscale('log')\n    flierprops = dict(linestyle='none', marker='d', markerfacecolor='g')\n    ax.bxp(logstats, flierprops=flierprops)\n\n\n@image_comparison(baseline_images=['bxp_withmean_custompoint'],\n                  remove_text=True, extensions=['png'],\n                  savefig_kwarg={'dpi': 40})\ndef test_bxp_showcustommean():\n    np.random.seed(937)\n    logstats = matplotlib.cbook.boxplot_stats(\n        np.random.lognormal(mean=1.25, sigma=1., size=(37, 4))\n    )\n\n    fig, ax = plt.subplots()\n    ax.set_yscale('log')\n    meanprops = dict(linestyle='none', marker='d', markerfacecolor='green')\n    ax.bxp(logstats, showmeans=True, meanprops=meanprops)\n\n\n@image_comparison(baseline_images=['bxp_custombox'],\n                  remove_text=True, extensions=['png'],\n                  savefig_kwarg={'dpi': 40})\ndef test_bxp_custombox():\n    np.random.seed(937)\n    logstats = matplotlib.cbook.boxplot_stats(\n        np.random.lognormal(mean=1.25, sigma=1., size=(37, 4))\n    )\n\n    fig, ax = plt.subplots()\n    ax.set_yscale('log')\n    boxprops = dict(linestyle='--', color='b', linewidth=3)\n    ax.bxp(logstats, boxprops=boxprops)\n\n\n@image_comparison(baseline_images=['bxp_custommedian'],\n                  remove_text=True, extensions=['png'],\n                  savefig_kwarg={'dpi': 40})\ndef test_bxp_custommedian():\n    np.random.seed(937)\n    logstats = matplotlib.cbook.boxplot_stats(\n        np.random.lognormal(mean=1.25, sigma=1., size=(37, 4))\n    )\n\n    fig, ax = plt.subplots()\n    ax.set_yscale('log')\n    medianprops = dict(linestyle='--', color='b', linewidth=3)\n    ax.bxp(logstats, medianprops=medianprops)\n\n\n@image_comparison(baseline_images=['bxp_customcap'],\n                  remove_text=True, extensions=['png'],\n                  savefig_kwarg={'dpi': 40})\ndef test_bxp_customcap():\n    np.random.seed(937)\n    logstats = matplotlib.cbook.boxplot_stats(\n        np.random.lognormal(mean=1.25, sigma=1., size=(37, 4))\n    )\n\n    fig, ax = plt.subplots()\n    ax.set_yscale('log')\n    capprops = dict(linestyle='--', color='g', linewidth=3)\n    ax.bxp(logstats, capprops=capprops)\n\n\n@image_comparison(baseline_images=['bxp_customwhisker'],\n                  remove_text=True, extensions=['png'],\n                  savefig_kwarg={'dpi': 40})\ndef test_bxp_customwhisker():\n    np.random.seed(937)\n    logstats = matplotlib.cbook.boxplot_stats(\n        np.random.lognormal(mean=1.25, sigma=1., size=(37, 4))\n    )\n\n    fig, ax = plt.subplots()\n    ax.set_yscale('log')\n    whiskerprops = dict(linestyle='-', color='m', linewidth=3)\n    ax.bxp(logstats, whiskerprops=whiskerprops)\n\n\n@image_comparison(baseline_images=['bxp_withnotch'],\n                  remove_text=True, extensions=['png'],\n                  savefig_kwarg={'dpi': 40})\ndef test_bxp_shownotches():\n    np.random.seed(937)\n    logstats = matplotlib.cbook.boxplot_stats(\n        np.random.lognormal(mean=1.25, sigma=1., size=(37, 4))\n    )\n\n    fig, ax = plt.subplots()\n    ax.set_yscale('log')\n    ax.bxp(logstats, shownotches=True)\n\n\n@image_comparison(baseline_images=['bxp_nocaps'],\n                  remove_text=True, extensions=['png'],\n                  savefig_kwarg={'dpi': 40})\ndef test_bxp_nocaps():\n    np.random.seed(937)\n    logstats = matplotlib.cbook.boxplot_stats(\n        np.random.lognormal(mean=1.25, sigma=1., size=(37, 4))\n    )\n\n    fig, ax = plt.subplots()\n    ax.set_yscale('log')\n    ax.bxp(logstats, showcaps=False)\n\n\n@image_comparison(baseline_images=['bxp_nobox'],\n                  remove_text=True, extensions=['png'],\n                  savefig_kwarg={'dpi': 40})\ndef test_bxp_nobox():\n    np.random.seed(937)\n    logstats = matplotlib.cbook.boxplot_stats(\n        np.random.lognormal(mean=1.25, sigma=1., size=(37, 4))\n    )\n\n    fig, ax = plt.subplots()\n    ax.set_yscale('log')\n    ax.bxp(logstats, showbox=False)\n\n\n@image_comparison(baseline_images=['bxp_withmean_point'],\n                  remove_text=True, extensions=['png'],\n                  savefig_kwarg={'dpi': 40})\ndef test_bxp_showmean():\n    np.random.seed(937)\n    logstats = matplotlib.cbook.boxplot_stats(\n        np.random.lognormal(mean=1.25, sigma=1., size=(37, 4))\n    )\n\n    fig, ax = plt.subplots()\n    ax.set_yscale('log')\n    ax.bxp(logstats, showmeans=True, meanline=False)\n\n\n@image_comparison(baseline_images=['bxp_withmean_line'],\n                  remove_text=True, extensions=['png'],\n                  savefig_kwarg={'dpi': 40})\ndef test_bxp_showmeanasline():\n    np.random.seed(937)\n    logstats = matplotlib.cbook.boxplot_stats(\n        np.random.lognormal(mean=1.25, sigma=1., size=(37, 4))\n    )\n\n    fig, ax = plt.subplots()\n    ax.set_yscale('log')\n    ax.bxp(logstats, showmeans=True, meanline=True)\n\n\n@image_comparison(baseline_images=['bxp_scalarwidth'],\n                  remove_text=True, extensions=['png'],\n                  savefig_kwarg={'dpi': 40})\ndef test_bxp_scalarwidth():\n    np.random.seed(937)\n    logstats = matplotlib.cbook.boxplot_stats(\n        np.random.lognormal(mean=1.25, sigma=1., size=(37, 4))\n    )\n\n    fig, ax = plt.subplots()\n    ax.set_yscale('log')\n    ax.bxp(logstats, widths=0.25)\n\n\n@image_comparison(baseline_images=['bxp_customwidths'],\n                  remove_text=True, extensions=['png'],\n                  savefig_kwarg={'dpi': 40})\ndef test_bxp_customwidths():\n    np.random.seed(937)\n    logstats = matplotlib.cbook.boxplot_stats(\n        np.random.lognormal(mean=1.25, sigma=1., size=(37, 4))\n    )\n\n    fig, ax = plt.subplots()\n    ax.set_yscale('log')\n    ax.bxp(logstats, widths=[0.10, 0.25, 0.65, 0.85])\n\n\n@image_comparison(baseline_images=['bxp_custompositions'],\n                  remove_text=True, extensions=['png'],\n                  savefig_kwarg={'dpi': 40})\ndef test_bxp_custompositions():\n    np.random.seed(937)\n    logstats = matplotlib.cbook.boxplot_stats(\n        np.random.lognormal(mean=1.25, sigma=1., size=(37, 4))\n    )\n\n    fig, ax = plt.subplots()\n    ax.set_yscale('log')\n    ax.bxp(logstats, positions=[1, 5, 6, 7])\n\n\n@cleanup\ndef test_bxp_bad_widths():\n    np.random.seed(937)\n    logstats = matplotlib.cbook.boxplot_stats(\n        np.random.lognormal(mean=1.25, sigma=1., size=(37, 4))\n    )\n\n    fig, ax = plt.subplots()\n    ax.set_yscale('log')\n    assert_raises(ValueError, ax.bxp, logstats, widths=[1])\n\n\n@cleanup\ndef test_bxp_bad_positions():\n    np.random.seed(937)\n    logstats = matplotlib.cbook.boxplot_stats(\n        np.random.lognormal(mean=1.25, sigma=1., size=(37, 4))\n    )\n\n    fig, ax = plt.subplots()\n    ax.set_yscale('log')\n    assert_raises(ValueError, ax.bxp, logstats, positions=[2, 3])\n\n\n@image_comparison(baseline_images=['boxplot'])\ndef test_boxplot():\n    x = np.linspace(-7, 7, 140)\n    x = np.hstack([-25, x, 25])\n    fig, ax = plt.subplots()\n\n    ax.boxplot([x, x], bootstrap=10000, notch=1)\n    ax.set_ylim((-30, 30))\n\n\n@image_comparison(baseline_images=['boxplot_sym2'],\n                  remove_text=True, extensions=['png'])\ndef test_boxplot_sym2():\n    x = np.linspace(-7, 7, 140)\n    x = np.hstack([-25, x, 25])\n    fig, [ax1, ax2] = plt.subplots(1, 2)\n\n    ax1.boxplot([x, x], bootstrap=10000, sym='^')\n    ax1.set_ylim((-30, 30))\n\n    ax2.boxplot([x, x], bootstrap=10000, sym='g')\n    ax2.set_ylim((-30, 30))\n\n\n@image_comparison(baseline_images=['boxplot_sym'],\n                  remove_text=True, extensions=['png'],\n                  savefig_kwarg={'dpi': 40})\ndef test_boxplot_sym():\n    x = np.linspace(-7, 7, 140)\n    x = np.hstack([-25, x, 25])\n    fig, ax = plt.subplots()\n\n    ax.boxplot([x, x], sym='gs')\n    ax.set_ylim((-30, 30))\n\n\n@image_comparison(baseline_images=['boxplot_autorange_whiskers'])\ndef test_boxplot_autorange_whiskers():\n    x = np.ones(140)\n    x = np.hstack([0, x, 2])\n    fig, ax = plt.subplots()\n\n    ax.boxplot([x, x], bootstrap=10000, notch=1)\n    ax.set_ylim((-5, 5))\n\n\n@image_comparison(baseline_images=['boxplot_with_CIarray'],\n                  remove_text=True, extensions=['png'],\n                  savefig_kwarg={'dpi': 40})\ndef test_boxplot_with_CIarray():\n    x = np.linspace(-7, 7, 140)\n    x = np.hstack([-25, x, 25])\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    CIs = np.array([[-1.5, 3.], [-1., 3.5]])\n\n    # show 1 boxplot with mpl medians/conf. interfals, 1 with manual values\n    ax.boxplot([x, x], bootstrap=10000, usermedians=[None, 1.0],\n               conf_intervals=CIs, notch=1)\n    ax.set_ylim((-30, 30))\n\n\n@image_comparison(baseline_images=['boxplot_no_inverted_whisker'],\n                  remove_text=True, extensions=['png'],\n                  savefig_kwarg={'dpi': 40})\ndef test_boxplot_no_weird_whisker():\n    x = np.array([3, 9000, 150, 88, 350, 200000, 1400, 960],\n                 dtype=np.float64)\n    ax1 = plt.axes()\n    ax1.boxplot(x)\n    ax1.set_yscale('log')\n    ax1.yaxis.grid(False, which='minor')\n    ax1.xaxis.grid(False)\n\n\n@cleanup\ndef test_boxplot_bad_medians_1():\n    x = np.linspace(-7, 7, 140)\n    x = np.hstack([-25, x, 25])\n    fig, ax = plt.subplots()\n    assert_raises(ValueError, ax.boxplot, x,  usermedians=[1, 2])\n\n\n@cleanup\ndef test_boxplot_bad_medians_2():\n    x = np.linspace(-7, 7, 140)\n    x = np.hstack([-25, x, 25])\n    fig, ax = plt.subplots()\n    assert_raises(ValueError, ax.boxplot, [x, x],  usermedians=[[1, 2], [1, 2]])\n\n\n@cleanup\ndef test_boxplot_bad_ci_1():\n    x = np.linspace(-7, 7, 140)\n    x = np.hstack([-25, x, 25])\n    fig, ax = plt.subplots()\n    assert_raises(ValueError, ax.boxplot, [x, x],\n                  conf_intervals=[[1, 2]])\n\n\n@cleanup\ndef test_boxplot_bad_ci_2():\n    x = np.linspace(-7, 7, 140)\n    x = np.hstack([-25, x, 25])\n    fig, ax = plt.subplots()\n    assert_raises(ValueError, ax.boxplot, [x, x],\n                  conf_intervals=[[1, 2], [1]])\n\n\n@image_comparison(baseline_images=['boxplot_mod_artists_after_plotting'],\n                  remove_text=True, extensions=['png'],\n                  savefig_kwarg={'dpi': 40})\ndef test_boxplot_mod_artist_after_plotting():\n    x = [0.15, 0.11, 0.06, 0.06, 0.12, 0.56, -0.56]\n    fig, ax = plt.subplots()\n    bp = ax.boxplot(x, sym=\"o\")\n    for key in bp:\n        for obj in bp[key]:\n            obj.set_color('green')\n\n\n@image_comparison(baseline_images=['violinplot_vert_baseline'],\n                  extensions=['png'])\ndef test_vert_violinplot_baseline():\n    # First 9 digits of frac(sqrt(2))\n    np.random.seed(414213562)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax = plt.axes()\n    ax.violinplot(data, positions=range(4), showmeans=0, showextrema=0,\n                  showmedians=0)\n\n\n@image_comparison(baseline_images=['violinplot_vert_showmeans'],\n                  extensions=['png'])\ndef test_vert_violinplot_showmeans():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(3))\n    np.random.seed(732050807)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), showmeans=1, showextrema=0,\n                  showmedians=0)\n\n\n@image_comparison(baseline_images=['violinplot_vert_showextrema'],\n                  extensions=['png'])\ndef test_vert_violinplot_showextrema():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(5))\n    np.random.seed(236067977)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), showmeans=0, showextrema=1,\n                  showmedians=0)\n\n\n@image_comparison(baseline_images=['violinplot_vert_showmedians'],\n                  extensions=['png'])\ndef test_vert_violinplot_showmedians():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(7))\n    np.random.seed(645751311)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), showmeans=0, showextrema=0,\n                  showmedians=1)\n\n\n@image_comparison(baseline_images=['violinplot_vert_showall'],\n                  extensions=['png'])\ndef test_vert_violinplot_showall():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(11))\n    np.random.seed(316624790)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), showmeans=1, showextrema=1,\n                  showmedians=1)\n\n\n@image_comparison(baseline_images=['violinplot_vert_custompoints_10'],\n                  extensions=['png'])\ndef test_vert_violinplot_custompoints_10():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(13))\n    np.random.seed(605551275)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), showmeans=0, showextrema=0,\n                  showmedians=0, points=10)\n\n\n@image_comparison(baseline_images=['violinplot_vert_custompoints_200'],\n                  extensions=['png'])\ndef test_vert_violinplot_custompoints_200():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(17))\n    np.random.seed(123105625)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), showmeans=0, showextrema=0,\n                  showmedians=0, points=200)\n\n\n@image_comparison(baseline_images=['violinplot_horiz_baseline'],\n                  extensions=['png'])\ndef test_horiz_violinplot_baseline():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(19))\n    np.random.seed(358898943)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), vert=False, showmeans=0,\n                  showextrema=0, showmedians=0)\n\n\n@image_comparison(baseline_images=['violinplot_horiz_showmedians'],\n                  extensions=['png'])\ndef test_horiz_violinplot_showmedians():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(23))\n    np.random.seed(795831523)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), vert=False, showmeans=0,\n                  showextrema=0, showmedians=1)\n\n\n@image_comparison(baseline_images=['violinplot_horiz_showmeans'],\n                  extensions=['png'])\ndef test_horiz_violinplot_showmeans():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(29))\n    np.random.seed(385164807)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), vert=False, showmeans=1,\n                  showextrema=0, showmedians=0)\n\n\n@image_comparison(baseline_images=['violinplot_horiz_showextrema'],\n                  extensions=['png'])\ndef test_horiz_violinplot_showextrema():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(31))\n    np.random.seed(567764362)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), vert=False, showmeans=0,\n                  showextrema=1, showmedians=0)\n\n\n@image_comparison(baseline_images=['violinplot_horiz_showall'],\n                  extensions=['png'])\ndef test_horiz_violinplot_showall():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(37))\n    np.random.seed(82762530)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), vert=False, showmeans=1,\n                  showextrema=1, showmedians=1)\n\n\n@image_comparison(baseline_images=['violinplot_horiz_custompoints_10'],\n                  extensions=['png'])\ndef test_horiz_violinplot_custompoints_10():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(41))\n    np.random.seed(403124237)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), vert=False, showmeans=0,\n                  showextrema=0, showmedians=0, points=10)\n\n\n@image_comparison(baseline_images=['violinplot_horiz_custompoints_200'],\n                  extensions=['png'])\ndef test_horiz_violinplot_custompoints_200():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(43))\n    np.random.seed(557438524)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), vert=False, showmeans=0,\n                  showextrema=0, showmedians=0, points=200)\n\n\n@cleanup\ndef test_violinplot_bad_positions():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(47))\n    np.random.seed(855654600)\n    data = [np.random.normal(size=100) for i in range(4)]\n    assert_raises(ValueError, ax.violinplot, data, positions=range(5))\n\n\n@cleanup\ndef test_violinplot_bad_widths():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(53))\n    np.random.seed(280109889)\n    data = [np.random.normal(size=100) for i in range(4)]\n    assert_raises(ValueError, ax.violinplot, data, positions=range(4),\n                  widths=[1, 2, 3])\n\n\n@cleanup\ndef test_manage_xticks():\n    _, ax = plt.subplots()\n    ax.set_xlim(0, 4)\n    old_xlim = ax.get_xlim()\n    np.random.seed(0)\n    y1 = np.random.normal(10, 3, 20)\n    y2 = np.random.normal(3, 1, 20)\n    ax.boxplot([y1, y2], positions=[1, 2],\n               manage_xticks=False)\n    new_xlim = ax.get_xlim()\n    assert_array_equal(old_xlim, new_xlim)\n\n\n@image_comparison(baseline_images=['errorbar_basic', 'errorbar_mixed'])\ndef test_errorbar():\n    x = np.arange(0.1, 4, 0.5)\n    y = np.exp(-x)\n\n    yerr = 0.1 + 0.2*np.sqrt(x)\n    xerr = 0.1 + yerr\n\n    # First illustrate basic pyplot interface, using defaults where possible.\n    fig = plt.figure()\n    ax = fig.gca()\n    ax.errorbar(x, y, xerr=0.2, yerr=0.4)\n    ax.set_title(\"Simplest errorbars, 0.2 in x, 0.4 in y\")\n\n    # Now switch to a more OO interface to exercise more features.\n    fig, axs = plt.subplots(nrows=2, ncols=2, sharex=True)\n    ax = axs[0, 0]\n    ax.errorbar(x, y, yerr=yerr, fmt='o')\n    ax.set_title('Vert. symmetric')\n\n    # With 4 subplots, reduce the number of axis ticks to avoid crowding.\n    ax.locator_params(nbins=4)\n\n    ax = axs[0, 1]\n    ax.errorbar(x, y, xerr=xerr, fmt='o', alpha=0.4)\n    ax.set_title('Hor. symmetric w/ alpha')\n\n    ax = axs[1, 0]\n    ax.errorbar(x, y, yerr=[yerr, 2*yerr], xerr=[xerr, 2*xerr], fmt='--o')\n    ax.set_title('H, V asymmetric')\n\n    ax = axs[1, 1]\n    ax.set_yscale('log')\n    # Here we have to be careful to keep all y values positive:\n    ylower = np.maximum(1e-2, y - yerr)\n    yerr_lower = y - ylower\n\n    ax.errorbar(x, y, yerr=[yerr_lower, 2*yerr], xerr=xerr,\n                fmt='o', ecolor='g', capthick=2)\n    ax.set_title('Mixed sym., log y')\n\n    fig.suptitle('Variable errorbars')\n\n\n@image_comparison(baseline_images=['errorbar_limits'])\ndef test_errorbar_limits():\n    x = np.arange(0.5, 5.5, 0.5)\n    y = np.exp(-x)\n    xerr = 0.1\n    yerr = 0.2\n    ls = 'dotted'\n\n    fig = plt.figure()\n    ax = fig.add_subplot(1, 1, 1)\n\n    # standard error bars\n    plt.errorbar(x, y, xerr=xerr, yerr=yerr, ls=ls, color='blue')\n\n    # including upper limits\n    uplims = np.zeros(x.shape)\n    uplims[[1, 5, 9]] = True\n    plt.errorbar(x, y+0.5, xerr=xerr, yerr=yerr, uplims=uplims, ls=ls,\n                 color='green')\n\n    # including lower limits\n    lolims = np.zeros(x.shape)\n    lolims[[2, 4, 8]] = True\n    plt.errorbar(x, y+1.0, xerr=xerr, yerr=yerr, lolims=lolims, ls=ls,\n                 color='red')\n\n    # including upper and lower limits\n    plt.errorbar(x, y+1.5, marker='o', ms=8, xerr=xerr, yerr=yerr,\n                 lolims=lolims, uplims=uplims, ls=ls, color='magenta')\n\n    # including xlower and xupper limits\n    xerr = 0.2\n    yerr = np.zeros(x.shape) + 0.2\n    yerr[[3, 6]] = 0.3\n    xlolims = lolims\n    xuplims = uplims\n    lolims = np.zeros(x.shape)\n    uplims = np.zeros(x.shape)\n    lolims[[6]] = True\n    uplims[[3]] = True\n    plt.errorbar(x, y+2.1, marker='o', ms=8, xerr=xerr, yerr=yerr,\n                 xlolims=xlolims, xuplims=xuplims, uplims=uplims,\n                 lolims=lolims, ls='none', mec='blue', capsize=0,\n                 color='cyan')\n    ax.set_xlim((0, 5.5))\n    ax.set_title('Errorbar upper and lower limits')\n\n\n@image_comparison(baseline_images=['hist_stacked_stepfilled'])\ndef test_hist_stacked_stepfilled():\n    # make some data\n    d1 = np.linspace(1, 3, 20)\n    d2 = np.linspace(0, 10, 50)\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist((d1, d2), histtype=\"stepfilled\", stacked=True)\n\n\n@image_comparison(baseline_images=['hist_offset'])\ndef test_hist_offset():\n    # make some data\n    d1 = np.linspace(0, 10, 50)\n    d2 = np.linspace(1, 3, 20)\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist(d1, bottom=5)\n    ax.hist(d2, bottom=15)\n\n\n@image_comparison(baseline_images=['hist_step'], extensions=['png'], remove_text=True)\ndef test_hist_step():\n    # make some data\n    d1 = np.linspace(1, 3, 20)\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist(d1, histtype=\"step\")\n    ax.set_ylim(0, 10)\n    ax.set_xlim(-1, 5)\n\n\n@image_comparison(baseline_images=['hist_step_horiz'], extensions=['png'])\ndef test_hist_step_horiz():\n    # make some data\n    d1 = np.linspace(0, 10, 50)\n    d2 = np.linspace(1, 3, 20)\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist((d1, d2), histtype=\"step\", orientation=\"horizontal\")\n\n\n@image_comparison(baseline_images=['hist_stacked_weights'])\ndef test_hist_stacked_weighted():\n    # make some data\n    d1 = np.linspace(0, 10, 50)\n    d2 = np.linspace(1, 3, 20)\n    w1 = np.linspace(0.01, 3.5, 50)\n    w2 = np.linspace(0.05, 2., 20)\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist((d1, d2), weights=(w1, w2), histtype=\"stepfilled\", stacked=True)\n\n\n@cleanup\ndef test_stem_args():\n    fig = plt.figure()\n    ax = fig.add_subplot(1, 1, 1)\n\n    x = list(xrange(10))\n    y = list(xrange(10))\n\n    # Test the call signatures\n    ax.stem(y)\n    ax.stem(x, y)\n    ax.stem(x, y, 'r--')\n    ax.stem(x, y, 'r--', basefmt='b--')\n\n\n@cleanup\ndef test_stem_dates():\n    fig, ax = plt.subplots(1, 1)\n    from dateutil import parser\n    x = parser.parse(\"2013-9-28 11:00:00\")\n    y = 100\n\n    x1 = parser.parse(\"2013-9-28 12:00:00\")\n    y1 = 200\n\n    ax.stem([x, x1], [y, y1], \"*-\")\n\n\n@image_comparison(baseline_images=['hist_stacked_stepfilled_alpha'])\ndef test_hist_stacked_stepfilled_alpha():\n    # make some data\n    d1 = np.linspace(1, 3, 20)\n    d2 = np.linspace(0, 10, 50)\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist((d1, d2), histtype=\"stepfilled\", stacked=True, alpha=0.5)\n\n\n@image_comparison(baseline_images=['hist_stacked_step'])\ndef test_hist_stacked_step():\n    # make some data\n    d1 = np.linspace(1, 3, 20)\n    d2 = np.linspace(0, 10, 50)\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist((d1, d2), histtype=\"step\", stacked=True)\n\n\n@image_comparison(baseline_images=['hist_stacked_normed'])\ndef test_hist_stacked_normed():\n    # make some data\n    d1 = np.linspace(1, 3, 20)\n    d2 = np.linspace(0, 10, 50)\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist((d1, d2), stacked=True, normed=True)\n\n\n@image_comparison(baseline_images=['hist_step_bottom'], extensions=['png'], remove_text=True)\ndef test_hist_step_bottom():\n    # make some data\n    d1 = np.linspace(1, 3, 20)\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist(d1, bottom=np.arange(10), histtype=\"stepfilled\")\n\n\n@image_comparison(baseline_images=['hist_stacked_bar'])\ndef test_hist_stacked_bar():\n    # make some data\n    d = [[100, 100, 100, 100, 200, 320, 450, 80, 20, 600, 310, 800],\n         [20, 23, 50, 11, 100, 420], [120, 120, 120, 140, 140, 150, 180],\n         [60, 60, 60, 60, 300, 300, 5, 5, 5, 5, 10, 300],\n         [555, 555, 555, 30, 30, 30, 30, 30, 100, 100, 100, 100, 30, 30],\n         [30, 30, 30, 30, 400, 400, 400, 400, 400, 400, 400, 400]]\n    colors = [(0.5759849696758961, 1.0, 0.0), (0.0, 1.0, 0.350624650815206),\n              (0.0, 1.0, 0.6549834156005998), (0.0, 0.6569064625276622, 1.0),\n              (0.28302699607823545, 0.0, 1.0), (0.6849123462299822, 0.0, 1.0)]\n    labels = ['green', 'orange', ' yellow', 'magenta', 'black']\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist(d, bins=10, histtype='barstacked', align='mid', color=colors, label=labels)\n    ax.legend(loc='upper right', bbox_to_anchor=(1.0, 1.0), ncol=1)\n\n\n@cleanup\ndef test_hist_emptydata():\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist([[], range(10), range(10)], histtype=\"step\")\n\n\n@image_comparison(baseline_images=['transparent_markers'], remove_text=True)\ndef test_transparent_markers():\n    np.random.seed(0)\n    data = np.random.random(50)\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.plot(data, 'D', mfc='none', markersize=100)\n\n\n@image_comparison(baseline_images=['mollweide_grid'], remove_text=True)\ndef test_mollweide_grid():\n    # test that both horizontal and vertical gridlines appear on the Mollweide\n    # projection\n    fig = plt.figure()\n    ax = fig.add_subplot(111, projection='mollweide')\n    ax.grid()\n\n\n@cleanup\ndef test_mollweide_forward_inverse_closure():\n    # test that the round-trip Mollweide forward->inverse transformation is an\n    # approximate identity\n    fig = plt.figure()\n    ax = fig.add_subplot(111, projection='mollweide')\n\n    # set up 1-degree grid in longitude, latitude\n    lon = np.linspace(-np.pi, np.pi, 360)\n    lat = np.linspace(-np.pi / 2.0, np.pi / 2.0, 180)\n    lon, lat = np.meshgrid(lon, lat)\n    ll = np.vstack((lon.flatten(), lat.flatten())).T\n\n    # perform forward transform\n    xy = ax.transProjection.transform(ll)\n\n    # perform inverse transform\n    ll2 = ax.transProjection.inverted().transform(xy)\n\n    # compare\n    np.testing.assert_array_almost_equal(ll, ll2, 3)\n\n\n@cleanup\ndef test_mollweide_inverse_forward_closure():\n    # test that the round-trip Mollweide inverse->forward transformation is an\n    # approximate identity\n    fig = plt.figure()\n    ax = fig.add_subplot(111, projection='mollweide')\n\n    # set up grid in x, y\n    x = np.linspace(0, 1, 500)\n    x, y = np.meshgrid(x, x)\n    xy = np.vstack((x.flatten(), y.flatten())).T\n\n    # perform inverse transform\n    ll = ax.transProjection.inverted().transform(xy)\n\n    # perform forward transform\n    xy2 = ax.transProjection.transform(ll)\n\n    # compare\n    np.testing.assert_array_almost_equal(xy, xy2, 3)\n\n\n@image_comparison(baseline_images=['test_alpha'], remove_text=True)\ndef test_alpha():\n    np.random.seed(0)\n    data = np.random.random(50)\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n\n    # alpha=.5 markers, solid line\n    ax.plot(data, '-D', color=[1, 0, 0], mfc=[1, 0, 0, .5],\n            markersize=20, lw=10)\n\n    # everything solid by kwarg\n    ax.plot(data + 2, '-D', color=[1, 0, 0, .5], mfc=[1, 0, 0, .5],\n            markersize=20, lw=10,\n            alpha=1)\n\n    # everything alpha=.5 by kwarg\n    ax.plot(data + 4, '-D', color=[1, 0, 0], mfc=[1, 0, 0],\n            markersize=20, lw=10,\n            alpha=.5)\n\n    # everything alpha=.5 by colors\n    ax.plot(data + 6, '-D', color=[1, 0, 0, .5], mfc=[1, 0, 0, .5],\n            markersize=20, lw=10)\n\n    # alpha=.5 line, solid markers\n    ax.plot(data + 8, '-D', color=[1, 0, 0, .5], mfc=[1, 0, 0],\n            markersize=20, lw=10)\n\n\n@image_comparison(baseline_images=['eventplot'], remove_text=True)\ndef test_eventplot():\n    '''\n    test that eventplot produces the correct output\n    '''\n    np.random.seed(0)\n\n    data1 = np.random.random([32, 20]).tolist()\n    data2 = np.random.random([6, 20]).tolist()\n    data = data1 + data2\n    num_datasets = len(data)\n\n    colors1 = [[0, 1, .7]] * len(data1)\n    colors2 = [[1, 0, 0],\n               [0, 1, 0],\n               [0, 0, 1],\n               [1, .75, 0],\n               [1, 0, 1],\n               [0, 1, 1]]\n    colors = colors1 + colors2\n\n    lineoffsets1 = 12 + np.arange(0, len(data1)) * .33\n    lineoffsets2 = [-15, -3, 1, 1.5, 6, 10]\n    lineoffsets = lineoffsets1.tolist() + lineoffsets2\n\n    linelengths1 = [.33] * len(data1)\n    linelengths2 = [5, 2, 1, 1, 3, 1.5]\n    linelengths = linelengths1 + linelengths2\n\n    fig = plt.figure()\n    axobj = fig.add_subplot(111)\n    colls = axobj.eventplot(data, colors=colors, lineoffsets=lineoffsets,\n                            linelengths=linelengths)\n\n    num_collections = len(colls)\n    np.testing.assert_equal(num_collections, num_datasets)\n\n\n@cleanup\ndef test_empty_eventplot():\n    fig, ax = plt.subplots(1, 1)\n    ax.eventplot([[]], colors=[(0.0, 0.0, 0.0, 0.0)])\n    plt.draw()\n\n\n@image_comparison(baseline_images=['marker_styles'], extensions=['png'], remove_text=True)\ndef test_marker_styles():\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    for y, marker in enumerate(sorted(matplotlib.markers.MarkerStyle.markers.keys(),\n                                      key=lambda x: str(type(x))+str(x))):\n        ax.plot((y % 2)*5 + np.arange(10)*10, np.ones(10)*10*y, linestyle='', marker=marker,\n                markersize=10+y/5, label=marker)\n\n\n@image_comparison(baseline_images=['vertex_markers'], extensions=['png'],\n                  remove_text=True)\ndef test_vertex_markers():\n    data = list(xrange(10))\n    marker_as_tuple = ((-1, -1), (1, -1), (1, 1), (-1, 1))\n    marker_as_list = [(-1, -1), (1, -1), (1, 1), (-1, 1)]\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.plot(data, linestyle='', marker=marker_as_tuple, mfc='k')\n    ax.plot(data[::-1], linestyle='', marker=marker_as_list, mfc='b')\n    ax.set_xlim([-1, 10])\n    ax.set_ylim([-1, 10])\n\n\n@image_comparison(baseline_images=['vline_hline_zorder',\n                                   'errorbar_zorder'])\ndef test_eb_line_zorder():\n    x = list(xrange(10))\n\n    # First illustrate basic pyplot interface, using defaults where possible.\n    fig = plt.figure()\n    ax = fig.gca()\n    ax.plot(x, lw=10, zorder=5)\n    ax.axhline(1, color='red', lw=10, zorder=1)\n    ax.axhline(5, color='green', lw=10, zorder=10)\n    ax.axvline(7, color='m', lw=10, zorder=7)\n    ax.axvline(2, color='k', lw=10, zorder=3)\n\n    ax.set_title(\"axvline and axhline zorder test\")\n\n    # Now switch to a more OO interface to exercise more features.\n    fig = plt.figure()\n    ax = fig.gca()\n    x = list(xrange(10))\n    y = np.zeros(10)\n    yerr = list(xrange(10))\n    ax.errorbar(x, y, yerr=yerr, zorder=5, lw=5, color='r')\n    for j in range(10):\n        ax.axhline(j, lw=5, color='k', zorder=j)\n        ax.axhline(-j, lw=5, color='k', zorder=j)\n\n    ax.set_title(\"errorbar zorder test\")\n\n\n@image_comparison(baseline_images=['step_linestyle'], remove_text=True)\ndef test_step_linestyle():\n    x = y = np.arange(10)\n\n    # First illustrate basic pyplot interface, using defaults where possible.\n    fig, ax_lst = plt.subplots(2, 2)\n    ax_lst = ax_lst.flatten()\n\n    ln_styles = ['-', '--', '-.', ':']\n\n    for ax, ls in zip(ax_lst, ln_styles):\n        ax.step(x, y, lw=5, linestyle=ls, where='pre')\n        ax.step(x, y + 1, lw=5, linestyle=ls, where='mid')\n        ax.step(x, y + 2, lw=5, linestyle=ls, where='post')\n        ax.set_xlim([-1, 5])\n        ax.set_ylim([-1, 7])\n\n\n@image_comparison(baseline_images=['mixed_collection'], remove_text=True)\ndef test_mixed_collection():\n    from matplotlib import patches\n    from matplotlib import collections\n\n    x = list(xrange(10))\n\n    # First illustrate basic pyplot interface, using defaults where possible.\n    fig = plt.figure()\n    ax = fig.add_subplot(1, 1, 1)\n\n    c = patches.Circle((8, 8), radius=4, facecolor='none', edgecolor='green')\n\n    # PDF can optimize this one\n    p1 = collections.PatchCollection([c], match_original=True)\n    p1.set_offsets([[0, 0], [24, 24]])\n    p1.set_linewidths([1, 5])\n\n    # PDF can't optimize this one, because the alpha of the edge changes\n    p2 = collections.PatchCollection([c], match_original=True)\n    p2.set_offsets([[48, 0], [-32, -16]])\n    p2.set_linewidths([1, 5])\n    p2.set_edgecolors([[0, 0, 0.1, 1.0], [0, 0, 0.1, 0.5]])\n\n    ax.patch.set_color('0.5')\n    ax.add_collection(p1)\n    ax.add_collection(p2)\n\n    ax.set_xlim(0, 16)\n    ax.set_ylim(0, 16)\n\n\n@cleanup\ndef test_subplot_key_hash():\n    ax = plt.subplot(np.float64(5.5), np.int64(1), np.float64(1.2))\n    ax.twinx()\n    assert_equal((5, 1, 0, None), ax.get_subplotspec().get_geometry())\n\n\n@image_comparison(baseline_images=['specgram_freqs',\n                                   'specgram_freqs_linear'],\n                  remove_text=True, extensions=['png'])\ndef test_specgram_freqs():\n    '''test axes.specgram in default (psd) mode with sinusoidal stimuli'''\n    n = 10000\n    Fs = 100.\n\n    fstims1 = [Fs/4, Fs/5, Fs/11]\n    fstims2 = [Fs/4.7, Fs/5.6, Fs/11.9]\n\n    NFFT = int(1000 * Fs / min(fstims1 + fstims2))\n    noverlap = int(NFFT / 2)\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    x = np.arange(0, n, 1/Fs)\n\n    y1 = np.zeros(x.size)\n    y2 = np.zeros(x.size)\n    for fstim1, fstim2 in zip(fstims1, fstims2):\n        y1 += np.sin(fstim1 * x * np.pi * 2)\n        y2 += np.sin(fstim2 * x * np.pi * 2)\n    y = np.hstack([y1, y2])\n\n    fig1 = plt.figure()\n    fig2 = plt.figure()\n\n    ax11 = fig1.add_subplot(3, 1, 1)\n    ax12 = fig1.add_subplot(3, 1, 2)\n    ax13 = fig1.add_subplot(3, 1, 3)\n\n    ax21 = fig2.add_subplot(3, 1, 1)\n    ax22 = fig2.add_subplot(3, 1, 2)\n    ax23 = fig2.add_subplot(3, 1, 3)\n\n    spec11 = ax11.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='default')\n    spec12 = ax12.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='onesided')\n    spec13 = ax13.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='twosided')\n\n    spec21 = ax21.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='default',\n                           scale='linear', norm=matplotlib.colors.LogNorm())\n    spec22 = ax22.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='onesided',\n                           scale='linear', norm=matplotlib.colors.LogNorm())\n    spec23 = ax23.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='twosided',\n                           scale='linear', norm=matplotlib.colors.LogNorm())\n\n\n@image_comparison(baseline_images=['specgram_noise',\n                                   'specgram_noise_linear'],\n                  remove_text=True, extensions=['png'])\ndef test_specgram_noise():\n    '''test axes.specgram in default (psd) mode with noise stimuli'''\n    np.random.seed(0)\n\n    n = 10000\n    Fs = 100.\n\n    NFFT = int(1000 * Fs / 11)\n    noverlap = int(NFFT / 2)\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    y1 = np.random.standard_normal(n)\n    y2 = np.random.rand(n)\n    y = np.hstack([y1, y2])\n\n    fig1 = plt.figure()\n    fig2 = plt.figure()\n\n    ax11 = fig1.add_subplot(3, 1, 1)\n    ax12 = fig1.add_subplot(3, 1, 2)\n    ax13 = fig1.add_subplot(3, 1, 3)\n\n    ax21 = fig2.add_subplot(3, 1, 1)\n    ax22 = fig2.add_subplot(3, 1, 2)\n    ax23 = fig2.add_subplot(3, 1, 3)\n\n    spec11 = ax11.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='default')\n    spec12 = ax12.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='onesided')\n    spec13 = ax13.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='twosided')\n\n    spec21 = ax21.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='default',\n                           scale='linear', norm=matplotlib.colors.LogNorm())\n    spec22 = ax22.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='onesided',\n                           scale='linear', norm=matplotlib.colors.LogNorm())\n    spec23 = ax23.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='twosided',\n                           scale='linear', norm=matplotlib.colors.LogNorm())\n\n\n@image_comparison(baseline_images=['specgram_magnitude_freqs',\n                                   'specgram_magnitude_freqs_linear'],\n                  remove_text=True, extensions=['png'])\ndef test_specgram_magnitude_freqs():\n    '''test axes.specgram in magnitude mode with sinusoidal stimuli'''\n    n = 10000\n    Fs = 100.\n\n    fstims1 = [Fs/4, Fs/5, Fs/11]\n    fstims2 = [Fs/4.7, Fs/5.6, Fs/11.9]\n\n    NFFT = int(1000 * Fs / min(fstims1 + fstims2))\n    noverlap = int(NFFT / 2)\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    x = np.arange(0, n, 1/Fs)\n\n    y1 = np.zeros(x.size)\n    y2 = np.zeros(x.size)\n    for i, (fstim1, fstim2) in enumerate(zip(fstims1, fstims2)):\n        y1 += np.sin(fstim1 * x * np.pi * 2)\n        y2 += np.sin(fstim2 * x * np.pi * 2)\n        y1[-1] = y1[-1]/y1[-1]\n        y2[-1] = y2[-1]/y2[-1]\n    y = np.hstack([y1, y2])\n\n    fig1 = plt.figure()\n    fig2 = plt.figure()\n\n    ax11 = fig1.add_subplot(3, 1, 1)\n    ax12 = fig1.add_subplot(3, 1, 2)\n    ax13 = fig1.add_subplot(3, 1, 3)\n\n    ax21 = fig2.add_subplot(3, 1, 1)\n    ax22 = fig2.add_subplot(3, 1, 2)\n    ax23 = fig2.add_subplot(3, 1, 3)\n\n    spec11 = ax11.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='default', mode='magnitude')\n    spec12 = ax12.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='onesided', mode='magnitude')\n    spec13 = ax13.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='twosided', mode='magnitude')\n\n    spec21 = ax21.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='default', mode='magnitude',\n                           scale='linear', norm=matplotlib.colors.LogNorm())\n    spec22 = ax22.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='onesided', mode='magnitude',\n                           scale='linear', norm=matplotlib.colors.LogNorm())\n    spec23 = ax23.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='twosided', mode='magnitude',\n                           scale='linear', norm=matplotlib.colors.LogNorm())\n\n\n@image_comparison(baseline_images=['specgram_magnitude_noise',\n                                   'specgram_magnitude_noise_linear'],\n                  remove_text=True, extensions=['png'])\ndef test_specgram_magnitude_noise():\n    '''test axes.specgram in magnitude mode with noise stimuli'''\n    np.random.seed(0)\n\n    n = 10000\n    Fs = 100.\n\n    NFFT = int(1000 * Fs / 11)\n    noverlap = int(NFFT / 2)\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    y1 = np.random.standard_normal(n)\n    y2 = np.random.rand(n)\n    y = np.hstack([y1, y2])\n\n    fig1 = plt.figure()\n    fig2 = plt.figure()\n\n    ax11 = fig1.add_subplot(3, 1, 1)\n    ax12 = fig1.add_subplot(3, 1, 2)\n    ax13 = fig1.add_subplot(3, 1, 3)\n\n    ax21 = fig2.add_subplot(3, 1, 1)\n    ax22 = fig2.add_subplot(3, 1, 2)\n    ax23 = fig2.add_subplot(3, 1, 3)\n\n    spec11 = ax11.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='default', mode='magnitude')\n    spec12 = ax12.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='onesided', mode='magnitude')\n    spec13 = ax13.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='twosided', mode='magnitude')\n\n    spec21 = ax21.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='default', mode='magnitude',\n                           scale='linear', norm=matplotlib.colors.LogNorm())\n    spec22 = ax22.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='onesided', mode='magnitude',\n                           scale='linear', norm=matplotlib.colors.LogNorm())\n    spec23 = ax23.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='twosided', mode='magnitude',\n                           scale='linear', norm=matplotlib.colors.LogNorm())\n\n\n@image_comparison(baseline_images=['specgram_angle_freqs'],\n                  remove_text=True, extensions=['png'])\ndef test_specgram_angle_freqs():\n    '''test axes.specgram in angle mode with sinusoidal stimuli'''\n    n = 10000\n    Fs = 100.\n\n    fstims1 = [Fs/4, Fs/5, Fs/11]\n    fstims2 = [Fs/4.7, Fs/5.6, Fs/11.9]\n\n    NFFT = int(1000 * Fs / min(fstims1 + fstims2))\n    noverlap = int(NFFT / 2)\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    x = np.arange(0, n, 1/Fs)\n\n    y1 = np.zeros(x.size)\n    y2 = np.zeros(x.size)\n    for i, (fstim1, fstim2) in enumerate(zip(fstims1, fstims2)):\n        y1 += np.sin(fstim1 * x * np.pi * 2)\n        y2 += np.sin(fstim2 * x * np.pi * 2)\n        y1[-1] = y1[-1]/y1[-1]\n        y2[-1] = y2[-1]/y2[-1]\n    y = np.hstack([y1, y2])\n\n    fig1 = plt.figure()\n\n    ax11 = fig1.add_subplot(3, 1, 1)\n    ax12 = fig1.add_subplot(3, 1, 2)\n    ax13 = fig1.add_subplot(3, 1, 3)\n\n    ax11.hold(True)\n    ax12.hold(True)\n    ax13.hold(True)\n\n    spec11 = ax11.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='default', mode='angle')\n    spec12 = ax12.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='onesided', mode='angle')\n    spec13 = ax13.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='twosided', mode='angle')\n\n    assert_raises(ValueError, ax11.specgram, y, NFFT=NFFT, Fs=Fs,\n                  noverlap=noverlap, pad_to=pad_to, sides='default',\n                  mode='phase', scale='dB')\n\n    assert_raises(ValueError, ax12.specgram, y, NFFT=NFFT, Fs=Fs,\n                  noverlap=noverlap, pad_to=pad_to, sides='onesided',\n                  mode='phase', scale='dB')\n\n    assert_raises(ValueError, ax13.specgram, y, NFFT=NFFT, Fs=Fs,\n                  noverlap=noverlap, pad_to=pad_to, sides='twosided',\n                  mode='phase', scale='dB')\n\n\n@image_comparison(baseline_images=['specgram_angle_noise'],\n                  remove_text=True, extensions=['png'])\ndef test_specgram_noise_angle():\n    '''test axes.specgram in angle mode with noise stimuli'''\n    np.random.seed(0)\n\n    n = 10000\n    Fs = 100.\n\n    NFFT = int(1000 * Fs / 11)\n    noverlap = int(NFFT / 2)\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    y1 = np.random.standard_normal(n)\n    y2 = np.random.rand(n)\n    y = np.hstack([y1, y2])\n\n    fig1 = plt.figure()\n\n    ax11 = fig1.add_subplot(3, 1, 1)\n    ax12 = fig1.add_subplot(3, 1, 2)\n    ax13 = fig1.add_subplot(3, 1, 3)\n\n    ax11.hold(True)\n    ax12.hold(True)\n    ax13.hold(True)\n\n    spec11 = ax11.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='default', mode='angle')\n    spec12 = ax12.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='onesided', mode='angle')\n    spec13 = ax13.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='twosided', mode='angle')\n\n    assert_raises(ValueError, ax11.specgram, y, NFFT=NFFT, Fs=Fs,\n                  noverlap=noverlap, pad_to=pad_to, sides='default',\n                  mode='phase', scale='dB')\n\n    assert_raises(ValueError, ax12.specgram, y, NFFT=NFFT, Fs=Fs,\n                  noverlap=noverlap, pad_to=pad_to, sides='onesided',\n                  mode='phase', scale='dB')\n\n    assert_raises(ValueError, ax13.specgram, y, NFFT=NFFT, Fs=Fs,\n                  noverlap=noverlap, pad_to=pad_to, sides='twosided',\n                  mode='phase', scale='dB')\n\n\n@image_comparison(baseline_images=['specgram_phase_freqs'],\n                  remove_text=True, extensions=['png'])\ndef test_specgram_freqs_phase():\n    '''test axes.specgram in phase mode with sinusoidal stimuli'''\n    n = 10000\n    Fs = 100.\n\n    fstims1 = [Fs/4, Fs/5, Fs/11]\n    fstims2 = [Fs/4.7, Fs/5.6, Fs/11.9]\n\n    NFFT = int(1000 * Fs / min(fstims1 + fstims2))\n    noverlap = int(NFFT / 2)\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    x = np.arange(0, n, 1/Fs)\n\n    y1 = np.zeros(x.size)\n    y2 = np.zeros(x.size)\n    for i, (fstim1, fstim2) in enumerate(zip(fstims1, fstims2)):\n        y1 += np.sin(fstim1 * x * np.pi * 2)\n        y2 += np.sin(fstim2 * x * np.pi * 2)\n        y1[-1] = y1[-1]/y1[-1]\n        y2[-1] = y2[-1]/y2[-1]\n    y = np.hstack([y1, y2])\n\n    fig1 = plt.figure()\n\n    ax11 = fig1.add_subplot(3, 1, 1)\n    ax12 = fig1.add_subplot(3, 1, 2)\n    ax13 = fig1.add_subplot(3, 1, 3)\n\n    ax11.hold(True)\n    ax12.hold(True)\n    ax13.hold(True)\n\n    spec11 = ax11.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='default', mode='phase')\n    spec12 = ax12.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='onesided', mode='phase')\n    spec13 = ax13.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='twosided', mode='phase')\n\n    assert_raises(ValueError, ax11.specgram, y, NFFT=NFFT, Fs=Fs,\n                  noverlap=noverlap, pad_to=pad_to, sides='default',\n                  mode='phase', scale='dB')\n\n    assert_raises(ValueError, ax12.specgram, y, NFFT=NFFT, Fs=Fs,\n                  noverlap=noverlap, pad_to=pad_to, sides='onesided',\n                  mode='phase', scale='dB')\n\n    assert_raises(ValueError, ax13.specgram, y, NFFT=NFFT, Fs=Fs,\n                  noverlap=noverlap, pad_to=pad_to, sides='twosided',\n                  mode='phase', scale='dB')\n\n\n@image_comparison(baseline_images=['specgram_phase_noise'],\n                  remove_text=True, extensions=['png'])\ndef test_specgram_noise_phase():\n    '''test axes.specgram in phase mode with noise stimuli'''\n    np.random.seed(0)\n\n    n = 10000\n    Fs = 100.\n\n    NFFT = int(1000 * Fs / 11)\n    noverlap = int(NFFT / 2)\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    y1 = np.random.standard_normal(n)\n    y2 = np.random.rand(n)\n    y = np.hstack([y1, y2])\n\n    fig1 = plt.figure()\n\n    ax11 = fig1.add_subplot(3, 1, 1)\n    ax12 = fig1.add_subplot(3, 1, 2)\n    ax13 = fig1.add_subplot(3, 1, 3)\n\n    ax11.hold(True)\n    ax12.hold(True)\n    ax13.hold(True)\n\n    spec11 = ax11.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='default',\n                           mode='phase', )\n    spec12 = ax12.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='onesided',\n                           mode='phase', )\n    spec13 = ax13.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='twosided',\n                           mode='phase', )\n\n    assert_raises(ValueError, ax11.specgram, y, NFFT=NFFT, Fs=Fs,\n                  noverlap=noverlap, pad_to=pad_to, sides='default',\n                  mode='phase', scale='dB')\n\n    assert_raises(ValueError, ax12.specgram, y, NFFT=NFFT, Fs=Fs,\n                  noverlap=noverlap, pad_to=pad_to, sides='onesided',\n                  mode='phase', scale='dB')\n\n    assert_raises(ValueError, ax13.specgram, y, NFFT=NFFT, Fs=Fs,\n                  noverlap=noverlap, pad_to=pad_to, sides='twosided',\n                  mode='phase', scale='dB')\n\n\n@image_comparison(baseline_images=['psd_freqs'], remove_text=True,\n                  extensions=['png'])\ndef test_psd_freqs():\n    '''test axes.psd with sinusoidal stimuli'''\n    n = 10000\n    Fs = 100.\n\n    fstims1 = [Fs/4, Fs/5, Fs/11]\n    fstims2 = [Fs/4.7, Fs/5.6, Fs/11.9]\n\n    NFFT = int(1000 * Fs / min(fstims1 + fstims2))\n    noverlap = int(NFFT / 2)\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    x = np.arange(0, n, 1/Fs)\n\n    y1 = np.zeros(x.size)\n    y2 = np.zeros(x.size)\n    for fstim1, fstim2 in zip(fstims1, fstims2):\n        y1 += np.sin(fstim1 * x * np.pi * 2)\n        y2 += np.sin(fstim2 * x * np.pi * 2)\n    y = np.hstack([y1, y2])\n\n    fig = plt.figure()\n    ax1 = fig.add_subplot(3, 1, 1)\n    ax2 = fig.add_subplot(3, 1, 2)\n    ax3 = fig.add_subplot(3, 1, 3)\n\n    psd1, freqs1 = ax1.psd(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='default')\n    psd2, freqs2 = ax2.psd(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='onesided',\n                           return_line=False)\n    psd3, freqs3, line3 = ax3.psd(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                                  pad_to=pad_to, sides='twosided',\n                                  return_line=True)\n\n    ax1.set_xlabel('')\n    ax2.set_xlabel('')\n    ax3.set_xlabel('')\n    ax1.set_ylabel('')\n    ax2.set_ylabel('')\n    ax3.set_ylabel('')\n\n\n@image_comparison(baseline_images=['psd_noise'], remove_text=True,\n                  extensions=['png'])\ndef test_psd_noise():\n    '''test axes.psd with noise stimuli'''\n    np.random.seed(0)\n\n    n = 10000\n    Fs = 100.\n\n    NFFT = int(1000 * Fs / 11)\n    noverlap = int(NFFT / 2)\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    y1 = np.random.standard_normal(n)\n    y2 = np.random.rand(n)\n    y = np.hstack([y1, y2])\n\n    fig = plt.figure()\n    ax1 = fig.add_subplot(3, 1, 1)\n    ax2 = fig.add_subplot(3, 1, 2)\n    ax3 = fig.add_subplot(3, 1, 3)\n\n    psd1, freqs1 = ax1.psd(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='default')\n    psd2, freqs2 = ax2.psd(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='onesided',\n                           return_line=False)\n    psd3, freqs3, line3 = ax3.psd(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                                  pad_to=pad_to, sides='twosided',\n                                  return_line=True)\n\n    ax1.set_xlabel('')\n    ax2.set_xlabel('')\n    ax3.set_xlabel('')\n    ax1.set_ylabel('')\n    ax2.set_ylabel('')\n    ax3.set_ylabel('')\n\n\n@image_comparison(baseline_images=['csd_freqs'], remove_text=True,\n                  extensions=['png'])\ndef test_csd_freqs():\n    '''test axes.csd with sinusoidal stimuli'''\n    n = 10000\n    Fs = 100.\n\n    fstims1 = [Fs/4, Fs/5, Fs/11]\n    fstims2 = [Fs/4.7, Fs/5.6, Fs/11.9]\n\n    NFFT = int(1000 * Fs / min(fstims1 + fstims2))\n    noverlap = int(NFFT / 2)\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    x = np.arange(0, n, 1/Fs)\n\n    y1 = np.zeros(x.size)\n    y2 = np.zeros(x.size)\n    for fstim1, fstim2 in zip(fstims1, fstims2):\n        y1 += np.sin(fstim1 * x * np.pi * 2)\n        y2 += np.sin(fstim2 * x * np.pi * 2)\n\n    fig = plt.figure()\n    ax1 = fig.add_subplot(3, 1, 1)\n    ax2 = fig.add_subplot(3, 1, 2)\n    ax3 = fig.add_subplot(3, 1, 3)\n\n    csd1, freqs1 = ax1.csd(y1, y2, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='default')\n    csd2, freqs2 = ax2.csd(y1, y2, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='onesided',\n                           return_line=False)\n    csd3, freqs3, line3 = ax3.csd(y1, y2, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                                  pad_to=pad_to, sides='twosided',\n                                  return_line=True)\n\n    ax1.set_xlabel('')\n    ax2.set_xlabel('')\n    ax3.set_xlabel('')\n    ax1.set_ylabel('')\n    ax2.set_ylabel('')\n    ax3.set_ylabel('')\n\n\n@image_comparison(baseline_images=['csd_noise'], remove_text=True,\n                  extensions=['png'])\ndef test_csd_noise():\n    '''test axes.csd with noise stimuli'''\n    np.random.seed(0)\n\n    n = 10000\n    Fs = 100.\n\n    NFFT = int(1000 * Fs / 11)\n    noverlap = int(NFFT / 2)\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    y1 = np.random.standard_normal(n)\n    y2 = np.random.rand(n)\n\n    fig = plt.figure()\n    ax1 = fig.add_subplot(3, 1, 1)\n    ax2 = fig.add_subplot(3, 1, 2)\n    ax3 = fig.add_subplot(3, 1, 3)\n\n    csd1, freqs1 = ax1.csd(y1, y2, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='default')\n    csd2, freqs2 = ax2.csd(y1, y2, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='onesided',\n                           return_line=False)\n    csd3, freqs3, line3 = ax3.csd(y1, y2, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                                  pad_to=pad_to, sides='twosided',\n                                  return_line=True)\n\n    ax1.set_xlabel('')\n    ax2.set_xlabel('')\n    ax3.set_xlabel('')\n    ax1.set_ylabel('')\n    ax2.set_ylabel('')\n    ax3.set_ylabel('')\n\n\n@image_comparison(baseline_images=['magnitude_spectrum_freqs_linear',\n                                   'magnitude_spectrum_freqs_dB'],\n                  remove_text=True,\n                  extensions=['png'])\ndef test_magnitude_spectrum_freqs():\n    '''test axes.magnitude_spectrum with sinusoidal stimuli'''\n    n = 10000\n    Fs = 100.\n\n    fstims1 = [Fs/4, Fs/5, Fs/11]\n\n    NFFT = int(1000 * Fs / min(fstims1))\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    x = np.arange(0, n, 1/Fs)\n\n    y = np.zeros(x.size)\n    for i, fstim1 in enumerate(fstims1):\n        y += np.sin(fstim1 * x * np.pi * 2) * 10**i\n    y = y\n\n    fig1 = plt.figure()\n    fig2 = plt.figure()\n\n    ax11 = fig1.add_subplot(3, 1, 1)\n    ax12 = fig1.add_subplot(3, 1, 2)\n    ax13 = fig1.add_subplot(3, 1, 3)\n\n    ax21 = fig2.add_subplot(3, 1, 1)\n    ax22 = fig2.add_subplot(3, 1, 2)\n    ax23 = fig2.add_subplot(3, 1, 3)\n\n    spec11, freqs11, line11 = ax11.magnitude_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                                      sides='default')\n    spec12, freqs12, line12 = ax12.magnitude_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                                      sides='onesided')\n    spec13, freqs13, line13 = ax13.magnitude_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                                      sides='twosided')\n\n    spec21, freqs21, line21 = ax21.magnitude_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                                      sides='default',\n                                                      scale='dB')\n    spec22, freqs22, line22 = ax22.magnitude_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                                      sides='onesided',\n                                                      scale='dB')\n    spec23, freqs23, line23 = ax23.magnitude_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                                      sides='twosided',\n                                                      scale='dB')\n\n    ax11.set_xlabel('')\n    ax12.set_xlabel('')\n    ax13.set_xlabel('')\n    ax11.set_ylabel('')\n    ax12.set_ylabel('')\n    ax13.set_ylabel('')\n\n    ax21.set_xlabel('')\n    ax22.set_xlabel('')\n    ax23.set_xlabel('')\n    ax21.set_ylabel('')\n    ax22.set_ylabel('')\n    ax23.set_ylabel('')\n\n\n@image_comparison(baseline_images=['magnitude_spectrum_noise_linear',\n                                   'magnitude_spectrum_noise_dB'],\n                  remove_text=True,\n                  extensions=['png'])\ndef test_magnitude_spectrum_noise():\n    '''test axes.magnitude_spectrum with noise stimuli'''\n    np.random.seed(0)\n\n    n = 10000\n    Fs = 100.\n\n    NFFT = int(1000 * Fs / 11)\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    y1 = np.random.standard_normal(n)\n    y2 = np.random.rand(n)\n    y = np.hstack([y1, y2]) - .5\n\n    fig1 = plt.figure()\n    fig2 = plt.figure()\n\n    ax11 = fig1.add_subplot(3, 1, 1)\n    ax12 = fig1.add_subplot(3, 1, 2)\n    ax13 = fig1.add_subplot(3, 1, 3)\n\n    ax21 = fig2.add_subplot(3, 1, 1)\n    ax22 = fig2.add_subplot(3, 1, 2)\n    ax23 = fig2.add_subplot(3, 1, 3)\n\n    spec11, freqs11, line11 = ax11.magnitude_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                                      sides='default')\n    spec12, freqs12, line12 = ax12.magnitude_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                                      sides='onesided')\n    spec13, freqs13, line13 = ax13.magnitude_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                                      sides='twosided')\n\n    spec21, freqs21, line21 = ax21.magnitude_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                                      sides='default',\n                                                      scale='dB')\n    spec22, freqs22, line22 = ax22.magnitude_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                                      sides='onesided',\n                                                      scale='dB')\n    spec23, freqs23, line23 = ax23.magnitude_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                                      sides='twosided',\n                                                      scale='dB')\n\n    ax11.set_xlabel('')\n    ax12.set_xlabel('')\n    ax13.set_xlabel('')\n    ax11.set_ylabel('')\n    ax12.set_ylabel('')\n    ax13.set_ylabel('')\n\n    ax21.set_xlabel('')\n    ax22.set_xlabel('')\n    ax23.set_xlabel('')\n    ax21.set_ylabel('')\n    ax22.set_ylabel('')\n    ax23.set_ylabel('')\n\n\n@image_comparison(baseline_images=['angle_spectrum_freqs'],\n                  remove_text=True,\n                  extensions=['png'])\ndef test_angle_spectrum_freqs():\n    '''test axes.angle_spectrum with sinusoidal stimuli'''\n    n = 10000\n    Fs = 100.\n\n    fstims1 = [Fs/4, Fs/5, Fs/11]\n\n    NFFT = int(1000 * Fs / min(fstims1))\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    x = np.arange(0, n, 1/Fs)\n\n    y = np.zeros(x.size)\n    for i, fstim1 in enumerate(fstims1):\n        y += np.sin(fstim1 * x * np.pi * 2) * 10**i\n    y = y\n\n    fig = plt.figure()\n    ax1 = fig.add_subplot(3, 1, 1)\n    ax2 = fig.add_subplot(3, 1, 2)\n    ax3 = fig.add_subplot(3, 1, 3)\n\n    spec1, freqs1, line1 = ax1.angle_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                              sides='default')\n    spec2, freqs2, line2 = ax2.angle_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                              sides='onesided')\n    spec3, freqs3, line3 = ax3.angle_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                              sides='twosided')\n\n    ax1.set_xlabel('')\n    ax2.set_xlabel('')\n    ax3.set_xlabel('')\n    ax1.set_ylabel('')\n    ax2.set_ylabel('')\n    ax3.set_ylabel('')\n\n\n@image_comparison(baseline_images=['angle_spectrum_noise'],\n                  remove_text=True,\n                  extensions=['png'])\ndef test_angle_spectrum_noise():\n    '''test axes.angle_spectrum with noise stimuli'''\n    np.random.seed(0)\n\n    n = 10000\n    Fs = 100.\n\n    NFFT = int(1000 * Fs / 11)\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    y1 = np.random.standard_normal(n)\n    y2 = np.random.rand(n)\n    y = np.hstack([y1, y2]) - .5\n\n    fig = plt.figure()\n    ax1 = fig.add_subplot(3, 1, 1)\n    ax2 = fig.add_subplot(3, 1, 2)\n    ax3 = fig.add_subplot(3, 1, 3)\n\n    spec1, freqs1, line1 = ax1.angle_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                              sides='default')\n    spec2, freqs2, line2 = ax2.angle_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                              sides='onesided')\n    spec3, freqs3, line3 = ax3.angle_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                              sides='twosided')\n\n    ax1.set_xlabel('')\n    ax2.set_xlabel('')\n    ax3.set_xlabel('')\n    ax1.set_ylabel('')\n    ax2.set_ylabel('')\n    ax3.set_ylabel('')\n\n\n@image_comparison(baseline_images=['phase_spectrum_freqs'],\n                  remove_text=True,\n                  extensions=['png'])\ndef test_phase_spectrum_freqs():\n    '''test axes.phase_spectrum with sinusoidal stimuli'''\n    n = 10000\n    Fs = 100.\n\n    fstims1 = [Fs/4, Fs/5, Fs/11]\n\n    NFFT = int(1000 * Fs / min(fstims1))\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    x = np.arange(0, n, 1/Fs)\n\n    y = np.zeros(x.size)\n    for i, fstim1 in enumerate(fstims1):\n        y += np.sin(fstim1 * x * np.pi * 2) * 10**i\n    y = y\n\n    fig = plt.figure()\n    ax1 = fig.add_subplot(3, 1, 1)\n    ax2 = fig.add_subplot(3, 1, 2)\n    ax3 = fig.add_subplot(3, 1, 3)\n\n    spec1, freqs1, line1 = ax1.phase_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                              sides='default')\n    spec2, freqs2, line2 = ax2.phase_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                              sides='onesided')\n    spec3, freqs3, line3 = ax3.phase_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                              sides='twosided')\n\n    ax1.set_xlabel('')\n    ax2.set_xlabel('')\n    ax3.set_xlabel('')\n    ax1.set_ylabel('')\n    ax2.set_ylabel('')\n    ax3.set_ylabel('')\n\n\n@image_comparison(baseline_images=['phase_spectrum_noise'],\n                  remove_text=True,\n                  extensions=['png'])\ndef test_phase_spectrum_noise():\n    '''test axes.phase_spectrum with noise stimuli'''\n    np.random.seed(0)\n\n    n = 10000\n    Fs = 100.\n\n    NFFT = int(1000 * Fs / 11)\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    y1 = np.random.standard_normal(n)\n    y2 = np.random.rand(n)\n    y = np.hstack([y1, y2]) - .5\n\n    fig = plt.figure()\n    ax1 = fig.add_subplot(3, 1, 1)\n    ax2 = fig.add_subplot(3, 1, 2)\n    ax3 = fig.add_subplot(3, 1, 3)\n\n    spec1, freqs1, line1 = ax1.phase_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                              sides='default')\n    spec2, freqs2, line2 = ax2.phase_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                              sides='onesided')\n    spec3, freqs3, line3 = ax3.phase_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                              sides='twosided')\n\n    ax1.set_xlabel('')\n    ax2.set_xlabel('')\n    ax3.set_xlabel('')\n    ax1.set_ylabel('')\n    ax2.set_ylabel('')\n    ax3.set_ylabel('')\n\n\n@image_comparison(baseline_images=['twin_spines'], remove_text=True,\n                  extensions=['png'])\ndef test_twin_spines():\n\n    def make_patch_spines_invisible(ax):\n        ax.set_frame_on(True)\n        ax.patch.set_visible(False)\n        for sp in six.itervalues(ax.spines):\n            sp.set_visible(False)\n\n    fig = plt.figure(figsize=(4, 3))\n    fig.subplots_adjust(right=0.75)\n\n    host = fig.add_subplot(111)\n    par1 = host.twinx()\n    par2 = host.twinx()\n\n    # Offset the right spine of par2.  The ticks and label have already been\n    # placed on the right by twinx above.\n    par2.spines[\"right\"].set_position((\"axes\", 1.2))\n    # Having been created by twinx, par2 has its frame off, so the line of its\n    # detached spine is invisible.  First, activate the frame but make the patch\n    # and spines invisible.\n    make_patch_spines_invisible(par2)\n    # Second, show the right spine.\n    par2.spines[\"right\"].set_visible(True)\n\n    p1, = host.plot([0, 1, 2], [0, 1, 2], \"b-\")\n    p2, = par1.plot([0, 1, 2], [0, 3, 2], \"r-\")\n    p3, = par2.plot([0, 1, 2], [50, 30, 15], \"g-\")\n\n    host.set_xlim(0, 2)\n    host.set_ylim(0, 2)\n    par1.set_ylim(0, 4)\n    par2.set_ylim(1, 65)\n\n    host.yaxis.label.set_color(p1.get_color())\n    par1.yaxis.label.set_color(p2.get_color())\n    par2.yaxis.label.set_color(p3.get_color())\n\n    tkw = dict(size=4, width=1.5)\n    host.tick_params(axis='y', colors=p1.get_color(), **tkw)\n    par1.tick_params(axis='y', colors=p2.get_color(), **tkw)\n    par2.tick_params(axis='y', colors=p3.get_color(), **tkw)\n    host.tick_params(axis='x', **tkw)\n\n\n@image_comparison(baseline_images=['twin_spines_on_top'], extensions=['png'],\n                  remove_text=True)\ndef test_twin_spines_on_top():\n    matplotlib.rcParams['axes.linewidth'] = 48.0\n    matplotlib.rcParams['lines.linewidth'] = 48.0\n\n    fig = plt.figure()\n    ax1 = fig.add_subplot(1, 1, 1)\n\n    data = np.array([[1000, 1100, 1200, 1250],\n                     [310, 301, 360, 400]])\n\n    ax2 = ax1.twinx()\n\n    ax1.plot(data[0], data[1]/1E3, color='#BEAED4')\n    ax1.fill_between(data[0], data[1]/1E3, color='#BEAED4', alpha=.8)\n\n    ax2.plot(data[0], data[1]/1E3, color='#7FC97F')\n    ax2.fill_between(data[0], data[1]/1E3, color='#7FC97F', alpha=.5)\n\n\n@cleanup\ndef test_rcparam_grid_minor():\n    orig_grid = matplotlib.rcParams['axes.grid']\n    orig_locator = matplotlib.rcParams['axes.grid.which']\n\n    matplotlib.rcParams['axes.grid'] = True\n\n    values = (\n        (('both'), (True, True)),\n        (('major'), (True, False)),\n        (('minor'), (False, True))\n        )\n\n    for locator, result in values:\n        matplotlib.rcParams['axes.grid.which'] = locator\n        fig = plt.figure()\n        ax = fig.add_subplot(1, 1, 1)\n        assert((ax.xaxis._gridOnMajor, ax.xaxis._gridOnMinor) == result)\n\n    matplotlib.rcParams['axes.grid'] = orig_grid\n    matplotlib.rcParams['axes.grid.which'] = orig_locator\n\n\n@cleanup\ndef test_vline_limit():\n    fig = plt.figure()\n    ax = fig.gca()\n    ax.axvline(0.5)\n    ax.plot([-0.1, 0, 0.2, 0.1])\n    (ymin, ymax) = ax.get_ylim()\n    assert ymin == -0.1\n    assert ymax == 0.25\n\n\n@cleanup\ndef test_empty_shared_subplots():\n    # empty plots with shared axes inherit limits from populated plots\n    fig, axes = plt.subplots(nrows=1, ncols=2, sharex=True, sharey=True)\n    axes[0].plot([1, 2, 3], [2, 4, 6])\n    x0, x1 = axes[1].get_xlim()\n    y0, y1 = axes[1].get_ylim()\n    assert x0 <= 1\n    assert x1 >= 3\n    assert y0 <= 2\n    assert y1 >= 6\n\n\n@cleanup\ndef test_relim_visible_only():\n    x1 = (0., 10.)\n    y1 = (0., 10.)\n    x2 = (-10., 20.)\n    y2 = (-10., 30.)\n\n    fig = matplotlib.figure.Figure()\n    ax = fig.add_subplot(111)\n    ax.plot(x1, y1)\n    assert ax.get_xlim() == x1\n    assert ax.get_ylim() == y1\n    l = ax.plot(x2, y2)\n    assert ax.get_xlim() == x2\n    assert ax.get_ylim() == y2\n    l[0].set_visible(False)\n    assert ax.get_xlim() == x2\n    assert ax.get_ylim() == y2\n\n    ax.relim(visible_only=True)\n    ax.autoscale_view()\n\n    assert ax.get_xlim() == x1\n    assert ax.get_ylim() == y1\n\n\n@cleanup\ndef test_text_labelsize():\n    \"\"\"\n    tests for issue #1172\n    \"\"\"\n    fig = plt.figure()\n    ax = fig.gca()\n    ax.tick_params(labelsize='large')\n    ax.tick_params(direction='out')\n\n\n@image_comparison(baseline_images=['pie_linewidth_0'], extensions=['png'])\ndef test_pie_linewidth_0():\n    # The slices will be ordered and plotted counter-clockwise.\n    labels = 'Frogs', 'Hogs', 'Dogs', 'Logs'\n    sizes = [15, 30, 45, 10]\n    colors = ['yellowgreen', 'gold', 'lightskyblue', 'lightcoral']\n    explode = (0, 0.1, 0, 0)  # only \"explode\" the 2nd slice (i.e. 'Hogs')\n\n    plt.pie(sizes, explode=explode, labels=labels, colors=colors,\n            autopct='%1.1f%%', shadow=True, startangle=90,\n            wedgeprops={'linewidth': 0})\n    # Set aspect ratio to be equal so that pie is drawn as a circle.\n    plt.axis('equal')\n\n\n@image_comparison(baseline_images=['pie_linewidth_2'], extensions=['png'])\ndef test_pie_linewidth_2():\n    # The slices will be ordered and plotted counter-clockwise.\n    labels = 'Frogs', 'Hogs', 'Dogs', 'Logs'\n    sizes = [15, 30, 45, 10]\n    colors = ['yellowgreen', 'gold', 'lightskyblue', 'lightcoral']\n    explode = (0, 0.1, 0, 0)  # only \"explode\" the 2nd slice (i.e. 'Hogs')\n\n    plt.pie(sizes, explode=explode, labels=labels, colors=colors,\n            autopct='%1.1f%%', shadow=True, startangle=90,\n            wedgeprops={'linewidth': 2})\n    # Set aspect ratio to be equal so that pie is drawn as a circle.\n    plt.axis('equal')\n\n\n@image_comparison(baseline_images=['pie_ccw_true'], extensions=['png'])\ndef test_pie_ccw_true():\n    # The slices will be ordered and plotted counter-clockwise.\n    labels = 'Frogs', 'Hogs', 'Dogs', 'Logs'\n    sizes = [15, 30, 45, 10]\n    colors = ['yellowgreen', 'gold', 'lightskyblue', 'lightcoral']\n    explode = (0, 0.1, 0, 0)  # only \"explode\" the 2nd slice (i.e. 'Hogs')\n\n    plt.pie(sizes, explode=explode, labels=labels, colors=colors,\n            autopct='%1.1f%%', shadow=True, startangle=90,\n            counterclock=True)\n    # Set aspect ratio to be equal so that pie is drawn as a circle.\n    plt.axis('equal')\n\n\n@cleanup\ndef test_margins():\n    # test all ways margins can be called\n    data = [1, 10]\n\n    fig1, ax1 = plt.subplots(1, 1)\n    ax1.plot(data)\n    ax1.margins(1)\n    assert_equal(ax1.margins(), (1, 1))\n\n    fig2, ax2 = plt.subplots(1, 1)\n    ax2.plot(data)\n    ax2.margins(1, 0.5)\n    assert_equal(ax2.margins(), (1, 0.5))\n\n    fig3, ax3 = plt.subplots(1, 1)\n    ax3.plot(data)\n    ax3.margins(x=1, y=0.5)\n    assert_equal(ax3.margins(), (1, 0.5))\n\n\n@cleanup\ndef test_pathological_hexbin():\n    # issue #2863\n    out = io.BytesIO()\n\n    with warnings.catch_warnings(record=True) as w:\n        mylist = [10] * 100\n        fig, ax = plt.subplots(1, 1)\n        ax.hexbin(mylist, mylist)\n        fig.savefig(out)\n        assert_equal(len(w), 0)\n\n\nif __name__ == '__main__':\n    import nose\n    import sys\n\n    args = ['-s', '--with-doctest']\n    argv = sys.argv\n    argv = argv[:1] + args + argv[1:]\n    nose.runmodule(argv=argv, exit=False)\n", "patch": "@@ -4,6 +4,8 @@\n import six\n from six.moves import xrange\n \n+import io\n+\n from nose.tools import assert_equal, assert_raises\n import datetime\n \n@@ -3392,11 +3394,13 @@ def test_margins():\n @cleanup\n def test_pathological_hexbin():\n     # issue #2863\n+    out = io.BytesIO()\n+\n     with warnings.catch_warnings(record=True) as w:\n         mylist = [10] * 100\n         fig, ax = plt.subplots(1, 1)\n         ax.hexbin(mylist, mylist)\n-        plt.show()\n+        fig.savefig(out)\n         assert_equal(len(w), 0)\n \n "}
{"patches_id": 2, "files_id": 24, "language": "py", "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Ftransforms.py", "raw_code": "\"\"\"\nmatplotlib includes a framework for arbitrary geometric\ntransformations that is used determine the final position of all\nelements drawn on the canvas.\n\nTransforms are composed into trees of :class:`TransformNode` objects\nwhose actual value depends on their children.  When the contents of\nchildren change, their parents are automatically invalidated.  The\nnext time an invalidated transform is accessed, it is recomputed to\nreflect those changes.  This invalidation/caching approach prevents\nunnecessary recomputations of transforms, and contributes to better\ninteractive performance.\n\nFor example, here is a graph of the transform tree used to plot data\nto the graph:\n\n.. image:: ../_static/transforms.png\n\nThe framework can be used for both affine and non-affine\ntransformations.  However, for speed, we want use the backend\nrenderers to perform affine transformations whenever possible.\nTherefore, it is possible to perform just the affine or non-affine\npart of a transformation on a set of data.  The affine is always\nassumed to occur after the non-affine.  For any transform::\n\n  full transform == non-affine part + affine part\n\nThe backends are not expected to handle non-affine transformations\nthemselves.\n\"\"\"\n\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport six\n\nimport numpy as np\nfrom numpy import ma\nfrom matplotlib._path import (affine_transform, count_bboxes_overlapping_bbox,\n    update_path_extents)\nfrom numpy.linalg import inv\n\nfrom weakref import WeakValueDictionary\nimport warnings\ntry:\n    set\nexcept NameError:\n    from sets import Set as set\n\nfrom .path import Path\n\nDEBUG = False\n\nMaskedArray = ma.MaskedArray\n\n\nclass TransformNode(object):\n    \"\"\"\n    :class:`TransformNode` is the base class for anything that\n    participates in the transform tree and needs to invalidate its\n    parents or be invalidated.  This includes classes that are not\n    really transforms, such as bounding boxes, since some transforms\n    depend on bounding boxes to compute their values.\n    \"\"\"\n    _gid = 0\n\n    # Invalidation may affect only the affine part.  If the\n    # invalidation was \"affine-only\", the _invalid member is set to\n    # INVALID_AFFINE_ONLY\n    INVALID_NON_AFFINE = 1\n    INVALID_AFFINE = 2\n    INVALID = INVALID_NON_AFFINE | INVALID_AFFINE\n\n    # Some metadata about the transform, used to determine whether an\n    # invalidation is affine-only\n    is_affine = False\n    is_bbox = False\n\n    pass_through = False\n    \"\"\"\n    If pass_through is True, all ancestors will always be\n    invalidated, even if 'self' is already invalid.\n    \"\"\"\n\n    def __init__(self, shorthand_name=None):\n        \"\"\"\n        Creates a new :class:`TransformNode`.\n\n        **shorthand_name** - a string representing the \"name\" of this\n                             transform. The name carries no significance\n                             other than to improve the readability of\n                             ``str(transform)`` when DEBUG=True.\n        \"\"\"\n        # Parents are stored in a WeakValueDictionary, so that if the\n        # parents are deleted, references from the children won't keep\n        # them alive.\n        self._parents = WeakValueDictionary()\n\n        # TransformNodes start out as invalid until their values are\n        # computed for the first time.\n        self._invalid = 1\n        self._shorthand_name = shorthand_name or ''\n\n    if DEBUG:\n        def __str__(self):\n            # either just return the name of this TransformNode, or it's repr\n            return self._shorthand_name or repr(self)\n\n    def __getstate__(self):\n        d = self.__dict__.copy()\n        # turn the weakkey dictionary into a normal dictionary\n        d['_parents'] = dict(six.iteritems(self._parents))\n        return d\n\n    def __setstate__(self, data_dict):\n        self.__dict__ = data_dict\n        # turn the normal dictionary back into a WeakValueDictionary\n        self._parents = WeakValueDictionary(self._parents)\n\n    def __copy__(self, *args):\n        raise NotImplementedError(\n            \"TransformNode instances can not be copied. \" +\n            \"Consider using frozen() instead.\")\n    __deepcopy__ = __copy__\n\n    def invalidate(self):\n        \"\"\"\n        Invalidate this :class:`TransformNode` and triggers an\n        invalidation of its ancestors.  Should be called any\n        time the transform changes.\n        \"\"\"\n        value = self.INVALID\n        if self.is_affine:\n            value = self.INVALID_AFFINE\n        return self._invalidate_internal(value, invalidating_node=self)\n\n    def _invalidate_internal(self, value, invalidating_node):\n        \"\"\"\n        Called by :meth:`invalidate` and subsequently ascends the transform\n        stack calling each TransformNode's _invalidate_internal method.\n        \"\"\"\n        # determine if this call will be an extension to the invalidation\n        # status. If not, then a shortcut means that we needn't invoke an\n        # invalidation up the transform stack as it will already have been\n        # invalidated.\n\n        # N.B This makes the invalidation sticky, once a transform has been\n        # invalidated as NON_AFFINE, then it will always be invalidated as\n        # NON_AFFINE even when triggered with a AFFINE_ONLY invalidation.\n        # In most cases this is not a problem (i.e. for interactive panning and\n        # zooming) and the only side effect will be on performance.\n        status_changed = self._invalid < value\n\n        if self.pass_through or status_changed:\n            self._invalid = value\n\n            for parent in list(six.itervalues(self._parents)):\n                parent._invalidate_internal(value=value,\n                                            invalidating_node=self)\n\n    def set_children(self, *children):\n        \"\"\"\n        Set the children of the transform, to let the invalidation\n        system know which transforms can invalidate this transform.\n        Should be called from the constructor of any transforms that\n        depend on other transforms.\n        \"\"\"\n        for child in children:\n            child._parents[id(self)] = self\n\n    if DEBUG:\n        _set_children = set_children\n\n        def set_children(self, *children):\n            self._set_children(*children)\n            self._children = children\n        set_children.__doc__ = _set_children.__doc__\n\n    def frozen(self):\n        \"\"\"\n        Returns a frozen copy of this transform node.  The frozen copy\n        will not update when its children change.  Useful for storing\n        a previously known state of a transform where\n        ``copy.deepcopy()`` might normally be used.\n        \"\"\"\n        return self\n\n    if DEBUG:\n        def write_graphviz(self, fobj, highlight=[]):\n            \"\"\"\n            For debugging purposes.\n\n            Writes the transform tree rooted at 'self' to a graphviz \"dot\"\n            format file.  This file can be run through the \"dot\" utility\n            to produce a graph of the transform tree.\n\n            Affine transforms are marked in blue.  Bounding boxes are\n            marked in yellow.\n\n            *fobj*: A Python file-like object\n\n            Once the \"dot\" file has been created, it can be turned into a\n            png easily with::\n\n                $> dot -Tpng -o $OUTPUT_FILE $DOT_FILE\n\n            \"\"\"\n            seen = set()\n\n            def recurse(root):\n                if root in seen:\n                    return\n                seen.add(root)\n                props = {}\n                label = root.__class__.__name__\n                if root._invalid:\n                    label = '[%s]' % label\n                if root in highlight:\n                    props['style'] = 'bold'\n                props['shape'] = 'box'\n                props['label'] = '\"%s\"' % label\n                props = ' '.join(['%s=%s' % (key, val)\n                                  for key, val\n                                  in six.iteritems(props)])\n\n                fobj.write('%s [%s];\\n' %\n                           (hash(root), props))\n\n                if hasattr(root, '_children'):\n                    for child in root._children:\n                        name = '?'\n                        for key, val in six.iteritems(root.__dict__):\n                            if val is child:\n                                name = key\n                                break\n                        fobj.write('\"%s\" -> \"%s\" [label=\"%s\", fontsize=10];\\n'\n                                    % (hash(root),\n                                    hash(child),\n                                    name))\n                        recurse(child)\n\n            fobj.write(\"digraph G {\\n\")\n            recurse(self)\n            fobj.write(\"}\\n\")\n\n\nclass BboxBase(TransformNode):\n    \"\"\"\n    This is the base class of all bounding boxes, and provides\n    read-only access to its data.  A mutable bounding box is provided\n    by the :class:`Bbox` class.\n\n    The canonical representation is as two points, with no\n    restrictions on their ordering.  Convenience properties are\n    provided to get the left, bottom, right and top edges and width\n    and height, but these are not stored explicitly.\n    \"\"\"\n    is_bbox = True\n    is_affine = True\n\n    #* Redundant: Removed for performance\n    #\n    # def __init__(self):\n    #     TransformNode.__init__(self)\n\n    if DEBUG:\n        def _check(points):\n            if ma.isMaskedArray(points):\n                warnings.warn(\"Bbox bounds are a masked array.\")\n            points = np.asarray(points)\n            if (points[1, 0] - points[0, 0] == 0 or\n                points[1, 1] - points[0, 1] == 0):\n                warnings.warn(\"Singular Bbox.\")\n        _check = staticmethod(_check)\n\n    def frozen(self):\n        return Bbox(self.get_points().copy())\n    frozen.__doc__ = TransformNode.__doc__\n\n    def __array__(self, *args, **kwargs):\n        return self.get_points()\n\n    def is_unit(self):\n        \"\"\"\n        Returns True if the :class:`Bbox` is the unit bounding box\n        from (0, 0) to (1, 1).\n        \"\"\"\n        return list(self.get_points().flatten()) == [0., 0., 1., 1.]\n\n    def _get_x0(self):\n        return self.get_points()[0, 0]\n    x0 = property(_get_x0, None, None, \"\"\"\n         (property) :attr:`x0` is the first of the pair of *x* coordinates that\n         define the bounding box.  :attr:`x0` is not guaranteed to be\n         less than :attr:`x1`.  If you require that, use :attr:`xmin`.\"\"\")\n\n    def _get_y0(self):\n        return self.get_points()[0, 1]\n    y0 = property(_get_y0, None, None, \"\"\"\n         (property) :attr:`y0` is the first of the pair of *y* coordinates that\n         define the bounding box.  :attr:`y0` is not guaranteed to be\n         less than :attr:`y1`.  If you require that, use :attr:`ymin`.\"\"\")\n\n    def _get_x1(self):\n        return self.get_points()[1, 0]\n    x1 = property(_get_x1, None, None, \"\"\"\n         (property) :attr:`x1` is the second of the pair of *x* coordinates\n         that define the bounding box.  :attr:`x1` is not guaranteed to be\n         greater than :attr:`x0`.  If you require that, use :attr:`xmax`.\"\"\")\n\n    def _get_y1(self):\n        return self.get_points()[1, 1]\n    y1 = property(_get_y1, None, None, \"\"\"\n         (property) :attr:`y1` is the second of the pair of *y* coordinates\n         that define the bounding box.  :attr:`y1` is not guaranteed to be\n         greater than :attr:`y0`.  If you require that, use :attr:`ymax`.\"\"\")\n\n    def _get_p0(self):\n        return self.get_points()[0]\n    p0 = property(_get_p0, None, None, \"\"\"\n         (property) :attr:`p0` is the first pair of (*x*, *y*) coordinates\n         that define the bounding box.  It is not guaranteed to be the\n         bottom-left corner.  For that, use :attr:`min`.\"\"\")\n\n    def _get_p1(self):\n        return self.get_points()[1]\n    p1 = property(_get_p1, None, None, \"\"\"\n         (property) :attr:`p1` is the second pair of (*x*, *y*) coordinates\n         that define the bounding box.  It is not guaranteed to be the\n         top-right corner.  For that, use :attr:`max`.\"\"\")\n\n    def _get_xmin(self):\n        return min(self.get_points()[:, 0])\n    xmin = property(_get_xmin, None, None, \"\"\"\n        (property) :attr:`xmin` is the left edge of the bounding box.\"\"\")\n\n    def _get_ymin(self):\n        return min(self.get_points()[:, 1])\n    ymin = property(_get_ymin, None, None, \"\"\"\n        (property) :attr:`ymin` is the bottom edge of the bounding box.\"\"\")\n\n    def _get_xmax(self):\n        return max(self.get_points()[:, 0])\n    xmax = property(_get_xmax, None, None, \"\"\"\n        (property) :attr:`xmax` is the right edge of the bounding box.\"\"\")\n\n    def _get_ymax(self):\n        return max(self.get_points()[:, 1])\n    ymax = property(_get_ymax, None, None, \"\"\"\n        (property) :attr:`ymax` is the top edge of the bounding box.\"\"\")\n\n    def _get_min(self):\n        return [min(self.get_points()[:, 0]),\n                min(self.get_points()[:, 1])]\n    min = property(_get_min, None, None, \"\"\"\n        (property) :attr:`min` is the bottom-left corner of the bounding\n        box.\"\"\")\n\n    def _get_max(self):\n        return [max(self.get_points()[:, 0]),\n                max(self.get_points()[:, 1])]\n    max = property(_get_max, None, None, \"\"\"\n        (property) :attr:`max` is the top-right corner of the bounding box.\"\"\")\n\n    def _get_intervalx(self):\n        return self.get_points()[:, 0]\n    intervalx = property(_get_intervalx, None, None, \"\"\"\n        (property) :attr:`intervalx` is the pair of *x* coordinates that define\n        the bounding box. It is not guaranteed to be sorted from left to\n        right.\"\"\")\n\n    def _get_intervaly(self):\n        return self.get_points()[:, 1]\n    intervaly = property(_get_intervaly, None, None, \"\"\"\n        (property) :attr:`intervaly` is the pair of *y* coordinates that define\n        the bounding box.  It is not guaranteed to be sorted from bottom to\n        top.\"\"\")\n\n    def _get_width(self):\n        points = self.get_points()\n        return points[1, 0] - points[0, 0]\n    width = property(_get_width, None, None, \"\"\"\n        (property) The width of the bounding box.  It may be negative if\n        :attr:`x1` < :attr:`x0`.\"\"\")\n\n    def _get_height(self):\n        points = self.get_points()\n        return points[1, 1] - points[0, 1]\n    height = property(_get_height, None, None, \"\"\"\n        (property) The height of the bounding box.  It may be negative if\n        :attr:`y1` < :attr:`y0`.\"\"\")\n\n    def _get_size(self):\n        points = self.get_points()\n        return points[1] - points[0]\n    size = property(_get_size, None, None, \"\"\"\n        (property) The width and height of the bounding box.  May be negative,\n        in the same way as :attr:`width` and :attr:`height`.\"\"\")\n\n    def _get_bounds(self):\n        x0, y0, x1, y1 = self.get_points().flatten()\n        return (x0, y0, x1 - x0, y1 - y0)\n    bounds = property(_get_bounds, None, None, \"\"\"\n        (property) Returns (:attr:`x0`, :attr:`y0`, :attr:`width`,\n        :attr:`height`).\"\"\")\n\n    def _get_extents(self):\n        return self.get_points().flatten().copy()\n    extents = property(_get_extents, None, None, \"\"\"\n        (property) Returns (:attr:`x0`, :attr:`y0`, :attr:`x1`,\n        :attr:`y1`).\"\"\")\n\n    def get_points(self):\n        return NotImplementedError()\n\n    def containsx(self, x):\n        \"\"\"\n        Returns True if *x* is between or equal to :attr:`x0` and\n        :attr:`x1`.\n        \"\"\"\n        x0, x1 = self.intervalx\n        return ((x0 < x1\n                 and (x >= x0 and x <= x1))\n                or (x >= x1 and x <= x0))\n\n    def containsy(self, y):\n        \"\"\"\n        Returns True if *y* is between or equal to :attr:`y0` and\n        :attr:`y1`.\n        \"\"\"\n        y0, y1 = self.intervaly\n        return ((y0 < y1\n                 and (y >= y0 and y <= y1))\n                or (y >= y1 and y <= y0))\n\n    def contains(self, x, y):\n        \"\"\"\n        Returns *True* if (*x*, *y*) is a coordinate inside the\n        bounding box or on its edge.\n        \"\"\"\n        return self.containsx(x) and self.containsy(y)\n\n    def overlaps(self, other):\n        \"\"\"\n        Returns True if this bounding box overlaps with the given\n        bounding box *other*.\n        \"\"\"\n        ax1, ay1, ax2, ay2 = self._get_extents()\n        bx1, by1, bx2, by2 = other._get_extents()\n\n        if ax2 < ax1:\n            ax2, ax1 = ax1, ax2\n        if ay2 < ay1:\n            ay2, ay1 = ay1, ay2\n        if bx2 < bx1:\n            bx2, bx1 = bx1, bx2\n        if by2 < by1:\n            by2, by1 = by1, by2\n\n        return not ((bx2 < ax1) or\n                    (by2 < ay1) or\n                    (bx1 > ax2) or\n                    (by1 > ay2))\n\n    def fully_containsx(self, x):\n        \"\"\"\n        Returns True if *x* is between but not equal to :attr:`x0` and\n        :attr:`x1`.\n        \"\"\"\n        x0, x1 = self.intervalx\n        return ((x0 < x1\n                 and (x > x0 and x < x1))\n                or (x > x1 and x < x0))\n\n    def fully_containsy(self, y):\n        \"\"\"\n        Returns True if *y* is between but not equal to :attr:`y0` and\n        :attr:`y1`.\n        \"\"\"\n        y0, y1 = self.intervaly\n        return ((y0 < y1\n                 and (y > y0 and y < y1))\n                or (y > y1 and y < y0))\n\n    def fully_contains(self, x, y):\n        \"\"\"\n        Returns True if (*x*, *y*) is a coordinate inside the bounding\n        box, but not on its edge.\n        \"\"\"\n        return self.fully_containsx(x) \\\n            and self.fully_containsy(y)\n\n    def fully_overlaps(self, other):\n        \"\"\"\n        Returns True if this bounding box overlaps with the given\n        bounding box *other*, but not on its edge alone.\n        \"\"\"\n        ax1, ay1, ax2, ay2 = self._get_extents()\n        bx1, by1, bx2, by2 = other._get_extents()\n\n        if ax2 < ax1:\n            ax2, ax1 = ax1, ax2\n        if ay2 < ay1:\n            ay2, ay1 = ay1, ay2\n        if bx2 < bx1:\n            bx2, bx1 = bx1, bx2\n        if by2 < by1:\n            by2, by1 = by1, by2\n\n        return not ((bx2 <= ax1) or\n                    (by2 <= ay1) or\n                    (bx1 >= ax2) or\n                    (by1 >= ay2))\n\n    def transformed(self, transform):\n        \"\"\"\n        Return a new :class:`Bbox` object, statically transformed by\n        the given transform.\n        \"\"\"\n        pts = self.get_points()\n        ll, ul, lr = transform.transform(np.array([pts[0],\n            [pts[0, 0], pts[1, 1]], [pts[1, 0], pts[0, 1]]]))\n        return Bbox([ll, [lr[0], ul[1]]])\n\n    def inverse_transformed(self, transform):\n        \"\"\"\n        Return a new :class:`Bbox` object, statically transformed by\n        the inverse of the given transform.\n        \"\"\"\n        return self.transformed(transform.inverted())\n\n    coefs = {'C':  (0.5, 0.5),\n             'SW': (0, 0),\n             'S':  (0.5, 0),\n             'SE': (1.0, 0),\n             'E':  (1.0, 0.5),\n             'NE': (1.0, 1.0),\n             'N':  (0.5, 1.0),\n             'NW': (0, 1.0),\n             'W':  (0, 0.5)}\n\n    def anchored(self, c, container=None):\n        \"\"\"\n        Return a copy of the :class:`Bbox`, shifted to position *c*\n        within a container.\n\n        *c*: may be either:\n\n          * a sequence (*cx*, *cy*) where *cx* and *cy* range from 0\n            to 1, where 0 is left or bottom and 1 is right or top\n\n          * a string:\n            - 'C' for centered\n            - 'S' for bottom-center\n            - 'SE' for bottom-left\n            - 'E' for left\n            - etc.\n\n        Optional argument *container* is the box within which the\n        :class:`Bbox` is positioned; it defaults to the initial\n        :class:`Bbox`.\n        \"\"\"\n        if container is None:\n            container = self\n        l, b, w, h = container.bounds\n        if isinstance(c, six.string_types):\n            cx, cy = self.coefs[c]\n        else:\n            cx, cy = c\n        L, B, W, H = self.bounds\n        return Bbox(self._points +\n                    [(l + cx * (w - W)) - L,\n                     (b + cy * (h - H)) - B])\n\n    def shrunk(self, mx, my):\n        \"\"\"\n        Return a copy of the :class:`Bbox`, shrunk by the factor *mx*\n        in the *x* direction and the factor *my* in the *y* direction.\n        The lower left corner of the box remains unchanged.  Normally\n        *mx* and *my* will be less than 1, but this is not enforced.\n        \"\"\"\n        w, h = self.size\n        return Bbox([self._points[0],\n                    self._points[0] + [mx * w, my * h]])\n\n    def shrunk_to_aspect(self, box_aspect, container=None, fig_aspect=1.0):\n        \"\"\"\n        Return a copy of the :class:`Bbox`, shrunk so that it is as\n        large as it can be while having the desired aspect ratio,\n        *box_aspect*.  If the box coordinates are relative---that\n        is, fractions of a larger box such as a figure---then the\n        physical aspect ratio of that figure is specified with\n        *fig_aspect*, so that *box_aspect* can also be given as a\n        ratio of the absolute dimensions, not the relative dimensions.\n        \"\"\"\n        assert box_aspect > 0 and fig_aspect > 0\n        if container is None:\n            container = self\n        w, h = container.size\n        H = w * box_aspect / fig_aspect\n        if H <= h:\n            W = w\n        else:\n            W = h * fig_aspect / box_aspect\n            H = h\n        return Bbox([self._points[0],\n                     self._points[0] + (W, H)])\n\n    def splitx(self, *args):\n        \"\"\"\n        e.g., ``bbox.splitx(f1, f2, ...)``\n\n        Returns a list of new :class:`Bbox` objects formed by\n        splitting the original one with vertical lines at fractional\n        positions *f1*, *f2*, ...\n        \"\"\"\n        boxes = []\n        xf = [0] + list(args) + [1]\n        x0, y0, x1, y1 = self._get_extents()\n        w = x1 - x0\n        for xf0, xf1 in zip(xf[:-1], xf[1:]):\n            boxes.append(Bbox([[x0 + xf0 * w, y0], [x0 + xf1 * w, y1]]))\n        return boxes\n\n    def splity(self, *args):\n        \"\"\"\n        e.g., ``bbox.splitx(f1, f2, ...)``\n\n        Returns a list of new :class:`Bbox` objects formed by\n        splitting the original one with horizontal lines at fractional\n        positions *f1*, *f2*, ...\n        \"\"\"\n        boxes = []\n        yf = [0] + list(args) + [1]\n        x0, y0, x1, y1 = self._get_extents()\n        h = y1 - y0\n        for yf0, yf1 in zip(yf[:-1], yf[1:]):\n            boxes.append(Bbox([[x0, y0 + yf0 * h], [x1, y0 + yf1 * h]]))\n        return boxes\n\n    def count_contains(self, vertices):\n        \"\"\"\n        Count the number of vertices contained in the :class:`Bbox`.\n\n        *vertices* is a Nx2 Numpy array.\n        \"\"\"\n        if len(vertices) == 0:\n            return 0\n        vertices = np.asarray(vertices)\n        x0, y0, x1, y1 = self._get_extents()\n        with np.errstate(invalid='ignore'):\n            dx0 = np.sign(vertices[:, 0] - x0)\n            dy0 = np.sign(vertices[:, 1] - y0)\n            dx1 = np.sign(vertices[:, 0] - x1)\n            dy1 = np.sign(vertices[:, 1] - y1)\n        inside = ((abs(dx0 + dx1) + abs(dy0 + dy1)) == 0)\n        return np.sum(inside)\n\n    def count_overlaps(self, bboxes):\n        \"\"\"\n        Count the number of bounding boxes that overlap this one.\n\n        bboxes is a sequence of :class:`BboxBase` objects\n        \"\"\"\n        return count_bboxes_overlapping_bbox(self, [np.array(x) for x in bboxes])\n\n    def expanded(self, sw, sh):\n        \"\"\"\n        Return a new :class:`Bbox` which is this :class:`Bbox`\n        expanded around its center by the given factors *sw* and\n        *sh*.\n        \"\"\"\n        width = self.width\n        height = self.height\n        deltaw = (sw * width - width) / 2.0\n        deltah = (sh * height - height) / 2.0\n        a = np.array([[-deltaw, -deltah], [deltaw, deltah]])\n        return Bbox(self._points + a)\n\n    def padded(self, p):\n        \"\"\"\n        Return a new :class:`Bbox` that is padded on all four sides by\n        the given value.\n        \"\"\"\n        points = self.get_points()\n        return Bbox(points + [[-p, -p], [p, p]])\n\n    def translated(self, tx, ty):\n        \"\"\"\n        Return a copy of the :class:`Bbox`, statically translated by\n        *tx* and *ty*.\n        \"\"\"\n        return Bbox(self._points + (tx, ty))\n\n    def corners(self):\n        \"\"\"\n        Return an array of points which are the four corners of this\n        rectangle.  For example, if this :class:`Bbox` is defined by\n        the points (*a*, *b*) and (*c*, *d*), :meth:`corners` returns\n        (*a*, *b*), (*a*, *d*), (*c*, *b*) and (*c*, *d*).\n        \"\"\"\n        l, b, r, t = self.get_points().flatten()\n        return np.array([[l, b], [l, t], [r, b], [r, t]])\n\n    def rotated(self, radians):\n        \"\"\"\n        Return a new bounding box that bounds a rotated version of\n        this bounding box by the given radians.  The new bounding box\n        is still aligned with the axes, of course.\n        \"\"\"\n        corners = self.corners()\n        corners_rotated = Affine2D().rotate(radians).transform(corners)\n        bbox = Bbox.unit()\n        bbox.update_from_data_xy(corners_rotated, ignore=True)\n        return bbox\n\n    @staticmethod\n    def union(bboxes):\n        \"\"\"\n        Return a :class:`Bbox` that contains all of the given bboxes.\n        \"\"\"\n        assert(len(bboxes))\n\n        if len(bboxes) == 1:\n            return bboxes[0]\n\n        x0 = np.inf\n        y0 = np.inf\n        x1 = -np.inf\n        y1 = -np.inf\n\n        for bbox in bboxes:\n            points = bbox.get_points()\n            xs = points[:, 0]\n            ys = points[:, 1]\n            x0 = min(x0, np.min(xs))\n            y0 = min(y0, np.min(ys))\n            x1 = max(x1, np.max(xs))\n            y1 = max(y1, np.max(ys))\n\n        return Bbox.from_extents(x0, y0, x1, y1)\n\n    @staticmethod\n    def intersection(bbox1, bbox2):\n        \"\"\"\n        Return the intersection of the two bboxes or None\n        if they do not intersect.\n\n        Implements the algorithm described at:\n\n            http://www.tekpool.com/node/2687\n\n        \"\"\"\n        intersects = not (bbox2.xmin > bbox1.xmax or\n                          bbox2.xmax < bbox1.xmin or\n                          bbox2.ymin > bbox1.ymax or\n                          bbox2.ymax < bbox1.ymin)\n\n        if intersects:\n            x0 = max([bbox1.xmin, bbox2.xmin])\n            x1 = min([bbox1.xmax, bbox2.xmax])\n            y0 = max([bbox1.ymin, bbox2.ymin])\n            y1 = min([bbox1.ymax, bbox2.ymax])\n            return Bbox.from_extents(x0, y0, x1, y1)\n\n        return None\n\n\nclass Bbox(BboxBase):\n    \"\"\"\n    A mutable bounding box.\n    \"\"\"\n\n    def __init__(self, points, **kwargs):\n        \"\"\"\n        *points*: a 2x2 numpy array of the form [[x0, y0], [x1, y1]]\n\n        If you need to create a :class:`Bbox` object from another form\n        of data, consider the static methods :meth:`unit`,\n        :meth:`from_bounds` and :meth:`from_extents`.\n        \"\"\"\n        BboxBase.__init__(self, **kwargs)\n        points = np.asarray(points, np.float_)\n        if points.shape != (2, 2):\n            raise ValueError('Bbox points must be of the form '\n                             '\"[[x0, y0], [x1, y1]]\".')\n        self._points = points\n        self._minpos = np.array([0.0000001, 0.0000001])\n        self._ignore = True\n        # it is helpful in some contexts to know if the bbox is a\n        # default or has been mutated; we store the orig points to\n        # support the mutated methods\n        self._points_orig = self._points.copy()\n    if DEBUG:\n        ___init__ = __init__\n\n        def __init__(self, points, **kwargs):\n            self._check(points)\n            self.___init__(points, **kwargs)\n\n        def invalidate(self):\n            self._check(self._points)\n            TransformNode.invalidate(self)\n\n    @staticmethod\n    def unit():\n        \"\"\"\n        (staticmethod) Create a new unit :class:`Bbox` from (0, 0) to\n        (1, 1).\n        \"\"\"\n        return Bbox(np.array([[0.0, 0.0], [1.0, 1.0]], np.float))\n\n    @staticmethod\n    def null():\n        \"\"\"\n        (staticmethod) Create a new null :class:`Bbox` from (inf, inf) to\n        (-inf, -inf).\n        \"\"\"\n        return Bbox(np.array([[np.inf, np.inf], [-np.inf, -np.inf]], np.float))\n\n    @staticmethod\n    def from_bounds(x0, y0, width, height):\n        \"\"\"\n        (staticmethod) Create a new :class:`Bbox` from *x0*, *y0*,\n        *width* and *height*.\n\n        *width* and *height* may be negative.\n        \"\"\"\n        return Bbox.from_extents(x0, y0, x0 + width, y0 + height)\n\n    @staticmethod\n    def from_extents(*args):\n        \"\"\"\n        (staticmethod) Create a new Bbox from *left*, *bottom*,\n        *right* and *top*.\n\n        The *y*-axis increases upwards.\n        \"\"\"\n        points = np.array(args, dtype=np.float_).reshape(2, 2)\n        return Bbox(points)\n\n    def __format__(self, fmt):\n        return (\n            'Bbox(x0={0.x0:{1}}, y0={0.y0:{1}}, x1={0.x1:{1}}, y1={0.y1:{1}})'.\n            format(self, fmt))\n\n    def __str__(self):\n        return format(self, '')\n\n    def __repr__(self):\n        return 'Bbox([[{0.x0}, {0.y0}], [{0.x1}, {0.y1}]])'.format(self)\n\n    def ignore(self, value):\n        \"\"\"\n        Set whether the existing bounds of the box should be ignored\n        by subsequent calls to :meth:`update_from_data` or\n        :meth:`update_from_data_xy`.\n\n        *value*:\n\n           - When True, subsequent calls to :meth:`update_from_data`\n             will ignore the existing bounds of the :class:`Bbox`.\n\n           - When False, subsequent calls to :meth:`update_from_data`\n             will include the existing bounds of the :class:`Bbox`.\n        \"\"\"\n        self._ignore = value\n\n    def update_from_data(self, x, y, ignore=None):\n        \"\"\"\n        Update the bounds of the :class:`Bbox` based on the passed in\n        data.  After updating, the bounds will have positive *width*\n        and *height*; *x0* and *y0* will be the minimal values.\n\n        *x*: a numpy array of *x*-values\n\n        *y*: a numpy array of *y*-values\n\n        *ignore*:\n           - when True, ignore the existing bounds of the :class:`Bbox`.\n           - when False, include the existing bounds of the :class:`Bbox`.\n           - when None, use the last value passed to :meth:`ignore`.\n        \"\"\"\n        warnings.warn(\n            \"update_from_data requires a memory copy -- please replace with \"\n            \"update_from_data_xy\")\n\n        xy = np.hstack((x.reshape((len(x), 1)), y.reshape((len(y), 1))))\n        return self.update_from_data_xy(xy, ignore)\n\n    def update_from_path(self, path, ignore=None, updatex=True, updatey=True):\n        \"\"\"\n        Update the bounds of the :class:`Bbox` based on the passed in\n        data.  After updating, the bounds will have positive *width*\n        and *height*; *x0* and *y0* will be the minimal values.\n\n        *path*: a :class:`~matplotlib.path.Path` instance\n\n        *ignore*:\n           - when True, ignore the existing bounds of the :class:`Bbox`.\n           - when False, include the existing bounds of the :class:`Bbox`.\n           - when None, use the last value passed to :meth:`ignore`.\n\n        *updatex*: when True, update the x values\n\n        *updatey*: when True, update the y values\n\n        \"\"\"\n        if ignore is None:\n            ignore = self._ignore\n\n        if path.vertices.size == 0:\n            return\n\n        points, minpos, changed = update_path_extents(\n            path, None, self._points, self._minpos, ignore)\n\n        if changed:\n            self.invalidate()\n            if updatex:\n                self._points[:, 0] = points[:, 0]\n                self._minpos[0] = minpos[0]\n            if updatey:\n                self._points[:, 1] = points[:, 1]\n                self._minpos[1] = minpos[1]\n\n    def update_from_data_xy(self, xy, ignore=None, updatex=True, updatey=True):\n        \"\"\"\n        Update the bounds of the :class:`Bbox` based on the passed in\n        data.  After updating, the bounds will have positive *width*\n        and *height*; *x0* and *y0* will be the minimal values.\n\n        *xy*: a numpy array of 2D points\n\n        *ignore*:\n           - when True, ignore the existing bounds of the :class:`Bbox`.\n           - when False, include the existing bounds of the :class:`Bbox`.\n           - when None, use the last value passed to :meth:`ignore`.\n\n        *updatex*: when True, update the x values\n\n        *updatey*: when True, update the y values\n        \"\"\"\n        if len(xy) == 0:\n            return\n\n        path = Path(xy)\n        self.update_from_path(path, ignore=ignore,\n                                    updatex=updatex, updatey=updatey)\n\n    def _set_x0(self, val):\n        self._points[0, 0] = val\n        self.invalidate()\n    x0 = property(BboxBase._get_x0, _set_x0)\n\n    def _set_y0(self, val):\n        self._points[0, 1] = val\n        self.invalidate()\n    y0 = property(BboxBase._get_y0, _set_y0)\n\n    def _set_x1(self, val):\n        self._points[1, 0] = val\n        self.invalidate()\n    x1 = property(BboxBase._get_x1, _set_x1)\n\n    def _set_y1(self, val):\n        self._points[1, 1] = val\n        self.invalidate()\n    y1 = property(BboxBase._get_y1, _set_y1)\n\n    def _set_p0(self, val):\n        self._points[0] = val\n        self.invalidate()\n    p0 = property(BboxBase._get_p0, _set_p0)\n\n    def _set_p1(self, val):\n        self._points[1] = val\n        self.invalidate()\n    p1 = property(BboxBase._get_p1, _set_p1)\n\n    def _set_intervalx(self, interval):\n        self._points[:, 0] = interval\n        self.invalidate()\n    intervalx = property(BboxBase._get_intervalx, _set_intervalx)\n\n    def _set_intervaly(self, interval):\n        self._points[:, 1] = interval\n        self.invalidate()\n    intervaly = property(BboxBase._get_intervaly, _set_intervaly)\n\n    def _set_bounds(self, bounds):\n        l, b, w, h = bounds\n        points = np.array([[l, b], [l + w, b + h]], np.float_)\n        if np.any(self._points != points):\n            self._points = points\n            self.invalidate()\n    bounds = property(BboxBase._get_bounds, _set_bounds)\n\n    def _get_minpos(self):\n        return self._minpos\n    minpos = property(_get_minpos)\n\n    def _get_minposx(self):\n        return self._minpos[0]\n    minposx = property(_get_minposx)\n\n    def _get_minposy(self):\n        return self._minpos[1]\n    minposy = property(_get_minposy)\n\n    def get_points(self):\n        \"\"\"\n        Get the points of the bounding box directly as a numpy array\n        of the form: [[x0, y0], [x1, y1]].\n        \"\"\"\n        self._invalid = 0\n        return self._points\n\n    def set_points(self, points):\n        \"\"\"\n        Set the points of the bounding box directly from a numpy array\n        of the form: [[x0, y0], [x1, y1]].  No error checking is\n        performed, as this method is mainly for internal use.\n        \"\"\"\n        if np.any(self._points != points):\n            self._points = points\n            self.invalidate()\n\n    def set(self, other):\n        \"\"\"\n        Set this bounding box from the \"frozen\" bounds of another\n        :class:`Bbox`.\n        \"\"\"\n        if np.any(self._points != other.get_points()):\n            self._points = other.get_points()\n            self.invalidate()\n\n    def mutated(self):\n        'return whether the bbox has changed since init'\n        return self.mutatedx() or self.mutatedy()\n\n    def mutatedx(self):\n        'return whether the x-limits have changed since init'\n        return (self._points[0, 0] != self._points_orig[0, 0] or\n                self._points[1, 0] != self._points_orig[1, 0])\n\n    def mutatedy(self):\n        'return whether the y-limits have changed since init'\n        return (self._points[0, 1] != self._points_orig[0, 1] or\n                self._points[1, 1] != self._points_orig[1, 1])\n\n\nclass TransformedBbox(BboxBase):\n    \"\"\"\n    A :class:`Bbox` that is automatically transformed by a given\n    transform.  When either the child bounding box or transform\n    changes, the bounds of this bbox will update accordingly.\n    \"\"\"\n    def __init__(self, bbox, transform, **kwargs):\n        \"\"\"\n        *bbox*: a child :class:`Bbox`\n\n        *transform*: a 2D :class:`Transform`\n        \"\"\"\n        assert bbox.is_bbox\n        assert isinstance(transform, Transform)\n        assert transform.input_dims == 2\n        assert transform.output_dims == 2\n\n        BboxBase.__init__(self, **kwargs)\n        self._bbox = bbox\n        self._transform = transform\n        self.set_children(bbox, transform)\n        self._points = None\n\n    def __repr__(self):\n        return \"TransformedBbox(%r, %r)\" % (self._bbox, self._transform)\n\n    def get_points(self):\n        if self._invalid:\n            points = self._transform.transform(self._bbox.get_points())\n            points = np.ma.filled(points, 0.0)\n            self._points = points\n            self._invalid = 0\n        return self._points\n    get_points.__doc__ = Bbox.get_points.__doc__\n\n    if DEBUG:\n        _get_points = get_points\n\n        def get_points(self):\n            points = self._get_points()\n            self._check(points)\n            return points\n\n\nclass Transform(TransformNode):\n    \"\"\"\n    The base class of all :class:`TransformNode` instances that\n    actually perform a transformation.\n\n    All non-affine transformations should be subclasses of this class.\n    New affine transformations should be subclasses of\n    :class:`Affine2D`.\n\n    Subclasses of this class should override the following members (at\n    minimum):\n\n      - :attr:`input_dims`\n      - :attr:`output_dims`\n      - :meth:`transform`\n      - :attr:`is_separable`\n      - :attr:`has_inverse`\n      - :meth:`inverted` (if :attr:`has_inverse` is True)\n\n    If the transform needs to do something non-standard with\n    :class:`matplotlib.path.Path` objects, such as adding curves\n    where there were once line segments, it should override:\n\n      - :meth:`transform_path`\n    \"\"\"\n    input_dims = None\n    \"\"\"\n    The number of input dimensions of this transform.\n    Must be overridden (with integers) in the subclass.\n    \"\"\"\n\n    output_dims = None\n    \"\"\"\n    The number of output dimensions of this transform.\n    Must be overridden (with integers) in the subclass.\n    \"\"\"\n\n    has_inverse = False\n    \"\"\"True if this transform has a corresponding inverse transform.\"\"\"\n\n    is_separable = False\n    \"\"\"True if this transform is separable in the x- and y- dimensions.\"\"\"\n\n    def __add__(self, other):\n        \"\"\"\n        Composes two transforms together such that *self* is followed\n        by *other*.\n        \"\"\"\n        if isinstance(other, Transform):\n            return composite_transform_factory(self, other)\n        raise TypeError(\n            \"Can not add Transform to object of type '%s'\" % type(other))\n\n    def __radd__(self, other):\n        \"\"\"\n        Composes two transforms together such that *self* is followed\n        by *other*.\n        \"\"\"\n        if isinstance(other, Transform):\n            return composite_transform_factory(other, self)\n        raise TypeError(\n            \"Can not add Transform to object of type '%s'\" % type(other))\n\n    def __eq__(self, other):\n        # equality is based on transform object id. Hence:\n        # Transform() != Transform().\n        # Some classes, such as TransformWrapper & AffineBase, will override.\n        return self is other\n\n    def _iter_break_from_left_to_right(self):\n        \"\"\"\n        Returns an iterator breaking down this transform stack from left to\n        right recursively. If self == ((A, N), A) then the result will be an\n        iterator which yields I : ((A, N), A), followed by A : (N, A),\n        followed by (A, N) : (A), but not ((A, N), A) : I.\n\n        This is equivalent to flattening the stack then yielding\n        ``flat_stack[:i], flat_stack[i:]`` where i=0..(n-1).\n\n        \"\"\"\n        yield IdentityTransform(), self\n\n    @property\n    def depth(self):\n        \"\"\"\n        Returns the number of transforms which have been chained\n        together to form this Transform instance.\n\n        .. note::\n\n            For the special case of a Composite transform, the maximum depth\n            of the two is returned.\n\n        \"\"\"\n        return 1\n\n    def contains_branch(self, other):\n        \"\"\"\n        Return whether the given transform is a sub-tree of this transform.\n\n        This routine uses transform equality to identify sub-trees, therefore\n        in many situations it is object id which will be used.\n\n        For the case where the given transform represents the whole\n        of this transform, returns True.\n\n        \"\"\"\n        if self.depth < other.depth:\n            return False\n\n        # check that a subtree is equal to other (starting from self)\n        for _, sub_tree in self._iter_break_from_left_to_right():\n            if sub_tree == other:\n                return True\n        return False\n\n    def contains_branch_seperately(self, other_transform):\n        \"\"\"\n        Returns whether the given branch is a sub-tree of this transform on\n        each seperate dimension.\n\n        A common use for this method is to identify if a transform is a blended\n        transform containing an axes' data transform. e.g.::\n\n            x_isdata, y_isdata = trans.contains_branch_seperately(ax.transData)\n\n        \"\"\"\n        if self.output_dims != 2:\n            raise ValueError('contains_branch_seperately only supports '\n                             'transforms with 2 output dimensions')\n        # for a non-blended transform each seperate dimension is the same, so\n        # just return the appropriate shape.\n        return [self.contains_branch(other_transform)] * 2\n\n    def __sub__(self, other):\n        \"\"\"\n        Returns a transform stack which goes all the way down self's transform\n        stack, and then ascends back up other's stack. If it can, this is\n        optimised::\n\n            # normally\n            A - B == a + b.inverted()\n\n            # sometimes, when A contains the tree B there is no need to\n            # descend all the way down to the base of A (via B), instead we\n            # can just stop at B.\n\n            (A + B) - (B)^-1 == A\n\n            # similarly, when B contains tree A, we can avoid decending A at\n            # all, basically:\n            A - (A + B) == ((B + A) - A).inverted() or B^-1\n\n        For clarity, the result of ``(A + B) - B + B == (A + B)``.\n\n        \"\"\"\n        # we only know how to do this operation if other is a Transform.\n        if not isinstance(other, Transform):\n            return NotImplemented\n\n        for remainder, sub_tree in self._iter_break_from_left_to_right():\n            if sub_tree == other:\n                return remainder\n\n        for remainder, sub_tree in other._iter_break_from_left_to_right():\n            if sub_tree == self:\n                if not remainder.has_inverse:\n                    raise ValueError(\"The shortcut cannot be computed since \"\n                     \"other's transform includes a non-invertable component.\")\n                return remainder.inverted()\n\n        # if we have got this far, then there was no shortcut possible\n        if other.has_inverse:\n            return self + other.inverted()\n        else:\n            raise ValueError('It is not possible to compute transA - transB '\n                             'since transB cannot be inverted and there is no '\n                             'shortcut possible.')\n\n    def __array__(self, *args, **kwargs):\n        \"\"\"\n        Array interface to get at this Transform's affine matrix.\n        \"\"\"\n        return self.get_affine().get_matrix()\n\n    def transform(self, values):\n        \"\"\"\n        Performs the transformation on the given array of values.\n\n        Accepts a numpy array of shape (N x :attr:`input_dims`) and\n        returns a numpy array of shape (N x :attr:`output_dims`).\n        \"\"\"\n        return self.transform_affine(self.transform_non_affine(values))\n\n    def transform_affine(self, values):\n        \"\"\"\n        Performs only the affine part of this transformation on the\n        given array of values.\n\n        ``transform(values)`` is always equivalent to\n        ``transform_affine(transform_non_affine(values))``.\n\n        In non-affine transformations, this is generally a no-op.  In\n        affine transformations, this is equivalent to\n        ``transform(values)``.\n\n        Accepts a numpy array of shape (N x :attr:`input_dims`) and\n        returns a numpy array of shape (N x :attr:`output_dims`).\n        \"\"\"\n        return self.get_affine().transform(values)\n\n    def transform_non_affine(self, values):\n        \"\"\"\n        Performs only the non-affine part of the transformation.\n\n        ``transform(values)`` is always equivalent to\n        ``transform_affine(transform_non_affine(values))``.\n\n        In non-affine transformations, this is generally equivalent to\n        ``transform(values)``.  In affine transformations, this is\n        always a no-op.\n\n        Accepts a numpy array of shape (N x :attr:`input_dims`) and\n        returns a numpy array of shape (N x :attr:`output_dims`).\n        \"\"\"\n        return values\n\n    def get_affine(self):\n        \"\"\"\n        Get the affine part of this transform.\n        \"\"\"\n        return IdentityTransform()\n\n    def get_matrix(self):\n        \"\"\"\n        Get the Affine transformation array for the affine part\n        of this transform.\n\n        \"\"\"\n        return self.get_affine().get_matrix()\n\n    def transform_point(self, point):\n        \"\"\"\n        A convenience function that returns the transformed copy of a\n        single point.\n\n        The point is given as a sequence of length :attr:`input_dims`.\n        The transformed point is returned as a sequence of length\n        :attr:`output_dims`.\n        \"\"\"\n        assert len(point) == self.input_dims\n        return self.transform(np.asarray([point]))[0]\n\n    def transform_path(self, path):\n        \"\"\"\n        Returns a transformed path.\n\n        *path*: a :class:`~matplotlib.path.Path` instance.\n\n        In some cases, this transform may insert curves into the path\n        that began as line segments.\n        \"\"\"\n        return self.transform_path_affine(self.transform_path_non_affine(path))\n\n    def transform_path_affine(self, path):\n        \"\"\"\n        Returns a path, transformed only by the affine part of\n        this transform.\n\n        *path*: a :class:`~matplotlib.path.Path` instance.\n\n        ``transform_path(path)`` is equivalent to\n        ``transform_path_affine(transform_path_non_affine(values))``.\n        \"\"\"\n        return self.get_affine().transform_path_affine(path)\n\n    def transform_path_non_affine(self, path):\n        \"\"\"\n        Returns a path, transformed only by the non-affine\n        part of this transform.\n\n        *path*: a :class:`~matplotlib.path.Path` instance.\n\n        ``transform_path(path)`` is equivalent to\n        ``transform_path_affine(transform_path_non_affine(values))``.\n        \"\"\"\n        return Path(self.transform_non_affine(path.vertices), path.codes,\n                    path._interpolation_steps)\n\n    def transform_angles(self, angles, pts, radians=False, pushoff=1e-5):\n        \"\"\"\n        Performs transformation on a set of angles anchored at\n        specific locations.\n\n        The *angles* must be a column vector (i.e., numpy array).\n\n        The *pts* must be a two-column numpy array of x,y positions\n        (angle transforms currently only work in 2D).  This array must\n        have the same number of rows as *angles*.\n\n        *radians* indicates whether or not input angles are given in\n         radians (True) or degrees (False; the default).\n\n        *pushoff* is the distance to move away from *pts* for\n         determining transformed angles (see discussion of method\n         below).\n\n        The transformed angles are returned in an array with the same\n        size as *angles*.\n\n        The generic version of this method uses a very generic\n        algorithm that transforms *pts*, as well as locations very\n        close to *pts*, to find the angle in the transformed system.\n        \"\"\"\n        # Must be 2D\n        if self.input_dims != 2 or self.output_dims != 2:\n            raise NotImplementedError('Only defined in 2D')\n\n        # pts must be array with 2 columns for x,y\n        assert pts.shape[1] == 2\n\n        # angles must be a column vector and have same number of\n        # rows as pts\n        assert np.prod(angles.shape) == angles.shape[0] == pts.shape[0]\n\n        # Convert to radians if desired\n        if not radians:\n            angles = angles / 180.0 * np.pi\n\n        # Move a short distance away\n        pts2 = pts + pushoff * np.c_[np.cos(angles), np.sin(angles)]\n\n        # Transform both sets of points\n        tpts = self.transform(pts)\n        tpts2 = self.transform(pts2)\n\n        # Calculate transformed angles\n        d = tpts2 - tpts\n        a = np.arctan2(d[:, 1], d[:, 0])\n\n        # Convert back to degrees if desired\n        if not radians:\n            a = a * 180.0 / np.pi\n\n        return a\n\n    def inverted(self):\n        \"\"\"\n        Return the corresponding inverse transformation.\n\n        The return value of this method should be treated as\n        temporary.  An update to *self* does not cause a corresponding\n        update to its inverted copy.\n\n        ``x === self.inverted().transform(self.transform(x))``\n        \"\"\"\n        raise NotImplementedError()\n\n\nclass TransformWrapper(Transform):\n    \"\"\"\n    A helper class that holds a single child transform and acts\n    equivalently to it.\n\n    This is useful if a node of the transform tree must be replaced at\n    run time with a transform of a different type.  This class allows\n    that replacement to correctly trigger invalidation.\n\n    Note that :class:`TransformWrapper` instances must have the same\n    input and output dimensions during their entire lifetime, so the\n    child transform may only be replaced with another child transform\n    of the same dimensions.\n    \"\"\"\n    pass_through = True\n\n    def __init__(self, child):\n        \"\"\"\n        *child*: A class:`Transform` instance.  This child may later\n        be replaced with :meth:`set`.\n        \"\"\"\n        assert isinstance(child, Transform)\n        Transform.__init__(self)\n        self.input_dims = child.input_dims\n        self.output_dims = child.output_dims\n        self._set(child)\n        self._invalid = 0\n\n    def __eq__(self, other):\n        return self._child.__eq__(other)\n\n    if DEBUG:\n\n        def __str__(self):\n            return str(self._child)\n\n    def __getstate__(self):\n        # only store the child\n        return {'child': self._child}\n\n    def __setstate__(self, state):\n        # re-initialise the TransformWrapper with the state's child\n        self.__init__(state['child'])\n\n    def __repr__(self):\n        return \"TransformWrapper(%r)\" % self._child\n\n    def frozen(self):\n        return self._child.frozen()\n    frozen.__doc__ = Transform.frozen.__doc__\n\n    def _set(self, child):\n        self._child = child\n        self.set_children(child)\n\n        self.transform = child.transform\n        self.transform_affine = child.transform_affine\n        self.transform_non_affine = child.transform_non_affine\n        self.transform_path = child.transform_path\n        self.transform_path_affine = child.transform_path_affine\n        self.transform_path_non_affine = child.transform_path_non_affine\n        self.get_affine = child.get_affine\n        self.inverted = child.inverted\n        self.get_matrix = child.get_matrix\n\n        # note we do not wrap other properties here since the transform's\n        # child can be changed with WrappedTransform.set and so checking\n        # is_affine and other such properties may be dangerous.\n\n    def set(self, child):\n        \"\"\"\n        Replace the current child of this transform with another one.\n\n        The new child must have the same number of input and output\n        dimensions as the current child.\n        \"\"\"\n        assert child.input_dims == self.input_dims\n        assert child.output_dims == self.output_dims\n\n        self._set(child)\n\n        self._invalid = 0\n        self.invalidate()\n        self._invalid = 0\n\n    def _get_is_affine(self):\n        return self._child.is_affine\n    is_affine = property(_get_is_affine)\n\n    def _get_is_separable(self):\n        return self._child.is_separable\n    is_separable = property(_get_is_separable)\n\n    def _get_has_inverse(self):\n        return self._child.has_inverse\n    has_inverse = property(_get_has_inverse)\n\n\nclass AffineBase(Transform):\n    \"\"\"\n    The base class of all affine transformations of any number of\n    dimensions.\n    \"\"\"\n    is_affine = True\n\n    def __init__(self, *args, **kwargs):\n        Transform.__init__(self, *args, **kwargs)\n        self._inverted = None\n\n    def __array__(self, *args, **kwargs):\n        # optimises the access of the transform matrix vs the superclass\n        return self.get_matrix()\n\n    @staticmethod\n    def _concat(a, b):\n        \"\"\"\n        Concatenates two transformation matrices (represented as numpy\n        arrays) together.\n        \"\"\"\n        return np.dot(b, a)\n\n    def __eq__(self, other):\n        if getattr(other, \"is_affine\", False):\n            return np.all(self.get_matrix() == other.get_matrix())\n        return NotImplemented\n\n    def transform(self, values):\n        return self.transform_affine(values)\n    transform.__doc__ = Transform.transform.__doc__\n\n    def transform_affine(self, values):\n        raise NotImplementedError('Affine subclasses should override this '\n                                  'method.')\n    transform_affine.__doc__ = Transform.transform_affine.__doc__\n\n    def transform_non_affine(self, points):\n        return points\n    transform_non_affine.__doc__ = Transform.transform_non_affine.__doc__\n\n    def transform_path(self, path):\n        return self.transform_path_affine(path)\n    transform_path.__doc__ = Transform.transform_path.__doc__\n\n    def transform_path_affine(self, path):\n        return Path(self.transform_affine(path.vertices),\n                    path.codes, path._interpolation_steps)\n    transform_path_affine.__doc__ = Transform.transform_path_affine.__doc__\n\n    def transform_path_non_affine(self, path):\n        return path\n    transform_path_non_affine.__doc__ = Transform.transform_path_non_affine.__doc__\n\n    def get_affine(self):\n        return self\n    get_affine.__doc__ = Transform.get_affine.__doc__\n\n\nclass Affine2DBase(AffineBase):\n    \"\"\"\n    The base class of all 2D affine transformations.\n\n    2D affine transformations are performed using a 3x3 numpy array::\n\n        a c e\n        b d f\n        0 0 1\n\n    This class provides the read-only interface.  For a mutable 2D\n    affine transformation, use :class:`Affine2D`.\n\n    Subclasses of this class will generally only need to override a\n    constructor and :meth:`get_matrix` that generates a custom 3x3 matrix.\n    \"\"\"\n    has_inverse = True\n\n    input_dims = 2\n    output_dims = 2\n\n    def frozen(self):\n        return Affine2D(self.get_matrix().copy())\n    frozen.__doc__ = AffineBase.frozen.__doc__\n\n    def _get_is_separable(self):\n        mtx = self.get_matrix()\n        return mtx[0, 1] == 0.0 and mtx[1, 0] == 0.0\n    is_separable = property(_get_is_separable)\n\n    def to_values(self):\n        \"\"\"\n        Return the values of the matrix as a sequence (a,b,c,d,e,f)\n        \"\"\"\n        mtx = self.get_matrix()\n        return tuple(mtx[:2].swapaxes(0, 1).flatten())\n\n    @staticmethod\n    def matrix_from_values(a, b, c, d, e, f):\n        \"\"\"\n        (staticmethod) Create a new transformation matrix as a 3x3\n        numpy array of the form::\n\n          a c e\n          b d f\n          0 0 1\n        \"\"\"\n        return np.array([[a, c, e], [b, d, f], [0.0, 0.0, 1.0]], np.float_)\n\n    def transform_affine(self, points):\n        mtx = self.get_matrix()\n        if isinstance(points, MaskedArray):\n            tpoints = affine_transform(points.data, mtx)\n            return ma.MaskedArray(tpoints, mask=ma.getmask(points))\n        return affine_transform(points, mtx)\n\n    def transform_point(self, point):\n        mtx = self.get_matrix()\n        return affine_transform([point], mtx)[0]\n    transform_point.__doc__ = AffineBase.transform_point.__doc__\n\n    if DEBUG:\n        _transform_affine = transform_affine\n\n        def transform_affine(self, points):\n            # The major speed trap here is just converting to the\n            # points to an array in the first place.  If we can use\n            # more arrays upstream, that should help here.\n            if (not ma.isMaskedArray(points) and\n                not isinstance(points, np.ndarray)):\n                warnings.warn(\n                    ('A non-numpy array of type %s was passed in for ' +\n                     'transformation.  Please correct this.')\n                    % type(points))\n            return self._transform_affine(points)\n    transform_affine.__doc__ = AffineBase.transform_affine.__doc__\n\n    def inverted(self):\n        if self._inverted is None or self._invalid:\n            mtx = self.get_matrix()\n            shorthand_name = None\n            if self._shorthand_name:\n                shorthand_name = '(%s)-1' % self._shorthand_name\n            self._inverted = Affine2D(inv(mtx), shorthand_name=shorthand_name)\n            self._invalid = 0\n        return self._inverted\n    inverted.__doc__ = AffineBase.inverted.__doc__\n\n\nclass Affine2D(Affine2DBase):\n    \"\"\"\n    A mutable 2D affine transformation.\n    \"\"\"\n\n    def __init__(self, matrix=None, **kwargs):\n        \"\"\"\n        Initialize an Affine transform from a 3x3 numpy float array::\n\n          a c e\n          b d f\n          0 0 1\n\n        If *matrix* is None, initialize with the identity transform.\n        \"\"\"\n        Affine2DBase.__init__(self, **kwargs)\n        if matrix is None:\n            matrix = np.identity(3)\n        elif DEBUG:\n            matrix = np.asarray(matrix, np.float_)\n            assert matrix.shape == (3, 3)\n        self._mtx = matrix\n        self._invalid = 0\n\n    def __repr__(self):\n        return \"Affine2D(%s)\" % repr(self._mtx)\n\n#    def __cmp__(self, other):\n#        # XXX redundant. this only tells us eq.\n#        if (isinstance(other, Affine2D) and\n#            (self.get_matrix() == other.get_matrix()).all()):\n#            return 0\n#        return -1\n\n    @staticmethod\n    def from_values(a, b, c, d, e, f):\n        \"\"\"\n        (staticmethod) Create a new Affine2D instance from the given\n        values::\n\n          a c e\n          b d f\n          0 0 1\n\n        .\n        \"\"\"\n        return Affine2D(\n            np.array([a, c, e, b, d, f, 0.0, 0.0, 1.0], np.float_)\n            .reshape((3, 3)))\n\n    def get_matrix(self):\n        \"\"\"\n        Get the underlying transformation matrix as a 3x3 numpy array::\n\n          a c e\n          b d f\n          0 0 1\n\n        .\n        \"\"\"\n        self._invalid = 0\n        return self._mtx\n\n    def set_matrix(self, mtx):\n        \"\"\"\n        Set the underlying transformation matrix from a 3x3 numpy array::\n\n          a c e\n          b d f\n          0 0 1\n\n        .\n        \"\"\"\n        self._mtx = mtx\n        self.invalidate()\n\n    def set(self, other):\n        \"\"\"\n        Set this transformation from the frozen copy of another\n        :class:`Affine2DBase` object.\n        \"\"\"\n        assert isinstance(other, Affine2DBase)\n        self._mtx = other.get_matrix()\n        self.invalidate()\n\n    @staticmethod\n    def identity():\n        \"\"\"\n        (staticmethod) Return a new :class:`Affine2D` object that is\n        the identity transform.\n\n        Unless this transform will be mutated later on, consider using\n        the faster :class:`IdentityTransform` class instead.\n        \"\"\"\n        return Affine2D(np.identity(3))\n\n    def clear(self):\n        \"\"\"\n        Reset the underlying matrix to the identity transform.\n        \"\"\"\n        self._mtx = np.identity(3)\n        self.invalidate()\n        return self\n\n    def rotate(self, theta):\n        \"\"\"\n        Add a rotation (in radians) to this transform in place.\n\n        Returns *self*, so this method can easily be chained with more\n        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`\n        and :meth:`scale`.\n        \"\"\"\n        a = np.cos(theta)\n        b = np.sin(theta)\n        rotate_mtx = np.array(\n            [[a, -b, 0.0], [b, a, 0.0], [0.0, 0.0, 1.0]],\n            np.float_)\n        self._mtx = np.dot(rotate_mtx, self._mtx)\n        self.invalidate()\n        return self\n\n    def rotate_deg(self, degrees):\n        \"\"\"\n        Add a rotation (in degrees) to this transform in place.\n\n        Returns *self*, so this method can easily be chained with more\n        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`\n        and :meth:`scale`.\n        \"\"\"\n        return self.rotate(degrees * np.pi / 180.)\n\n    def rotate_around(self, x, y, theta):\n        \"\"\"\n        Add a rotation (in radians) around the point (x, y) in place.\n\n        Returns *self*, so this method can easily be chained with more\n        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`\n        and :meth:`scale`.\n        \"\"\"\n        return self.translate(-x, -y).rotate(theta).translate(x, y)\n\n    def rotate_deg_around(self, x, y, degrees):\n        \"\"\"\n        Add a rotation (in degrees) around the point (x, y) in place.\n\n        Returns *self*, so this method can easily be chained with more\n        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`\n        and :meth:`scale`.\n        \"\"\"\n        return self.translate(-x, -y).rotate_deg(degrees).translate(x, y)\n\n    def translate(self, tx, ty):\n        \"\"\"\n        Adds a translation in place.\n\n        Returns *self*, so this method can easily be chained with more\n        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`\n        and :meth:`scale`.\n        \"\"\"\n        translate_mtx = np.array(\n            [[1.0, 0.0, tx], [0.0, 1.0, ty], [0.0, 0.0, 1.0]],\n            np.float_)\n        self._mtx = np.dot(translate_mtx, self._mtx)\n        self.invalidate()\n        return self\n\n    def scale(self, sx, sy=None):\n        \"\"\"\n        Adds a scale in place.\n\n        If *sy* is None, the same scale is applied in both the *x*- and\n        *y*-directions.\n\n        Returns *self*, so this method can easily be chained with more\n        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`\n        and :meth:`scale`.\n        \"\"\"\n        if sy is None:\n            sy = sx\n        scale_mtx = np.array(\n            [[sx, 0.0, 0.0], [0.0, sy, 0.0], [0.0, 0.0, 1.0]],\n            np.float_)\n        self._mtx = np.dot(scale_mtx, self._mtx)\n        self.invalidate()\n        return self\n\n    def skew(self, xShear, yShear):\n        \"\"\"\n        Adds a skew in place.\n\n        *xShear* and *yShear* are the shear angles along the *x*- and\n        *y*-axes, respectively, in radians.\n\n        Returns *self*, so this method can easily be chained with more\n        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`\n        and :meth:`scale`.\n        \"\"\"\n        rotX = np.tan(xShear)\n        rotY = np.tan(yShear)\n        skew_mtx = np.array(\n                [[1.0, rotX, 0.0], [rotY, 1.0, 0.0], [0.0, 0.0, 1.0]],\n                np.float_)\n        self._mtx = np.dot(skew_mtx, self._mtx)\n        self.invalidate()\n        return self\n\n    def skew_deg(self, xShear, yShear):\n        \"\"\"\n        Adds a skew in place.\n\n        *xShear* and *yShear* are the shear angles along the *x*- and\n        *y*-axes, respectively, in degrees.\n\n        Returns *self*, so this method can easily be chained with more\n        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`\n        and :meth:`scale`.\n        \"\"\"\n        return self.skew(np.deg2rad(xShear), np.deg2rad(yShear))\n\n    def _get_is_separable(self):\n        mtx = self.get_matrix()\n        return mtx[0, 1] == 0.0 and mtx[1, 0] == 0.0\n    is_separable = property(_get_is_separable)\n\n\nclass IdentityTransform(Affine2DBase):\n    \"\"\"\n    A special class that does on thing, the identity transform, in a\n    fast way.\n    \"\"\"\n    _mtx = np.identity(3)\n\n    def frozen(self):\n        return self\n    frozen.__doc__ = Affine2DBase.frozen.__doc__\n\n    def __repr__(self):\n        return \"IdentityTransform()\"\n\n    def get_matrix(self):\n        return self._mtx\n    get_matrix.__doc__ = Affine2DBase.get_matrix.__doc__\n\n    def transform(self, points):\n        return points\n    transform.__doc__ = Affine2DBase.transform.__doc__\n\n    transform_affine = transform\n    transform_affine.__doc__ = Affine2DBase.transform_affine.__doc__\n\n    transform_non_affine = transform\n    transform_non_affine.__doc__ = Affine2DBase.transform_non_affine.__doc__\n\n    def transform_path(self, path):\n        return path\n    transform_path.__doc__ = Affine2DBase.transform_path.__doc__\n\n    transform_path_affine = transform_path\n    transform_path_affine.__doc__ = Affine2DBase.transform_path_affine.__doc__\n\n    transform_path_non_affine = transform_path\n    transform_path_non_affine.__doc__ = Affine2DBase.transform_path_non_affine.__doc__\n\n    def get_affine(self):\n        return self\n    get_affine.__doc__ = Affine2DBase.get_affine.__doc__\n\n    inverted = get_affine\n    inverted.__doc__ = Affine2DBase.inverted.__doc__\n\n\nclass BlendedGenericTransform(Transform):\n    \"\"\"\n    A \"blended\" transform uses one transform for the *x*-direction, and\n    another transform for the *y*-direction.\n\n    This \"generic\" version can handle any given child transform in the\n    *x*- and *y*-directions.\n    \"\"\"\n    input_dims = 2\n    output_dims = 2\n    is_separable = True\n    pass_through = True\n\n    def __init__(self, x_transform, y_transform, **kwargs):\n        \"\"\"\n        Create a new \"blended\" transform using *x_transform* to\n        transform the *x*-axis and *y_transform* to transform the\n        *y*-axis.\n\n        You will generally not call this constructor directly but use\n        the :func:`blended_transform_factory` function instead, which\n        can determine automatically which kind of blended transform to\n        create.\n        \"\"\"\n        # Here we ask: \"Does it blend?\"\n\n        Transform.__init__(self, **kwargs)\n        self._x = x_transform\n        self._y = y_transform\n        self.set_children(x_transform, y_transform)\n        self._affine = None\n\n    def __eq__(self, other):\n        # Note, this is an exact copy of BlendedAffine2D.__eq__\n        if isinstance(other, (BlendedAffine2D, BlendedGenericTransform)):\n            return (self._x == other._x) and (self._y == other._y)\n        elif self._x == self._y:\n            return self._x == other\n        else:\n            return NotImplemented\n\n    def contains_branch_seperately(self, transform):\n        # Note, this is an exact copy of BlendedAffine2D.contains_branch_seperately\n        return self._x.contains_branch(transform), self._y.contains_branch(transform)\n\n    @property\n    def depth(self):\n        return max([self._x.depth, self._y.depth])\n\n    def contains_branch(self, other):\n        # a blended transform cannot possibly contain a branch from two different transforms.\n        return False\n\n    def _get_is_affine(self):\n        return self._x.is_affine and self._y.is_affine\n    is_affine = property(_get_is_affine)\n\n    def _get_has_inverse(self):\n        return self._x.has_inverse and self._y.has_inverse\n    has_inverse = property(_get_has_inverse)\n\n    def frozen(self):\n        return blended_transform_factory(self._x.frozen(), self._y.frozen())\n    frozen.__doc__ = Transform.frozen.__doc__\n\n    def __repr__(self):\n        return \"BlendedGenericTransform(%s,%s)\" % (self._x, self._y)\n\n    def transform_non_affine(self, points):\n        if self._x.is_affine and self._y.is_affine:\n            return points\n        x = self._x\n        y = self._y\n\n        if x == y and x.input_dims == 2:\n            return x.transform_non_affine(points)\n\n        if x.input_dims == 2:\n            x_points = x.transform_non_affine(points)[:, 0:1]\n        else:\n            x_points = x.transform_non_affine(points[:, 0])\n            x_points = x_points.reshape((len(x_points), 1))\n\n        if y.input_dims == 2:\n            y_points = y.transform_non_affine(points)[:, 1:]\n        else:\n            y_points = y.transform_non_affine(points[:, 1])\n            y_points = y_points.reshape((len(y_points), 1))\n\n        if isinstance(x_points, MaskedArray) or isinstance(y_points, MaskedArray):\n            return ma.concatenate((x_points, y_points), 1)\n        else:\n            return np.concatenate((x_points, y_points), 1)\n    transform_non_affine.__doc__ = Transform.transform_non_affine.__doc__\n\n    def inverted(self):\n        return BlendedGenericTransform(self._x.inverted(), self._y.inverted())\n    inverted.__doc__ = Transform.inverted.__doc__\n\n    def get_affine(self):\n        if self._invalid or self._affine is None:\n            if self._x == self._y:\n                self._affine = self._x.get_affine()\n            else:\n                x_mtx = self._x.get_affine().get_matrix()\n                y_mtx = self._y.get_affine().get_matrix()\n                # This works because we already know the transforms are\n                # separable, though normally one would want to set b and\n                # c to zero.\n                mtx = np.vstack((x_mtx[0], y_mtx[1], [0.0, 0.0, 1.0]))\n                self._affine = Affine2D(mtx)\n            self._invalid = 0\n        return self._affine\n    get_affine.__doc__ = Transform.get_affine.__doc__\n\n\nclass BlendedAffine2D(Affine2DBase):\n    \"\"\"\n    A \"blended\" transform uses one transform for the *x*-direction, and\n    another transform for the *y*-direction.\n\n    This version is an optimization for the case where both child\n    transforms are of type :class:`Affine2DBase`.\n    \"\"\"\n    is_separable = True\n\n    def __init__(self, x_transform, y_transform, **kwargs):\n        \"\"\"\n        Create a new \"blended\" transform using *x_transform* to\n        transform the *x*-axis and *y_transform* to transform the\n        *y*-axis.\n\n        Both *x_transform* and *y_transform* must be 2D affine\n        transforms.\n\n        You will generally not call this constructor directly but use\n        the :func:`blended_transform_factory` function instead, which\n        can determine automatically which kind of blended transform to\n        create.\n        \"\"\"\n        assert x_transform.is_affine\n        assert y_transform.is_affine\n        assert x_transform.is_separable\n        assert y_transform.is_separable\n\n        Transform.__init__(self, **kwargs)\n        self._x = x_transform\n        self._y = y_transform\n        self.set_children(x_transform, y_transform)\n\n        Affine2DBase.__init__(self)\n        self._mtx = None\n\n    def __eq__(self, other):\n        # Note, this is an exact copy of BlendedGenericTransform.__eq__\n        if isinstance(other, (BlendedAffine2D, BlendedGenericTransform)):\n            return (self._x == other._x) and (self._y == other._y)\n        elif self._x == self._y:\n            return self._x == other\n        else:\n            return NotImplemented\n\n    def contains_branch_seperately(self, transform):\n        # Note, this is an exact copy of BlendedTransform.contains_branch_seperately\n        return self._x.contains_branch(transform), self._y.contains_branch(transform)\n\n    def __repr__(self):\n        return \"BlendedAffine2D(%s,%s)\" % (self._x, self._y)\n\n    def get_matrix(self):\n        if self._invalid:\n            if self._x == self._y:\n                self._mtx = self._x.get_matrix()\n            else:\n                x_mtx = self._x.get_matrix()\n                y_mtx = self._y.get_matrix()\n                # This works because we already know the transforms are\n                # separable, though normally one would want to set b and\n                # c to zero.\n                self._mtx = np.vstack((x_mtx[0], y_mtx[1], [0.0, 0.0, 1.0]))\n            self._inverted = None\n            self._invalid = 0\n        return self._mtx\n    get_matrix.__doc__ = Affine2DBase.get_matrix.__doc__\n\n\ndef blended_transform_factory(x_transform, y_transform):\n    \"\"\"\n    Create a new \"blended\" transform using *x_transform* to transform\n    the *x*-axis and *y_transform* to transform the *y*-axis.\n\n    A faster version of the blended transform is returned for the case\n    where both child transforms are affine.\n    \"\"\"\n    if (isinstance(x_transform, Affine2DBase)\n        and isinstance(y_transform, Affine2DBase)):\n        return BlendedAffine2D(x_transform, y_transform)\n    return BlendedGenericTransform(x_transform, y_transform)\n\n\nclass CompositeGenericTransform(Transform):\n    \"\"\"\n    A composite transform formed by applying transform *a* then\n    transform *b*.\n\n    This \"generic\" version can handle any two arbitrary\n    transformations.\n    \"\"\"\n    pass_through = True\n\n    def __init__(self, a, b, **kwargs):\n        \"\"\"\n        Create a new composite transform that is the result of\n        applying transform *a* then transform *b*.\n\n        You will generally not call this constructor directly but use\n        the :func:`composite_transform_factory` function instead,\n        which can automatically choose the best kind of composite\n        transform instance to create.\n        \"\"\"\n        assert a.output_dims == b.input_dims\n        self.input_dims = a.input_dims\n        self.output_dims = b.output_dims\n\n        Transform.__init__(self, **kwargs)\n        self._a = a\n        self._b = b\n        self.set_children(a, b)\n\n    is_affine = property(lambda self: self._a.is_affine and self._b.is_affine)\n\n    def frozen(self):\n        self._invalid = 0\n        frozen = composite_transform_factory(self._a.frozen(), self._b.frozen())\n        if not isinstance(frozen, CompositeGenericTransform):\n            return frozen.frozen()\n        return frozen\n    frozen.__doc__ = Transform.frozen.__doc__\n\n    def _invalidate_internal(self, value, invalidating_node):\n        # In some cases for a composite transform, an invalidating call to AFFINE_ONLY needs\n        # to be extended to invalidate the NON_AFFINE part too. These cases are when the right\n        # hand transform is non-affine and either:\n        # (a) the left hand transform is non affine\n        # (b) it is the left hand node which has triggered the invalidation\n        if value == Transform.INVALID_AFFINE \\\n            and not self._b.is_affine \\\n            and (not self._a.is_affine or invalidating_node is self._a):\n\n            value = Transform.INVALID\n\n        Transform._invalidate_internal(self, value=value,\n                                       invalidating_node=invalidating_node)\n\n    def __eq__(self, other):\n        if isinstance(other, (CompositeGenericTransform, CompositeAffine2D)):\n            return self is other or (self._a == other._a and self._b == other._b)\n        else:\n            return False\n\n    def _iter_break_from_left_to_right(self):\n        for lh_compliment, rh_compliment in self._a._iter_break_from_left_to_right():\n            yield lh_compliment, rh_compliment + self._b\n        for lh_compliment, rh_compliment in self._b._iter_break_from_left_to_right():\n            yield self._a + lh_compliment, rh_compliment\n\n    @property\n    def depth(self):\n        return self._a.depth + self._b.depth\n\n    def _get_is_affine(self):\n        return self._a.is_affine and self._b.is_affine\n    is_affine = property(_get_is_affine)\n\n    def _get_is_separable(self):\n        return self._a.is_separable and self._b.is_separable\n    is_separable = property(_get_is_separable)\n\n    if DEBUG:\n        def __str__(self):\n            return '(%s, %s)' % (self._a, self._b)\n\n    def __repr__(self):\n        return \"CompositeGenericTransform(%r, %r)\" % (self._a, self._b)\n\n    def transform_affine(self, points):\n        return self.get_affine().transform(points)\n    transform_affine.__doc__ = Transform.transform_affine.__doc__\n\n    def transform_non_affine(self, points):\n        if self._a.is_affine and self._b.is_affine:\n            return points\n        elif not self._a.is_affine and self._b.is_affine:\n            return self._a.transform_non_affine(points)\n        else:\n            return self._b.transform_non_affine(\n                                self._a.transform(points))\n    transform_non_affine.__doc__ = Transform.transform_non_affine.__doc__\n\n    def transform_path_non_affine(self, path):\n        if self._a.is_affine and self._b.is_affine:\n            return path\n        elif not self._a.is_affine and self._b.is_affine:\n            return self._a.transform_path_non_affine(path)\n        else:\n            return self._b.transform_path_non_affine(\n                                    self._a.transform_path(path))\n    transform_path_non_affine.__doc__ = Transform.transform_path_non_affine.__doc__\n\n    def get_affine(self):\n        if not self._b.is_affine:\n            return self._b.get_affine()\n        else:\n            return Affine2D(np.dot(self._b.get_affine().get_matrix(),\n                                self._a.get_affine().get_matrix()))\n    get_affine.__doc__ = Transform.get_affine.__doc__\n\n    def inverted(self):\n        return CompositeGenericTransform(self._b.inverted(), self._a.inverted())\n    inverted.__doc__ = Transform.inverted.__doc__\n\n    def _get_has_inverse(self):\n        return self._a.has_inverse and self._b.has_inverse\n    has_inverse = property(_get_has_inverse)\n\n\nclass CompositeAffine2D(Affine2DBase):\n    \"\"\"\n    A composite transform formed by applying transform *a* then transform *b*.\n\n    This version is an optimization that handles the case where both *a*\n    and *b* are 2D affines.\n    \"\"\"\n    def __init__(self, a, b, **kwargs):\n        \"\"\"\n        Create a new composite transform that is the result of\n        applying transform *a* then transform *b*.\n\n        Both *a* and *b* must be instances of :class:`Affine2DBase`.\n\n        You will generally not call this constructor directly but use\n        the :func:`composite_transform_factory` function instead,\n        which can automatically choose the best kind of composite\n        transform instance to create.\n        \"\"\"\n        assert a.output_dims == b.input_dims\n        self.input_dims = a.input_dims\n        self.output_dims = b.output_dims\n        assert a.is_affine\n        assert b.is_affine\n\n        Affine2DBase.__init__(self, **kwargs)\n        self._a = a\n        self._b = b\n        self.set_children(a, b)\n        self._mtx = None\n\n    if DEBUG:\n        def __str__(self):\n            return '(%s, %s)' % (self._a, self._b)\n\n    @property\n    def depth(self):\n        return self._a.depth + self._b.depth\n\n    def _iter_break_from_left_to_right(self):\n        for lh_compliment, rh_compliment in self._a._iter_break_from_left_to_right():\n            yield lh_compliment, rh_compliment + self._b\n        for lh_compliment, rh_compliment in self._b._iter_break_from_left_to_right():\n            yield self._a + lh_compliment, rh_compliment\n\n    def __repr__(self):\n        return \"CompositeAffine2D(%r, %r)\" % (self._a, self._b)\n\n    def get_matrix(self):\n        if self._invalid:\n            self._mtx = np.dot(\n                self._b.get_matrix(),\n                self._a.get_matrix())\n            self._inverted = None\n            self._invalid = 0\n        return self._mtx\n    get_matrix.__doc__ = Affine2DBase.get_matrix.__doc__\n\n\ndef composite_transform_factory(a, b):\n    \"\"\"\n    Create a new composite transform that is the result of applying\n    transform a then transform b.\n\n    Shortcut versions of the blended transform are provided for the\n    case where both child transforms are affine, or one or the other\n    is the identity transform.\n\n    Composite transforms may also be created using the '+' operator,\n    e.g.::\n\n      c = a + b\n    \"\"\"\n    # check to see if any of a or b are IdentityTransforms. We use\n    # isinstance here to guarantee that the transforms will *always*\n    # be IdentityTransforms. Since TransformWrappers are mutable,\n    # use of equality here would be wrong.\n    if isinstance(a, IdentityTransform):\n        return b\n    elif isinstance(b, IdentityTransform):\n        return a\n    elif isinstance(a, Affine2D) and isinstance(b, Affine2D):\n        return CompositeAffine2D(a, b)\n    return CompositeGenericTransform(a, b)\n\n\nclass BboxTransform(Affine2DBase):\n    \"\"\"\n    :class:`BboxTransform` linearly transforms points from one\n    :class:`Bbox` to another :class:`Bbox`.\n    \"\"\"\n    is_separable = True\n\n    def __init__(self, boxin, boxout, **kwargs):\n        \"\"\"\n        Create a new :class:`BboxTransform` that linearly transforms\n        points from *boxin* to *boxout*.\n        \"\"\"\n        assert boxin.is_bbox\n        assert boxout.is_bbox\n\n        Affine2DBase.__init__(self, **kwargs)\n        self._boxin = boxin\n        self._boxout = boxout\n        self.set_children(boxin, boxout)\n        self._mtx = None\n        self._inverted = None\n\n    def __repr__(self):\n        return \"BboxTransform(%r, %r)\" % (self._boxin, self._boxout)\n\n    def get_matrix(self):\n        if self._invalid:\n            inl, inb, inw, inh = self._boxin.bounds\n            outl, outb, outw, outh = self._boxout.bounds\n            x_scale = outw / inw\n            y_scale = outh / inh\n            if DEBUG and (x_scale == 0 or y_scale == 0):\n                raise ValueError(\"Transforming from or to a singular bounding box.\")\n            self._mtx = np.array([[x_scale, 0.0    , (-inl*x_scale+outl)],\n                                   [0.0    , y_scale, (-inb*y_scale+outb)],\n                                   [0.0    , 0.0    , 1.0        ]],\n                                  np.float_)\n            self._inverted = None\n            self._invalid = 0\n        return self._mtx\n    get_matrix.__doc__ = Affine2DBase.get_matrix.__doc__\n\n\nclass BboxTransformTo(Affine2DBase):\n    \"\"\"\n    :class:`BboxTransformTo` is a transformation that linearly\n    transforms points from the unit bounding box to a given\n    :class:`Bbox`.\n    \"\"\"\n    is_separable = True\n\n    def __init__(self, boxout, **kwargs):\n        \"\"\"\n        Create a new :class:`BboxTransformTo` that linearly transforms\n        points from the unit bounding box to *boxout*.\n        \"\"\"\n        assert boxout.is_bbox\n\n        Affine2DBase.__init__(self, **kwargs)\n        self._boxout = boxout\n        self.set_children(boxout)\n        self._mtx = None\n        self._inverted = None\n\n    def __repr__(self):\n        return \"BboxTransformTo(%r)\" % (self._boxout)\n\n    def get_matrix(self):\n        if self._invalid:\n            outl, outb, outw, outh = self._boxout.bounds\n            if DEBUG and (outw == 0 or outh == 0):\n                raise ValueError(\"Transforming to a singular bounding box.\")\n            self._mtx = np.array([[outw,  0.0, outl],\n                                   [ 0.0, outh, outb],\n                                   [ 0.0,  0.0,  1.0]],\n                                  np.float_)\n            self._inverted = None\n            self._invalid = 0\n        return self._mtx\n    get_matrix.__doc__ = Affine2DBase.get_matrix.__doc__\n\n\nclass BboxTransformToMaxOnly(BboxTransformTo):\n    \"\"\"\n    :class:`BboxTransformTo` is a transformation that linearly\n    transforms points from the unit bounding box to a given\n    :class:`Bbox` with a fixed upper left of (0, 0).\n    \"\"\"\n    def __repr__(self):\n        return \"BboxTransformToMaxOnly(%r)\" % (self._boxout)\n\n    def get_matrix(self):\n        if self._invalid:\n            xmax, ymax = self._boxout.max\n            if DEBUG and (xmax == 0 or ymax == 0):\n                raise ValueError(\"Transforming to a singular bounding box.\")\n            self._mtx = np.array([[xmax,  0.0, 0.0],\n                                  [ 0.0, ymax, 0.0],\n                                  [ 0.0,  0.0, 1.0]],\n                                 np.float_)\n            self._inverted = None\n            self._invalid = 0\n        return self._mtx\n    get_matrix.__doc__ = Affine2DBase.get_matrix.__doc__\n\n\nclass BboxTransformFrom(Affine2DBase):\n    \"\"\"\n    :class:`BboxTransformFrom` linearly transforms points from a given\n    :class:`Bbox` to the unit bounding box.\n    \"\"\"\n    is_separable = True\n\n    def __init__(self, boxin, **kwargs):\n        assert boxin.is_bbox\n\n        Affine2DBase.__init__(self, **kwargs)\n        self._boxin = boxin\n        self.set_children(boxin)\n        self._mtx = None\n        self._inverted = None\n\n    def __repr__(self):\n        return \"BboxTransformFrom(%r)\" % (self._boxin)\n\n    def get_matrix(self):\n        if self._invalid:\n            inl, inb, inw, inh = self._boxin.bounds\n            if DEBUG and (inw == 0 or inh == 0):\n                raise ValueError(\"Transforming from a singular bounding box.\")\n            x_scale = 1.0 / inw\n            y_scale = 1.0 / inh\n            self._mtx = np.array([[x_scale, 0.0    , (-inl*x_scale)],\n                                   [0.0    , y_scale, (-inb*y_scale)],\n                                   [0.0    , 0.0    , 1.0        ]],\n                                  np.float_)\n            self._inverted = None\n            self._invalid = 0\n        return self._mtx\n    get_matrix.__doc__ = Affine2DBase.get_matrix.__doc__\n\n\nclass ScaledTranslation(Affine2DBase):\n    \"\"\"\n    A transformation that translates by *xt* and *yt*, after *xt* and *yt*\n    have been transformad by the given transform *scale_trans*.\n    \"\"\"\n    def __init__(self, xt, yt, scale_trans, **kwargs):\n        Affine2DBase.__init__(self, **kwargs)\n        self._t = (xt, yt)\n        self._scale_trans = scale_trans\n        self.set_children(scale_trans)\n        self._mtx = None\n        self._inverted = None\n\n    def __repr__(self):\n        return \"ScaledTranslation(%r)\" % (self._t,)\n\n    def get_matrix(self):\n        if self._invalid:\n            xt, yt = self._scale_trans.transform_point(self._t)\n            self._mtx = np.array([[1.0, 0.0, xt],\n                                   [0.0, 1.0, yt],\n                                   [0.0, 0.0, 1.0]],\n                                  np.float_)\n            self._invalid = 0\n            self._inverted = None\n        return self._mtx\n    get_matrix.__doc__ = Affine2DBase.get_matrix.__doc__\n\n\nclass TransformedPath(TransformNode):\n    \"\"\"\n    A :class:`TransformedPath` caches a non-affine transformed copy of\n    the :class:`~matplotlib.path.Path`.  This cached copy is\n    automatically updated when the non-affine part of the transform\n    changes.\n\n    .. note::\n\n        Paths are considered immutable by this class. Any update to the\n        path's vertices/codes will not trigger a transform recomputation.\n\n    \"\"\"\n    def __init__(self, path, transform):\n        \"\"\"\n        Create a new :class:`TransformedPath` from the given\n        :class:`~matplotlib.path.Path` and :class:`Transform`.\n        \"\"\"\n        assert isinstance(transform, Transform)\n        TransformNode.__init__(self)\n\n        self._path = path\n        self._transform = transform\n        self.set_children(transform)\n        self._transformed_path = None\n        self._transformed_points = None\n\n    def _revalidate(self):\n        # only recompute if the invalidation includes the non_affine part of the transform\n        if ((self._invalid & self.INVALID_NON_AFFINE == self.INVALID_NON_AFFINE)\n            or self._transformed_path is None):\n            self._transformed_path = \\\n                self._transform.transform_path_non_affine(self._path)\n            self._transformed_points = \\\n                Path(self._transform.transform_non_affine(self._path.vertices),\n                     None, self._path._interpolation_steps)\n        self._invalid = 0\n\n    def get_transformed_points_and_affine(self):\n        \"\"\"\n        Return a copy of the child path, with the non-affine part of\n        the transform already applied, along with the affine part of\n        the path necessary to complete the transformation.  Unlike\n        :meth:`get_transformed_path_and_affine`, no interpolation will\n        be performed.\n        \"\"\"\n        self._revalidate()\n        return self._transformed_points, self.get_affine()\n\n    def get_transformed_path_and_affine(self):\n        \"\"\"\n        Return a copy of the child path, with the non-affine part of\n        the transform already applied, along with the affine part of\n        the path necessary to complete the transformation.\n        \"\"\"\n        self._revalidate()\n        return self._transformed_path, self.get_affine()\n\n    def get_fully_transformed_path(self):\n        \"\"\"\n        Return a fully-transformed copy of the child path.\n        \"\"\"\n        self._revalidate()\n        return self._transform.transform_path_affine(self._transformed_path)\n\n    def get_affine(self):\n        return self._transform.get_affine()\n\n\ndef nonsingular(vmin, vmax, expander=0.001, tiny=1e-15, increasing=True):\n    '''\n    Modify the endpoints of a range as needed to avoid singularities.\n\n    *vmin*, *vmax*\n        the initial endpoints.\n\n    *tiny*\n        threshold for the ratio of the interval to the maximum absolute\n        value of its endpoints.  If the interval is smaller than\n        this, it will be expanded.  This value should be around\n        1e-15 or larger; otherwise the interval will be approaching\n        the double precision resolution limit.\n\n    *expander*\n        fractional amount by which *vmin* and *vmax* are expanded if\n        the original interval is too small, based on *tiny*.\n\n    *increasing*: [True | False]\n        If True (default), swap *vmin*, *vmax* if *vmin* > *vmax*\n\n    Returns *vmin*, *vmax*, expanded and/or swapped if necessary.\n\n    If either input is inf or NaN, or if both inputs are 0,\n    returns -*expander*, *expander*.\n    '''\n    if (not np.isfinite(vmin)) or (not np.isfinite(vmax)):\n        return -expander, expander\n    swapped = False\n    if vmax < vmin:\n        vmin, vmax = vmax, vmin\n        swapped = True\n    if vmax - vmin <= max(abs(vmin), abs(vmax)) * tiny:\n        if vmax == 0 and vmin == 0:\n            vmin = -expander\n            vmax = expander\n        else:\n            vmin -= expander*abs(vmin)\n            vmax += expander*abs(vmax)\n\n    if swapped and not increasing:\n        vmin, vmax = vmax, vmin\n    return vmin, vmax\n\n\ndef interval_contains(interval, val):\n    a, b = interval\n    return (\n        ((a < b) and (a <= val and b >= val))\n        or (b <= val and a >= val))\n\ndef interval_contains_open(interval, val):\n    a, b = interval\n    return (\n        ((a < b) and (a < val and b > val))\n        or (b < val and a > val))\n\ndef offset_copy(trans, fig=None, x=0.0, y=0.0, units='inches'):\n    '''\n    Return a new transform with an added offset.\n      args:\n        trans is any transform\n      kwargs:\n        fig is the current figure; it can be None if units are 'dots'\n        x, y give the offset\n        units is 'inches', 'points' or 'dots'\n    '''\n    if units == 'dots':\n        return trans + Affine2D().translate(x, y)\n    if fig is None:\n        raise ValueError('For units of inches or points a fig kwarg is needed')\n    if units == 'points':\n        x /= 72.0\n        y /= 72.0\n    elif not units == 'inches':\n        raise ValueError('units must be dots, points, or inches')\n    return trans + ScaledTranslation(x, y, fig.dpi_scale_trans)\n", "patch": "@@ -662,7 +662,7 @@ def count_overlaps(self, bboxes):\n \n         bboxes is a sequence of :class:`BboxBase` objects\n         \"\"\"\n-        return count_bboxes_overlapping_bbox(self, bboxes)\n+        return count_bboxes_overlapping_bbox(self, [np.array(x) for x in bboxes])\n \n     def expanded(self, sw, sh):\n         \"\"\"\n@@ -1668,7 +1668,7 @@ def transform_affine(self, points):\n \n     def transform_point(self, point):\n         mtx = self.get_matrix()\n-        return affine_transform(point, mtx)\n+        return affine_transform([point], mtx)[0]\n     transform_point.__doc__ = AffineBase.transform_point.__doc__\n \n     if DEBUG:"}
{"patches_id": 2, "files_id": 25, "language": "cpp", "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Ftri%2F_tri.cpp", "raw_code": "/* This file contains liberal use of asserts to assist code development and\n * debugging.  Standard matplotlib builds disable asserts so they cause no\n * performance reduction.  To enable the asserts, you need to undefine the\n * NDEBUG macro, which is achieved by adding the following\n *     undef_macros=['NDEBUG']\n * to the appropriate make_extension call in setupext.py, and then rebuilding.\n */\n#include \"_tri.h\"\n#include \"src/mplutils.h\"\n\n#include <algorithm>\n#include <iostream>\n#include <set>\n\n#define MOVETO 1\n#define LINETO 2\n\n\n\nTriEdge::TriEdge()\n    : tri(-1), edge(-1)\n{}\n\nTriEdge::TriEdge(int tri_, int edge_)\n    : tri(tri_), edge(edge_)\n{}\n\nbool TriEdge::operator<(const TriEdge& other) const\n{\n    if (tri != other.tri)\n        return tri < other.tri;\n    else\n        return edge < other.edge;\n}\n\nbool TriEdge::operator==(const TriEdge& other) const\n{\n    return tri == other.tri && edge == other.edge;\n}\n\nbool TriEdge::operator!=(const TriEdge& other) const\n{\n    return !operator==(other);\n}\n\nstd::ostream& operator<<(std::ostream& os, const TriEdge& tri_edge)\n{\n    return os << tri_edge.tri << ' ' << tri_edge.edge;\n}\n\n\n\nXY::XY()\n{}\n\nXY::XY(const double& x_, const double& y_)\n    : x(x_), y(y_)\n{}\n\ndouble XY::angle() const\n{\n    return atan2(y, x);\n}\n\ndouble XY::cross_z(const XY& other) const\n{\n    return x*other.y - y*other.x;\n}\n\nbool XY::is_right_of(const XY& other) const\n{\n    if (x == other.x)\n        return y > other.y;\n    else\n        return x > other.x;\n}\n\nbool XY::operator==(const XY& other) const\n{\n    return x == other.x && y == other.y;\n}\n\nbool XY::operator!=(const XY& other) const\n{\n    return x != other.x || y != other.y;\n}\n\nXY XY::operator*(const double& multiplier) const\n{\n    return XY(x*multiplier, y*multiplier);\n}\n\nconst XY& XY::operator+=(const XY& other)\n{\n    x += other.x;\n    y += other.y;\n    return *this;\n}\n\nconst XY& XY::operator-=(const XY& other)\n{\n    x -= other.x;\n    y -= other.y;\n    return *this;\n}\n\nXY XY::operator+(const XY& other) const\n{\n    return XY(x + other.x, y + other.y);\n}\n\nXY XY::operator-(const XY& other) const\n{\n    return XY(x - other.x, y - other.y);\n}\n\nstd::ostream& operator<<(std::ostream& os, const XY& xy)\n{\n    return os << '(' << xy.x << ' ' << xy.y << ')';\n}\n\n\n\nXYZ::XYZ(const double& x_, const double& y_, const double& z_)\n    : x(x_), y(y_), z(z_)\n{}\n\nXYZ XYZ::cross(const XYZ& other) const\n{\n    return XYZ(y*other.z - z*other.y,\n               z*other.x - x*other.z,\n               x*other.y - y*other.x);\n}\n\ndouble XYZ::dot(const XYZ& other) const\n{\n    return x*other.x + y*other.y + z*other.z;\n}\n\ndouble XYZ::length_squared() const\n{\n    return x*x + y*y + z*z;\n}\n\nXYZ XYZ::operator-(const XYZ& other) const\n{\n    return XYZ(x - other.x, y - other.y, z - other.z);\n}\n\nstd::ostream& operator<<(std::ostream& os, const XYZ& xyz)\n{\n    return os << '(' << xyz.x << ' ' << xyz.y << ' ' << xyz.z << ')';\n}\n\n\n\nBoundingBox::BoundingBox()\n    : empty(true)\n{}\n\nvoid BoundingBox::add(const XY& point)\n{\n    if (empty) {\n        empty = false;\n        lower = upper = point;\n    } else {\n        if      (point.x < lower.x) lower.x = point.x;\n        else if (point.x > upper.x) upper.x = point.x;\n\n        if      (point.y < lower.y) lower.y = point.y;\n        else if (point.y > upper.y) upper.y = point.y;\n    }\n}\n\nvoid BoundingBox::expand(const XY& delta)\n{\n    if (!empty)\n    {\n        lower -= delta;\n        upper += delta;\n    }\n}\n\n\n\nContourLine::ContourLine()\n    : std::vector<XY>()\n{}\n\nvoid ContourLine::insert_unique(iterator pos, const XY& point)\n{\n    if (empty() || pos == end() || point != *pos)\n        std::vector<XY>::insert(pos, point);\n}\n\nvoid ContourLine::push_back(const XY& point)\n{\n    if (empty() || point != back())\n        std::vector<XY>::push_back(point);\n}\n\nvoid ContourLine::write() const\n{\n    std::cout << \"ContourLine of \" << size() << \" points:\";\n    for (const_iterator it = begin(); it != end(); ++it)\n        std::cout << ' ' << *it;\n    std::cout << std::endl;\n}\n\n\n\nvoid write_contour(const Contour& contour)\n{\n    std::cout << \"Contour of \" << contour.size() << \" lines.\" << std::endl;\n    for (Contour::const_iterator it = contour.begin(); it != contour.end(); ++it)\n        it->write();\n}\n\n\n\n\nTriangulation::Triangulation(PyArrayObject* x,\n                             PyArrayObject* y,\n                             PyArrayObject* triangles,\n                             PyArrayObject* mask,\n                             PyArrayObject* edges,\n                             PyArrayObject* neighbors)\n    : _npoints(PyArray_DIM(x,0)),\n      _ntri(PyArray_DIM(triangles,0)),\n      _x(x),\n      _y(y),\n      _triangles(triangles),\n      _mask(mask),\n      _edges(edges),\n      _neighbors(neighbors)\n{\n\n    correct_triangles();\n}\n\nTriangulation::~Triangulation()\n{\n\n    Py_XDECREF(_x);\n    Py_XDECREF(_y);\n    Py_XDECREF(_triangles);\n    Py_XDECREF(_mask);\n    Py_XDECREF(_edges);\n    Py_XDECREF(_neighbors);\n}\n\nvoid Triangulation::calculate_boundaries()\n{\n\n\n    get_neighbors();  // Ensure _neighbors has been created.\n\n    // Create set of all boundary TriEdges, which are those which do not\n    // have a neighbor triangle.\n    typedef std::set<TriEdge> BoundaryEdges;\n    BoundaryEdges boundary_edges;\n    for (int tri = 0; tri < _ntri; ++tri) {\n        if (!is_masked(tri)) {\n            for (int edge = 0; edge < 3; ++edge) {\n                if (get_neighbor(tri, edge) == -1) {\n                    boundary_edges.insert(TriEdge(tri, edge));\n                }\n            }\n        }\n    }\n\n    // Take any boundary edge and follow the boundary until return to start\n    // point, removing edges from boundary_edges as they are used.  At the same\n    // time, initialise the _tri_edge_to_boundary_map.\n    while (!boundary_edges.empty()) {\n        // Start of new boundary.\n        BoundaryEdges::iterator it = boundary_edges.begin();\n        int tri = it->tri;\n        int edge = it->edge;\n        _boundaries.push_back(Boundary());\n        Boundary& boundary = _boundaries.back();\n\n        while (true) {\n            boundary.push_back(TriEdge(tri, edge));\n            boundary_edges.erase(it);\n            _tri_edge_to_boundary_map[TriEdge(tri, edge)] =\n                BoundaryEdge(_boundaries.size()-1, boundary.size()-1);\n\n            // Move to next edge of current triangle.\n            edge = (edge+1) % 3;\n\n            // Find start point index of boundary edge.\n            int point = get_triangle_point(tri, edge);\n\n            // Find next TriEdge by traversing neighbors until find one\n            // without a neighbor.\n            while (get_neighbor(tri, edge) != -1) {\n                tri = get_neighbor(tri, edge);\n                edge = get_edge_in_triangle(tri, point);\n            }\n\n            if (TriEdge(tri,edge) == boundary.front())\n                break;  // Reached beginning of this boundary, so finished it.\n            else\n                it = boundary_edges.find(TriEdge(tri, edge));\n        }\n    }\n}\n\nvoid Triangulation::calculate_edges()\n{\n\n    Py_XDECREF(_edges);\n\n    // Create set of all edges, storing them with start point index less than\n    // end point index.\n    typedef std::set<Edge> EdgeSet;\n    EdgeSet edge_set;\n    for (int tri = 0; tri < _ntri; ++tri) {\n        if (!is_masked(tri)) {\n            for (int edge = 0; edge < 3; edge++) {\n                int start = get_triangle_point(tri, edge);\n                int end   = get_triangle_point(tri, (edge+1)%3);\n                edge_set.insert(start > end ? Edge(start,end) : Edge(end,start));\n            }\n        }\n    }\n\n    // Convert to python _edges array.\n    npy_intp dims[2] = {static_cast<npy_intp>(edge_set.size()), 2};\n    _edges = (PyArrayObject*)PyArray_SimpleNew(2, dims, NPY_INT);\n    int* edges_ptr = (int*)PyArray_DATA(_edges);\n    for (EdgeSet::const_iterator it = edge_set.begin(); it != edge_set.end(); ++it) {\n        *edges_ptr++ = it->start;\n        *edges_ptr++ = it->end;\n    }\n}\n\nvoid Triangulation::calculate_neighbors()\n{\n\n    Py_XDECREF(_neighbors);\n\n    // Create _neighbors array with shape (ntri,3) and initialise all to -1.\n    npy_intp dims[2] = {_ntri,3};\n    _neighbors = (PyArrayObject*)PyArray_SimpleNew(2, dims, NPY_INT);\n    int* neighbors_ptr = (int*)PyArray_DATA(_neighbors);\n    std::fill(neighbors_ptr, neighbors_ptr + 3*_ntri, -1);\n\n    // For each triangle edge (start to end point), find corresponding neighbor\n    // edge from end to start point.  Do this by traversing all edges and\n    // storing them in a map from edge to TriEdge.  If corresponding neighbor\n    // edge is already in the map, don't need to store new edge as neighbor\n    // already found.\n    typedef std::map<Edge, TriEdge> EdgeToTriEdgeMap;\n    EdgeToTriEdgeMap edge_to_tri_edge_map;\n    for (int tri = 0; tri < _ntri; ++tri) {\n        if (!is_masked(tri)) {\n            for (int edge = 0; edge < 3; ++edge) {\n                int start = get_triangle_point(tri, edge);\n                int end   = get_triangle_point(tri, (edge+1)%3);\n                EdgeToTriEdgeMap::iterator it =\n                    edge_to_tri_edge_map.find(Edge(end,start));\n                if (it == edge_to_tri_edge_map.end()) {\n                    // No neighbor edge exists in the edge_to_tri_edge_map, so\n                    // add this edge to it.\n                    edge_to_tri_edge_map[Edge(start,end)] = TriEdge(tri,edge);\n                } else {\n                    // Neighbor edge found, set the two elements of _neighbors\n                    // and remove edge from edge_to_tri_edge_map.\n                    neighbors_ptr[3*tri + edge] = it->second.tri;\n                    neighbors_ptr[3*it->second.tri + it->second.edge] = tri;\n                    edge_to_tri_edge_map.erase(it);\n                }\n            }\n        }\n    }\n\n    // Note that remaining edges in the edge_to_tri_edge_map correspond to\n    // boundary edges, but the boundaries are calculated separately elsewhere.\n}\n\nPy::Object Triangulation::calculate_plane_coefficients(const Py::Tuple &args)\n{\n\n    args.verify_length(1);\n\n    PyArrayObject* z = (PyArrayObject*)PyArray_ContiguousFromObject(\n                           args[0].ptr(), NPY_DOUBLE, 1, 1);\n    if (z == 0 || PyArray_DIM(z,0) != PyArray_DIM(_x,0)) {\n        Py_XDECREF(z);\n        throw Py::ValueError(\n            \"z array must have same length as triangulation x and y arrays\");\n    }\n\n    PyArrayObject* planes_array = 0;  // Array to return.\n\n    try\n    {\n        const double* zs = (const double*)PyArray_DATA(z);\n\n        npy_intp dims[2] = {_ntri, 3};\n        planes_array = (PyArrayObject*)PyArray_SimpleNew(2, dims,\n                                                         NPY_DOUBLE);\n        double* planes = (double*)PyArray_DATA(planes_array);\n        const int* tris = get_triangles_ptr();\n        const double* xs = (const double*)PyArray_DATA(_x);\n        const double* ys = (const double*)PyArray_DATA(_y);\n        for (int tri = 0; tri < _ntri; ++tri)\n        {\n            if (is_masked(tri))\n            {\n                *planes++ = 0.0;\n                *planes++ = 0.0;\n                *planes++ = 0.0;\n                tris += 3;\n            }\n            else\n            {\n                // Equation of plane for all points r on plane is r.normal = p\n                // where normal is vector normal to the plane, and p is a\n                // constant.  Rewrite as\n                // r_x*normal_x + r_y*normal_y + r_z*normal_z = p\n                // and rearrange to give\n                // r_z = (-normal_x/normal_z)*r_x + (-normal_y/normal_z)*r_y +\n                //       p/normal_z\n                XYZ point0(xs[*tris], ys[*tris], zs[*tris]);\n                tris++;\n                XYZ side01 = XYZ(xs[*tris], ys[*tris], zs[*tris]) - point0;\n                tris++;\n                XYZ side02 = XYZ(xs[*tris], ys[*tris], zs[*tris]) - point0;\n                tris++;\n\n                XYZ normal = side01.cross(side02);\n\n                if (normal.z == 0.0)\n                {\n                    // Normal is in x-y plane which means triangle consists of\n                    // colinear points. To avoid dividing by zero, we use the\n                    // Moore-Penrose pseudo-inverse.\n                    double sum2 = (side01.x*side01.x + side01.y*side01.y +\n                                   side02.x*side02.x + side02.y*side02.y);\n                    double a = (side01.x*side01.z + side02.x*side02.z) / sum2;\n                    double b = (side01.y*side01.z + side02.y*side02.z) / sum2;\n                    *planes++ = a;\n                    *planes++ = b;\n                    *planes++ = point0.z - a*point0.x - b*point0.y;\n                }\n                else\n                {\n                    *planes++ = -normal.x / normal.z;           // x\n                    *planes++ = -normal.y / normal.z;           // y\n                    *planes++ = normal.dot(point0) / normal.z;  // constant\n                }\n            }\n        }\n    }\n    catch (...)\n    {\n        Py_DECREF(z);\n        Py_XDECREF(planes_array);\n        throw;\n    }\n\n    Py_DECREF(z);\n    return Py::asObject((PyObject*)planes_array);\n}\n\nvoid Triangulation::correct_triangles()\n{\n    int* triangles_ptr = (int*)PyArray_DATA(_triangles);\n    int* neighbors_ptr = _neighbors != 0 ? (int*)PyArray_DATA(_neighbors) : 0;\n    for (int tri = 0; tri < _ntri; ++tri) {\n        XY point0 = get_point_coords(*triangles_ptr++);\n        XY point1 = get_point_coords(*triangles_ptr++);\n        XY point2 = get_point_coords(*triangles_ptr++);\n        if ( (point1 - point0).cross_z(point2 - point0) < 0.0) {\n            // Triangle points are clockwise, so change them to anticlockwise.\n            std::swap(*(triangles_ptr-2), *(triangles_ptr-1));\n            if (neighbors_ptr)\n                std::swap(*(neighbors_ptr+3*tri+1), *(neighbors_ptr+3*tri+2));\n        }\n    }\n}\n\nconst Triangulation::Boundaries& Triangulation::get_boundaries() const\n{\n\n    if (_boundaries.empty())\n        const_cast<Triangulation*>(this)->calculate_boundaries();\n    return _boundaries;\n}\n\nvoid Triangulation::get_boundary_edge(const TriEdge& triEdge,\n                                      int& boundary,\n                                      int& edge) const\n{\n    get_boundaries();  // Ensure _tri_edge_to_boundary_map has been created.\n    TriEdgeToBoundaryMap::const_iterator it =\n        _tri_edge_to_boundary_map.find(triEdge);\n    assert(it != _tri_edge_to_boundary_map.end() &&\n           \"TriEdge is not on a boundary\");\n    boundary = it->second.boundary;\n    edge = it->second.edge;\n}\n\nint Triangulation::get_edge_in_triangle(int tri, int point) const\n{\n    assert(tri >= 0 && tri < _ntri && \"Triangle index out of bounds\");\n    assert(point >= 0 && point < _npoints && \"Point index out of bounds.\");\n    const int* triangles_ptr = get_triangles_ptr() + 3*tri;\n    for (int edge = 0; edge < 3; ++edge) {\n        if (*triangles_ptr++ == point) return edge;\n    }\n    return -1;  // point is not in triangle.\n}\n\nPy::Object Triangulation::get_edges()\n{\n\n    if (_edges == 0)\n        calculate_edges();\n    return Py::asObject(Py::new_reference_to((PyObject*)_edges));\n}\n\nint Triangulation::get_neighbor(int tri, int edge) const\n{\n    assert(tri >= 0 && tri < _ntri && \"Triangle index out of bounds\");\n    assert(edge >= 0 && edge < 3 && \"Edge index out of bounds\");\n    return get_neighbors_ptr()[3*tri + edge];\n}\n\nTriEdge Triangulation::get_neighbor_edge(int tri, int edge) const\n{\n    int neighbor_tri = get_neighbor(tri, edge);\n    if (neighbor_tri == -1)\n        return TriEdge(-1,-1);\n    else\n        return TriEdge(neighbor_tri,\n                       get_edge_in_triangle(neighbor_tri,\n                                            get_triangle_point(tri,\n                                                               (edge+1)%3)));\n}\n\nPy::Object Triangulation::get_neighbors()\n{\n\n    if (_neighbors == 0) calculate_neighbors();\n    return Py::asObject(Py::new_reference_to((PyObject*)_neighbors));\n}\n\nconst int* Triangulation::get_neighbors_ptr() const\n{\n    if (_neighbors == 0)\n        const_cast<Triangulation*>(this)->calculate_neighbors();\n    return (const int*)PyArray_DATA(_neighbors);\n}\n\nint Triangulation::get_npoints() const\n{\n    return _npoints;\n}\n\nint Triangulation::get_ntri() const\n{\n    return _ntri;\n}\n\nXY Triangulation::get_point_coords(int point) const\n{\n    assert(point >= 0 && point < _npoints && \"Point index out of bounds.\");\n    return XY( ((const double*)PyArray_DATA(_x))[point],\n               ((const double*)PyArray_DATA(_y))[point] );\n}\n\nint Triangulation::get_triangle_point(int tri, int edge) const\n{\n    assert(tri >= 0 && tri < _ntri && \"Triangle index out of bounds\");\n    assert(edge >= 0 && edge < 3 && \"Edge index out of bounds\");\n    return get_triangles_ptr()[3*tri + edge];\n}\n\nint Triangulation::get_triangle_point(const TriEdge& tri_edge) const\n{\n    return get_triangle_point(tri_edge.tri, tri_edge.edge);\n}\n\nconst int* Triangulation::get_triangles_ptr() const\n{\n    return (const int*)PyArray_DATA(_triangles);\n}\n\nvoid Triangulation::init_type()\n{\n\n\n    behaviors().name(\"Triangulation\");\n    behaviors().doc(\"Triangulation\");\n\n    add_varargs_method(\"calculate_plane_coefficients\",\n                       &Triangulation::calculate_plane_coefficients,\n                       \"calculate_plane_coefficients(z)\");\n    add_noargs_method(\"get_edges\", &Triangulation::get_edges,\n                      \"get_edges()\");\n    add_noargs_method(\"get_neighbors\", &Triangulation::get_neighbors,\n                      \"get_neighbors()\");\n    add_varargs_method(\"set_mask\", &Triangulation::set_mask,\n                       \"set_mask(mask)\");\n}\n\nbool Triangulation::is_masked(int tri) const\n{\n    assert(tri >= 0 && tri < _ntri && \"Triangle index out of bounds.\");\n    return _mask && *((bool*)PyArray_DATA(_mask) + tri);\n}\n\nPy::Object Triangulation::set_mask(const Py::Tuple &args)\n{\n\n    args.verify_length(1);\n\n    Py_XDECREF(_mask);\n    _mask = 0;\n    if (args[0] != Py::None())\n    {\n        _mask = (PyArrayObject*)PyArray_ContiguousFromObject(\n                    args[0].ptr(), NPY_BOOL, 1, 1);\n        if (_mask == 0 || PyArray_DIM(_mask,0) != PyArray_DIM(_triangles,0)) {\n            Py_XDECREF(_mask);\n            throw Py::ValueError(\n                \"mask must be a 1D array with the same length as the triangles array\");\n        }\n    }\n\n    // Clear derived fields so they are recalculated when needed.\n     Py_XDECREF(_edges);\n    _edges = 0;\n    Py_XDECREF(_neighbors);\n    _neighbors = 0;\n    _boundaries.clear();\n\n    return Py::None();\n}\n\nvoid Triangulation::write_boundaries() const\n{\n    const Boundaries& bs = get_boundaries();\n    std::cout << \"Number of boundaries: \" << bs.size() << std::endl;\n    for (Boundaries::const_iterator it = bs.begin(); it != bs.end(); ++it) {\n        const Boundary& b = *it;\n        std::cout << \"  Boundary of \" << b.size() << \" points: \";\n        for (Boundary::const_iterator itb = b.begin(); itb != b.end(); ++itb) {\n            std::cout << *itb << \", \";\n        }\n        std::cout << std::endl;\n    }\n}\n\n\n\n\nTriContourGenerator::TriContourGenerator(Py::Object triangulation,\n                                         PyArrayObject* z)\n    : _triangulation(triangulation),\n      _z(z),\n      _interior_visited(2*get_triangulation().get_ntri()),\n      _boundaries_visited(0),\n      _boundaries_used(0)\n{\n\n}\n\nTriContourGenerator::~TriContourGenerator()\n{\n\n    Py_XDECREF(_z);\n}\n\nvoid TriContourGenerator::clear_visited_flags(bool include_boundaries)\n{\n    // Clear _interiorVisited.\n    std::fill(_interior_visited.begin(), _interior_visited.end(), false);\n\n    if (include_boundaries) {\n        if (_boundaries_visited.empty()) {\n            const Boundaries& boundaries = get_boundaries();\n\n            // Initialise _boundaries_visited.\n            _boundaries_visited.reserve(boundaries.size());\n            for (Boundaries::const_iterator it = boundaries.begin();\n                    it != boundaries.end(); ++it)\n                _boundaries_visited.push_back(BoundaryVisited(it->size()));\n\n            // Initialise _boundaries_used.\n            _boundaries_used = BoundariesUsed(boundaries.size());\n        }\n\n        // Clear _boundaries_visited.\n        for (BoundariesVisited::iterator it = _boundaries_visited.begin();\n                it != _boundaries_visited.end(); ++it)\n            std::fill(it->begin(), it->end(), false);\n\n        // Clear _boundaries_used.\n        std::fill(_boundaries_used.begin(), _boundaries_used.end(), false);\n    }\n}\n\nPy::Object TriContourGenerator::contour_to_segs(const Contour& contour)\n{\n    Py::List segs(contour.size());\n    for (Contour::size_type i = 0; i < contour.size(); ++i) {\n        const ContourLine& line = contour[i];\n        npy_intp dims[2] = {static_cast<npy_intp>(line.size()),2};\n        PyArrayObject* py_line = (PyArrayObject*)PyArray_SimpleNew(\n                                                     2, dims, NPY_DOUBLE);\n        double* p = (double*)PyArray_DATA(py_line);\n        for (ContourLine::const_iterator it = line.begin(); it != line.end(); ++it) {\n            *p++ = it->x;\n            *p++ = it->y;\n        }\n        segs[i] = Py::asObject((PyObject*)py_line);\n    }\n    return segs;\n}\n\nPy::Object TriContourGenerator::contour_to_segs_and_kinds(const Contour& contour)\n{\n    Contour::const_iterator line;\n    ContourLine::const_iterator point;\n\n    // Find total number of points in all contour lines.\n    int n_points = 0;\n    for (line = contour.begin(); line != contour.end(); ++line)\n        n_points += line->size();\n\n    // Create segs array for point coordinates.\n    npy_intp segs_dims[2] = {n_points, 2};\n    PyArrayObject* segs = (PyArrayObject*)PyArray_SimpleNew(\n                                                2, segs_dims, NPY_DOUBLE);\n    double* segs_ptr = (double*)PyArray_DATA(segs);\n\n    // Create kinds array for code types.\n    npy_intp kinds_dims[1] = {n_points};\n    PyArrayObject* kinds = (PyArrayObject*)PyArray_SimpleNew(\n                                                1, kinds_dims, NPY_UBYTE);\n    unsigned char* kinds_ptr = (unsigned char*)PyArray_DATA(kinds);\n\n    for (line = contour.begin(); line != contour.end(); ++line) {\n        for (point = line->begin(); point != line->end(); point++) {\n            *segs_ptr++ = point->x;\n            *segs_ptr++ = point->y;\n            *kinds_ptr++ = (point == line->begin() ? MOVETO : LINETO);\n        }\n    }\n\n    Py::Tuple result(2);\n    result[0] = Py::asObject((PyObject*)segs);\n    result[1] = Py::asObject((PyObject*)kinds);\n    return result;\n}\n\nPy::Object TriContourGenerator::create_contour(const Py::Tuple &args)\n{\n\n    args.verify_length(1);\n\n    double level = (Py::Float)args[0];\n\n    clear_visited_flags(false);\n    Contour contour;\n\n    find_boundary_lines(contour, level);\n    find_interior_lines(contour, level, false, false);\n\n    return contour_to_segs(contour);\n}\n\nPy::Object TriContourGenerator::create_filled_contour(const Py::Tuple &args)\n{\n\n    args.verify_length(2);\n\n    double lower_level = (Py::Float)args[0];\n    double upper_level = (Py::Float)args[1];\n\n    clear_visited_flags(true);\n    Contour contour;\n\n    find_boundary_lines_filled(contour, lower_level, upper_level);\n    find_interior_lines(contour, lower_level, false, true);\n    find_interior_lines(contour, upper_level, true,  true);\n\n    return contour_to_segs_and_kinds(contour);\n}\n\nXY TriContourGenerator::edge_interp(int tri, int edge, const double& level)\n{\n    return interp(get_triangulation().get_triangle_point(tri, edge),\n                  get_triangulation().get_triangle_point(tri, (edge+1)%3),\n                  level);\n}\n\nvoid TriContourGenerator::find_boundary_lines(Contour& contour,\n                                              const double& level)\n{\n    // Traverse boundaries to find starting points for all contour lines that\n    // intersect the boundaries.  For each starting point found, follow the\n    // line to its end before continuing.\n    const Triangulation& triang = get_triangulation();\n    const Boundaries& boundaries = get_boundaries();\n    for (Boundaries::const_iterator it = boundaries.begin();\n            it != boundaries.end(); ++it) {\n        const Boundary& boundary = *it;\n        bool startAbove, endAbove = false;\n        for (Boundary::const_iterator itb = boundary.begin();\n                itb != boundary.end(); ++itb) {\n            if (itb == boundary.begin())\n                startAbove = get_z(triang.get_triangle_point(*itb)) >= level;\n            else\n                startAbove = endAbove;\n            endAbove = get_z(triang.get_triangle_point(itb->tri,\n                                                       (itb->edge+1)%3)) >= level;\n            if (startAbove && !endAbove) {\n                // This boundary edge is the start point for a contour line,\n                // so follow the line.\n                contour.push_back(ContourLine());\n                ContourLine& contour_line = contour.back();\n                TriEdge tri_edge = *itb;\n                follow_interior(contour_line, tri_edge, true, level, false);\n            }\n        }\n    }\n}\n\nvoid TriContourGenerator::find_boundary_lines_filled(Contour& contour,\n                                                     const double& lower_level,\n                                                     const double& upper_level)\n{\n    // Traverse boundaries to find starting points for all contour lines that\n    // intersect the boundaries.  For each starting point found, follow the\n    // line to its end before continuing.\n    const Triangulation& triang = get_triangulation();\n    const Boundaries& boundaries = get_boundaries();\n    for (Boundaries::size_type i = 0; i < boundaries.size(); ++i) {\n        const Boundary& boundary = boundaries[i];\n        for (Boundary::size_type j = 0; j < boundary.size(); ++j) {\n            if (!_boundaries_visited[i][j]) {\n                // z values of start and end of this boundary edge.\n                double z_start = get_z(triang.get_triangle_point(boundary[j]));\n                double z_end = get_z(triang.get_triangle_point(\n                                   boundary[j].tri, (boundary[j].edge+1)%3));\n\n                // Does this boundary edge's z increase through upper level\n                // and/or decrease through lower level?\n                bool incr_upper = (z_start < upper_level && z_end >= upper_level);\n                bool decr_lower = (z_start >= lower_level && z_end < lower_level);\n\n                if (decr_lower || incr_upper) {\n                    // Start point for contour line, so follow it.\n                    contour.push_back(ContourLine());\n                    ContourLine& contour_line = contour.back();\n                    TriEdge start_tri_edge = boundary[j];\n                    TriEdge tri_edge = start_tri_edge;\n\n                    // Traverse interior and boundaries until return to start.\n                    bool on_upper = incr_upper;\n                    do {\n                        follow_interior(contour_line, tri_edge, true,\n                            on_upper ? upper_level : lower_level, on_upper);\n                        on_upper = follow_boundary(contour_line, tri_edge,\n                                       lower_level, upper_level, on_upper);\n                    } while (tri_edge != start_tri_edge);\n\n                    // Filled contour lines must not have same first and last\n                    // points.\n                    if (contour_line.size() > 1 &&\n                            contour_line.front() == contour_line.back())\n                        contour_line.pop_back();\n                }\n            }\n        }\n    }\n\n    // Add full boundaries that lie between the lower and upper levels.  These\n    // are boundaries that have not been touched by an internal contour line\n    // which are stored in _boundaries_used.\n    for (Boundaries::size_type i = 0; i < boundaries.size(); ++i) {\n        if (!_boundaries_used[i]) {\n            const Boundary& boundary = boundaries[i];\n            double z = get_z(triang.get_triangle_point(boundary[0]));\n            if (z >= lower_level && z < upper_level) {\n                contour.push_back(ContourLine());\n                ContourLine& contour_line = contour.back();\n                for (Boundary::size_type j = 0; j < boundary.size(); ++j)\n                    contour_line.push_back(triang.get_point_coords(\n                                      triang.get_triangle_point(boundary[j])));\n            }\n        }\n    }\n}\n\nvoid TriContourGenerator::find_interior_lines(Contour& contour,\n                                              const double& level,\n                                              bool on_upper,\n                                              bool filled)\n{\n    const Triangulation& triang = get_triangulation();\n    int ntri = triang.get_ntri();\n    for (int tri = 0; tri < ntri; ++tri) {\n        int visited_index = (on_upper ? tri+ntri : tri);\n\n        if (_interior_visited[visited_index] || triang.is_masked(tri))\n            continue;  // Triangle has already been visited or is masked.\n\n        _interior_visited[visited_index] = true;\n\n        // Determine edge via which to leave this triangle.\n        int edge = get_exit_edge(tri, level, on_upper);\n        assert(edge >= -1 && edge < 3 && \"Invalid exit edge\");\n        if (edge == -1)\n            continue;  // Contour does not pass through this triangle.\n\n        // Found start of new contour line loop.\n        contour.push_back(ContourLine());\n        ContourLine& contour_line = contour.back();\n        TriEdge tri_edge = triang.get_neighbor_edge(tri, edge);\n        follow_interior(contour_line, tri_edge, false, level, on_upper);\n\n        if (!filled)\n            // Non-filled contour lines must be closed.\n            contour_line.push_back(contour_line.front());\n        else if (contour_line.size() > 1 &&\n                 contour_line.front() == contour_line.back())\n            // Filled contour lines must not have same first and last points.\n            contour_line.pop_back();\n    }\n}\n\nbool TriContourGenerator::follow_boundary(ContourLine& contour_line,\n                                          TriEdge& tri_edge,\n                                          const double& lower_level,\n                                          const double& upper_level,\n                                          bool on_upper)\n{\n    const Triangulation& triang = get_triangulation();\n    const Boundaries& boundaries = get_boundaries();\n\n    // Have TriEdge to start at, need equivalent boundary edge.\n    int boundary, edge;\n    triang.get_boundary_edge(tri_edge, boundary, edge);\n    _boundaries_used[boundary] = true;\n\n    bool stop = false;\n    bool first_edge = true;\n    double z_start, z_end = 0;\n    while (!stop)\n    {\n        assert(!_boundaries_visited[boundary][edge] && \"Boundary already visited\");\n        _boundaries_visited[boundary][edge] = true;\n\n        // z values of start and end points of boundary edge.\n        if (first_edge)\n            z_start = get_z(triang.get_triangle_point(tri_edge));\n        else\n            z_start = z_end;\n        z_end = get_z(triang.get_triangle_point(tri_edge.tri,\n                                                (tri_edge.edge+1)%3));\n\n        if (z_end > z_start) {  // z increasing.\n            if (!(!on_upper && first_edge) &&\n                z_end >= lower_level && z_start < lower_level) {\n                stop = true;\n                on_upper = false;\n            } else if (z_end >= upper_level && z_start < upper_level) {\n                stop = true;\n                on_upper = true;\n            }\n        } else {  // z decreasing.\n            if (!(on_upper && first_edge) &&\n                z_start >= upper_level && z_end < upper_level) {\n                stop = true;\n                on_upper = true;\n            } else if (z_start >= lower_level && z_end < lower_level) {\n                stop = true;\n                on_upper = false;\n            }\n        }\n\n        first_edge = false;\n\n        if (!stop) {\n            // Move to next boundary edge, adding point to contour line.\n            edge = (edge+1) % (int)boundaries[boundary].size();\n            tri_edge = boundaries[boundary][edge];\n            contour_line.push_back(triang.get_point_coords(\n                                       triang.get_triangle_point(tri_edge)));\n        }\n    }\n\n    return on_upper;\n}\n\nvoid TriContourGenerator::follow_interior(ContourLine& contour_line,\n                                          TriEdge& tri_edge,\n                                          bool end_on_boundary,\n                                          const double& level,\n                                          bool on_upper)\n{\n    int& tri = tri_edge.tri;\n    int& edge = tri_edge.edge;\n\n    // Initial point.\n    contour_line.push_back(edge_interp(tri, edge, level));\n\n    while (true) {\n        int visited_index = tri;\n        if (on_upper)\n            visited_index += get_triangulation().get_ntri();\n\n        // Check for end not on boundary.\n        if (!end_on_boundary && _interior_visited[visited_index])\n            break;  // Reached start point, so return.\n\n        // Determine edge by which to leave this triangle.\n        edge = get_exit_edge(tri, level, on_upper);\n        assert(edge >= 0 && edge < 3 && \"Invalid exit edge\");\n\n        _interior_visited[visited_index] = true;\n\n        // Append new point to point set.\n        assert(edge >= 0 && edge < 3 && \"Invalid triangle edge\");\n        contour_line.push_back(edge_interp(tri, edge, level));\n\n        // Move to next triangle.\n        TriEdge next_tri_edge = get_triangulation().get_neighbor_edge(tri,edge);\n\n        // Check if ending on a boundary.\n        if (end_on_boundary && next_tri_edge.tri == -1)\n            break;\n\n        tri_edge = next_tri_edge;\n        assert(tri_edge.tri != -1 && \"Invalid triangle for internal loop\");\n    }\n}\n\nconst TriContourGenerator::Boundaries& TriContourGenerator::get_boundaries() const\n{\n    return get_triangulation().get_boundaries();\n}\n\nint TriContourGenerator::get_exit_edge(int tri,\n                                       const double& level,\n                                       bool on_upper) const\n{\n    assert(tri >= 0 && tri < get_triangulation().get_ntri() &&\n           \"Triangle index out of bounds.\");\n\n    unsigned int config =\n        (get_z(get_triangulation().get_triangle_point(tri, 0)) >= level) |\n        (get_z(get_triangulation().get_triangle_point(tri, 1)) >= level) << 1 |\n        (get_z(get_triangulation().get_triangle_point(tri, 2)) >= level) << 2;\n\n    if (on_upper) config = 7-config;\n\n    switch (config) {\n        case 0: return -1;\n        case 1: return  2;\n        case 2: return  0;\n        case 3: return  2;\n        case 4: return  1;\n        case 5: return  1;\n        case 6: return  0;\n        case 7: return -1;\n        default: assert(0 && \"Invalid config value\"); return -1;\n    }\n}\n\nconst Triangulation& TriContourGenerator::get_triangulation() const\n{\n    return *(Triangulation*)_triangulation.ptr();\n}\n\nconst double& TriContourGenerator::get_z(int point) const\n{\n    assert(point >= 0 && point < get_triangulation().get_npoints() &&\n           \"Point index out of bounds.\");\n    return ((const double*)PyArray_DATA(_z))[point];\n}\n\nvoid TriContourGenerator::init_type()\n{\n\n\n    behaviors().name(\"TriContourGenerator\");\n    behaviors().doc(\"TriContourGenerator\");\n\n    add_varargs_method(\"create_contour\",\n                       &TriContourGenerator::create_contour,\n                       \"create_contour(level)\");\n    add_varargs_method(\"create_filled_contour\",\n                       &TriContourGenerator::create_filled_contour,\n                       \"create_filled_contour(lower_level, upper_level)\");\n}\n\nXY TriContourGenerator::interp(int point1,\n                               int point2,\n                               const double& level) const\n{\n    assert(point1 >= 0 && point1 < get_triangulation().get_npoints() &&\n           \"Point index 1 out of bounds.\");\n    assert(point2 >= 0 && point2 < get_triangulation().get_npoints() &&\n           \"Point index 2 out of bounds.\");\n    assert(point1 != point2 && \"Identical points\");\n    double fraction = (get_z(point2) - level) / (get_z(point2) - get_z(point1));\n    return get_triangulation().get_point_coords(point1)*fraction +\n           get_triangulation().get_point_coords(point2)*(1.0 - fraction);\n}\n\n\n\n\nTrapezoidMapTriFinder::TrapezoidMapTriFinder(Py::Object triangulation)\n    : _triangulation(triangulation),\n      _points(0),\n      _tree(0)\n{\n\n}\n\nTrapezoidMapTriFinder::~TrapezoidMapTriFinder()\n{\n\n    clear();\n}\n\nbool\nTrapezoidMapTriFinder::add_edge_to_tree(const Edge& edge)\n{\n    std::vector<Trapezoid*> trapezoids;\n    if (!find_trapezoids_intersecting_edge(edge, trapezoids))\n        return false;\n    assert(!trapezoids.empty() && \"No trapezoids intersect edge\");\n\n    const Point* p = edge.left;\n    const Point* q = edge.right;\n    Trapezoid* left_old = 0;    // old trapezoid to the left.\n    Trapezoid* left_below = 0;  // below trapezoid to the left.\n    Trapezoid* left_above = 0;  // above trapezoid to the left.\n\n    // Iterate through trapezoids intersecting edge from left to right.\n    // Replace each old trapezoid with 2+ new trapezoids, and replace its\n    // corresponding nodes in the search tree with new nodes.\n    unsigned int ntraps = trapezoids.size();\n    for (unsigned int i = 0; i < ntraps; ++i) {\n        Trapezoid* old = trapezoids[i];  // old trapezoid to replace.\n        bool start_trap = (i == 0);\n        bool end_trap = (i == ntraps-1);\n        bool have_left = (start_trap && edge.left != old->left);\n        bool have_right = (end_trap && edge.right != old->right);\n\n        // Old trapezoid is replaced by up to 4 new trapezoids: left is to the\n        // left of the start point p, below/above are below/above the edge\n        // inserted, and right is to the right of the end point q.\n        Trapezoid* left = 0;\n        Trapezoid* below = 0;\n        Trapezoid* above = 0;\n        Trapezoid* right = 0;\n\n        // There are 4 different cases here depending on whether the old\n        // trapezoid in question is the start and/or end trapezoid of those\n        // that intersect the edge inserted.  There is some code duplication\n        // here but it is much easier to understand this way rather than\n        // interleave the 4 different cases with many more if-statements.\n        if (start_trap && end_trap) {\n            // Edge intersects a single trapezoid.\n            if (have_left)\n                left = new Trapezoid(old->left, p, old->below, old->above);\n            below = new Trapezoid(p, q, old->below, edge);\n            above = new Trapezoid(p, q, edge, old->above);\n            if (have_right)\n                right = new Trapezoid(q, old->right, old->below, old->above);\n\n            // Set pairs of trapezoid neighbours.\n            if (have_left) {\n                left->set_lower_left(old->lower_left);\n                left->set_upper_left(old->upper_left);\n                left->set_lower_right(below);\n                left->set_upper_right(above);\n            }\n            else {\n                below->set_lower_left(old->lower_left);\n                above->set_upper_left(old->upper_left);\n            }\n\n            if (have_right) {\n                right->set_lower_right(old->lower_right);\n                right->set_upper_right(old->upper_right);\n                below->set_lower_right(right);\n                above->set_upper_right(right);\n            }\n            else {\n                below->set_lower_right(old->lower_right);\n                above->set_upper_right(old->upper_right);\n            }\n        }\n        else if (start_trap) {\n            // Old trapezoid is the first of 2+ trapezoids that the edge\n            // intersects.\n            if (have_left)\n                left = new Trapezoid(old->left, p, old->below, old->above);\n            below = new Trapezoid(p, old->right, old->below, edge);\n            above = new Trapezoid(p, old->right, edge, old->above);\n\n            // Set pairs of trapezoid neighbours.\n            if (have_left) {\n                left->set_lower_left(old->lower_left);\n                left->set_upper_left(old->upper_left);\n                left->set_lower_right(below);\n                left->set_upper_right(above);\n            }\n            else {\n                below->set_lower_left(old->lower_left);\n                above->set_upper_left(old->upper_left);\n            }\n\n            below->set_lower_right(old->lower_right);\n            above->set_upper_right(old->upper_right);\n        }\n        else if (end_trap) {\n            // Old trapezoid is the last of 2+ trapezoids that the edge\n            // intersects.\n            if (left_below->below == old->below) {\n                below = left_below;\n                below->right = q;\n            }\n            else\n                below = new Trapezoid(old->left, q, old->below, edge);\n\n            if (left_above->above == old->above) {\n                above = left_above;\n                above->right = q;\n            }\n            else\n                above = new Trapezoid(old->left, q, edge, old->above);\n\n            if (have_right)\n                right = new Trapezoid(q, old->right, old->below, old->above);\n\n            // Set pairs of trapezoid neighbours.\n            if (have_right) {\n                right->set_lower_right(old->lower_right);\n                right->set_upper_right(old->upper_right);\n                below->set_lower_right(right);\n                above->set_upper_right(right);\n            }\n            else {\n                below->set_lower_right(old->lower_right);\n                above->set_upper_right(old->upper_right);\n            }\n\n            // Connect to new trapezoids replacing prevOld.\n            if (below != left_below) {\n                below->set_upper_left(left_below);\n                if (old->lower_left == left_old)\n                    below->set_lower_left(left_below);\n                else\n                    below->set_lower_left(old->lower_left);\n            }\n\n            if (above != left_above) {\n                above->set_lower_left(left_above);\n                if (old->upper_left == left_old)\n                    above->set_upper_left(left_above);\n                else\n                    above->set_upper_left(old->upper_left);\n            }\n        }\n        else {  // Middle trapezoid.\n            // Old trapezoid is neither the first nor last of the 3+ trapezoids\n            // that the edge intersects.\n            if (left_below->below == old->below) {\n                below = left_below;\n                below->right = old->right;\n            }\n            else\n                below = new Trapezoid(old->left, old->right, old->below, edge);\n\n            if (left_above->above == old->above) {\n                above = left_above;\n                above->right = old->right;\n            }\n            else\n                above = new Trapezoid(old->left, old->right, edge, old->above);\n\n            // Connect to new trapezoids replacing prevOld.\n            if (below != left_below) {  // below is new.\n                below->set_upper_left(left_below);\n                if (old->lower_left == left_old)\n                    below->set_lower_left(left_below);\n                else\n                    below->set_lower_left(old->lower_left);\n            }\n\n            if (above != left_above) {  // above is new.\n                above->set_lower_left(left_above);\n                if (old->upper_left == left_old)\n                    above->set_upper_left(left_above);\n                else\n                    above->set_upper_left(old->upper_left);\n            }\n\n            below->set_lower_right(old->lower_right);\n            above->set_upper_right(old->upper_right);\n        }\n\n        // Create new nodes to add to search tree.  Below and above trapezoids\n        // may already have owning trapezoid nodes, in which case reuse them.\n        Node* new_top_node = new Node(\n            &edge,\n            below == left_below ? below->trapezoid_node : new Node(below),\n            above == left_above ? above->trapezoid_node : new Node(above));\n        if (have_right)\n            new_top_node = new Node(q, new_top_node, new Node(right));\n        if (have_left)\n            new_top_node = new Node(p, new Node(left), new_top_node);\n\n        // Insert new_top_node in correct position or positions in search tree.\n        Node* old_node = old->trapezoid_node;\n        if (old_node == _tree)\n            _tree = new_top_node;\n        else\n            old_node->replace_with(new_top_node);\n\n        // old_node has been removed from all of its parents and is no longer\n        // needed.\n        assert(old_node->has_no_parents() && \"Node should have no parents\");\n        delete old_node;\n\n        // Clearing up.\n        if (!end_trap) {\n            // Prepare for next loop.\n            left_old = old;\n            left_above = above;\n            left_below = below;\n        }\n    }\n\n    return true;\n}\n\nvoid\nTrapezoidMapTriFinder::clear()\n{\n    delete [] _points;\n    _points = 0;\n\n    _edges.clear();\n\n    delete _tree;\n    _tree = 0;\n}\n\nPy::Object\nTrapezoidMapTriFinder::find_many(const Py::Tuple& args)\n{\n    args.verify_length(2);\n\n    // Check input arguments.\n    PyArrayObject* x = (PyArrayObject*)PyArray_ContiguousFromObject(\n                           args[0].ptr(), NPY_DOUBLE, 0, 0);\n    PyArrayObject* y = (PyArrayObject*)PyArray_ContiguousFromObject(\n                           args[1].ptr(), NPY_DOUBLE, 0, 0);\n    bool ok = (x != 0 && y != 0 && PyArray_NDIM(x) == PyArray_NDIM(y));\n    int ndim = x == 0 ? 0 : PyArray_NDIM(x);\n    for (int i = 0; ok && i < ndim; ++i)\n        ok = (PyArray_DIM(x,i) == PyArray_DIM(y,i));\n\n    if (!ok) {\n        Py_XDECREF(x);\n        Py_XDECREF(y);\n        throw Py::ValueError(\"x and y must be array_like with same shape\");\n    }\n\n    // Create integer array to return.\n    PyArrayObject* tri = (PyArrayObject*)PyArray_SimpleNew(\n                             ndim, PyArray_DIMS(x), NPY_INT);\n\n    // Fill returned array.\n    double* x_ptr = (double*)PyArray_DATA(x);\n    double* y_ptr = (double*)PyArray_DATA(y);\n    int* tri_ptr = (int*)PyArray_DATA(tri);\n    int* tri_end = tri_ptr + PyArray_SIZE(tri);\n    while (tri_ptr < tri_end)\n        *tri_ptr++ = find_one(XY(*x_ptr++, *y_ptr++));\n\n    Py_XDECREF(x);\n    Py_XDECREF(y);\n    return Py::asObject((PyObject*)tri);\n}\n\nint\nTrapezoidMapTriFinder::find_one(const XY& xy)\n{\n    const Node* node = _tree->search(xy);\n    assert(node != 0 && \"Search tree for point returned null node\");\n    return node->get_tri();\n}\n\nbool\nTrapezoidMapTriFinder::find_trapezoids_intersecting_edge(\n    const Edge& edge,\n    std::vector<Trapezoid*>& trapezoids)\n{\n    // This is the FollowSegment algorithm of de Berg et al, with some extra\n    // checks to deal with simple colinear (i.e. invalid) triangles.\n    trapezoids.clear();\n    Trapezoid* trapezoid = _tree->search(edge);\n    if (trapezoid == 0) {\n        assert(trapezoid != 0 && \"search(edge) returns null trapezoid\");\n        return false;\n    }\n\n    trapezoids.push_back(trapezoid);\n    while (edge.right->is_right_of(*trapezoid->right)) {\n        int orient = edge.get_point_orientation(*trapezoid->right);\n        if (orient == 0) {\n            if (edge.point_below == trapezoid->right)\n                orient = +1;\n            else if (edge.point_above == trapezoid->right)\n                orient = -1;\n            else {\n                assert(0 && \"Unable to deal with point on edge\");\n                return false;\n            }\n        }\n\n        if (orient == -1)\n            trapezoid = trapezoid->lower_right;\n        else if (orient == +1)\n            trapezoid = trapezoid->upper_right;\n\n        if (trapezoid == 0) {\n            assert(0 && \"Expected trapezoid neighbor\");\n            return false;\n        }\n        trapezoids.push_back(trapezoid);\n    }\n\n    return true;\n}\n\nPy::Object\nTrapezoidMapTriFinder::get_tree_stats()\n{\n\n\n    NodeStats stats;\n    _tree->get_stats(0, stats);\n\n    Py::List list(7);\n    list[0] = Py::Int(stats.node_count);\n    list[1] = Py::Int(static_cast<long>(stats.unique_nodes.size()));\n    list[2] = Py::Int(stats.trapezoid_count);\n    list[3] = Py::Int(static_cast<long>(stats.unique_trapezoid_nodes.size()));\n    list[4] = Py::Int(stats.max_parent_count);\n    list[5] = Py::Int(stats.max_depth);\n    list[6] = Py::Float(stats.sum_trapezoid_depth / stats.trapezoid_count);\n    return list;\n}\n\nconst Triangulation&\nTrapezoidMapTriFinder::get_triangulation() const\n{\n    return *(Triangulation*)_triangulation.ptr();\n}\n\nvoid\nTrapezoidMapTriFinder::init_type()\n{\n\n\n    behaviors().name(\"TrapezoidMapTriFinder\");\n    behaviors().doc(\"TrapezoidMapTriFinder\");\n\n    add_varargs_method(\"find_many\",\n                       &TrapezoidMapTriFinder::find_many,\n                       \"find_many(x,y)\");\n    add_noargs_method(\"get_tree_stats\",\n                      &TrapezoidMapTriFinder::get_tree_stats,\n                      \"get_tree_stats()\");\n    add_noargs_method(\"initialize\",\n                      &TrapezoidMapTriFinder::initialize,\n                      \"initialize()\");\n    add_noargs_method(\"print_tree\",\n                      &TrapezoidMapTriFinder::print_tree,\n                      \"print_tree()\");\n}\n\nPy::Object\nTrapezoidMapTriFinder::initialize()\n{\n\n\n    clear();\n    const Triangulation& triang = get_triangulation();\n\n    // Set up points array, which contains all of the points in the\n    // triangulation plus the 4 corners of the enclosing rectangle.\n    int npoints = triang.get_npoints();\n    _points = new Point[npoints + 4];\n    BoundingBox bbox;\n    for (int i = 0; i < npoints; ++i) {\n        XY xy = triang.get_point_coords(i);\n        // Avoid problems with -0.0 values different from 0.0\n        if (xy.x == -0.0)\n            xy.x = 0.0;\n        if (xy.y == -0.0)\n            xy.y = 0.0;\n        _points[i] = Point(xy);\n        bbox.add(xy);\n    }\n\n    // Last 4 points are corner points of enclosing rectangle.  Enclosing\n    // rectangle made slightly larger in case corner points are already in the\n    // triangulation.\n    if (bbox.empty) {\n        bbox.add(XY(0.0, 0.0));\n        bbox.add(XY(1.0, 1.0));\n    }\n    else {\n        const double small = 0.1;  // Any value > 0.0\n        bbox.expand( (bbox.upper - bbox.lower)*small );\n    }\n    _points[npoints  ] = Point(bbox.lower);                  // SW point.\n    _points[npoints+1] = Point(bbox.upper.x, bbox.lower.y);  // SE point.\n    _points[npoints+2] = Point(bbox.lower.x, bbox.upper.y);  // NW point.\n    _points[npoints+3] = Point(bbox.upper);                  // NE point.\n\n    // Set up edges array.\n    // First the bottom and top edges of the enclosing rectangle.\n    _edges.push_back(Edge(&_points[npoints],  &_points[npoints+1],-1,-1,0,0));\n    _edges.push_back(Edge(&_points[npoints+2],&_points[npoints+3],-1,-1,0,0));\n\n    // Add all edges in the triangulation that point to the right.  Do not\n    // explicitly include edges that point to the left as the neighboring\n    // triangle will supply that, unless there is no such neighbor.\n    int ntri = triang.get_ntri();\n    for (int tri = 0; tri < ntri; ++tri) {\n        if (!triang.is_masked(tri)) {\n            for (int edge = 0; edge < 3; ++edge) {\n                Point* start = _points + triang.get_triangle_point(tri,edge);\n                Point* end   = _points +\n                               triang.get_triangle_point(tri,(edge+1)%3);\n                Point* other = _points +\n                               triang.get_triangle_point(tri,(edge+2)%3);\n                TriEdge neighbor = triang.get_neighbor_edge(tri,edge);\n                if (end->is_right_of(*start)) {\n                    const Point* neighbor_point_below = (neighbor.tri == -1) ?\n                        0 : _points + triang.get_triangle_point(\n                                          neighbor.tri, (neighbor.edge+2)%3);\n                    _edges.push_back(Edge(start, end, neighbor.tri, tri,\n                                          neighbor_point_below, other));\n                }\n                else if (neighbor.tri == -1)\n                    _edges.push_back(Edge(end, start, tri, -1, other, 0));\n\n                // Set triangle associated with start point if not already set.\n                if (start->tri == -1)\n                    start->tri = tri;\n            }\n        }\n    }\n\n    // Initial trapezoid is enclosing rectangle.\n    _tree = new Node(new Trapezoid(&_points[npoints], &_points[npoints+1],\n                                   _edges[0], _edges[1]));\n    _tree->assert_valid(false);\n\n    // Randomly shuffle all edges other than first 2.\n    RandomNumberGenerator rng(1234);\n    std::random_shuffle(_edges.begin()+2, _edges.end(), rng);\n\n    // Add edges, one at a time, to tree.\n    unsigned int nedges = _edges.size();\n    for (unsigned int index = 2; index < nedges; ++index) {\n        if (!add_edge_to_tree(_edges[index]))\n            throw Py::RuntimeError(\"Triangulation is invalid\");\n        _tree->assert_valid(index == nedges-1);\n    }\n\n    return Py::None();\n}\n\nPy::Object\nTrapezoidMapTriFinder::print_tree()\n{\n\n\n    assert(_tree != 0 && \"Null Node tree\");\n    _tree->print();\n\n    return Py::None();\n}\n\nTrapezoidMapTriFinder::Edge::Edge(const Point* left_,\n                                  const Point* right_,\n                                  int triangle_below_,\n                                  int triangle_above_,\n                                  const Point* point_below_,\n                                  const Point* point_above_)\n    : left(left_),\n      right(right_),\n      triangle_below(triangle_below_),\n      triangle_above(triangle_above_),\n      point_below(point_below_),\n      point_above(point_above_)\n{\n    assert(left != 0 && \"Null left point\");\n    assert(right != 0 && \"Null right point\");\n    assert(right->is_right_of(*left) && \"Incorrect point order\");\n    assert(triangle_below >= -1 && \"Invalid triangle below index\");\n    assert(triangle_above >= -1 && \"Invalid triangle above index\");\n}\n\nint\nTrapezoidMapTriFinder::Edge::get_point_orientation(const XY& xy) const\n{\n    double cross_z = (xy - *left).cross_z(*right - *left);\n    return (cross_z > 0.0) ? +1 : ((cross_z < 0.0) ? -1 : 0);\n}\n\ndouble\nTrapezoidMapTriFinder::Edge::get_slope() const\n{\n    // Divide by zero is acceptable here.\n    XY diff = *right - *left;\n    return diff.y / diff.x;\n}\n\ndouble\nTrapezoidMapTriFinder::Edge::get_y_at_x(const double& x) const\n{\n    if (left->x == right->x) {\n        // If edge is vertical, return lowest y from left point.\n        assert(x == left->x && \"x outside of edge\");\n        return left->y;\n    }\n    else {\n        // Equation of line: left + lambda*(right - left) = xy.\n        // i.e. left.x + lambda(right.x - left.x) = x and similar for y.\n        double lambda = (x - left->x) / (right->x - left->x);\n        assert(lambda >= 0 && lambda <= 1.0 && \"Lambda out of bounds\");\n        return left->y + lambda*(right->y - left->y);\n    }\n}\n\nbool\nTrapezoidMapTriFinder::Edge::has_point(const Point* point) const\n{\n    assert(point != 0 && \"Null point\");\n    return (left == point || right == point);\n}\n\nbool\nTrapezoidMapTriFinder::Edge::operator==(const Edge& other) const\n{\n    return this == &other;\n}\n\nvoid\nTrapezoidMapTriFinder::Edge::print_debug() const\n{\n    std::cout << \"Edge \" << *this << \" tri_below=\" << triangle_below\n        << \" tri_above=\" << triangle_above << std::endl;\n}\n\nTrapezoidMapTriFinder::Node::Node(const Point* point, Node* left, Node* right)\n    : _type(Type_XNode)\n{\n    assert(point != 0 && \"Invalid point\");\n    assert(left != 0 && \"Invalid left node\");\n    assert(right != 0 && \"Invalid right node\");\n    _union.xnode.point = point;\n    _union.xnode.left = left;\n    _union.xnode.right = right;\n    left->add_parent(this);\n    right->add_parent(this);\n}\n\nTrapezoidMapTriFinder::Node::Node(const Edge* edge, Node* below, Node* above)\n    : _type(Type_YNode)\n{\n    assert(edge != 0 && \"Invalid edge\");\n    assert(below != 0 && \"Invalid below node\");\n    assert(above != 0 && \"Invalid above node\");\n    _union.ynode.edge = edge;\n    _union.ynode.below = below;\n    _union.ynode.above = above;\n    below->add_parent(this);\n    above->add_parent(this);\n}\n\nTrapezoidMapTriFinder::Node::Node(Trapezoid* trapezoid)\n    : _type(Type_TrapezoidNode)\n{\n    assert(trapezoid != 0 && \"Null Trapezoid\");\n    _union.trapezoid = trapezoid;\n    trapezoid->trapezoid_node = this;\n}\n\nTrapezoidMapTriFinder::Node::~Node()\n{\n    switch (_type) {\n        case Type_XNode:\n            if (_union.xnode.left->remove_parent(this))\n                delete _union.xnode.left;\n            if (_union.xnode.right->remove_parent(this))\n                delete _union.xnode.right;\n            break;\n        case Type_YNode:\n            if (_union.ynode.below->remove_parent(this))\n                delete _union.ynode.below;\n            if (_union.ynode.above->remove_parent(this))\n                delete _union.ynode.above;\n            break;\n        case Type_TrapezoidNode:\n            delete _union.trapezoid;\n            break;\n    }\n}\n\nvoid\nTrapezoidMapTriFinder::Node::add_parent(Node* parent)\n{\n    assert(parent != 0 && \"Null parent\");\n    assert(parent != this && \"Cannot be parent of self\");\n    assert(!has_parent(parent) && \"Parent already in collection\");\n    _parents.push_back(parent);\n}\n\nvoid\nTrapezoidMapTriFinder::Node::assert_valid(bool tree_complete) const\n{\n#ifndef NDEBUG\n    // Check parents.\n    for (Parents::const_iterator it = _parents.begin();\n         it != _parents.end(); ++it) {\n        Node* parent = *it;\n        assert(parent != this && \"Cannot be parent of self\");\n        assert(parent->has_child(this) && \"Parent missing child\");\n    }\n\n    // Check children, and recurse.\n    switch (_type) {\n        case Type_XNode:\n            assert(_union.xnode.left != 0 && \"Null left child\");\n            assert(_union.xnode.left->has_parent(this) && \"Incorrect parent\");\n            assert(_union.xnode.right != 0 && \"Null right child\");\n            assert(_union.xnode.right->has_parent(this) && \"Incorrect parent\");\n            _union.xnode.left->assert_valid(tree_complete);\n            _union.xnode.right->assert_valid(tree_complete);\n            break;\n        case Type_YNode:\n            assert(_union.ynode.below != 0 && \"Null below child\");\n            assert(_union.ynode.below->has_parent(this) && \"Incorrect parent\");\n            assert(_union.ynode.above != 0 && \"Null above child\");\n            assert(_union.ynode.above->has_parent(this) && \"Incorrect parent\");\n            _union.ynode.below->assert_valid(tree_complete);\n            _union.ynode.above->assert_valid(tree_complete);\n            break;\n        case Type_TrapezoidNode:\n            assert(_union.trapezoid != 0 && \"Null trapezoid\");\n            assert(_union.trapezoid->trapezoid_node == this &&\n                   \"Incorrect trapezoid node\");\n            _union.trapezoid->assert_valid(tree_complete);\n            break;\n    }\n#endif\n}\n\nvoid\nTrapezoidMapTriFinder::Node::get_stats(int depth,\n                                       NodeStats& stats) const\n{\n    stats.node_count++;\n    if (depth > stats.max_depth)\n        stats.max_depth = depth;\n    bool new_node = stats.unique_nodes.insert(this).second;\n    if (new_node)\n        stats.max_parent_count = std::max(stats.max_parent_count,\n                                          static_cast<long>(_parents.size()));\n\n    switch (_type) {\n        case Type_XNode:\n            _union.xnode.left->get_stats(depth+1, stats);\n            _union.xnode.right->get_stats(depth+1, stats);\n            break;\n        case Type_YNode:\n            _union.ynode.below->get_stats(depth+1, stats);\n            _union.ynode.above->get_stats(depth+1, stats);\n            break;\n        default:  // Type_TrapezoidNode:\n            stats.unique_trapezoid_nodes.insert(this);\n            stats.trapezoid_count++;\n            stats.sum_trapezoid_depth += depth;\n            break;\n    }\n}\n\nint\nTrapezoidMapTriFinder::Node::get_tri() const\n{\n    switch (_type) {\n        case Type_XNode:\n            return _union.xnode.point->tri;\n        case Type_YNode:\n            if (_union.ynode.edge->triangle_above != -1)\n                return _union.ynode.edge->triangle_above;\n            else\n                return _union.ynode.edge->triangle_below;\n        default:  // Type_TrapezoidNode:\n            assert(_union.trapezoid->below.triangle_above ==\n                   _union.trapezoid->above.triangle_below &&\n                   \"Inconsistent triangle indices from trapezoid edges\");\n            return _union.trapezoid->below.triangle_above;\n    }\n}\n\nbool\nTrapezoidMapTriFinder::Node::has_child(const Node* child) const\n{\n    assert(child != 0 && \"Null child node\");\n    switch (_type) {\n        case Type_XNode:\n            return (_union.xnode.left == child || _union.xnode.right == child);\n        case Type_YNode:\n            return (_union.ynode.below == child ||\n                    _union.ynode.above == child);\n        default:  // Type_TrapezoidNode:\n            return false;\n    }\n}\n\nbool\nTrapezoidMapTriFinder::Node::has_no_parents() const\n{\n    return _parents.empty();\n}\n\nbool\nTrapezoidMapTriFinder::Node::has_parent(const Node* parent) const\n{\n    return (std::find(_parents.begin(), _parents.end(), parent) !=\n            _parents.end());\n}\n\nvoid\nTrapezoidMapTriFinder::Node::print(int depth /* = 0 */) const\n{\n    for (int i = 0; i < depth; ++i) std::cout << \"  \";\n    switch (_type) {\n        case Type_XNode:\n            std::cout << \"XNode \" << *_union.xnode.point << std::endl;\n            _union.xnode.left->print(depth + 1);\n            _union.xnode.right->print(depth + 1);\n            break;\n        case Type_YNode:\n            std::cout << \"YNode \" << *_union.ynode.edge << std::endl;\n            _union.ynode.below->print(depth + 1);\n            _union.ynode.above->print(depth + 1);\n            break;\n        case Type_TrapezoidNode:\n            std::cout << \"Trapezoid ll=\"\n                << _union.trapezoid->get_lower_left_point()  << \" lr=\"\n                << _union.trapezoid->get_lower_right_point() << \" ul=\"\n                << _union.trapezoid->get_upper_left_point()  << \" ur=\"\n                << _union.trapezoid->get_upper_right_point() << std::endl;\n            break;\n    }\n}\n\nbool\nTrapezoidMapTriFinder::Node::remove_parent(Node* parent)\n{\n    assert(parent != 0 && \"Null parent\");\n    assert(parent != this && \"Cannot be parent of self\");\n    Parents::iterator it = std::find(_parents.begin(), _parents.end(), parent);\n    assert(it != _parents.end() && \"Parent not in collection\");\n    _parents.erase(it);\n    return _parents.empty();\n}\n\nvoid\nTrapezoidMapTriFinder::Node::replace_child(Node* old_child, Node* new_child)\n{\n    switch (_type) {\n        case Type_XNode:\n            assert((_union.xnode.left == old_child ||\n                    _union.xnode.right == old_child) && \"Not a child Node\");\n            assert(new_child != 0 && \"Null child node\");\n            if (_union.xnode.left == old_child)\n                _union.xnode.left = new_child;\n            else\n                _union.xnode.right = new_child;\n            break;\n        case Type_YNode:\n            assert((_union.ynode.below == old_child ||\n                    _union.ynode.above == old_child) && \"Not a child node\");\n            assert(new_child != 0 && \"Null child node\");\n            if (_union.ynode.below == old_child)\n                _union.ynode.below = new_child;\n            else\n                _union.ynode.above = new_child;\n            break;\n        case Type_TrapezoidNode:\n            assert(0 && \"Invalid type for this operation\");\n            break;\n    }\n    old_child->remove_parent(this);\n    new_child->add_parent(this);\n}\n\nvoid\nTrapezoidMapTriFinder::Node::replace_with(Node* new_node)\n{\n    assert(new_node != 0 && \"Null replacement node\");\n    // Replace child of each parent with new_node.  As each has parent has its\n    // child replaced it is removed from the _parents collection.\n    while (!_parents.empty())\n        _parents.front()->replace_child(this, new_node);\n}\n\nconst TrapezoidMapTriFinder::Node*\nTrapezoidMapTriFinder::Node::search(const XY& xy)\n{\n    switch (_type) {\n        case Type_XNode:\n            if (xy == *_union.xnode.point)\n                return this;\n            else if (xy.is_right_of(*_union.xnode.point))\n                return _union.xnode.right->search(xy);\n            else\n                return _union.xnode.left->search(xy);\n        case Type_YNode: {\n            int orient = _union.ynode.edge->get_point_orientation(xy);\n            if (orient == 0)\n                return this;\n            else if (orient < 0)\n                return _union.ynode.above->search(xy);\n            else\n                return _union.ynode.below->search(xy);\n        }\n        default:  // Type_TrapezoidNode:\n            return this;\n    }\n}\n\nTrapezoidMapTriFinder::Trapezoid*\nTrapezoidMapTriFinder::Node::search(const Edge& edge)\n{\n    switch (_type) {\n        case Type_XNode:\n            if (edge.left == _union.xnode.point)\n                return _union.xnode.right->search(edge);\n            else {\n                if (edge.left->is_right_of(*_union.xnode.point))\n                    return _union.xnode.right->search(edge);\n                else\n                    return _union.xnode.left->search(edge);\n            }\n        case Type_YNode:\n            if (edge.left == _union.ynode.edge->left) {\n                // Coinciding left edge points.\n                if (edge.get_slope() == _union.ynode.edge->get_slope()) {\n                    if (_union.ynode.edge->triangle_above ==\n                        edge.triangle_below)\n                        return _union.ynode.above->search(edge);\n                    else if (_union.ynode.edge->triangle_below ==\n                             edge.triangle_above)\n                        return _union.ynode.below->search(edge);\n                    else {\n                        assert(0 &&\n                               \"Invalid triangulation, common left points\");\n                        return 0;\n                    }\n                }\n                if (edge.get_slope() > _union.ynode.edge->get_slope())\n                    return _union.ynode.above->search(edge);\n                else\n                    return _union.ynode.below->search(edge);\n            }\n            else if (edge.right == _union.ynode.edge->right) {\n                // Coinciding right edge points.\n                if (edge.get_slope() == _union.ynode.edge->get_slope()) {\n                    if (_union.ynode.edge->triangle_above ==\n                        edge.triangle_below)\n                        return _union.ynode.above->search(edge);\n                    else if (_union.ynode.edge->triangle_below ==\n                             edge.triangle_above)\n                        return _union.ynode.below->search(edge);\n                    else {\n                        assert(0 &&\n                               \"Invalid triangulation, common right points\");\n                        return 0;\n                    }\n                }\n                if (edge.get_slope() > _union.ynode.edge->get_slope())\n                    return _union.ynode.below->search(edge);\n                else\n                    return _union.ynode.above->search(edge);\n            }\n            else {\n                int orient =\n                    _union.ynode.edge->get_point_orientation(*edge.left);\n                if (orient == 0) {\n                    // edge.left lies on _union.ynode.edge\n                    if (_union.ynode.edge->point_above != 0 &&\n                        edge.has_point(_union.ynode.edge->point_above))\n                        orient = -1;\n                    else if (_union.ynode.edge->point_below != 0 &&\n                             edge.has_point(_union.ynode.edge->point_below))\n                        orient = +1;\n                    else {\n                        assert(0 && \"Invalid triangulation, point on edge\");\n                        return 0;\n                    }\n                }\n                if (orient < 0)\n                    return _union.ynode.above->search(edge);\n                else\n                    return _union.ynode.below->search(edge);\n            }\n        default:  // Type_TrapezoidNode:\n            return _union.trapezoid;\n    }\n}\n\nTrapezoidMapTriFinder::Trapezoid::Trapezoid(const Point* left_,\n                                            const Point* right_,\n                                            const Edge& below_,\n                                            const Edge& above_)\n    : left(left_), right(right_), below(below_), above(above_),\n      lower_left(0), lower_right(0), upper_left(0), upper_right(0),\n      trapezoid_node(0)\n{\n    assert(left != 0 && \"Null left point\");\n    assert(right != 0 && \"Null right point\");\n    assert(right->is_right_of(*left) && \"Incorrect point order\");\n}\n\nvoid\nTrapezoidMapTriFinder::Trapezoid::assert_valid(bool tree_complete) const\n{\n#ifndef NDEBUG\n    assert(left != 0 && \"Null left point\");\n    assert(right != 0 && \"Null right point\");\n\n    if (lower_left != 0) {\n        assert(lower_left->below == below &&\n               lower_left->lower_right == this &&\n               \"Incorrect lower_left trapezoid\");\n        assert(get_lower_left_point() == lower_left->get_lower_right_point() &&\n               \"Incorrect lower left point\");\n    }\n\n    if (lower_right != 0) {\n        assert(lower_right->below == below &&\n               lower_right->lower_left == this &&\n               \"Incorrect lower_right trapezoid\");\n        assert(get_lower_right_point() == lower_right->get_lower_left_point() &&\n               \"Incorrect lower right point\");\n    }\n\n    if (upper_left != 0) {\n        assert(upper_left->above == above &&\n               upper_left->upper_right == this &&\n               \"Incorrect upper_left trapezoid\");\n        assert(get_upper_left_point() == upper_left->get_upper_right_point() &&\n               \"Incorrect upper left point\");\n    }\n\n    if (upper_right != 0) {\n        assert(upper_right->above == above &&\n               upper_right->upper_left == this &&\n               \"Incorrect upper_right trapezoid\");\n        assert(get_upper_right_point() == upper_right->get_upper_left_point() &&\n               \"Incorrect upper right point\");\n    }\n\n    assert(trapezoid_node != 0 && \"Null trapezoid_node\");\n\n    if (tree_complete) {\n        assert(below.triangle_above == above.triangle_below &&\n               \"Inconsistent triangle indices from trapezoid edges\");\n    }\n#endif\n}\n\nXY\nTrapezoidMapTriFinder::Trapezoid::get_lower_left_point() const\n{\n    double x = left->x;\n    return XY(x, below.get_y_at_x(x));\n}\n\nXY\nTrapezoidMapTriFinder::Trapezoid::get_lower_right_point() const\n{\n    double x = right->x;\n    return XY(x, below.get_y_at_x(x));\n}\n\nXY\nTrapezoidMapTriFinder::Trapezoid::get_upper_left_point() const\n{\n    double x = left->x;\n    return XY(x, above.get_y_at_x(x));\n}\n\nXY\nTrapezoidMapTriFinder::Trapezoid::get_upper_right_point() const\n{\n    double x = right->x;\n    return XY(x, above.get_y_at_x(x));\n}\n\nvoid\nTrapezoidMapTriFinder::Trapezoid::print_debug() const\n{\n    std::cout << \"Trapezoid \" << this\n        << \" left=\" << *left\n        << \" right=\" << *right\n        << \" below=\" << below\n        << \" above=\" << above\n        << \" ll=\" << lower_left\n        << \" lr=\" << lower_right\n        << \" ul=\" << upper_left\n        << \" ur=\" << upper_right\n        << \" node=\" << trapezoid_node\n        << \" llp=\" << get_lower_left_point()\n        << \" lrp=\" << get_lower_right_point()\n        << \" ulp=\" << get_upper_left_point()\n        << \" urp=\" << get_upper_right_point() << std::endl;\n}\n\nvoid\nTrapezoidMapTriFinder::Trapezoid::set_lower_left(Trapezoid* lower_left_)\n{\n    lower_left = lower_left_;\n    if (lower_left != 0)\n        lower_left->lower_right = this;\n}\n\nvoid\nTrapezoidMapTriFinder::Trapezoid::set_lower_right(Trapezoid* lower_right_)\n{\n    lower_right = lower_right_;\n    if (lower_right != 0)\n        lower_right->lower_left = this;\n}\n\nvoid\nTrapezoidMapTriFinder::Trapezoid::set_upper_left(Trapezoid* upper_left_)\n{\n    upper_left = upper_left_;\n    if (upper_left != 0)\n        upper_left->upper_right = this;\n}\n\nvoid\nTrapezoidMapTriFinder::Trapezoid::set_upper_right(Trapezoid* upper_right_)\n{\n    upper_right = upper_right_;\n    if (upper_right != 0)\n        upper_right->upper_left = this;\n}\n\n\nRandomNumberGenerator::RandomNumberGenerator(unsigned long seed)\n    : _m(21870), _a(1291), _c(4621), _seed(seed % _m)\n{}\n\nunsigned long\nRandomNumberGenerator::operator()(unsigned long max_value)\n{\n    _seed = (_seed*_a + _c) % _m;\n    return (_seed*max_value) / _m;\n}\n\n\n\n\n\n#if PY_MAJOR_VERSION >= 3\nPyMODINIT_FUNC\nPyInit__tri(void)\n#else\nPyMODINIT_FUNC\ninit_tri(void)\n#endif\n{\n    import_array();\n\n    static TriModule* triModule = NULL;\n    triModule = new TriModule();\n\n    #if PY_MAJOR_VERSION >= 3\n    return triModule->module().ptr();\n    #endif\n}\n\nTriModule::TriModule()\n    : Py::ExtensionModule<TriModule>(\"tri\")\n{\n    Triangulation::init_type();\n    TriContourGenerator::init_type();\n    TrapezoidMapTriFinder::init_type();\n\n    add_varargs_method(\"Triangulation\", &TriModule::new_triangulation,\n                       \"Create and return new C++ Triangulation object\");\n    add_varargs_method(\"TriContourGenerator\", &TriModule::new_tricontourgenerator,\n                       \"Create and return new C++ TriContourGenerator object\");\n    add_varargs_method(\"TrapezoidMapTriFinder\",\n                       &TriModule::new_TrapezoidMapTriFinder,\n                       \"Create and return new C++ TrapezoidMapTriFinder object\");\n\n    initialize(\"Module for unstructured triangular grids\");\n}\n\nPy::Object TriModule::new_triangulation(const Py::Tuple &args)\n{\n\n    args.verify_length(6);\n\n    // x and y.\n    PyArrayObject* x = (PyArrayObject*)PyArray_ContiguousFromObject(\n                           args[0].ptr(), NPY_DOUBLE, 1, 1);\n    PyArrayObject* y = (PyArrayObject*)PyArray_ContiguousFromObject(\n                           args[1].ptr(), NPY_DOUBLE, 1, 1);\n    if (x == 0 || y == 0 || PyArray_DIM(x,0) != PyArray_DIM(y,0)) {\n        Py_XDECREF(x);\n        Py_XDECREF(y);\n        throw Py::ValueError(\"x and y must be 1D arrays of the same length\");\n    }\n\n    // triangles.\n    PyArrayObject* triangles = (PyArrayObject*)PyArray_ContiguousFromObject(\n                                   args[2].ptr(), NPY_INT, 2, 2);\n    if (triangles == 0 || PyArray_DIM(triangles,1) != 3) {\n        Py_XDECREF(x);\n        Py_XDECREF(y);\n        Py_XDECREF(triangles);\n        throw Py::ValueError(\"triangles must be a 2D array of shape (?,3)\");\n    }\n\n    // Optional mask.\n    PyArrayObject* mask = 0;\n    if (args[3].ptr() != 0 && args[3] != Py::None())\n    {\n        mask = (PyArrayObject*)PyArray_ContiguousFromObject(\n                   args[3].ptr(), NPY_BOOL, 1, 1);\n        if (mask == 0 || PyArray_DIM(mask,0) != PyArray_DIM(triangles,0)) {\n            Py_XDECREF(x);\n            Py_XDECREF(y);\n            Py_XDECREF(triangles);\n            Py_XDECREF(mask);\n            throw Py::ValueError(\n                \"mask must be a 1D array with the same length as the triangles array\");\n        }\n    }\n\n    // Optional edges.\n    PyArrayObject* edges = 0;\n    if (args[4].ptr() != 0 && args[4] != Py::None())\n    {\n        edges = (PyArrayObject*)PyArray_ContiguousFromObject(\n                    args[4].ptr(), NPY_INT, 2, 2);\n        if (edges == 0 || PyArray_DIM(edges,1) != 2) {\n            Py_XDECREF(x);\n            Py_XDECREF(y);\n            Py_XDECREF(triangles);\n            Py_XDECREF(mask);\n            Py_XDECREF(edges);\n            throw Py::ValueError(\"edges must be a 2D array with shape (?,2)\");\n        }\n    }\n\n    // Optional neighbors.\n    PyArrayObject* neighbors = 0;\n    if (args[5].ptr() != 0 && args[5] != Py::None())\n    {\n        neighbors = (PyArrayObject*)PyArray_ContiguousFromObject(\n                        args[5].ptr(), NPY_INT, 2, 2);\n        if (neighbors == 0 ||\n            PyArray_DIM(neighbors,0) != PyArray_DIM(triangles,0) ||\n            PyArray_DIM(neighbors,1) != PyArray_DIM(triangles,1)) {\n            Py_XDECREF(x);\n            Py_XDECREF(y);\n            Py_XDECREF(triangles);\n            Py_XDECREF(mask);\n            Py_XDECREF(edges);\n            Py_XDECREF(neighbors);\n            throw Py::ValueError(\n                \"neighbors must be a 2D array with the same shape as the triangles array\");\n        }\n    }\n\n    return Py::asObject(new Triangulation(x, y, triangles, mask, edges, neighbors));\n}\n\nPy::Object TriModule::new_tricontourgenerator(const Py::Tuple &args)\n{\n\n    args.verify_length(2);\n\n    Py::Object tri = args[0];\n    if (!Triangulation::check(tri))\n        throw Py::ValueError(\"Expecting a C++ Triangulation object\");\n\n    PyArrayObject* z = (PyArrayObject*)PyArray_ContiguousFromObject(\n                           args[1].ptr(), NPY_DOUBLE, 1, 1);\n    if (z == 0 ||\n        PyArray_DIM(z,0) != ((Triangulation*)tri.ptr())->get_npoints()) {\n        Py_XDECREF(z);\n        throw Py::ValueError(\n            \"z must be a 1D array with the same length as the x and y arrays\");\n    }\n\n    return Py::asObject(new TriContourGenerator(tri, z));\n}\n\nPy::Object\nTriModule::new_TrapezoidMapTriFinder(const Py::Tuple &args)\n{\n\n    args.verify_length(1);\n\n    Py::Object triangulation = args[0];\n    if (!Triangulation::check(triangulation))\n        throw Py::ValueError(\"Expecting a C++ Triangulation object\");\n\n    return Py::asObject(new TrapezoidMapTriFinder(triangulation));\n}\n", "patch": "@@ -234,13 +234,13 @@ Triangulation::Triangulation(PyArrayObject* x,\n       _edges(edges),\n       _neighbors(neighbors)\n {\n-    _VERBOSE(\"Triangulation::Triangulation\");\n+\n     correct_triangles();\n }\n \n Triangulation::~Triangulation()\n {\n-    _VERBOSE(\"Triangulation::~Triangulation\");\n+\n     Py_XDECREF(_x);\n     Py_XDECREF(_y);\n     Py_XDECREF(_triangles);\n@@ -251,7 +251,7 @@ Triangulation::~Triangulation()\n \n void Triangulation::calculate_boundaries()\n {\n-    _VERBOSE(\"Triangulation::calculate_boundaries\");\n+\n \n     get_neighbors();  // Ensure _neighbors has been created.\n \n@@ -309,7 +309,7 @@ void Triangulation::calculate_boundaries()\n \n void Triangulation::calculate_edges()\n {\n-    _VERBOSE(\"Triangulation::calculate_edges\");\n+\n     Py_XDECREF(_edges);\n \n     // Create set of all edges, storing them with start point index less than\n@@ -338,7 +338,7 @@ void Triangulation::calculate_edges()\n \n void Triangulation::calculate_neighbors()\n {\n-    _VERBOSE(\"Triangulation::calculate_neighbors\");\n+\n     Py_XDECREF(_neighbors);\n \n     // Create _neighbors array with shape (ntri,3) and initialise all to -1.\n@@ -382,7 +382,7 @@ void Triangulation::calculate_neighbors()\n \n Py::Object Triangulation::calculate_plane_coefficients(const Py::Tuple &args)\n {\n-    _VERBOSE(\"Triangulation::calculate_plane_coefficients\");\n+\n     args.verify_length(1);\n \n     PyArrayObject* z = (PyArrayObject*)PyArray_ContiguousFromObject(\n@@ -485,7 +485,7 @@ void Triangulation::correct_triangles()\n \n const Triangulation::Boundaries& Triangulation::get_boundaries() const\n {\n-    _VERBOSE(\"Triangulation::get_boundaries\");\n+\n     if (_boundaries.empty())\n         const_cast<Triangulation*>(this)->calculate_boundaries();\n     return _boundaries;\n@@ -517,7 +517,7 @@ int Triangulation::get_edge_in_triangle(int tri, int point) const\n \n Py::Object Triangulation::get_edges()\n {\n-    _VERBOSE(\"Triangulation::get_edges\");\n+\n     if (_edges == 0)\n         calculate_edges();\n     return Py::asObject(Py::new_reference_to((PyObject*)_edges));\n@@ -544,7 +544,7 @@ TriEdge Triangulation::get_neighbor_edge(int tri, int edge) const\n \n Py::Object Triangulation::get_neighbors()\n {\n-    _VERBOSE(\"Triangulation::get_neighbors\");\n+\n     if (_neighbors == 0) calculate_neighbors();\n     return Py::asObject(Py::new_reference_to((PyObject*)_neighbors));\n }\n@@ -592,7 +592,7 @@ const int* Triangulation::get_triangles_ptr() const\n \n void Triangulation::init_type()\n {\n-    _VERBOSE(\"Triangulation::init_type\");\n+\n \n     behaviors().name(\"Triangulation\");\n     behaviors().doc(\"Triangulation\");\n@@ -616,7 +616,7 @@ bool Triangulation::is_masked(int tri) const\n \n Py::Object Triangulation::set_mask(const Py::Tuple &args)\n {\n-    _VERBOSE(\"Triangulation::set_mask\");\n+\n     args.verify_length(1);\n \n     Py_XDECREF(_mask);\n@@ -667,12 +667,12 @@ TriContourGenerator::TriContourGenerator(Py::Object triangulation,\n       _boundaries_visited(0),\n       _boundaries_used(0)\n {\n-    _VERBOSE(\"TriContourGenerator::TriContourGenerator\");\n+\n }\n \n TriContourGenerator::~TriContourGenerator()\n {\n-    _VERBOSE(\"TriContourGenerator::~TriContourGenerator\");\n+\n     Py_XDECREF(_z);\n }\n \n@@ -761,7 +761,7 @@ Py::Object TriContourGenerator::contour_to_segs_and_kinds(const Contour& contour\n \n Py::Object TriContourGenerator::create_contour(const Py::Tuple &args)\n {\n-    _VERBOSE(\"TriContourGenerator::create_contour\");\n+\n     args.verify_length(1);\n \n     double level = (Py::Float)args[0];\n@@ -777,7 +777,7 @@ Py::Object TriContourGenerator::create_contour(const Py::Tuple &args)\n \n Py::Object TriContourGenerator::create_filled_contour(const Py::Tuple &args)\n {\n-    _VERBOSE(\"TriContourGenerator::create_filled_contour\");\n+\n     args.verify_length(2);\n \n     double lower_level = (Py::Float)args[0];\n@@ -1089,7 +1089,7 @@ const double& TriContourGenerator::get_z(int point) const\n \n void TriContourGenerator::init_type()\n {\n-    _VERBOSE(\"TriContourGenerator::init_type\");\n+\n \n     behaviors().name(\"TriContourGenerator\");\n     behaviors().doc(\"TriContourGenerator\");\n@@ -1124,12 +1124,12 @@ TrapezoidMapTriFinder::TrapezoidMapTriFinder(Py::Object triangulation)\n       _points(0),\n       _tree(0)\n {\n-    _VERBOSE(\"TrapezoidMapTriFinder::TrapezoidMapTriFinder\");\n+\n }\n \n TrapezoidMapTriFinder::~TrapezoidMapTriFinder()\n {\n-    _VERBOSE(\"TrapezoidMapTriFinder::~TrapezoidMapTriFinder\");\n+\n     clear();\n }\n \n@@ -1452,7 +1452,7 @@ TrapezoidMapTriFinder::find_trapezoids_intersecting_edge(\n Py::Object\n TrapezoidMapTriFinder::get_tree_stats()\n {\n-    _VERBOSE(\"TrapezoidMapTriFinder::get_tree_stats\");\n+\n \n     NodeStats stats;\n     _tree->get_stats(0, stats);\n@@ -1477,7 +1477,7 @@ TrapezoidMapTriFinder::get_triangulation() const\n void\n TrapezoidMapTriFinder::init_type()\n {\n-    _VERBOSE(\"TrapezoidMapTriFinder::init_type\");\n+\n \n     behaviors().name(\"TrapezoidMapTriFinder\");\n     behaviors().doc(\"TrapezoidMapTriFinder\");\n@@ -1499,7 +1499,7 @@ TrapezoidMapTriFinder::init_type()\n Py::Object\n TrapezoidMapTriFinder::initialize()\n {\n-    _VERBOSE(\"TrapezoidMapTriFinder::initialize\");\n+\n \n     clear();\n     const Triangulation& triang = get_triangulation();\n@@ -1594,7 +1594,7 @@ TrapezoidMapTriFinder::initialize()\n Py::Object\n TrapezoidMapTriFinder::print_tree()\n {\n-    _VERBOSE(\"TrapezoidMapTriFinder::print_tree\");\n+\n \n     assert(_tree != 0 && \"Null Node tree\");\n     _tree->print();\n@@ -2229,7 +2229,7 @@ TriModule::TriModule()\n \n Py::Object TriModule::new_triangulation(const Py::Tuple &args)\n {\n-    _VERBOSE(\"TriModule::new_triangulation\");\n+\n     args.verify_length(6);\n \n     // x and y.\n@@ -2310,7 +2310,7 @@ Py::Object TriModule::new_triangulation(const Py::Tuple &args)\n \n Py::Object TriModule::new_tricontourgenerator(const Py::Tuple &args)\n {\n-    _VERBOSE(\"TriModule::new_tricontourgenerator\");\n+\n     args.verify_length(2);\n \n     Py::Object tri = args[0];\n@@ -2332,7 +2332,7 @@ Py::Object TriModule::new_tricontourgenerator(const Py::Tuple &args)\n Py::Object\n TriModule::new_TrapezoidMapTriFinder(const Py::Tuple &args)\n {\n-    _VERBOSE(\"TriModule::new_TrapezoidMapTriFinder\");\n+\n     args.verify_length(1);\n \n     Py::Object triangulation = args[0];"}
{"patches_id": 2, "files_id": 26, "language": "py", "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmpl_toolkits%2Fmplot3d%2Faxis3d.py", "raw_code": "#!/usr/bin/python\n# axis3d.py, original mplot3d version by John Porter\n# Created: 23 Sep 2005\n# Parts rewritten by Reinier Heeres <reinier@heeres.eu>\n\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport six\n\nimport math\nimport copy\n\nfrom matplotlib import lines as mlines, axis as maxis, \\\n        patches as mpatches\nfrom . import art3d\nfrom . import proj3d\n\nimport numpy as np\n\ndef get_flip_min_max(coord, index, mins, maxs):\n    if coord[index] == mins[index]:\n        return maxs[index]\n    else:\n        return mins[index]\n\ndef move_from_center(coord, centers, deltas, axmask=(True, True, True)):\n    '''Return a coordinate that is moved by \"deltas\" away from the center.'''\n    coord = copy.copy(coord)\n    #print coord, centers, deltas, axmask\n    for i in range(3):\n        if not axmask[i]:\n            continue\n        if coord[i] < centers[i]:\n            coord[i] -= deltas[i]\n        else:\n            coord[i] += deltas[i]\n    return coord\n\ndef tick_update_position(tick, tickxs, tickys, labelpos):\n    '''Update tick line and label position and style.'''\n\n    for (label, on) in ((tick.label1, tick.label1On), \\\n            (tick.label2, tick.label2On)):\n        if on:\n            label.set_position(labelpos)\n\n    tick.tick1On, tick.tick2On = True, False\n    tick.tick1line.set_linestyle('-')\n    tick.tick1line.set_marker('')\n    tick.tick1line.set_data(tickxs, tickys)\n    tick.gridline.set_data(0, 0)\n\nclass Axis(maxis.XAxis):\n\n    # These points from the unit cube make up the x, y and z-planes\n    _PLANES = (\n        (0, 3, 7, 4), (1, 2, 6, 5),     # yz planes\n        (0, 1, 5, 4), (3, 2, 6, 7),     # xz planes\n        (0, 1, 2, 3), (4, 5, 6, 7),     # xy planes\n    )\n\n    # Some properties for the axes\n    _AXINFO = {\n        'x': {'i': 0, 'tickdir': 1, 'juggled': (1, 0, 2),\n            'color': (0.95, 0.95, 0.95, 0.5)},\n        'y': {'i': 1, 'tickdir': 0, 'juggled': (0, 1, 2),\n            'color': (0.90, 0.90, 0.90, 0.5)},\n        'z': {'i': 2, 'tickdir': 0, 'juggled': (0, 2, 1),\n            'color': (0.925, 0.925, 0.925, 0.5)},\n    }\n\n    def __init__(self, adir, v_intervalx, d_intervalx, axes, *args, **kwargs):\n        # adir identifies which axes this is\n        self.adir = adir\n        # data and viewing intervals for this direction\n        self.d_interval = d_intervalx\n        self.v_interval = v_intervalx\n\n        # This is a temporary member variable.\n        # Do not depend on this existing in future releases!\n        self._axinfo = self._AXINFO[adir].copy()\n        self._axinfo.update({'label' : {'space_factor': 1.6,\n                                        'va': 'center',\n                                        'ha': 'center'},\n                             'tick' : {'inward_factor': 0.2,\n                                       'outward_factor': 0.1},\n                             'ticklabel': {'space_factor': 0.7},\n                             'axisline': {'linewidth': 0.75,\n                                          'color': (0, 0, 0, 1)},\n                             'grid' : {'color': (0.9, 0.9, 0.9, 1),\n                                       'linewidth': 1.0},\n                            })\n\n\n        maxis.XAxis.__init__(self, axes, *args, **kwargs)\n\n        self.set_rotate_label(kwargs.get('rotate_label', None))\n\n\n    def init3d(self):\n        self.line = mlines.Line2D(xdata=(0, 0), ydata=(0, 0),\n                            linewidth=self._axinfo['axisline']['linewidth'],\n                            color=self._axinfo['axisline']['color'],\n                            antialiased=True,\n                           )\n\n        # Store dummy data in Polygon object\n        self.pane = mpatches.Polygon(np.array([[0,0], [0,1], [1,0], [0,0]]),\n                                    closed=False,\n                                    alpha=0.8,\n                                    facecolor=(1,1,1,0),\n                                    edgecolor=(1,1,1,0))\n        self.set_pane_color(self._axinfo['color'])\n\n        self.axes._set_artist_props(self.line)\n        self.axes._set_artist_props(self.pane)\n        self.gridlines = art3d.Line3DCollection([], )\n        self.axes._set_artist_props(self.gridlines)\n        self.axes._set_artist_props(self.label)\n        self.axes._set_artist_props(self.offsetText)\n        # Need to be able to place the label at the correct location\n        self.label._transform = self.axes.transData\n        self.offsetText._transform = self.axes.transData\n\n    def get_tick_positions(self):\n        majorLocs = self.major.locator()\n        self.major.formatter.set_locs(majorLocs)\n        majorLabels = [self.major.formatter(val, i) for i, val in enumerate(majorLocs)]\n        return majorLabels, majorLocs\n\n    def get_major_ticks(self, numticks=None):\n        ticks = maxis.XAxis.get_major_ticks(self, numticks)\n        for t in ticks:\n            t.tick1line.set_transform(self.axes.transData)\n            t.tick2line.set_transform(self.axes.transData)\n            t.gridline.set_transform(self.axes.transData)\n            t.label1.set_transform(self.axes.transData)\n            t.label2.set_transform(self.axes.transData)\n        return ticks\n\n    def set_pane_pos(self, xys):\n        xys = np.asarray(xys)\n        xys = xys[:,:2]\n        self.pane.xy = xys\n\n    def set_pane_color(self, color):\n        '''Set pane color to a RGBA tuple'''\n        self._axinfo['color'] = color\n        self.pane.set_edgecolor(color)\n        self.pane.set_facecolor(color)\n        self.pane.set_alpha(color[-1])\n\n    def set_rotate_label(self, val):\n        '''\n        Whether to rotate the axis label: True, False or None.\n        If set to None the label will be rotated if longer than 4 chars.\n        '''\n        self._rotate_label = val\n\n    def get_rotate_label(self, text):\n        if self._rotate_label is not None:\n            return self._rotate_label\n        else:\n            return len(text) > 4\n\n    def _get_coord_info(self, renderer):\n        minx, maxx, miny, maxy, minz, maxz = self.axes.get_w_lims()\n        if minx > maxx:\n            minx, maxx = maxx, minx\n        if miny > maxy:\n            miny, maxy = maxy, miny\n        if minz > maxz:\n            minz, maxz = maxz, minz\n        mins = np.array((minx, miny, minz))\n        maxs = np.array((maxx, maxy, maxz))\n        centers = (maxs + mins) / 2.\n        deltas = (maxs - mins) / 12.\n        mins = mins - deltas / 4.\n        maxs = maxs + deltas / 4.\n\n        vals = mins[0], maxs[0], mins[1], maxs[1], mins[2], maxs[2]\n        tc = self.axes.tunit_cube(vals, renderer.M)\n        avgz = [tc[p1][2] + tc[p2][2] + tc[p3][2] + tc[p4][2] for \\\n                p1, p2, p3, p4 in self._PLANES]\n        highs = np.array([avgz[2*i] < avgz[2*i+1] for i in range(3)])\n\n        return mins, maxs, centers, deltas, tc, highs\n\n    def draw_pane(self, renderer):\n        renderer.open_group('pane3d')\n\n        mins, maxs, centers, deltas, tc, highs = self._get_coord_info(renderer)\n\n        info = self._axinfo\n        index = info['i']\n        if not highs[index]:\n            plane = self._PLANES[2 * index]\n        else:\n            plane = self._PLANES[2 * index + 1]\n        xys = [tc[p] for p in plane]\n        self.set_pane_pos(xys)\n        self.pane.draw(renderer)\n\n        renderer.close_group('pane3d')\n\n    def draw(self, renderer):\n        self.label._transform = self.axes.transData\n        renderer.open_group('axis3d')\n\n        # code from XAxis\n        majorTicks = self.get_major_ticks()\n        majorLocs = self.major.locator()\n\n        info = self._axinfo\n        index = info['i']\n\n        # filter locations here so that no extra grid lines are drawn\n        locmin, locmax = self.get_view_interval()\n        if locmin > locmax:\n            locmin, locmax = locmax, locmin\n\n        # Rudimentary clipping\n        majorLocs = [loc for loc in majorLocs if\n                     locmin <= loc <= locmax]\n        self.major.formatter.set_locs(majorLocs)\n        majorLabels = [self.major.formatter(val, i)\n                       for i, val in enumerate(majorLocs)]\n\n        mins, maxs, centers, deltas, tc, highs = self._get_coord_info(renderer)\n\n        # Determine grid lines\n        minmax = np.where(highs, maxs, mins)\n\n        # Draw main axis line\n        juggled = info['juggled']\n        edgep1 = minmax.copy()\n        edgep1[juggled[0]] = get_flip_min_max(edgep1, juggled[0], mins, maxs)\n\n        edgep2 = edgep1.copy()\n        edgep2[juggled[1]] = get_flip_min_max(edgep2, juggled[1], mins, maxs)\n        pep = proj3d.proj_trans_points([edgep1, edgep2], renderer.M)\n        centpt = proj3d.proj_transform(centers[0], centers[1], centers[2], renderer.M)\n        self.line.set_data((pep[0][0], pep[0][1]), (pep[1][0], pep[1][1]))\n        self.line.draw(renderer)\n\n        # Grid points where the planes meet\n        xyz0 = []\n        for val in majorLocs:\n            coord = minmax.copy()\n            coord[index] = val\n            xyz0.append(coord)\n\n        # Draw labels\n        peparray = np.asanyarray(pep)\n        # The transAxes transform is used because the Text object\n        # rotates the text relative to the display coordinate system.\n        # Therefore, if we want the labels to remain parallel to the\n        # axis regardless of the aspect ratio, we need to convert the\n        # edge points of the plane to display coordinates and calculate\n        # an angle from that.\n        # TODO: Maybe Text objects should handle this themselves?\n        dx, dy = (self.axes.transAxes.transform([peparray[0:2, 1]]) -\n                  self.axes.transAxes.transform([peparray[0:2, 0]]))[0]\n\n        lxyz = 0.5*(edgep1 + edgep2)\n\n        labeldeltas = info['label']['space_factor'] * deltas\n        axmask = [True, True, True]\n        axmask[index] = False\n        lxyz = move_from_center(lxyz, centers, labeldeltas, axmask)\n        tlx, tly, tlz = proj3d.proj_transform(lxyz[0], lxyz[1], lxyz[2], \\\n                renderer.M)\n        self.label.set_position((tlx, tly))\n        if self.get_rotate_label(self.label.get_text()):\n            angle = art3d.norm_text_angle(math.degrees(math.atan2(dy, dx)))\n            self.label.set_rotation(angle)\n        self.label.set_va(info['label']['va'])\n        self.label.set_ha(info['label']['ha'])\n        self.label.draw(renderer)\n\n\n        # Draw Offset text\n\n        # Which of the two edge points do we want to\n        # use for locating the offset text?\n        if juggled[2] == 2 :\n            outeredgep = edgep1\n            outerindex = 0\n        else :\n            outeredgep = edgep2\n            outerindex = 1\n\n        pos = copy.copy(outeredgep)\n        pos = move_from_center(pos, centers, labeldeltas, axmask)\n        olx, oly, olz = proj3d.proj_transform(pos[0], pos[1], pos[2], renderer.M)\n        self.offsetText.set_text( self.major.formatter.get_offset() )\n        self.offsetText.set_position( (olx, oly) )\n        angle = art3d.norm_text_angle(math.degrees(math.atan2(dy, dx)))\n        self.offsetText.set_rotation(angle)\n        # Must set rotation mode to \"anchor\" so that\n        # the alignment point is used as the \"fulcrum\" for rotation.\n        self.offsetText.set_rotation_mode('anchor')\n\n        #-----------------------------------------------------------------------\n        # Note: the following statement for determining the proper alignment of\n        #       the offset text. This was determined entirely by trial-and-error\n        #       and should not be in any way considered as \"the way\".  There are\n        #       still some edge cases where alignment is not quite right, but\n        #       this seems to be more of a geometry issue (in other words, I\n        #       might be using the wrong reference points).\n        #\n        #   (TT, FF, TF, FT) are the shorthand for the tuple of\n        #     (centpt[info['tickdir']] <= peparray[info['tickdir'], outerindex],\n        #      centpt[index] <= peparray[index, outerindex])\n        #\n        #   Three-letters (e.g., TFT, FTT) are short-hand for the array\n        #    of bools from the variable 'highs'.\n        # ---------------------------------------------------------------------\n        if centpt[info['tickdir']] > peparray[info['tickdir'], outerindex] :\n            # if FT and if highs has an even number of Trues\n            if (centpt[index] <= peparray[index, outerindex]\n                and ((len(highs.nonzero()[0]) % 2) == 0)) :\n                # Usually, this means align right, except for the FTT case,\n                # in which offset for axis 1 and 2 are aligned left.\n                if highs.tolist() == [False, True, True] and index in (1, 2) :\n                    align = 'left'\n                else :\n                    align = 'right'\n            else :\n                # The FF case\n                align = 'left'\n        else :\n            # if TF and if highs has an even number of Trues\n            if (centpt[index] > peparray[index, outerindex]\n                and ((len(highs.nonzero()[0]) % 2) == 0)) :\n                # Usually mean align left, except if it is axis 2\n                if index == 2 :\n                    align = 'right'\n                else :\n                    align = 'left'\n            else :\n                # The TT case\n                align = 'right'\n\n        self.offsetText.set_va('center')\n        self.offsetText.set_ha(align)\n        self.offsetText.draw(renderer)\n\n        # Draw grid lines\n        if len(xyz0) > 0:\n            # Grid points at end of one plane\n            xyz1 = copy.deepcopy(xyz0)\n            newindex = (index + 1) % 3\n            newval = get_flip_min_max(xyz1[0], newindex, mins, maxs)\n            for i in range(len(majorLocs)):\n                xyz1[i][newindex] = newval\n\n            # Grid points at end of the other plane\n            xyz2 = copy.deepcopy(xyz0)\n            newindex = (index + 2) %  3\n            newval = get_flip_min_max(xyz2[0], newindex, mins, maxs)\n            for i in range(len(majorLocs)):\n                xyz2[i][newindex] = newval\n\n            lines = list(zip(xyz1, xyz0, xyz2))\n            if self.axes._draw_grid:\n                self.gridlines.set_segments(lines)\n                self.gridlines.set_color([info['grid']['color']] * len(lines))\n                self.gridlines.draw(renderer, project=True)\n\n        # Draw ticks\n        tickdir = info['tickdir']\n        tickdelta = deltas[tickdir]\n        if highs[tickdir]:\n            ticksign = 1\n        else:\n            ticksign = -1\n\n        for tick, loc, label in zip(majorTicks, majorLocs, majorLabels):\n            if tick is None:\n                continue\n\n            # Get tick line positions\n            pos = copy.copy(edgep1)\n            pos[index] = loc\n            pos[tickdir] = edgep1[tickdir] + info['tick']['outward_factor'] * \\\n                                             ticksign * tickdelta\n            x1, y1, z1 = proj3d.proj_transform(pos[0], pos[1], pos[2], \\\n                    renderer.M)\n            pos[tickdir] = edgep1[tickdir] - info['tick']['inward_factor'] * \\\n                                             ticksign * tickdelta\n            x2, y2, z2 = proj3d.proj_transform(pos[0], pos[1], pos[2], \\\n                    renderer.M)\n\n            # Get position of label\n            labeldeltas = [info['ticklabel']['space_factor'] * x for\n                           x in deltas]\n            axmask = [True, True, True]\n            axmask[index] = False\n            pos[tickdir] = edgep1[tickdir]\n            pos = move_from_center(pos, centers, labeldeltas, axmask)\n            lx, ly, lz = proj3d.proj_transform(pos[0], pos[1], pos[2], \\\n                    renderer.M)\n\n            tick_update_position(tick, (x1, x2), (y1, y2), (lx, ly))\n            tick.set_label1(label)\n            tick.set_label2(label)\n            tick.draw(renderer)\n\n        renderer.close_group('axis3d')\n\n    def get_view_interval(self):\n        \"\"\"return the Interval instance for this 3d axis view limits\"\"\"\n        return self.v_interval\n\n    def set_view_interval(self, vmin, vmax, ignore=False):\n        if ignore:\n            self.v_interval = vmin, vmax\n        else:\n            Vmin, Vmax = self.get_view_interval()\n            self.v_interval = min(vmin, Vmin), max(vmax, Vmax)\n\n    # TODO: Get this to work properly when mplot3d supports\n    #       the transforms framework.\n    def get_tightbbox(self, renderer) :\n        # Currently returns None so that Axis.get_tightbbox\n        # doesn't return junk info.\n        return None\n\n# Use classes to look at different data limits\n\nclass XAxis(Axis):\n    def get_data_interval(self):\n        'return the Interval instance for this axis data limits'\n        return self.axes.xy_dataLim.intervalx\n\nclass YAxis(Axis):\n    def get_data_interval(self):\n        'return the Interval instance for this axis data limits'\n        return self.axes.xy_dataLim.intervaly\n\nclass ZAxis(Axis):\n    def get_data_interval(self):\n        'return the Interval instance for this axis data limits'\n        return self.axes.zz_dataLim.intervalx\n", "patch": "@@ -260,8 +260,8 @@ def draw(self, renderer):\n         # edge points of the plane to display coordinates and calculate\n         # an angle from that.\n         # TODO: Maybe Text objects should handle this themselves?\n-        dx, dy = (self.axes.transAxes.transform(peparray[0:2, 1]) -\n-                  self.axes.transAxes.transform(peparray[0:2, 0]))\n+        dx, dy = (self.axes.transAxes.transform([peparray[0:2, 1]]) -\n+                  self.axes.transAxes.transform([peparray[0:2, 0]]))[0]\n \n         lxyz = 0.5*(edgep1 + edgep2)\n "}
{"patches_id": 2, "files_id": 27, "language": "py", "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/setupext.py", "raw_code": "from __future__ import print_function, absolute_import\n\nfrom distutils import sysconfig\nfrom distutils import version\nfrom distutils.core import Extension\nimport glob\nimport io\nimport multiprocessing\nimport os\nimport re\nimport subprocess\nimport sys\nimport warnings\nfrom textwrap import fill\n\n\nPY3 = (sys.version_info[0] >= 3)\n\n\ntry:\n    from subprocess import check_output\nexcept ImportError:\n    # check_output is not available in Python 2.6\n    def check_output(*popenargs, **kwargs):\n        \"\"\"\n        Run command with arguments and return its output as a byte\n        string.\n\n        Backported from Python 2.7 as it's implemented as pure python\n        on stdlib.\n        \"\"\"\n        process = subprocess.Popen(\n            stdout=subprocess.PIPE, *popenargs, **kwargs)\n        output, unused_err = process.communicate()\n        retcode = process.poll()\n        if retcode:\n            cmd = kwargs.get(\"args\")\n            if cmd is None:\n                cmd = popenargs[0]\n            error = subprocess.CalledProcessError(retcode, cmd)\n            error.output = output\n            raise error\n        return output\n\n\nif sys.platform != 'win32':\n    if sys.version_info[0] < 3:\n        from commands import getstatusoutput\n    else:\n        from subprocess import getstatusoutput\n\n\nif PY3:\n    import configparser\nelse:\n    import ConfigParser as configparser\n\n\n# matplotlib build options, which can be altered using setup.cfg\noptions = {\n    'display_status': True,\n    'verbose': False,\n    'backend': None,\n    'basedirlist': None\n    }\n\n\nsetup_cfg = os.environ.get('MPLSETUPCFG', 'setup.cfg')\nif os.path.exists(setup_cfg):\n    config = configparser.SafeConfigParser()\n    config.read(setup_cfg)\n\n    try:\n        options['display_status'] = not config.getboolean(\"status\", \"suppress\")\n    except:\n        pass\n\n    try:\n        options['backend'] = config.get(\"rc_options\", \"backend\")\n    except:\n        pass\n\n    try:\n        options['basedirlist'] = [\n            x.strip() for x in\n            config.get(\"directories\", \"basedirlist\").split(',')]\n    except:\n        pass\nelse:\n    config = None\n\n\ndef get_win32_compiler():\n    \"\"\"\n    Determine the compiler being used on win32.\n    \"\"\"\n    # Used to determine mingw32 or msvc\n    # This is pretty bad logic, someone know a better way?\n    for v in sys.argv:\n        if 'mingw32' in v:\n            return 'mingw32'\n    return 'msvc'\nwin32_compiler = get_win32_compiler()\n\n\ndef extract_versions():\n    \"\"\"\n    Extracts version values from the main matplotlib __init__.py and\n    returns them as a dictionary.\n    \"\"\"\n    with open('lib/matplotlib/__init__.py') as fd:\n        for line in fd.readlines():\n            if (line.startswith('__version__')):\n                exec(line.strip())\n    return locals()\n\n\ndef has_include_file(include_dirs, filename):\n    \"\"\"\n    Returns `True` if `filename` can be found in one of the\n    directories in `include_dirs`.\n    \"\"\"\n    if sys.platform == 'win32':\n        include_dirs += os.environ.get('INCLUDE', '.').split(';')\n    for dir in include_dirs:\n        if os.path.exists(os.path.join(dir, filename)):\n            return True\n    return False\n\n\ndef check_include_file(include_dirs, filename, package):\n    \"\"\"\n    Raises an exception if the given include file can not be found.\n    \"\"\"\n    if not has_include_file(include_dirs, filename):\n        raise CheckFailed(\n            \"The C/C++ header for %s (%s) could not be found.  You \"\n            \"may need to install the development package.\" %\n            (package, filename))\n\n\ndef get_base_dirs():\n    \"\"\"\n    Returns a list of standard base directories on this platform.\n    \"\"\"\n    if options['basedirlist']:\n        return options['basedirlist']\n\n    basedir_map = {\n        'win32': ['win32_static',],\n        'darwin': ['/usr/local/', '/usr', '/usr/X11', '/opt/local'],\n        'sunos5': [os.getenv('MPLIB_BASE') or '/usr/local',],\n        'gnu0': ['/usr'],\n        'aix5': ['/usr/local'],\n        }\n    return basedir_map.get(sys.platform, ['/usr/local', '/usr'])\n\n\ndef get_include_dirs():\n    \"\"\"\n    Returns a list of standard include directories on this platform.\n    \"\"\"\n    return [os.path.join(d, 'include') for d in get_base_dirs()]\n\n\ndef is_min_version(found, minversion):\n    \"\"\"\n    Returns `True` if `found` is at least as high a version as\n    `minversion`.\n    \"\"\"\n    expected_version = version.LooseVersion(minversion)\n    found_version = version.LooseVersion(found)\n    return found_version >= expected_version\n\n\n# Define the display functions only if display_status is True.\nif options['display_status']:\n    def print_line(char='='):\n        print(char * 76)\n\n    def print_status(package, status):\n        initial_indent = \"%22s: \" % package\n        indent = ' ' * 24\n        print(fill(str(status), width=76,\n                   initial_indent=initial_indent,\n                   subsequent_indent=indent))\n\n    def print_message(message):\n        indent = ' ' * 24 + \"* \"\n        print(fill(str(message), width=76,\n                   initial_indent=indent,\n                   subsequent_indent=indent))\n\n    def print_raw(section):\n        print(section)\nelse:\n    def print_line(*args, **kwargs):\n        pass\n    print_status = print_message = print_raw = print_line\n\n\n# Remove the -Wstrict-prototypesoption, is it's not valid for C++\ncustomize_compiler = sysconfig.customize_compiler\ndef my_customize_compiler(compiler):\n    retval = customize_compiler(compiler)\n    try:\n        compiler.compiler_so.remove('-Wstrict-prototypes')\n    except (ValueError, AttributeError):\n        pass\n    return retval\n\nsysconfig.customize_compiler = my_customize_compiler\n\n\ndef make_extension(name, files, *args, **kwargs):\n    \"\"\"\n    Make a new extension.  Automatically sets include_dirs and\n    library_dirs to the base directories appropriate for this\n    platform.\n\n    `name` is the name of the extension.\n\n    `files` is a list of source files.\n\n    Any additional arguments are passed to the\n    `distutils.core.Extension` constructor.\n    \"\"\"\n    ext = DelayedExtension(name, files, *args, **kwargs)\n    for dir in get_base_dirs():\n        include_dir = os.path.join(dir, 'include')\n        if os.path.exists(include_dir):\n            ext.include_dirs.append(include_dir)\n        for lib in ('lib', 'lib64'):\n            lib_dir = os.path.join(dir, lib)\n            if os.path.exists(lib_dir):\n                ext.library_dirs.append(lib_dir)\n    ext.include_dirs.append('.')\n\n    return ext\n\n\nclass PkgConfig(object):\n    \"\"\"\n    This is a class for communicating with pkg-config.\n    \"\"\"\n    def __init__(self):\n        \"\"\"\n        Determines whether pkg-config exists on this machine.\n        \"\"\"\n        if sys.platform == 'win32':\n            self.has_pkgconfig = False\n        else:\n            self.set_pkgconfig_path()\n            status, output = getstatusoutput(\"pkg-config --help\")\n            self.has_pkgconfig = (status == 0)\n            if not self.has_pkgconfig:\n                print(\"IMPORTANT WARNING:\")\n                print(\n                    \"    pkg-config is not installed.\\n\"\n                    \"    matplotlib may not be able to find some of its dependencies\")\n\n    def set_pkgconfig_path(self):\n        pkgconfig_path = sysconfig.get_config_var('LIBDIR')\n        if pkgconfig_path is None:\n            return\n\n        pkgconfig_path = os.path.join(pkgconfig_path, 'pkgconfig')\n        if not os.path.isdir(pkgconfig_path):\n            return\n\n        try:\n            os.environ['PKG_CONFIG_PATH'] += ':' + pkgconfig_path\n        except KeyError:\n            os.environ['PKG_CONFIG_PATH'] = pkgconfig_path\n\n    def setup_extension(self, ext, package, default_include_dirs=[],\n                        default_library_dirs=[], default_libraries=[],\n                        alt_exec=None):\n        \"\"\"\n        Add parameters to the given `ext` for the given `package`.\n        \"\"\"\n        flag_map = {\n            '-I': 'include_dirs', '-L': 'library_dirs', '-l': 'libraries'}\n\n        executable = alt_exec\n        if self.has_pkgconfig:\n            executable = 'pkg-config {0}'.format(package)\n\n        use_defaults = True\n\n        if executable is not None:\n            command = \"{0} --libs --cflags \".format(executable)\n\n            try:\n                output = check_output(command, shell=True,\n                                      stderr=subprocess.STDOUT)\n            except subprocess.CalledProcessError:\n                pass\n            else:\n                output = output.decode(sys.getfilesystemencoding())\n                use_defaults = False\n                for token in output.split():\n                    attr = flag_map.get(token[:2])\n                    if attr is not None:\n                        getattr(ext, attr).insert(0, token[2:])\n\n        if use_defaults:\n            basedirs = get_base_dirs()\n            for base in basedirs:\n                for include in default_include_dirs:\n                    dir = os.path.join(base, include)\n                    if os.path.exists(dir):\n                        ext.include_dirs.append(dir)\n                for lib in default_library_dirs:\n                    dir = os.path.join(base, lib)\n                    if os.path.exists(dir):\n                        ext.library_dirs.append(dir)\n            ext.libraries.extend(default_libraries)\n            return True\n\n        return False\n\n    def get_version(self, package):\n        \"\"\"\n        Get the version of the package from pkg-config.\n        \"\"\"\n        if not self.has_pkgconfig:\n            return None\n\n        status, output = getstatusoutput(\n            \"pkg-config %s --modversion\" % (package))\n        if status == 0:\n            return output\n        return None\n\n\n# The PkgConfig class should be used through this singleton\npkg_config = PkgConfig()\n\n\nclass CheckFailed(Exception):\n    \"\"\"\n    Exception thrown when a `SetupPackage.check` method fails.\n    \"\"\"\n    pass\n\n\nclass SetupPackage(object):\n    optional = False\n\n    def check(self):\n        \"\"\"\n        Checks whether the dependencies are met.  Should raise a\n        `CheckFailed` exception if the dependency could not be met,\n        otherwise return a string indicating a version number or some\n        other message indicating what was found.\n        \"\"\"\n        pass\n\n    def get_packages(self):\n        \"\"\"\n        Get a list of package names to add to the configuration.\n        These are added to the `packages` list passed to\n        `distutils.setup`.\n        \"\"\"\n        return []\n\n    def get_namespace_packages(self):\n        \"\"\"\n        Get a list of namespace package names to add to the configuration.\n        These are added to the `namespace_packages` list passed to\n        `distutils.setup`.\n        \"\"\"\n        return []\n\n\n    def get_py_modules(self):\n        \"\"\"\n        Get a list of top-level modules to add to the configuration.\n        These are added to the `py_modules` list passed to\n        `distutils.setup`.\n        \"\"\"\n        return []\n\n    def get_package_data(self):\n        \"\"\"\n        Get a package data dictionary to add to the configuration.\n        These are merged into to the `package_data` list passed to\n        `distutils.setup`.\n        \"\"\"\n        return {}\n\n    def get_extension(self):\n        \"\"\"\n        Get a list of C extensions (`distutils.core.Extension`\n        objects) to add to the configuration.  These are added to the\n        `extensions` list passed to `distutils.setup`.\n        \"\"\"\n        return None\n\n    def get_install_requires(self):\n        \"\"\"\n        Get a list of Python packages that we require.\n        pip/easy_install will attempt to download and install this\n        package if it is not installed.\n        \"\"\"\n        return []\n\n    def get_setup_requires(self):\n        \"\"\"\n        Get a list of Python packages that we require at build time.\n        pip/easy_install will attempt to download and install this\n        package if it is not installed.\n        \"\"\"\n        return []\n\n    def _check_for_pkg_config(self, package, include_file, min_version=None,\n                              version=None):\n        \"\"\"\n        A convenience function for writing checks for a\n        pkg_config-defined dependency.\n\n        `package` is the pkg_config package name.\n\n        `include_file` is a top-level include file we expect to find.\n\n        `min_version` is the minimum version required.\n\n        `version` will override the found version if this package\n        requires an alternate method for that.\n        \"\"\"\n        if version is None:\n            version = pkg_config.get_version(package)\n\n            if version is None:\n                raise CheckFailed(\n                    \"pkg-config information for '%s' could not be found.\" %\n                    package)\n\n        if min_version == 'PATCH':\n            raise CheckFailed(\n                \"Requires patches that have not been merged upstream.\")\n\n        if min_version:\n            if (not is_min_version(version, min_version)):\n                raise CheckFailed(\n                    \"Requires %s %s or later.  Found %s.\" %\n                    (package, min_version, version))\n\n        ext = self.get_extension()\n        if ext is None:\n            ext = make_extension('test', [])\n            pkg_config.setup_extension(ext, package)\n\n        check_include_file(ext.include_dirs, include_file, package)\n\n        return 'version %s' % version\n\n\nclass OptionalPackage(SetupPackage):\n    optional = True\n    force = False\n    config_category = \"packages\"\n\n    @classmethod\n    def get_config(cls):\n        \"\"\"\n        Look at `setup.cfg` and return one of [\"auto\", True, False] indicating\n        if the package is at default state (\"auto\"), forced by the user (True)\n        or opted-out (False).\n        \"\"\"\n        try:\n            return config.getboolean(cls.config_category, cls.name)\n        except:\n            return \"auto\"\n\n    def check(self):\n        \"\"\"\n        Do not override this method!\n\n        For custom dependency checks override self.check_requirements().\n        Two things are checked: Configuration file and requirements.\n        \"\"\"\n        # Check configuration file\n        conf = self.get_config()\n        # Default \"auto\" state or install forced by user\n        if conf in [True, 'auto']:\n            message = \"installing\"\n            # Set non-optional if user sets `True` in config\n            if conf is True:\n                self.optional = False\n        # Configuration opt-out by user\n        else:\n            # Some backend extensions (e.g. Agg) need to be built for certain\n            # other GUI backends (e.g. TkAgg) even when manually disabled\n            if self.force is True:\n                message = \"installing forced (config override)\"\n            else:\n                raise CheckFailed(\"skipping due to configuration\")\n\n        # Check requirements and add extra information (if any) to message.\n        # If requirements are not met a CheckFailed should be raised in there.\n        additional_info = self.check_requirements()\n        if additional_info:\n            message += \", \" + additional_info\n\n        # No CheckFailed raised until now, return install message.\n        return message\n\n    def check_requirements(self):\n        \"\"\"\n        Override this method to do custom dependency checks.\n\n         - Raise CheckFailed() if requirements are not met.\n         - Return message with additional information, or an empty string\n           (or None) for no additional information.\n        \"\"\"\n        return \"\"\n\n\nclass OptionalBackendPackage(OptionalPackage):\n    config_category = \"gui_support\"\n\n\nclass Platform(SetupPackage):\n    name = \"platform\"\n\n    def check(self):\n        return sys.platform\n\n\nclass Python(SetupPackage):\n    name = \"python\"\n\n    def check(self):\n        major, minor1, minor2, s, tmp = sys.version_info\n\n        if major < 2:\n            raise CheckFailed(\n                \"Requires Python 2.6 or later\")\n        elif major == 2 and minor1 < 6:\n            raise CheckFailed(\n                \"Requires Python 2.6 or later (in the 2.x series)\")\n        elif major == 3 and minor1 < 1:\n            raise CheckFailed(\n                \"Requires Python 3.1 or later (in the 3.x series)\")\n\n        return sys.version\n\n\nclass Matplotlib(SetupPackage):\n    name = \"matplotlib\"\n\n    def check(self):\n        return extract_versions()['__version__']\n\n    def get_packages(self):\n        return [\n            'matplotlib',\n            'matplotlib.backends',\n            'matplotlib.backends.qt_editor',\n            'matplotlib.compat',\n            'matplotlib.projections',\n            'matplotlib.axes',\n            'matplotlib.sphinxext',\n            'matplotlib.style',\n            'matplotlib.testing',\n            'matplotlib.testing.jpl_units',\n            'matplotlib.tri',\n            ]\n\n    def get_py_modules(self):\n        return ['pylab']\n\n    def get_package_data(self):\n        return {\n            'matplotlib':\n            [\n                'mpl-data/fonts/afm/*.afm',\n                'mpl-data/fonts/pdfcorefonts/*.afm',\n                'mpl-data/fonts/pdfcorefonts/*.txt',\n                'mpl-data/fonts/ttf/*.ttf',\n                'mpl-data/fonts/ttf/LICENSE_STIX',\n                'mpl-data/fonts/ttf/COPYRIGHT.TXT',\n                'mpl-data/fonts/ttf/README.TXT',\n                'mpl-data/fonts/ttf/RELEASENOTES.TXT',\n                'mpl-data/images/*.xpm',\n                'mpl-data/images/*.svg',\n                'mpl-data/images/*.gif',\n                'mpl-data/images/*.png',\n                'mpl-data/images/*.ppm',\n                'mpl-data/example/*.npy',\n                'mpl-data/matplotlibrc',\n                'backends/web_backend/*.*',\n                'backends/web_backend/jquery/js/*',\n                'backends/web_backend/jquery/css/themes/base/*.*',\n                'backends/web_backend/jquery/css/themes/base/images/*',\n                'backends/web_backend/css/*.*',\n                'backends/Matplotlib.nib/*',\n                'mpl-data/stylelib/*.mplstyle',\n             ]}\n\n\nclass SampleData(OptionalPackage):\n    \"\"\"\n    This handles the sample data that ships with matplotlib.  It is\n    technically optional, though most often will be desired.\n    \"\"\"\n    name = \"sample_data\"\n\n    def get_package_data(self):\n        return {\n            'matplotlib':\n            [\n                'mpl-data/sample_data/*.*',\n                'mpl-data/sample_data/axes_grid/*.*',\n            ]}\n\n\nclass Toolkits(OptionalPackage):\n    name = \"toolkits\"\n\n    def get_packages(self):\n        return [\n            'mpl_toolkits',\n            'mpl_toolkits.mplot3d',\n            'mpl_toolkits.axes_grid',\n            'mpl_toolkits.axes_grid1',\n            'mpl_toolkits.axisartist',\n            ]\n\n    def get_namespace_packages(self):\n        return ['mpl_toolkits']\n\n\nclass Tests(OptionalPackage):\n    name = \"tests\"\n    nose_min_version = '0.11.1'\n\n    def check(self):\n        super(Tests, self).check()\n\n        msgs = []\n        msg_template = ('{package} is required to run the matplotlib test '\n                        'suite.  pip/easy_install may attempt to install it '\n                        'after matplotlib.')\n\n\n        bad_nose = msg_template.format(\n            package='nose %s or later' % self.nose_min_version\n        )\n        try:\n            import nose\n            if is_min_version(nose.__version__, self.nose_min_version):\n                msgs += ['using nose version %s' % nose.__version__]\n            else:\n                msgs += [bad_nose]\n        except ImportError:\n            msgs += [bad_nose]\n\n\n        if sys.version_info >= (3, 3):\n            msgs += ['using unittest.mock']\n        else:\n            try:\n                import mock\n                msgs += ['using mock %s' % mock.__version__]\n            except ImportError:\n                msgs += [msg_template.format(package='mock')]\n\n        return ' / '.join(msgs)\n\n    def get_packages(self):\n        return [\n            'matplotlib.tests',\n            ]\n\n    def get_package_data(self):\n        baseline_images = [\n            'tests/baseline_images/%s/*' % x\n            for x in os.listdir('lib/matplotlib/tests/baseline_images')]\n\n        return {\n            'matplotlib':\n            baseline_images +\n            [\n                'tests/mpltest.ttf',\n                'tests/test_rcparams.rc',\n                'tests/test_utf32_be_rcparams.rc',\n            ]}\n\n    def get_install_requires(self):\n        requires = ['nose>=%s' % self.nose_min_version]\n        if not sys.version_info >= (3, 3):\n            requires += ['mock']\n        return requires\n\nclass Toolkits_Tests(Tests):\n    name = \"toolkits_tests\"\n\n    def check_requirements(self):\n        conf = self.get_config()\n        toolkits_conf = Toolkits.get_config()\n        tests_conf = Tests.get_config()\n\n        if conf is True:\n            Tests.force = True\n            Toolkits.force = True\n        elif conf == \"auto\" and not (toolkits_conf and tests_conf):\n            # Only auto-install if both toolkits and tests are set\n            # to be installed\n            raise CheckFailed(\"toolkits_tests needs 'toolkits' and 'tests'\")\n        return \"\"\n\n    def get_packages(self):\n        return [\n            'mpl_toolkits.tests',\n            ]\n\n    def get_package_data(self):\n        baseline_images = [\n            'tests/baseline_images/%s/*' % x\n            for x in os.listdir('lib/mpl_toolkits/tests/baseline_images')]\n\n        return {'mpl_toolkits': baseline_images}\n\n    def get_namespace_packages(self):\n        return ['mpl_toolkits']\n\n\nclass DelayedExtension(Extension, object):\n    \"\"\"\n    A distutils Extension subclass where some of its members\n    may have delayed computation until reaching the build phase.\n\n    This is so we can, for example, get the Numpy include dirs\n    after pip has installed Numpy for us if it wasn't already\n    on the system.\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        super(DelayedExtension, self).__init__(*args, **kwargs)\n        self._finalized = False\n        self._hooks = {}\n\n    def add_hook(self, member, func):\n        \"\"\"\n        Add a hook to dynamically compute a member.\n\n        Parameters\n        ----------\n        member : string\n            The name of the member\n\n        func : callable\n            The function to call to get dynamically-computed values\n            for the member.\n        \"\"\"\n        self._hooks[member] = func\n\n    def finalize(self):\n        self._finalized = True\n\n    class DelayedMember(property):\n        def __init__(self, name):\n            self._name = name\n\n        def __get__(self, obj, objtype=None):\n            result = getattr(obj, '_' + self._name, [])\n\n            if obj._finalized:\n                if self._name in obj._hooks:\n                    result = obj._hooks[self._name]() + result\n\n            return result\n\n        def __set__(self, obj, value):\n            setattr(obj, '_' + self._name, value)\n\n    include_dirs = DelayedMember('include_dirs')\n\n\nclass Numpy(SetupPackage):\n    name = \"numpy\"\n\n    @staticmethod\n    def include_dirs_hook():\n        if sys.version_info[0] >= 3:\n            import builtins\n            if hasattr(builtins, '__NUMPY_SETUP__'):\n                del builtins.__NUMPY_SETUP__\n            import imp\n            import numpy\n            imp.reload(numpy)\n        else:\n            import __builtin__\n            if hasattr(__builtin__, '__NUMPY_SETUP__'):\n                del __builtin__.__NUMPY_SETUP__\n            import numpy\n            reload(numpy)\n\n        ext = Extension('test', [])\n        ext.include_dirs.append(numpy.get_include())\n        if not has_include_file(\n                ext.include_dirs, os.path.join(\"numpy\", \"arrayobject.h\")):\n            warnings.warn(\n                \"The C headers for numpy could not be found. \"\n                \"You may need to install the development package\")\n\n        return [numpy.get_include()]\n\n    def check(self):\n        min_version = extract_versions()['__version__numpy__']\n        try:\n            import numpy\n        except ImportError:\n            return 'not found. pip may install it below.'\n\n        if not is_min_version(numpy.__version__, min_version):\n            raise SystemExit(\n                \"Requires numpy %s or later to build.  (Found %s)\" %\n                (min_version, numpy.__version__))\n\n        return 'version %s' % numpy.__version__\n\n    def add_flags(self, ext):\n        # Ensure that PY_ARRAY_UNIQUE_SYMBOL is uniquely defined for\n        # each extension\n        array_api_name = 'MPL_' + ext.name.replace('.', '_') + '_ARRAY_API'\n\n        ext.define_macros.append(('PY_ARRAY_UNIQUE_SYMBOL', array_api_name))\n        ext.add_hook('include_dirs', self.include_dirs_hook)\n\n        ext.define_macros.append(('NPY_NO_DEPRECATED_API',\n                                  'NPY_1_7_API_VERSION'))\n\n    def get_setup_requires(self):\n        return ['numpy>=1.6']\n\n    def get_install_requires(self):\n        return ['numpy>=1.6']\n\n\nclass CXX(SetupPackage):\n    name = 'pycxx'\n\n    def check(self):\n        if PY3:\n            # There is no version of PyCXX in the wild that will work\n            # with Python 3.x and matplotlib, since they lack support\n            # for the buffer object.\n            self.__class__.found_external = False\n            return (\"Official versions of PyCXX are not compatible \"\n                    \"with matplotlib on Python 3.x, since they lack \"\n                    \"support for the buffer object.  Using local \"\n                    \"copy\")\n\n        self.__class__.found_external = True\n        old_stdout = sys.stdout\n        if PY3:\n            sys.stdout = io.StringIO()\n        else:\n            sys.stdout = io.BytesIO()\n\n        try:\n            import CXX\n        except ImportError:\n            self.__class__.found_external = False\n            return \"Couldn't import.  Using local copy.\"\n        finally:\n            sys.stdout = old_stdout\n\n        try:\n            return self._check_for_pkg_config(\n                'PyCXX', 'CXX/Extensions.hxx', min_version='6.2.4')\n        except CheckFailed as e:\n            # It's ok to just proceed here, since the `import CXX`\n            # worked above, and PyCXX (at least upstream) ensures that\n            # its header files are on the default distutils include\n            # path (either in a standard C place such as /usr/include,\n            # or in /usr/include/pythonX.Y.\n            return 'Using system CXX (version unknown, no pkg-config info)'\n\n    def add_flags(self, ext):\n        if self.found_external and not 'sdist' in sys.argv:\n            support_dir = os.path.normpath(\n                   os.path.join(\n                       sys.prefix,\n                       'share',\n                       'python%d.%d' % (\n                           sys.version_info[0], sys.version_info[1]),\n                       'CXX'))\n            if not os.path.exists(support_dir):\n                # On Fedora 17, these files are installed in /usr/share/CXX\n                support_dir = '/usr/src/CXX'\n            ext.sources.extend([\n                os.path.join(support_dir, x) for x in\n                ['cxxsupport.cxx', 'cxx_extensions.cxx',\n                 'IndirectPythonInterface.cxx',\n                 'cxxextensions.c']])\n            pkg_config.setup_extension(ext, 'PyCXX')\n        else:\n            ext.include_dirs.append('extern')\n            ext.sources.extend(glob.glob('extern/CXX/*.cxx'))\n            ext.sources.extend(glob.glob('extern/CXX/*.c'))\n        ext.define_macros.append(('PYCXX_ISO_CPP_LIB', '1'))\n        if PY3:\n            ext.define_macros.append(('PYCXX_PYTHON_2TO3', '1'))\n        if not (sys.platform == 'win32' and win32_compiler == 'msvc'):\n            ext.libraries.append('stdc++')\n            ext.libraries.append('m')\n\n\nclass LibAgg(SetupPackage):\n    name = 'libagg'\n\n    def check(self):\n        self.__class__.found_external = True\n        try:\n            return self._check_for_pkg_config(\n                'libagg', 'agg2/agg_basics.h', min_version='PATCH')\n        except CheckFailed as e:\n            self.__class__.found_external = False\n            return str(e) + ' Using local copy.'\n\n    def add_flags(self, ext):\n        if self.found_external:\n            pkg_config.setup_extension(ext, 'libagg')\n        else:\n            ext.include_dirs.append('extern/agg24/include')\n            agg_sources = [\n                'agg_bezier_arc.cpp',\n                'agg_curves.cpp',\n                'agg_image_filters.cpp',\n                'agg_trans_affine.cpp',\n                'agg_vcgen_contour.cpp',\n                'agg_vcgen_dash.cpp',\n                'agg_vcgen_stroke.cpp',\n                'agg_vpgen_segmentator.cpp'\n                ]\n            ext.sources.extend(\n                os.path.join('extern', 'agg24', 'src', x) for x in agg_sources)\n\n\nclass FreeType(SetupPackage):\n    name = \"freetype\"\n\n    def check(self):\n        if sys.platform == 'win32':\n            check_include_file(get_include_dirs(), 'ft2build.h', 'freetype')\n            return 'Using unknown version found on system.'\n\n        status, output = getstatusoutput(\"freetype-config --ftversion\")\n        if status == 0:\n            version = output\n        else:\n            version = None\n\n        # Early versions of freetype grep badly inside freetype-config,\n        # so catch those cases. (tested with 2.5.3).\n        if version is None or 'No such file or directory\\ngrep:' in version:\n            version = self.version_from_header()\n\n        return self._check_for_pkg_config(\n            'freetype2', 'ft2build.h',\n            min_version='2.3', version=version)\n\n    def version_from_header(self):\n        version = 'Failed to identify version.'\n        ext = self.get_extension()\n        if ext is None:\n            return version\n        # Return the first version found in the include dirs.\n        for include_dir in ext.include_dirs:\n            header_fname = os.path.join(include_dir, 'freetype.h')\n            if os.path.exists(header_fname):\n                major, minor, patch = 0, 0, 0\n                with open(header_fname, 'r') as fh:\n                    for line in fh:\n                        if line.startswith('#define FREETYPE_'):\n                            value = line.rsplit(' ', 1)[1].strip()\n                            if 'MAJOR' in line:\n                                major = value\n                            elif 'MINOR' in line:\n                                minor = value\n                            else:\n                                patch = value\n                return '.'.join([major, minor, patch])\n\n    def add_flags(self, ext):\n        pkg_config.setup_extension(\n            ext, 'freetype2',\n            default_include_dirs=[\n                'include/freetype2', 'freetype2',\n                'lib/freetype2/include',\n                'lib/freetype2/include/freetype2'],\n            default_library_dirs=[\n                'freetype2/lib'],\n            default_libraries=['freetype', 'z'])\n\n\n\nclass FT2Font(SetupPackage):\n    name = 'ft2font'\n\n    def get_extension(self):\n        sources = [\n            'src/ft2font.cpp',\n            'src/ft2font_wrapper.cpp',\n            'src/mplutils.cpp'\n            ]\n        ext = make_extension('matplotlib.ft2font', sources)\n        FreeType().add_flags(ext)\n        Numpy().add_flags(ext)\n        return ext\n\n\nclass Png(SetupPackage):\n    name = \"png\"\n\n    def check(self):\n        if sys.platform == 'win32':\n            check_include_file(get_include_dirs(), 'png.h', 'png')\n            return 'Using unknown version found on system.'\n\n        status, output = getstatusoutput(\"libpng-config --version\")\n        if status == 0:\n            version = output\n        else:\n            version = None\n\n        try:\n            return self._check_for_pkg_config(\n                'libpng', 'png.h',\n                min_version='1.2', version=version)\n        except CheckFailed as e:\n            if has_include_file(get_include_dirs(), 'png.h'):\n                return str(e) + ' Using unknown version found on system.'\n            raise\n\n    def get_extension(self):\n        sources = [\n            'src/_png.cpp',\n            'src/mplutils.cpp'\n            ]\n        ext = make_extension('matplotlib._png', sources)\n        pkg_config.setup_extension(\n            ext, 'libpng', default_libraries=['png', 'z'],\n            alt_exec='libpng-config --ldflags')\n        Numpy().add_flags(ext)\n        return ext\n\n\nclass Qhull(SetupPackage):\n    name = \"qhull\"\n\n    def check(self):\n        self.__class__.found_external = True\n        try:\n            return self._check_for_pkg_config(\n                'qhull', 'qhull/qhull_a.h', min_version='2003.1')\n        except CheckFailed as e:\n            self.__class__.found_pkgconfig = False\n            # Qhull may not be in the pkg-config system but may still be\n            # present on this system, so check if the header files can be\n            # found.\n            include_dirs = [\n                os.path.join(x, 'qhull') for x in get_include_dirs()]\n            if has_include_file(include_dirs, 'qhull_a.h'):\n                return 'Using system Qhull (version unknown, no pkg-config info)'\n            else:\n                self.__class__.found_external = False\n                return str(e) + ' Using local copy.'\n\n    def add_flags(self, ext):\n        if self.found_external:\n            pkg_config.setup_extension(ext, 'qhull',\n                                       default_libraries=['qhull'])\n        else:\n            ext.include_dirs.append('extern')\n            ext.sources.extend(glob.glob('extern/qhull/*.c'))\n\n\nclass TTConv(SetupPackage):\n    name = \"ttconv\"\n\n    def get_extension(self):\n        sources = [\n            'src/_ttconv.cpp',\n            'extern/ttconv/pprdrv_tt.cpp',\n            'extern/ttconv/pprdrv_tt2.cpp',\n            'extern/ttconv/ttutil.cpp'\n            ]\n        ext = make_extension('matplotlib.ttconv', sources)\n        Numpy().add_flags(ext)\n        ext.include_dirs.append('extern')\n        return ext\n\n\nclass Path(SetupPackage):\n    name = \"path\"\n\n    def get_extension(self):\n        sources = [\n            'src/py_converters.cpp',\n            'src/_path_wrapper.cpp'\n            ]\n\n        ext = make_extension('matplotlib._path', sources)\n        Numpy().add_flags(ext)\n        LibAgg().add_flags(ext)\n        return ext\n\n\nclass Image(SetupPackage):\n    name = \"image\"\n\n    def get_extension(self):\n        sources = [\n            'src/_image.cpp',\n            'src/mplutils.cpp',\n            'src/_image_wrapper.cpp'\n            ]\n        ext = make_extension('matplotlib._image', sources)\n        Numpy().add_flags(ext)\n        LibAgg().add_flags(ext)\n        return ext\n\n\nclass Contour(SetupPackage):\n    name = \"contour\"\n\n    def get_extension(self):\n        sources = [\n            \"src/cntr.c\"\n            ]\n        ext = make_extension('matplotlib._cntr', sources)\n        Numpy().add_flags(ext)\n        return ext\n\n\nclass Delaunay(SetupPackage):\n    name = \"delaunay\"\n\n    def get_packages(self):\n        return ['matplotlib.delaunay']\n\n    def get_extension(self):\n        sources = [\"_delaunay.cpp\", \"VoronoiDiagramGenerator.cpp\",\n                   \"delaunay_utils.cpp\", \"natneighbors.cpp\"]\n        sources = [os.path.join('lib/matplotlib/delaunay', s) for s in sources]\n        ext = make_extension('matplotlib._delaunay', sources)\n        Numpy().add_flags(ext)\n        return ext\n\n\nclass QhullWrap(SetupPackage):\n    name = \"qhull_wrap\"\n\n    def get_extension(self):\n        sources = ['src/qhull_wrap.c']\n        ext = make_extension('matplotlib._qhull', sources,\n                             define_macros=[('MPL_DEVNULL', os.devnull)])\n        Numpy().add_flags(ext)\n        Qhull().add_flags(ext)\n        return ext\n\n\nclass Tri(SetupPackage):\n    name = \"tri\"\n\n    def get_extension(self):\n        sources = [\n            \"lib/matplotlib/tri/_tri.cpp\",\n            \"src/mplutils.cpp\"\n            ]\n        ext = make_extension('matplotlib._tri', sources)\n        Numpy().add_flags(ext)\n        CXX().add_flags(ext)\n        return ext\n\n\nclass Six(SetupPackage):\n    name = \"six\"\n    min_version = \"1.4\"\n\n    def check(self):\n        try:\n            import six\n        except ImportError:\n            return (\n                \"six was not found.\")\n\n        if not is_min_version(six.__version__, self.min_version):\n            raise CheckFailed(\n                \"Requires six %s or later.  Found %s.\" %\n                (self.min_version, six.__version__))\n\n        return \"using six version %s\" % six.__version__\n\n    def get_install_requires(self):\n        return ['six>={0}'.format(self.min_version)]\n\n\nclass Pytz(SetupPackage):\n    name = \"pytz\"\n\n    def check(self):\n        try:\n            import pytz\n        except ImportError:\n            return (\n                \"pytz was not found. \"\n                \"pip will attempt to install it \"\n                \"after matplotlib.\")\n\n        return \"using pytz version %s\" % pytz.__version__\n\n    def get_install_requires(self):\n        return ['pytz']\n\n\nclass Dateutil(SetupPackage):\n    name = \"dateutil\"\n\n    def __init__(self, version=None):\n        self.version = version\n\n    def check(self):\n        try:\n            import dateutil\n        except ImportError:\n            # dateutil 2.1 has a file encoding bug that breaks installation on\n            # python 3.3\n            # https://github.com/matplotlib/matplotlib/issues/2373\n            # hack around the problem by installing the the (working) v2.0\n            major, minor1, _, _, _ = sys.version_info\n            if self.version is None and (major, minor1) == (3, 3):\n                self.version = '!=2.1'\n\n            return (\n                \"dateutil was not found. It is required for date axis \"\n                \"support. pip/easy_install may attempt to install it \"\n                \"after matplotlib.\")\n\n        return \"using dateutil version %s\" % dateutil.__version__\n\n    def get_install_requires(self):\n        dateutil = 'python-dateutil'\n        if self.version is not None:\n            dateutil += self.version\n        return [dateutil]\n\n\nclass Tornado(OptionalPackage):\n    name = \"tornado\"\n\n    def check(self):\n        try:\n            import tornado\n        except ImportError:\n            return (\n                \"tornado was not found. It is required for the WebAgg \"\n                \"backend. pip/easy_install may attempt to install it \"\n                \"after matplotlib.\")\n\n        return \"using tornado version %s\" % tornado.version\n\n\nclass Pyparsing(SetupPackage):\n    name = \"pyparsing\"\n\n    def is_ok(self):\n        # pyparsing 2.0.0 bug, but it may be patched in distributions\n        try:\n            import pyparsing\n            f = pyparsing.Forward()\n            f <<= pyparsing.Literal('a')\n            return f is not None\n        except (ImportError, TypeError):\n            return False\n\n    def check(self):\n        try:\n            import pyparsing\n        except ImportError:\n            return (\n                \"pyparsing was not found. It is required for mathtext \"\n                \"support. pip/easy_install may attempt to install it \"\n                \"after matplotlib.\")\n\n        required = [1, 5, 6]\n        if [int(x) for x in pyparsing.__version__.split('.')] < required:\n            return (\n                \"matplotlib requires pyparsing >= {0}\".format(\n                    '.'.join(str(x) for x in required)))\n\n        if not self.is_ok():\n            return (\n                \"Your pyparsing contains a bug that will be monkey-patched by \"\n                \"matplotlib.  For best results, upgrade to pyparsing 2.0.1 or \"\n                \"later.\")\n\n        return \"using pyparsing version %s\" % pyparsing.__version__\n\n    def get_install_requires(self):\n        if self.is_ok():\n            return ['pyparsing>=1.5.6']\n        else:\n            return ['pyparsing>=1.5.6,!=2.0.0']\n\n\nclass BackendAgg(OptionalBackendPackage):\n    name = \"agg\"\n\n    def get_extension(self):\n        sources = [\n            \"src/mplutils.cpp\",\n            \"src/py_converters.cpp\",\n            \"src/_backend_agg.cpp\",\n            \"src/_backend_agg_wrapper.cpp\"\n            ]\n        ext = make_extension('matplotlib.backends._backend_agg', sources)\n        Numpy().add_flags(ext)\n        LibAgg().add_flags(ext)\n        FreeType().add_flags(ext)\n        return ext\n\n\nclass BackendTkAgg(OptionalBackendPackage):\n    name = \"tkagg\"\n\n    def __init__(self):\n        self.tcl_tk_cache = None\n\n    def check_requirements(self):\n        try:\n            if PY3:\n                import tkinter as Tkinter\n            else:\n                import Tkinter\n        except ImportError:\n            raise CheckFailed('TKAgg requires Tkinter.')\n        except RuntimeError:\n            raise CheckFailed('Tkinter present but import failed.')\n        else:\n            if Tkinter.TkVersion < 8.3:\n                raise CheckFailed(\"Tcl/Tk v8.3 or later required.\")\n\n        ext = self.get_extension()\n        check_include_file(ext.include_dirs, \"tk.h\", \"Tk\")\n\n        try:\n            tk_v = Tkinter.__version__.split()[-2]\n        except (AttributeError, IndexError):\n            # Tkinter.__version__ has been removed in python 3\n            tk_v = 'version not identified'\n\n        BackendAgg.force = True\n\n        return \"version %s\" % tk_v\n\n    def get_extension(self):\n        sources = [\n            'src/py_converters.cpp',\n            'src/_tkagg.cpp'\n            ]\n\n        ext = make_extension('matplotlib.backends._tkagg', sources)\n        self.add_flags(ext)\n        Numpy().add_flags(ext)\n        LibAgg().add_flags(ext)\n        return ext\n\n    def query_tcltk(self):\n        \"\"\"\n        Tries to open a Tk window in order to query the Tk object\n        about its library paths.  This should never be called more\n        than once by the same process, as Tk intricacies may cause the\n        Python interpreter to hang. The function also has a workaround\n        if no X server is running (useful for autobuild systems).\n        \"\"\"\n        # Use cached values if they exist, which ensures this function\n        # only executes once\n        if self.tcl_tk_cache is not None:\n            return self.tcl_tk_cache\n\n        # By this point, we already know that Tkinter imports correctly\n        if PY3:\n            import tkinter as Tkinter\n        else:\n            import Tkinter\n        tcl_lib_dir = ''\n        tk_lib_dir = ''\n        # First try to open a Tk window (requires a running X server)\n        try:\n            tk = Tkinter.Tk()\n        except Tkinter.TclError:\n            # Next, start Tcl interpreter without opening a Tk window\n            # (no need for X server) This feature is available in\n            # python version 2.4 and up\n            try:\n                tcl = Tkinter.Tcl()\n            except AttributeError:    # Python version not high enough\n                pass\n            except Tkinter.TclError:  # Something went wrong while opening Tcl\n                pass\n            else:\n                tcl_lib_dir = str(tcl.getvar('tcl_library'))\n                # Guess Tk location based on Tcl location\n                (head, tail) = os.path.split(tcl_lib_dir)\n                tail = tail.replace('Tcl', 'Tk').replace('tcl', 'tk')\n                tk_lib_dir = os.path.join(head, tail)\n                if not os.path.exists(tk_lib_dir):\n                    tk_lib_dir = tcl_lib_dir.replace(\n                        'Tcl', 'Tk').replace('tcl', 'tk')\n        else:\n            # Obtain Tcl and Tk locations from Tk widget\n            tk.withdraw()\n            tcl_lib_dir = str(tk.getvar('tcl_library'))\n            tk_lib_dir = str(tk.getvar('tk_library'))\n            tk.destroy()\n\n        # Save directories and version string to cache\n        self.tcl_tk_cache = tcl_lib_dir, tk_lib_dir, str(Tkinter.TkVersion)[:3]\n        return self.tcl_tk_cache\n\n    def parse_tcl_config(self, tcl_lib_dir, tk_lib_dir):\n        try:\n            if PY3:\n                import tkinter as Tkinter\n            else:\n                import Tkinter\n        except ImportError:\n            return None\n\n        tcl_poss = [tcl_lib_dir,\n                    os.path.normpath(os.path.join(tcl_lib_dir, '..')),\n                    \"/usr/lib/tcl\" + str(Tkinter.TclVersion),\n                    \"/usr/lib\"]\n        tk_poss = [tk_lib_dir,\n                    os.path.normpath(os.path.join(tk_lib_dir, '..')),\n                   \"/usr/lib/tk\" + str(Tkinter.TkVersion),\n                   \"/usr/lib\"]\n        for ptcl, ptk in zip(tcl_poss, tk_poss):\n            tcl_config = os.path.join(ptcl, \"tclConfig.sh\")\n            tk_config = os.path.join(ptk, \"tkConfig.sh\")\n            if (os.path.exists(tcl_config) and os.path.exists(tk_config)):\n                break\n        if not (os.path.exists(tcl_config) and os.path.exists(tk_config)):\n            return None\n\n        def get_var(file, varname):\n            p = subprocess.Popen(\n                '. %s ; eval echo ${%s}' % (file, varname),\n                shell=True,\n                executable=\"/bin/sh\",\n                stdout=subprocess.PIPE)\n            result = p.communicate()[0]\n            return result.decode('ascii')\n\n        tcl_lib_dir = get_var(\n            tcl_config, 'TCL_LIB_SPEC').split()[0][2:].strip()\n        tcl_inc_dir = get_var(\n            tcl_config, 'TCL_INCLUDE_SPEC')[2:].strip()\n        tcl_lib = get_var(tcl_config, 'TCL_LIB_FLAG')[2:].strip()\n\n        tk_lib_dir = get_var(tk_config, 'TK_LIB_SPEC').split()[0][2:].strip()\n        tk_inc_dir = get_var(tk_config, 'TK_INCLUDE_SPEC').strip()\n        if tk_inc_dir == '':\n            tk_inc_dir = tcl_inc_dir\n        else:\n            tk_inc_dir = tk_inc_dir[2:]\n        tk_lib = get_var(tk_config, 'TK_LIB_FLAG')[2:].strip()\n\n        if not os.path.exists(os.path.join(tk_inc_dir, 'tk.h')):\n            return None\n\n        return (tcl_lib_dir, tcl_inc_dir, tcl_lib,\n                tk_lib_dir, tk_inc_dir, tk_lib)\n\n    def guess_tcl_config(self, tcl_lib_dir, tk_lib_dir, tk_ver):\n        if not (os.path.exists(tcl_lib_dir) and os.path.exists(tk_lib_dir)):\n            return None\n\n        tcl_lib = os.path.normpath(os.path.join(tcl_lib_dir, '../'))\n        tk_lib = os.path.normpath(os.path.join(tk_lib_dir, '../'))\n\n        tcl_inc = os.path.normpath(\n            os.path.join(tcl_lib_dir,\n                         '../../include/tcl' + tk_ver))\n        if not os.path.exists(tcl_inc):\n            tcl_inc = os.path.normpath(\n                os.path.join(tcl_lib_dir,\n                             '../../include'))\n\n        tk_inc = os.path.normpath(os.path.join(\n            tk_lib_dir,\n            '../../include/tk' + tk_ver))\n        if not os.path.exists(tk_inc):\n            tk_inc = os.path.normpath(os.path.join(\n                tk_lib_dir,\n                '../../include'))\n\n        if not os.path.exists(os.path.join(tk_inc, 'tk.h')):\n            tk_inc = tcl_inc\n\n        if not os.path.exists(tcl_inc):\n            # this is a hack for suse linux, which is broken\n            if (sys.platform.startswith('linux') and\n                os.path.exists('/usr/include/tcl.h') and\n                os.path.exists('/usr/include/tk.h')):\n                tcl_inc = '/usr/include'\n                tk_inc = '/usr/include'\n\n        if not os.path.exists(os.path.join(tk_inc, 'tk.h')):\n            return None\n\n        return tcl_lib, tcl_inc, 'tcl' + tk_ver, tk_lib, tk_inc, 'tk' + tk_ver\n\n    def hardcoded_tcl_config(self):\n        tcl_inc = \"/usr/local/include\"\n        tk_inc = \"/usr/local/include\"\n        tcl_lib = \"/usr/local/lib\"\n        tk_lib = \"/usr/local/lib\"\n        return tcl_lib, tcl_inc, 'tcl', tk_lib, tk_inc, 'tk'\n\n    def add_flags(self, ext):\n        if sys.platform == 'win32':\n            major, minor1, minor2, s, tmp = sys.version_info\n            if sys.version_info[0:2] < (3, 4):\n                ext.include_dirs.extend(['win32_static/include/tcl85'])\n                ext.libraries.extend(['tk85', 'tcl85'])\n            else:\n                ext.include_dirs.extend(['win32_static/include/tcl86'])\n                ext.libraries.extend(['tk86t', 'tcl86t'])\n            ext.library_dirs.extend([os.path.join(sys.prefix, 'dlls')])\n\n        elif sys.platform == 'darwin':\n            # this config section lifted directly from Imaging - thanks to\n            # the effbot!\n\n            # First test for a MacOSX/darwin framework install\n            from os.path import join, exists\n            framework_dirs = [\n                join(os.getenv('HOME'), '/Library/Frameworks'),\n                '/Library/Frameworks',\n                '/System/Library/Frameworks/',\n            ]\n\n            # Find the directory that contains the Tcl.framework and\n            # Tk.framework bundles.\n            tk_framework_found = 0\n            for F in framework_dirs:\n                # both Tcl.framework and Tk.framework should be present\n                for fw in 'Tcl', 'Tk':\n                    if not exists(join(F, fw + '.framework')):\n                        break\n                else:\n                    # ok, F is now directory with both frameworks. Continure\n                    # building\n                    tk_framework_found = 1\n                    break\n            if tk_framework_found:\n                # For 8.4a2, we must add -I options that point inside\n                # the Tcl and Tk frameworks. In later release we\n                # should hopefully be able to pass the -F option to\n                # gcc, which specifies a framework lookup path.\n\n                tk_include_dirs = [\n                    join(F, fw + '.framework', H)\n                    for fw in ('Tcl', 'Tk')\n                    for H in ('Headers', 'Versions/Current/PrivateHeaders')\n                ]\n\n                # For 8.4a2, the X11 headers are not included. Rather\n                # than include a complicated search, this is a\n                # hard-coded path. It could bail out if X11 libs are\n                # not found...\n\n                # tk_include_dirs.append('/usr/X11R6/include')\n                frameworks = ['-framework', 'Tcl', '-framework', 'Tk']\n                ext.include_dirs.extend(tk_include_dirs)\n                ext.extra_link_args.extend(frameworks)\n                ext.extra_compile_args.extend(frameworks)\n\n        # you're still here? ok we'll try it this way...\n        else:\n            # There are 3 methods to try, in decreasing order of \"smartness\"\n            #\n            #   1. Parse the tclConfig.sh and tkConfig.sh files that have\n            #      all the information we need\n            #\n            #   2. Guess the include and lib dirs based on the location of\n            #      Tkinter's 'tcl_library' and 'tk_library' variables.\n            #\n            #   3. Use some hardcoded locations that seem to work on a lot\n            #      of distros.\n\n            # Query Tcl/Tk system for library paths and version string\n            try:\n                tcl_lib_dir, tk_lib_dir, tk_ver = self.query_tcltk()\n            except:\n                tk_ver = ''\n                result = self.hardcoded_tcl_config()\n            else:\n                result = self.parse_tcl_config(tcl_lib_dir, tk_lib_dir)\n                if result is None:\n                    result = self.guess_tcl_config(\n                        tcl_lib_dir, tk_lib_dir, tk_ver)\n                    if result is None:\n                        result = self.hardcoded_tcl_config()\n\n            # Add final versions of directories and libraries to ext lists\n            (tcl_lib_dir, tcl_inc_dir, tcl_lib,\n             tk_lib_dir, tk_inc_dir, tk_lib) = result\n            ext.include_dirs.extend([tcl_inc_dir, tk_inc_dir])\n            ext.library_dirs.extend([tcl_lib_dir, tk_lib_dir])\n            ext.libraries.extend([tcl_lib, tk_lib])\n\n\nclass BackendGtk(OptionalBackendPackage):\n    name = \"gtk\"\n\n    def check_requirements(self):\n        try:\n            import gtk\n        except ImportError:\n            raise CheckFailed(\"Requires pygtk\")\n        except RuntimeError:\n            raise CheckFailed('pygtk present, but import failed.')\n        else:\n            version = (2, 2, 0)\n            if gtk.pygtk_version < version:\n                raise CheckFailed(\n                    \"Requires pygtk %d.%d.%d or later. \"\n                    \"Found %d.%d.%d\" % (version + gtk.pygtk_version))\n\n        ext = self.get_extension()\n        self.add_flags(ext)\n        check_include_file(ext.include_dirs,\n                           os.path.join(\"gtk\", \"gtk.h\"),\n                           'gtk')\n        check_include_file(ext.include_dirs,\n                           os.path.join(\"pygtk\", \"pygtk.h\"),\n                           'pygtk')\n\n        return 'Gtk: %s pygtk: %s' % (\n            \".\".join(str(x) for x in gtk.gtk_version),\n            \".\".join(str(x) for x in gtk.pygtk_version))\n\n    def get_package_data(self):\n        return {'matplotlib': ['mpl-data/*.glade']}\n\n    def get_extension(self):\n        sources = [\n            'src/_backend_gdk.c'\n            ]\n        ext = make_extension('matplotlib.backends._backend_gdk', sources)\n        self.add_flags(ext)\n        Numpy().add_flags(ext)\n        return ext\n\n    def add_flags(self, ext):\n        if sys.platform == 'win32':\n            def getoutput(s):\n                ret = os.popen(s).read().strip()\n                return ret\n\n            if 'PKG_CONFIG_PATH' not in os.environ:\n                # If Gtk+ is installed, pkg-config is required to be installed\n                os.environ['PKG_CONFIG_PATH'] = 'C:\\\\GTK\\\\lib\\\\pkgconfig'\n\n                # popen broken on my win32 plaform so I can't use pkgconfig\n                ext.library_dirs.extend(\n                    ['C:/GTK/bin', 'C:/GTK/lib'])\n\n                ext.include_dirs.extend(\n                    ['win32_static/include/pygtk-2.0',\n                     'C:/GTK/include',\n                     'C:/GTK/include/gobject',\n                     'C:/GTK/include/gext',\n                     'C:/GTK/include/glib',\n                     'C:/GTK/include/pango',\n                     'C:/GTK/include/atk',\n                     'C:/GTK/include/X11',\n                     'C:/GTK/include/cairo',\n                     'C:/GTK/include/gdk',\n                     'C:/GTK/include/gdk-pixbuf',\n                     'C:/GTK/include/gtk',\n                     ])\n\n            pygtkIncludes = getoutput(\n                'pkg-config --cflags-only-I pygtk-2.0').split()\n            gtkIncludes = getoutput(\n                'pkg-config --cflags-only-I gtk+-2.0').split()\n            includes = pygtkIncludes + gtkIncludes\n            ext.include_dirs.extend([include[2:] for include in includes])\n\n            pygtkLinker = getoutput('pkg-config --libs pygtk-2.0').split()\n            gtkLinker = getoutput('pkg-config --libs gtk+-2.0').split()\n            linkerFlags = pygtkLinker + gtkLinker\n\n            ext.libraries.extend(\n                [flag[2:] for flag in linkerFlags if flag.startswith('-l')])\n\n            ext.library_dirs.extend(\n                [flag[2:] for flag in linkerFlags if flag.startswith('-L')])\n\n            ext.extra_link_args.extend(\n                [flag for flag in linkerFlags if not\n                 (flag.startswith('-l') or flag.startswith('-L'))])\n\n            # visual studio doesn't need the math library\n            if (sys.platform == 'win32' and\n                win32_compiler == 'msvc' and\n                'm' in ext.libraries):\n                ext.libraries.remove('m')\n\n        elif sys.platform != 'win32':\n            pkg_config.setup_extension(ext, 'pygtk-2.0')\n            pkg_config.setup_extension(ext, 'gtk+-2.0')\n\n\nclass BackendGtkAgg(BackendGtk):\n    name = \"gtkagg\"\n\n    def check(self):\n        try:\n            return super(BackendGtkAgg, self).check()\n        except:\n            raise\n        else:\n            BackendAgg.force = True\n\n    def get_package_data(self):\n        return {'matplotlib': ['mpl-data/*.glade']}\n\n    def get_extension(self):\n        sources = [\n            'src/py_converters.cpp',\n            'src/_gtkagg.cpp',\n            'src/mplutils.cpp'\n            ]\n        ext = make_extension('matplotlib.backends._gtkagg', sources)\n        self.add_flags(ext)\n        LibAgg().add_flags(ext)\n        Numpy().add_flags(ext)\n        return ext\n\n\ndef backend_gtk3agg_internal_check(x):\n    try:\n        import gi\n    except ImportError:\n        return (False, \"Requires pygobject to be installed.\")\n\n    try:\n        gi.require_version(\"Gtk\", \"3.0\")\n    except ValueError:\n        return (False, \"Requires gtk3 development files to be installed.\")\n    except AttributeError:\n        return (False, \"pygobject version too old.\")\n\n    try:\n        from gi.repository import Gtk, Gdk, GObject\n    except (ImportError, RuntimeError):\n        return (False, \"Requires pygobject to be installed.\")\n\n    return (True, \"version %s.%s.%s\" % (\n        Gtk.get_major_version(),\n        Gtk.get_micro_version(),\n        Gtk.get_minor_version()))\n\n\nclass BackendGtk3Agg(OptionalBackendPackage):\n    name = \"gtk3agg\"\n\n    def check_requirements(self):\n        if 'TRAVIS' in os.environ:\n            raise CheckFailed(\"Can't build with Travis\")\n\n        # This check needs to be performed out-of-process, because\n        # importing gi and then importing regular old pygtk afterward\n        # segfaults the interpreter.\n        try:\n            p = multiprocessing.Pool()\n        except:\n            return \"unknown (can not use multiprocessing to determine)\"\n        try:\n            success, msg = p.map(backend_gtk3agg_internal_check, [0])[0]\n        except:\n            success = False\n            msg = \"Could not determine\"\n        finally:\n            p.close()\n            p.join()\n        if success:\n            BackendAgg.force = True\n\n            return msg\n        else:\n            raise CheckFailed(msg)\n\n    def get_package_data(self):\n        return {'matplotlib': ['mpl-data/*.glade']}\n\n\ndef backend_gtk3cairo_internal_check(x):\n    try:\n        import cairocffi\n    except ImportError:\n        try:\n            import cairo\n        except ImportError:\n            return (False, \"Requires cairocffi or pycairo to be installed.\")\n\n    try:\n        import gi\n    except ImportError:\n        return (False, \"Requires pygobject to be installed.\")\n\n    try:\n        gi.require_version(\"Gtk\", \"3.0\")\n    except ValueError:\n        return (False, \"Requires gtk3 development files to be installed.\")\n    except AttributeError:\n        return (False, \"pygobject version too old.\")\n\n    try:\n        from gi.repository import Gtk, Gdk, GObject\n    except (RuntimeError, ImportError):\n        return (False, \"Requires pygobject to be installed.\")\n\n    return (True, \"version %s.%s.%s\" % (\n        Gtk.get_major_version(),\n        Gtk.get_micro_version(),\n        Gtk.get_minor_version()))\n\n\nclass BackendGtk3Cairo(OptionalBackendPackage):\n    name = \"gtk3cairo\"\n\n    def check_requirements(self):\n        if 'TRAVIS' in os.environ:\n            raise CheckFailed(\"Can't build with Travis\")\n\n        # This check needs to be performed out-of-process, because\n        # importing gi and then importing regular old pygtk afterward\n        # segfaults the interpreter.\n        try:\n            p = multiprocessing.Pool()\n        except:\n            return \"unknown (can not use multiprocessing to determine)\"\n        success, msg = p.map(backend_gtk3cairo_internal_check, [0])[0]\n        p.close()\n        p.join()\n        if success:\n            BackendAgg.force = True\n\n            return msg\n        else:\n            raise CheckFailed(msg)\n\n    def get_package_data(self):\n        return {'matplotlib': ['mpl-data/*.glade']}\n\n\nclass BackendWxAgg(OptionalBackendPackage):\n    name = \"wxagg\"\n\n    def check_requirements(self):\n        try:\n            import wxversion\n        except ImportError:\n            raise CheckFailed(\"requires wxPython\")\n\n        try:\n            _wx_ensure_failed = wxversion.AlreadyImportedError\n        except AttributeError:\n            _wx_ensure_failed = wxversion.VersionError\n\n        try:\n            wxversion.ensureMinimal('2.8')\n        except _wx_ensure_failed:\n            pass\n\n        try:\n            import wx\n            backend_version = wx.VERSION_STRING\n        except ImportError:\n            raise CheckFailed(\"requires wxPython\")\n\n        # Extra version check in case wxversion lacks AlreadyImportedError;\n        # then VersionError might have been raised and ignored when\n        # there really *is* a problem with the version.\n        major, minor = [int(n) for n in backend_version.split('.')[:2]]\n        if major < 2 or (major < 3 and minor < 8):\n            raise CheckFailed(\n                \"Requires wxPython 2.8, found %s\" % backend_version)\n\n        BackendAgg.force = True\n\n        return \"version %s\" % backend_version\n\n\nclass BackendMacOSX(OptionalBackendPackage):\n    name = 'macosx'\n\n    def check_requirements(self):\n        if sys.platform != 'darwin':\n            raise CheckFailed(\"Mac OS-X only\")\n\n        return 'darwin'\n\n    def get_extension(self):\n        sources = [\n            'src/_macosx.m',\n            'src/py_converters.cpp',\n            'src/path_cleanup.cpp'\n            ]\n\n        ext = make_extension('matplotlib.backends._macosx', sources)\n        Numpy().add_flags(ext)\n        LibAgg().add_flags(ext)\n        ext.extra_link_args.extend(['-framework', 'Cocoa'])\n        return ext\n\n\nclass Windowing(OptionalBackendPackage):\n    \"\"\"\n    Builds the windowing extension.\n    \"\"\"\n    name = \"windowing\"\n\n    def check_requirements(self):\n        if sys.platform != 'win32':\n            raise CheckFailed(\"Microsoft Windows only\")\n        config = self.get_config()\n        if config is False:\n            raise CheckFailed(\"skipping due to configuration\")\n        return \"installing\"\n\n    def get_extension(self):\n        sources = [\n            \"src/_windowing.cpp\"\n            ]\n        ext = make_extension('matplotlib._windowing', sources)\n        ext.include_dirs.extend(['C:/include'])\n        ext.libraries.extend(['user32'])\n        ext.library_dirs.extend(['C:/lib'])\n        ext.extra_link_args.append(\"-mwindows\")\n        return ext\n\n\nclass BackendQtBase(OptionalBackendPackage):\n\n    def convert_qt_version(self, version):\n        version = '%x' % version\n        temp = []\n        while len(version) > 0:\n            version, chunk = version[:-2], version[-2:]\n            temp.insert(0, str(int(chunk, 16)))\n        return '.'.join(temp)\n\n    def check_requirements(self):\n        '''\n        If PyQt4/PyQt5 is already imported, importing PyQt5/PyQt4 will fail\n        so we need to test in a subprocess (as for Gtk3).\n        '''\n        try:\n            p = multiprocessing.Pool()\n\n        except:\n            # Can't do multiprocessing, fall back to normal approach ( this will fail if importing both PyQt4 and PyQt5 )\n            try:\n                # Try in-process\n                msg = self.callback(self)\n\n            except RuntimeError:\n                raise CheckFailed(\"Could not import: are PyQt4 & PyQt5 both installed?\")\n\n            except:\n                # Raise any other exceptions\n                raise\n\n        else:\n            # Multiprocessing OK\n            try:\n                msg = p.map(self.callback, [self])[0]\n            except:\n                # If we hit an error on multiprocessing raise it\n                raise\n            finally:\n                # Tidy up multiprocessing\n                p.close()\n                p.join()\n\n        return msg\n\n\ndef backend_qt4_internal_check(self):\n    try:\n        from PyQt4 import QtCore\n    except ImportError:\n        raise CheckFailed(\"PyQt4 not found\")\n\n    try:\n        qt_version = QtCore.QT_VERSION\n        pyqt_version_str = QtCore.QT_VERSION_STR\n    except AttributeError:\n        raise CheckFailed('PyQt4 not correctly imported')\n    else:\n        BackendAgg.force = True\n        return (\"Qt: %s, PyQt: %s\" % (self.convert_qt_version(qt_version), pyqt_version_str))\n\n\nclass BackendQt4(BackendQtBase):\n    name = \"qt4agg\"\n\n    def __init__(self, *args, **kwargs):\n        BackendQtBase.__init__(self, *args, **kwargs)\n        self.callback = backend_qt4_internal_check\n\n\ndef backend_qt5_internal_check(self):\n    try:\n        from PyQt5 import QtCore\n    except ImportError:\n        raise CheckFailed(\"PyQt5 not found\")\n\n    try:\n        qt_version = QtCore.QT_VERSION\n        pyqt_version_str = QtCore.QT_VERSION_STR\n    except AttributeError:\n        raise CheckFailed('PyQt5 not correctly imported')\n    else:\n        BackendAgg.force = True\n        return (\"Qt: %s, PyQt: %s\" % (self.convert_qt_version(qt_version), pyqt_version_str))\n\n\nclass BackendQt5(BackendQtBase):\n    name = \"qt5agg\"\n\n    def __init__(self, *args, **kwargs):\n        BackendQtBase.__init__(self, *args, **kwargs)\n        self.callback = backend_qt5_internal_check\n\n\ndef backend_pyside_internal_check(self):\n    try:\n        from PySide import __version__\n        from PySide import QtCore\n    except ImportError:\n        raise CheckFailed(\"PySide not found\")\n    else:\n        BackendAgg.force = True\n        return (\"Qt: %s, PySide: %s\" %\n                (QtCore.__version__, __version__))\n\n\nclass BackendPySide(BackendQtBase):\n    name = \"pyside\"\n\n    def __init__(self, *args, **kwargs):\n        BackendQtBase.__init__(self, *args, **kwargs)\n        self.callback = backend_pyside_internal_check\n\n\n\nclass BackendCairo(OptionalBackendPackage):\n    name = \"cairo\"\n\n    def check_requirements(self):\n        try:\n            import cairocffi\n        except ImportError:\n            try:\n                import cairo\n            except ImportError:\n                raise CheckFailed(\"cairocffi or pycairo not found\")\n            else:\n                return \"pycairo version %s\" % cairo.version\n        else:\n            return \"cairocffi version %s\" % cairocffi.version\n\n\nclass DviPng(SetupPackage):\n    name = \"dvipng\"\n    optional = True\n\n    def check(self):\n        try:\n            output = check_output('dvipng -version', shell=True,\n                                  stderr=subprocess.STDOUT)\n            return \"version %s\" % output.splitlines()[1].decode().split()[-1]\n        except (IndexError, ValueError, subprocess.CalledProcessError):\n            raise CheckFailed()\n\n\nclass Ghostscript(SetupPackage):\n    name = \"ghostscript\"\n    optional = True\n\n    def check(self):\n        try:\n            if sys.platform == 'win32':\n                command = 'gswin32c --version'\n                try:\n                    output = check_output(command, shell=True,\n                                          stderr=subprocess.STDOUT)\n                except subprocess.CalledProcessError:\n                    command = 'gswin64c --version'\n                    output = check_output(command, shell=True,\n                                          stderr=subprocess.STDOUT)\n            else:\n                command = 'gs --version'\n                output = check_output(command, shell=True,\n                                      stderr=subprocess.STDOUT)\n            return \"version %s\" % output.decode()[:-1]\n        except (IndexError, ValueError, subprocess.CalledProcessError):\n            raise CheckFailed()\n\n\nclass LaTeX(SetupPackage):\n    name = \"latex\"\n    optional = True\n\n    def check(self):\n        try:\n            output = check_output('latex -version', shell=True,\n                                  stderr=subprocess.STDOUT)\n            line = output.splitlines()[0].decode()\n            pattern = '(3\\.1\\d+)|(MiKTeX \\d+.\\d+)'\n            match = re.search(pattern, line)\n            return \"version %s\" % match.group(0)\n        except (IndexError, ValueError, AttributeError, subprocess.CalledProcessError):\n            raise CheckFailed()\n\n\nclass PdfToPs(SetupPackage):\n    name = \"pdftops\"\n    optional = True\n\n    def check(self):\n        try:\n            output = check_output('pdftops -v', shell=True,\n                                  stderr=subprocess.STDOUT)\n            for line in output.splitlines():\n                line = line.decode()\n                if 'version' in line:\n                    return \"version %s\" % line.split()[2]\n        except (IndexError, ValueError, subprocess.CalledProcessError):\n            pass\n\n        raise CheckFailed()\n", "patch": "@@ -1005,12 +1005,12 @@ class FT2Font(SetupPackage):\n     def get_extension(self):\n         sources = [\n             'src/ft2font.cpp',\n+            'src/ft2font_wrapper.cpp',\n             'src/mplutils.cpp'\n             ]\n         ext = make_extension('matplotlib.ft2font', sources)\n         FreeType().add_flags(ext)\n         Numpy().add_flags(ext)\n-        CXX().add_flags(ext)\n         return ext\n \n \n@@ -1039,14 +1039,14 @@ def check(self):\n \n     def get_extension(self):\n         sources = [\n-            'src/_png.cpp', 'src/mplutils.cpp'\n+            'src/_png.cpp',\n+            'src/mplutils.cpp'\n             ]\n         ext = make_extension('matplotlib._png', sources)\n         pkg_config.setup_extension(\n             ext, 'libpng', default_libraries=['png', 'z'],\n             alt_exec='libpng-config --ldflags')\n         Numpy().add_flags(ext)\n-        CXX().add_flags(ext)\n         return ext\n \n \n@@ -1092,7 +1092,6 @@ def get_extension(self):\n             ]\n         ext = make_extension('matplotlib.ttconv', sources)\n         Numpy().add_flags(ext)\n-        CXX().add_flags(ext)\n         ext.include_dirs.append('extern')\n         return ext\n \n@@ -1102,15 +1101,13 @@ class Path(SetupPackage):\n \n     def get_extension(self):\n         sources = [\n-            'src/_path.cpp',\n-            'src/path_cleanup.cpp',\n-            'src/agg_py_transforms.cpp'\n+            'src/py_converters.cpp',\n+            'src/_path_wrapper.cpp'\n             ]\n \n         ext = make_extension('matplotlib._path', sources)\n         Numpy().add_flags(ext)\n         LibAgg().add_flags(ext)\n-        CXX().add_flags(ext)\n         return ext\n \n \n@@ -1119,12 +1116,13 @@ class Image(SetupPackage):\n \n     def get_extension(self):\n         sources = [\n-            'src/_image.cpp', 'src/mplutils.cpp'\n+            'src/_image.cpp',\n+            'src/mplutils.cpp',\n+            'src/_image_wrapper.cpp'\n             ]\n         ext = make_extension('matplotlib._image', sources)\n         Numpy().add_flags(ext)\n         LibAgg().add_flags(ext)\n-        CXX().add_flags(ext)\n         return ext\n \n \n@@ -1317,14 +1315,14 @@ class BackendAgg(OptionalBackendPackage):\n     def get_extension(self):\n         sources = [\n             \"src/mplutils.cpp\",\n-            \"src/agg_py_transforms.cpp\",\n-            \"src/_backend_agg.cpp\"\n+            \"src/py_converters.cpp\",\n+            \"src/_backend_agg.cpp\",\n+            \"src/_backend_agg_wrapper.cpp\"\n             ]\n         ext = make_extension('matplotlib.backends._backend_agg', sources)\n         Numpy().add_flags(ext)\n         LibAgg().add_flags(ext)\n         FreeType().add_flags(ext)\n-        CXX().add_flags(ext)\n         return ext\n \n \n@@ -1363,15 +1361,14 @@ def check_requirements(self):\n \n     def get_extension(self):\n         sources = [\n-            'src/agg_py_transforms.cpp',\n+            'src/py_converters.cpp',\n             'src/_tkagg.cpp'\n             ]\n \n         ext = make_extension('matplotlib.backends._tkagg', sources)\n         self.add_flags(ext)\n         Numpy().add_flags(ext)\n         LibAgg().add_flags(ext)\n-        CXX().add_flags(ext)\n         return ext\n \n     def query_tcltk(self):\n@@ -1740,14 +1737,13 @@ def get_package_data(self):\n \n     def get_extension(self):\n         sources = [\n-            'src/agg_py_transforms.cpp',\n+            'src/py_converters.cpp',\n             'src/_gtkagg.cpp',\n             'src/mplutils.cpp'\n             ]\n         ext = make_extension('matplotlib.backends._gtkagg', sources)\n         self.add_flags(ext)\n         LibAgg().add_flags(ext)\n-        CXX().add_flags(ext)\n         Numpy().add_flags(ext)\n         return ext\n \n@@ -1919,14 +1915,13 @@ def check_requirements(self):\n     def get_extension(self):\n         sources = [\n             'src/_macosx.m',\n-            'src/agg_py_transforms.cpp',\n+            'src/py_converters.cpp',\n             'src/path_cleanup.cpp'\n             ]\n \n         ext = make_extension('matplotlib.backends._macosx', sources)\n         Numpy().add_flags(ext)\n         LibAgg().add_flags(ext)\n-        CXX().add_flags(ext)\n         ext.extra_link_args.extend(['-framework', 'Cocoa'])\n         return ext\n "}
{"patches_id": 2, "files_id": 28, "language": "cpp", "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_backend_agg.cpp", "raw_code": "/* -*- mode: c++; c-basic-offset: 4 -*- */\n\n/* A rewrite of _backend_agg using PyCXX to handle ref counting, etc..\n */\n\n#define NO_IMPORT_ARRAY\n\n#include \"_backend_agg.h\"\n#include \"mplutils.h\"\n#include \"MPL_isnan.h\"\n\nvoid BufferRegion::to_string_argb(uint8_t *buf)\n{\n    unsigned char *pix;\n    unsigned char tmp;\n    size_t i, j;\n\n    memcpy(buf, data, height * stride);\n\n    for (i = 0; i < (size_t)height; ++i) {\n        pix = buf + i * stride;\n        for (j = 0; j < (size_t)width; ++j) {\n            // Convert rgba to argb\n            tmp = pix[2];\n            pix[2] = pix[0];\n            pix[0] = tmp;\n            pix += 4;\n        }\n    }\n}\n\nRendererAgg::RendererAgg(unsigned int width, unsigned int height, double dpi)\n    : width(width),\n      height(height),\n      dpi(dpi),\n      NUMBYTES(width * height * 4),\n      pixBuffer(NULL),\n      renderingBuffer(),\n      alphaBuffer(NULL),\n      alphaMaskRenderingBuffer(),\n      alphaMask(alphaMaskRenderingBuffer),\n      pixfmtAlphaMask(alphaMaskRenderingBuffer),\n      rendererBaseAlphaMask(),\n      rendererAlphaMask(),\n      scanlineAlphaMask(),\n      slineP8(),\n      slineBin(),\n      pixFmt(),\n      rendererBase(),\n      rendererAA(),\n      rendererBin(),\n      theRasterizer(),\n      lastclippath(NULL),\n      _fill_color(agg::rgba(1, 1, 1, 0))\n{\n    unsigned stride(width * 4);\n\n    pixBuffer = new agg::int8u[NUMBYTES];\n    renderingBuffer.attach(pixBuffer, width, height, stride);\n    pixFmt.attach(renderingBuffer);\n    rendererBase.attach(pixFmt);\n    rendererBase.clear(_fill_color);\n    rendererAA.attach(rendererBase);\n    rendererBin.attach(rendererBase);\n    hatchRenderingBuffer.attach(hatchBuffer, HATCH_SIZE, HATCH_SIZE, HATCH_SIZE * 4);\n}\n\nRendererAgg::~RendererAgg()\n{\n    delete[] alphaBuffer;\n    delete[] pixBuffer;\n}\n\nvoid RendererAgg::create_alpha_buffers()\n{\n    if (!alphaBuffer) {\n        alphaBuffer = new agg::int8u[width * height];\n        alphaMaskRenderingBuffer.attach(alphaBuffer, width, height, width);\n        rendererBaseAlphaMask.attach(pixfmtAlphaMask);\n        rendererAlphaMask.attach(rendererBaseAlphaMask);\n    }\n}\n\nBufferRegion *RendererAgg::copy_from_bbox(agg::rect_d in_rect)\n{\n    agg::rect_i rect(\n        (int)in_rect.x1, height - (int)in_rect.y2, (int)in_rect.x2, height - (int)in_rect.y1);\n\n    BufferRegion *reg = NULL;\n    reg = new BufferRegion(rect);\n\n    agg::rendering_buffer rbuf;\n    rbuf.attach(reg->get_data(), reg->get_width(), reg->get_height(), reg->get_stride());\n\n    pixfmt pf(rbuf);\n    renderer_base rb(pf);\n    rb.copy_from(renderingBuffer, &rect, -rect.x1, -rect.y1);\n\n    return reg;\n}\n\nvoid RendererAgg::restore_region(BufferRegion &region)\n{\n    if (region.get_data() == NULL) {\n        throw \"Cannot restore_region from NULL data\";\n    }\n\n    agg::rendering_buffer rbuf;\n    rbuf.attach(region.get_data(), region.get_width(), region.get_height(), region.get_stride());\n\n    rendererBase.copy_from(rbuf, 0, region.get_rect().x1, region.get_rect().y1);\n}\n\n// Restore the part of the saved region with offsets\nvoid\nRendererAgg::restore_region(BufferRegion &region, int x, int y, int xx1, int yy1, int xx2, int yy2)\n{\n    if (region.get_data() == NULL) {\n        throw \"Cannot restore_region from NULL data\";\n    }\n\n    agg::rect_i &rrect = region.get_rect();\n\n    agg::rect_i rect(xx1 - rrect.x1, (yy1 - rrect.y1), xx2 - rrect.x1, (yy2 - rrect.y1));\n\n    agg::rendering_buffer rbuf;\n    rbuf.attach(region.get_data(), region.get_width(), region.get_height(), region.get_stride());\n\n    rendererBase.copy_from(rbuf, &rect, x, y);\n}\n\nbool RendererAgg::render_clippath(py::PathIterator &clippath,\n                                  const agg::trans_affine &clippath_trans)\n{\n    typedef agg::conv_transform<py::PathIterator> transformed_path_t;\n    typedef agg::conv_curve<transformed_path_t> curve_t;\n\n    bool has_clippath = (clippath.total_vertices() != 0);\n\n    if (has_clippath &&\n        (clippath.get_id() != lastclippath || clippath_trans != lastclippath_transform)) {\n        create_alpha_buffers();\n        agg::trans_affine trans(clippath_trans);\n        trans *= agg::trans_affine_scaling(1.0, -1.0);\n        trans *= agg::trans_affine_translation(0.0, (double)height);\n\n        rendererBaseAlphaMask.clear(agg::gray8(0, 0));\n        transformed_path_t transformed_clippath(clippath, trans);\n        curve_t curved_clippath(transformed_clippath);\n        theRasterizer.add_path(curved_clippath);\n        rendererAlphaMask.color(agg::gray8(255, 255));\n        agg::render_scanlines(theRasterizer, scanlineAlphaMask, rendererAlphaMask);\n        lastclippath = clippath.get_id();\n        lastclippath_transform = clippath_trans;\n    }\n\n    return has_clippath;\n}\n\nvoid RendererAgg::tostring_rgb(uint8_t *buf)\n{\n    // \"Return the rendered buffer as an RGB string\"\n\n    int row_len = width * 3;\n\n    agg::rendering_buffer renderingBufferTmp;\n    renderingBufferTmp.attach(buf, width, height, row_len);\n\n    agg::color_conv(&renderingBufferTmp, &renderingBuffer, agg::color_conv_rgba32_to_rgb24());\n}\n\nvoid RendererAgg::tostring_argb(uint8_t *buf)\n{\n    //\"Return the rendered buffer as an RGB string\";\n\n    int row_len = width * 4;\n\n    agg::rendering_buffer renderingBufferTmp;\n    renderingBufferTmp.attach(buf, width, height, row_len);\n    agg::color_conv(&renderingBufferTmp, &renderingBuffer, agg::color_conv_rgba32_to_argb32());\n}\n\nvoid RendererAgg::tostring_bgra(uint8_t *buf)\n{\n    //\"Return the rendered buffer as an RGB string\";\n\n    int row_len = width * 4;\n\n    agg::rendering_buffer renderingBufferTmp;\n    renderingBufferTmp.attach(buf, width, height, row_len);\n\n    agg::color_conv(&renderingBufferTmp, &renderingBuffer, agg::color_conv_rgba32_to_bgra32());\n}\n\nagg::rect_i RendererAgg::get_content_extents()\n{\n    agg::rect_i r(width, height, 0, 0);\n\n    // Looks at the alpha channel to find the minimum extents of the image\n    unsigned char *pixel = pixBuffer + 3;\n    for (int y = 0; y < (int)height; ++y) {\n        for (int x = 0; x < (int)width; ++x) {\n            if (*pixel) {\n                if (x < r.x1)\n                    r.x1 = x;\n                if (y < r.y1)\n                    r.y1 = y;\n                if (x > r.x2)\n                    r.x2 = x;\n                if (y > r.y2)\n                    r.y2 = y;\n            }\n            pixel += 4;\n        }\n    }\n\n    r.x1 = std::max(0, r.x1 - 1);\n    r.y1 = std::max(0, r.y1 - 1);\n    r.x2 = std::max(r.x2 + 1, (int)width);\n    r.y2 = std::max(r.y2 + 1, (int)height);\n\n    return r;\n}\n\nvoid RendererAgg::clear()\n{\n    //\"clear the rendered buffer\";\n\n    rendererBase.clear(_fill_color);\n}\n", "patch": "@@ -3,428 +3,57 @@\n /* A rewrite of _backend_agg using PyCXX to handle ref counting, etc..\n  */\n \n-/* Python API mandates Python.h is included *first* */\n-#include \"Python.h\"\n+#define NO_IMPORT_ARRAY\n \n-/* TODO: Remove this dependency */\n-#include \"ft2font.h\"\n-#include \"_image.h\"\n #include \"_backend_agg.h\"\n #include \"mplutils.h\"\n-\n-#include <iostream>\n-#include <fstream>\n-#include <cmath>\n-#include <cstdio>\n-#include <stdexcept>\n-#include <time.h>\n-#include <algorithm>\n-\n-#include \"agg_conv_curve.h\"\n-#include \"agg_conv_transform.h\"\n-#include \"agg_image_accessors.h\"\n-#include \"agg_renderer_primitives.h\"\n-#include \"agg_scanline_storage_aa.h\"\n-#include \"agg_scanline_storage_bin.h\"\n-#include \"agg_span_allocator.h\"\n-#include \"agg_span_converter.h\"\n-#include \"agg_span_image_filter_gray.h\"\n-#include \"agg_span_image_filter_rgba.h\"\n-#include \"agg_span_interpolator_linear.h\"\n-#include \"agg_span_pattern_rgba.h\"\n-#include \"agg_span_gouraud_rgba.h\"\n-#include \"agg_conv_shorten_path.h\"\n-#include \"util/agg_color_conv_rgb8.h\"\n-\n #include \"MPL_isnan.h\"\n \n-#include \"numpy/arrayobject.h\"\n-#include \"agg_py_transforms.h\"\n-\n-#include \"file_compat.h\"\n-\n-#ifndef M_PI\n-#define M_PI       3.14159265358979323846\n-#endif\n-#ifndef M_PI_4\n-#define M_PI_4     0.785398163397448309616\n-#endif\n-#ifndef M_PI_2\n-#define M_PI_2     1.57079632679489661923\n-#endif\n-\n-\n-/*\n- Convert dashes from the Python representation as nested sequences to\n- the C++ representation as a std::vector<std::pair<double, double> >\n- (GCAgg::dash_t) */\n-void\n-convert_dashes(const Py::Tuple& dashes, double dpi,\n-               GCAgg::dash_t& dashes_out, double& dashOffset_out)\n-{\n-    if (dashes.length() != 2)\n-    {\n-        throw Py::ValueError(\n-            Printf(\"Dash descriptor must be a length 2 tuple; found %d\",\n-                   dashes.length()).str()\n-        );\n-    }\n-\n-    dashes_out.clear();\n-    dashOffset_out = 0.0;\n-    if (dashes[0].ptr() == Py_None)\n-    {\n-        return;\n-    }\n-\n-    dashOffset_out = double(Py::Float(dashes[0])) * dpi / 72.0;\n-\n-    Py::SeqBase<Py::Object> dashSeq = dashes[1];\n-\n-    size_t Ndash = dashSeq.length();\n-    if (Ndash % 2 != 0)\n-    {\n-        throw Py::ValueError(\n-            Printf(\"Dash sequence must be an even length sequence; found %d\", Ndash).str()\n-        );\n-    }\n-\n-    dashes_out.clear();\n-    dashes_out.reserve(Ndash / 2);\n-\n-    double val0, val1;\n-    for (size_t i = 0; i < Ndash; i += 2)\n-    {\n-        val0 = double(Py::Float(dashSeq[i])) * dpi / 72.0;\n-        val1 = double(Py::Float(dashSeq[i+1])) * dpi / 72.0;\n-        dashes_out.push_back(std::make_pair(val0, val1));\n-    }\n-}\n-\n-\n-Py::Object\n-BufferRegion::to_string(const Py::Tuple &args)\n-{\n-    // owned=true to prevent memory leak\n-    #if PY3K\n-    return Py::Bytes\n-    #else\n-    return Py::String\n-    #endif\n-        (PyBytes_FromStringAndSize((const char*)data, height*stride), true);\n-}\n-\n-\n-Py::Object\n-BufferRegion::set_x(const Py::Tuple &args)\n-{\n-    args.verify_length(1);\n-    size_t x = (long) Py::Int(args[0]);\n-    rect.x1 = x;\n-    return Py::Object();\n-}\n-\n-\n-Py::Object\n-BufferRegion::set_y(const Py::Tuple &args)\n-{\n-    args.verify_length(1);\n-    size_t y = (long)Py::Int(args[0]);\n-    rect.y1 = y;\n-    return Py::Object();\n-}\n-\n-\n-Py::Object\n-BufferRegion::get_extents(const Py::Tuple &args)\n-{\n-    args.verify_length(0);\n-\n-    Py::Tuple extents(4);\n-    extents[0] = Py::Int(rect.x1);\n-    extents[1] = Py::Int(rect.y1);\n-    extents[2] = Py::Int(rect.x2);\n-    extents[3] = Py::Int(rect.y2);\n-\n-    return extents;\n-}\n-\n-\n-Py::Object\n-BufferRegion::to_string_argb(const Py::Tuple &args)\n+void BufferRegion::to_string_argb(uint8_t *buf)\n {\n-    // owned=true to prevent memory leak\n-    Py_ssize_t length;\n-    unsigned char* pix;\n-    unsigned char* begin;\n+    unsigned char *pix;\n     unsigned char tmp;\n     size_t i, j;\n \n-    PyObject* str = PyBytes_FromStringAndSize((const char*)data, height * stride);\n-    if (PyBytes_AsStringAndSize(str, (char**)&begin, &length))\n-    {\n-        throw Py::TypeError(\"Could not create memory for blit\");\n-    }\n+    memcpy(buf, data, height * stride);\n \n-    for (i = 0; i < (size_t)height; ++i)\n-    {\n-        pix = begin + i * stride;\n-        for (j = 0; j < (size_t)width; ++j)\n-        {\n+    for (i = 0; i < (size_t)height; ++i) {\n+        pix = buf + i * stride;\n+        for (j = 0; j < (size_t)width; ++j) {\n             // Convert rgba to argb\n             tmp = pix[2];\n             pix[2] = pix[0];\n             pix[0] = tmp;\n             pix += 4;\n         }\n     }\n-\n-    #if PY3K\n-    return Py::Bytes\n-    #else\n-    return Py::String\n-    #endif\n-        (str, true);\n-}\n-\n-\n-GCAgg::GCAgg(const Py::Object &gc, double dpi) :\n-        dpi(dpi), isaa(true), dashOffset(0.0)\n-{\n-    _VERBOSE(\"GCAgg::GCAgg\");\n-    linewidth = points_to_pixels(gc.getAttr(\"_linewidth\")) ;\n-    alpha = Py::Float(gc.getAttr(\"_alpha\"));\n-    forced_alpha = Py::Boolean(gc.getAttr(\"_forced_alpha\"));\n-    color = get_color(gc);\n-    _set_antialiased(gc);\n-    _set_linecap(gc);\n-    _set_joinstyle(gc);\n-    _set_dashes(gc);\n-    _set_clip_rectangle(gc);\n-    _set_clip_path(gc);\n-    _set_snap(gc);\n-    _set_hatch_path(gc);\n-    _set_sketch_params(gc);\n-}\n-\n-\n-void\n-GCAgg::_set_antialiased(const Py::Object& gc)\n-{\n-    _VERBOSE(\"GCAgg::antialiased\");\n-    isaa = Py::Boolean(gc.getAttr(\"_antialiased\"));\n-}\n-\n-\n-agg::rgba\n-GCAgg::get_color(const Py::Object& gc)\n-{\n-    _VERBOSE(\"GCAgg::get_color\");\n-    Py::Tuple rgb = Py::Tuple(gc.getAttr(\"_rgb\"));\n-\n-    double r = Py::Float(rgb[0]);\n-    double g = Py::Float(rgb[1]);\n-    double b = Py::Float(rgb[2]);\n-    double a = Py::Float(rgb[3]);\n-    return agg::rgba(r, g, b, a);\n-}\n-\n-\n-double\n-GCAgg::points_to_pixels(const Py::Object& points)\n-{\n-    _VERBOSE(\"GCAgg::points_to_pixels\");\n-    double p = Py::Float(points) ;\n-    return p * dpi / 72.0;\n-}\n-\n-\n-void\n-GCAgg::_set_linecap(const Py::Object& gc)\n-{\n-    _VERBOSE(\"GCAgg::_set_linecap\");\n-\n-    std::string capstyle = Py::String(gc.getAttr(\"_capstyle\")).encode(\"utf-8\");\n-\n-    if (capstyle == \"butt\")\n-    {\n-        cap = agg::butt_cap;\n-    }\n-    else if (capstyle == \"round\")\n-    {\n-        cap = agg::round_cap;\n-    }\n-    else if (capstyle == \"projecting\")\n-    {\n-        cap = agg::square_cap;\n-    }\n-    else\n-    {\n-        throw Py::ValueError(Printf(\"GC _capstyle attribute must be one of butt, round, projecting; found %s\", capstyle.c_str()).str());\n-    }\n-}\n-\n-\n-void\n-GCAgg::_set_joinstyle(const Py::Object& gc)\n-{\n-    _VERBOSE(\"GCAgg::_set_joinstyle\");\n-\n-    std::string joinstyle = Py::String(gc.getAttr(\"_joinstyle\")).encode(\"utf-8\");\n-\n-    if (joinstyle == \"miter\")\n-    {\n-        join = agg::miter_join_revert;\n-    }\n-    else if (joinstyle == \"round\")\n-    {\n-        join = agg::round_join;\n-    }\n-    else if (joinstyle == \"bevel\")\n-    {\n-        join = agg::bevel_join;\n-    }\n-    else\n-    {\n-        throw Py::ValueError(Printf(\"GC _joinstyle attribute must be one of butt, round, projecting; found %s\", joinstyle.c_str()).str());\n-    }\n-}\n-\n-\n-void\n-GCAgg::_set_dashes(const Py::Object& gc)\n-{\n-    //return the dashOffset, dashes sequence tuple.\n-    _VERBOSE(\"GCAgg::_set_dashes\");\n-\n-    Py::Object dash_obj(gc.getAttr(\"_dashes\"));\n-    if (dash_obj.ptr() == Py_None)\n-    {\n-        dashes.clear();\n-        return;\n-    }\n-\n-    convert_dashes(dash_obj, dpi, dashes, dashOffset);\n-}\n-\n-\n-void\n-GCAgg::_set_clip_rectangle(const Py::Object& gc)\n-{\n-    //set the clip rectangle from the gc\n-\n-    _VERBOSE(\"GCAgg::_set_clip_rectangle\");\n-\n-    Py::Object o(gc.getAttr(\"_cliprect\"));\n-    cliprect = o;\n-}\n-\n-\n-void\n-GCAgg::_set_clip_path(const Py::Object& gc)\n-{\n-    //set the clip path from the gc\n-\n-    _VERBOSE(\"GCAgg::_set_clip_path\");\n-\n-    Py::Object method_obj = gc.getAttr(\"get_clip_path\");\n-    Py::Callable method(method_obj);\n-    Py::Tuple path_and_transform = method.apply(Py::Tuple());\n-    if (path_and_transform[0].ptr() != Py_None)\n-    {\n-        clippath = path_and_transform[0];\n-        clippath_trans = py_to_agg_transformation_matrix(path_and_transform[1].ptr());\n-    }\n-}\n-\n-\n-void\n-GCAgg::_set_snap(const Py::Object& gc)\n-{\n-    //set the snap setting\n-\n-    _VERBOSE(\"GCAgg::_set_snap\");\n-\n-    Py::Object method_obj = gc.getAttr(\"get_snap\");\n-    Py::Callable method(method_obj);\n-    Py::Object py_snap = method.apply(Py::Tuple());\n-    if (py_snap.isNone())\n-    {\n-        snap_mode = SNAP_AUTO;\n-    }\n-    else if (py_snap.isTrue())\n-    {\n-        snap_mode = SNAP_TRUE;\n-    }\n-    else\n-    {\n-        snap_mode = SNAP_FALSE;\n-    }\n-}\n-\n-\n-void\n-GCAgg::_set_hatch_path(const Py::Object& gc)\n-{\n-    _VERBOSE(\"GCAgg::_set_hatch_path\");\n-\n-    Py::Object method_obj = gc.getAttr(\"get_hatch_path\");\n-    Py::Callable method(method_obj);\n-    hatchpath = method.apply(Py::Tuple());\n-    if (hatchpath.ptr() == NULL)\n-        throw Py::Exception();\n-}\n-\n-void\n-GCAgg::_set_sketch_params(const Py::Object& gc)\n-{\n-    _VERBOSE(\"GCAgg::_get_sketch_params\");\n-\n-    Py::Object method_obj = gc.getAttr(\"get_sketch_params\");\n-    Py::Callable method(method_obj);\n-    Py::Object result = method.apply(Py::Tuple());\n-    if (result.ptr() == Py_None) {\n-        sketch_scale = 0.0;\n-    } else {\n-        Py::Tuple sketch_params(result);\n-        sketch_scale = Py::Float(sketch_params[0]);\n-        sketch_length = Py::Float(sketch_params[1]);\n-        sketch_randomness = Py::Float(sketch_params[2]);\n-    }\n }\n \n-\n-const size_t\n-RendererAgg::PIXELS_PER_INCH(96);\n-\n-\n-RendererAgg::RendererAgg(unsigned int width, unsigned int height, double dpi,\n-                         int debug) :\n-    width(width),\n-    height(height),\n-    dpi(dpi),\n-    NUMBYTES(width*height*4),\n-    pixBuffer(NULL),\n-    renderingBuffer(),\n-    alphaBuffer(NULL),\n-    alphaMaskRenderingBuffer(),\n-    alphaMask(alphaMaskRenderingBuffer),\n-    pixfmtAlphaMask(alphaMaskRenderingBuffer),\n-    rendererBaseAlphaMask(),\n-    rendererAlphaMask(),\n-    scanlineAlphaMask(),\n-    slineP8(),\n-    slineBin(),\n-    pixFmt(),\n-    rendererBase(),\n-    rendererAA(),\n-    rendererBin(),\n-    theRasterizer(),\n-    debug(debug),\n-    _fill_color(agg::rgba(1, 1, 1, 0))\n-{\n-    _VERBOSE(\"RendererAgg::RendererAgg\");\n-    unsigned stride(width*4);\n+RendererAgg::RendererAgg(unsigned int width, unsigned int height, double dpi)\n+    : width(width),\n+      height(height),\n+      dpi(dpi),\n+      NUMBYTES(width * height * 4),\n+      pixBuffer(NULL),\n+      renderingBuffer(),\n+      alphaBuffer(NULL),\n+      alphaMaskRenderingBuffer(),\n+      alphaMask(alphaMaskRenderingBuffer),\n+      pixfmtAlphaMask(alphaMaskRenderingBuffer),\n+      rendererBaseAlphaMask(),\n+      rendererAlphaMask(),\n+      scanlineAlphaMask(),\n+      slineP8(),\n+      slineBin(),\n+      pixFmt(),\n+      rendererBase(),\n+      rendererAA(),\n+      rendererBin(),\n+      theRasterizer(),\n+      lastclippath(NULL),\n+      _fill_color(agg::rgba(1, 1, 1, 0))\n+{\n+    unsigned stride(width * 4);\n \n     pixBuffer = new agg::int8u[NUMBYTES];\n     renderingBuffer.attach(pixBuffer, width, height, stride);\n@@ -433,2201 +62,169 @@ RendererAgg::RendererAgg(unsigned int width, unsigned int height, double dpi,\n     rendererBase.clear(_fill_color);\n     rendererAA.attach(rendererBase);\n     rendererBin.attach(rendererBase);\n-    hatchRenderingBuffer.attach(hatchBuffer, HATCH_SIZE, HATCH_SIZE,\n-                                HATCH_SIZE*4);\n+    hatchRenderingBuffer.attach(hatchBuffer, HATCH_SIZE, HATCH_SIZE, HATCH_SIZE * 4);\n }\n \n+RendererAgg::~RendererAgg()\n+{\n+    delete[] alphaBuffer;\n+    delete[] pixBuffer;\n+}\n \n-void\n-RendererAgg::create_alpha_buffers()\n+void RendererAgg::create_alpha_buffers()\n {\n-    if (!alphaBuffer)\n-    {\n+    if (!alphaBuffer) {\n         alphaBuffer = new agg::int8u[width * height];\n         alphaMaskRenderingBuffer.attach(alphaBuffer, width, height, width);\n         rendererBaseAlphaMask.attach(pixfmtAlphaMask);\n         rendererAlphaMask.attach(rendererBaseAlphaMask);\n     }\n }\n \n-\n-template<class R>\n-void\n-RendererAgg::set_clipbox(const Py::Object& cliprect, R& rasterizer)\n-{\n-    //set the clip rectangle from the gc\n-\n-    _VERBOSE(\"RendererAgg::set_clipbox\");\n-\n-    double l, b, r, t;\n-    if (py_convert_bbox(cliprect.ptr(), l, b, r, t))\n-    {\n-        rasterizer.clip_box(std::max(int(floor(l + 0.5)), 0),\n-                            std::max(int(floor(height - b + 0.5)), 0),\n-                            std::min(int(floor(r + 0.5)), int(width)),\n-                            std::min(int(floor(height - t + 0.5)), int(height)));\n-    }\n-    else\n-    {\n-        rasterizer.clip_box(0, 0, width, height);\n-    }\n-\n-    _VERBOSE(\"RendererAgg::set_clipbox done\");\n-}\n-\n-\n-std::pair<bool, agg::rgba>\n-RendererAgg::_get_rgba_face(const Py::Object& rgbFace, double alpha, bool forced_alpha)\n-{\n-    _VERBOSE(\"RendererAgg::_get_rgba_face\");\n-    std::pair<bool, agg::rgba> face;\n-\n-    if (rgbFace.ptr() == Py_None)\n-    {\n-        face.first = false;\n-    }\n-    else\n-    {\n-        face.first = true;\n-        Py::Tuple rgb = Py::Tuple(rgbFace);\n-        if (forced_alpha || rgb.length() < 4)\n-        {\n-            face.second = rgb_to_color(rgb, alpha);\n-        }\n-        else\n-        {\n-            face.second = rgb_to_color(rgb, Py::Float(rgb[3]));\n-        }\n-    }\n-    return face;\n-}\n-\n-\n-Py::Object\n-RendererAgg::copy_from_bbox(const Py::Tuple& args)\n+BufferRegion *RendererAgg::copy_from_bbox(agg::rect_d in_rect)\n {\n-    //copy region in bbox to buffer and return swig/agg buffer object\n-    args.verify_length(1);\n-\n-    Py::Object box_obj = args[0];\n-    double l, b, r, t;\n-    if (!py_convert_bbox(box_obj.ptr(), l, b, r, t))\n-    {\n-        throw Py::TypeError(\"Invalid bbox provided to copy_from_bbox\");\n-    }\n-\n-    agg::rect_i rect((int)l, height - (int)t, (int)r, height - (int)b);\n+    agg::rect_i rect(\n+        (int)in_rect.x1, height - (int)in_rect.y2, (int)in_rect.x2, height - (int)in_rect.y1);\n \n-    BufferRegion* reg = NULL;\n-    try\n-    {\n-        reg = new BufferRegion(rect, true);\n-    }\n-    catch (...)\n-    {\n-        throw Py::MemoryError(\n-            \"RendererAgg::copy_from_bbox could not allocate memory for buffer\");\n-    }\n+    BufferRegion *reg = NULL;\n+    reg = new BufferRegion(rect);\n \n-    if (!reg)\n-    {\n-        throw Py::MemoryError(\n-            \"RendererAgg::copy_from_bbox could not allocate memory for buffer\");\n-    }\n+    agg::rendering_buffer rbuf;\n+    rbuf.attach(reg->get_data(), reg->get_width(), reg->get_height(), reg->get_stride());\n \n-    try\n-    {\n-        agg::rendering_buffer rbuf;\n-        rbuf.attach(reg->data, reg->width, reg->height, reg->stride);\n+    pixfmt pf(rbuf);\n+    renderer_base rb(pf);\n+    rb.copy_from(renderingBuffer, &rect, -rect.x1, -rect.y1);\n \n-        pixfmt pf(rbuf);\n-        renderer_base rb(pf);\n-        rb.copy_from(renderingBuffer, &rect, -rect.x1, -rect.y1);\n-    }\n-    catch (...)\n-    {\n-        delete reg;\n-        throw Py::RuntimeError(\"An unknown error occurred in copy_from_bbox\");\n-    }\n-    return Py::asObject(reg);\n+    return reg;\n }\n \n-\n-Py::Object\n-RendererAgg::restore_region(const Py::Tuple& args)\n+void RendererAgg::restore_region(BufferRegion &region)\n {\n-    //copy BufferRegion to buffer\n-    args.verify_length(1);\n-    BufferRegion* region  = static_cast<BufferRegion*>(args[0].ptr());\n-\n-    if (region->data == NULL)\n-    {\n-        throw Py::ValueError(\"Cannot restore_region from NULL data\");\n+    if (region.get_data() == NULL) {\n+        throw \"Cannot restore_region from NULL data\";\n     }\n \n     agg::rendering_buffer rbuf;\n-    rbuf.attach(region->data,\n-                region->width,\n-                region->height,\n-                region->stride);\n+    rbuf.attach(region.get_data(), region.get_width(), region.get_height(), region.get_stride());\n \n-    rendererBase.copy_from(rbuf, 0, region->rect.x1, region->rect.y1);\n-\n-    return Py::Object();\n+    rendererBase.copy_from(rbuf, 0, region.get_rect().x1, region.get_rect().y1);\n }\n \n-\n // Restore the part of the saved region with offsets\n-Py::Object\n-RendererAgg::restore_region2(const Py::Tuple& args)\n+void\n+RendererAgg::restore_region(BufferRegion &region, int x, int y, int xx1, int yy1, int xx2, int yy2)\n {\n-    //copy BufferRegion to buffer\n-    args.verify_length(7);\n-\n-    int x(0), y(0), xx1(0), yy1(0), xx2(0), yy2(0);\n-    try\n-    {\n-        xx1 = Py::Int(args[1]);\n-        yy1 = Py::Int(args[2]);\n-        xx2 = Py::Int(args[3]);\n-        yy2 = Py::Int(args[4]);\n-        x = Py::Int(args[5]);\n-        y = Py::Int(args[6]);\n+    if (region.get_data() == NULL) {\n+        throw \"Cannot restore_region from NULL data\";\n     }\n-    catch (Py::TypeError)\n-    {\n-        throw Py::TypeError(\"Invalid input arguments to restore_region2\");\n-    }\n-\n \n-    BufferRegion* region  = static_cast<BufferRegion*>(args[0].ptr());\n+    agg::rect_i &rrect = region.get_rect();\n \n-    if (region->data == NULL)\n-    {\n-        throw Py::ValueError(\"Cannot restore_region from NULL data\");\n-    }\n-\n-    agg::rect_i rect(xx1 - region->rect.x1, (yy1 - region->rect.y1),\n-                     xx2 - region->rect.x1, (yy2 - region->rect.y1));\n+    agg::rect_i rect(xx1 - rrect.x1, (yy1 - rrect.y1), xx2 - rrect.x1, (yy2 - rrect.y1));\n \n     agg::rendering_buffer rbuf;\n-    rbuf.attach(region->data,\n-                region->width,\n-                region->height,\n-                region->stride);\n+    rbuf.attach(region.get_data(), region.get_width(), region.get_height(), region.get_stride());\n \n     rendererBase.copy_from(rbuf, &rect, x, y);\n-\n-    return Py::Object();\n }\n \n-\n-bool\n-RendererAgg::render_clippath(const Py::Object& clippath,\n-                             const agg::trans_affine& clippath_trans)\n+bool RendererAgg::render_clippath(py::PathIterator &clippath,\n+                                  const agg::trans_affine &clippath_trans)\n {\n-    typedef agg::conv_transform<PathIterator> transformed_path_t;\n+    typedef agg::conv_transform<py::PathIterator> transformed_path_t;\n     typedef agg::conv_curve<transformed_path_t> curve_t;\n \n-    bool has_clippath = (clippath.ptr() != Py_None);\n+    bool has_clippath = (clippath.total_vertices() != 0);\n \n     if (has_clippath &&\n-        (clippath.ptr() != lastclippath.ptr() ||\n-         clippath_trans != lastclippath_transform))\n-    {\n+        (clippath.get_id() != lastclippath || clippath_trans != lastclippath_transform)) {\n         create_alpha_buffers();\n         agg::trans_affine trans(clippath_trans);\n         trans *= agg::trans_affine_scaling(1.0, -1.0);\n         trans *= agg::trans_affine_translation(0.0, (double)height);\n \n-        PathIterator clippath_iter(clippath);\n         rendererBaseAlphaMask.clear(agg::gray8(0, 0));\n-        transformed_path_t transformed_clippath(clippath_iter, trans);\n+        transformed_path_t transformed_clippath(clippath, trans);\n         curve_t curved_clippath(transformed_clippath);\n-        try {\n-            theRasterizer.add_path(curved_clippath);\n-        } catch (std::overflow_error &e) {\n-            throw Py::OverflowError(e.what());\n-        }\n+        theRasterizer.add_path(curved_clippath);\n         rendererAlphaMask.color(agg::gray8(255, 255));\n         agg::render_scanlines(theRasterizer, scanlineAlphaMask, rendererAlphaMask);\n-        lastclippath = clippath;\n+        lastclippath = clippath.get_id();\n         lastclippath_transform = clippath_trans;\n     }\n \n     return has_clippath;\n }\n \n-#define MARKER_CACHE_SIZE 512\n-\n-\n-Py::Object\n-RendererAgg::draw_markers(const Py::Tuple& args)\n+void RendererAgg::tostring_rgb(uint8_t *buf)\n {\n-    typedef agg::conv_transform<PathIterator>                  transformed_path_t;\n-    typedef PathSnapper<transformed_path_t>                    snap_t;\n-    typedef agg::conv_curve<snap_t>                            curve_t;\n-    typedef agg::conv_stroke<curve_t>                          stroke_t;\n-    typedef agg::pixfmt_amask_adaptor<pixfmt, alpha_mask_type> pixfmt_amask_type;\n-    typedef agg::renderer_base<pixfmt_amask_type>              amask_ren_type;\n-    typedef agg::renderer_scanline_aa_solid<amask_ren_type>    amask_aa_renderer_type;\n-    args.verify_length(5, 6);\n-\n-    Py::Object        gc_obj          = args[0];\n-    Py::Object        marker_path_obj = args[1];\n-    agg::trans_affine marker_trans    = py_to_agg_transformation_matrix(args[2].ptr());\n-    Py::Object        path_obj        = args[3];\n-    agg::trans_affine trans           = py_to_agg_transformation_matrix(args[4].ptr());\n-    Py::Object        face_obj;\n-    if (args.size() == 6)\n-    {\n-        face_obj = args[5];\n-    }\n-\n-    GCAgg gc(gc_obj, dpi);\n-\n-    // Deal with the difference in y-axis direction\n-    marker_trans *= agg::trans_affine_scaling(1.0, -1.0);\n-    trans *= agg::trans_affine_scaling(1.0, -1.0);\n-    trans *= agg::trans_affine_translation(0.5, (double)height + 0.5);\n-\n-    PathIterator       marker_path(marker_path_obj);\n-    transformed_path_t marker_path_transformed(marker_path, marker_trans);\n-    snap_t             marker_path_snapped(marker_path_transformed,\n-                                           gc.snap_mode,\n-                                           marker_path.total_vertices(),\n-                                           gc.linewidth);\n-    curve_t            marker_path_curve(marker_path_snapped);\n-\n-    PathIterator path(path_obj);\n-    transformed_path_t path_transformed(path, trans);\n-    snap_t             path_snapped(path_transformed,\n-                                    SNAP_FALSE,\n-                                    path.total_vertices(),\n-                                    0.0);\n-    curve_t            path_curve(path_snapped);\n-    path_curve.rewind(0);\n-\n-    facepair_t face = _get_rgba_face(face_obj, gc.alpha, gc.forced_alpha);\n-\n-    //maxim's suggestions for cached scanlines\n-    agg::scanline_storage_aa8 scanlines;\n-    theRasterizer.reset();\n-    theRasterizer.reset_clipping();\n-    rendererBase.reset_clipping(true);\n-\n-    agg::int8u  staticFillCache[MARKER_CACHE_SIZE];\n-    agg::int8u  staticStrokeCache[MARKER_CACHE_SIZE];\n-    agg::int8u* fillCache = staticFillCache;\n-    agg::int8u* strokeCache = staticStrokeCache;\n-\n-    try\n-    {\n-        unsigned fillSize = 0;\n-        if (face.first)\n-        {\n-            try {\n-                theRasterizer.add_path(marker_path_curve);\n-            } catch (std::overflow_error &e) {\n-                throw Py::OverflowError(e.what());\n-            }\n-            agg::render_scanlines(theRasterizer, slineP8, scanlines);\n-            fillSize = scanlines.byte_size();\n-            if (fillSize >= MARKER_CACHE_SIZE)\n-            {\n-                fillCache = new agg::int8u[fillSize];\n-            }\n-            scanlines.serialize(fillCache);\n-        }\n+    // \"Return the rendered buffer as an RGB string\"\n \n-        stroke_t stroke(marker_path_curve);\n-        stroke.width(gc.linewidth);\n-        stroke.line_cap(gc.cap);\n-        stroke.line_join(gc.join);\n-        theRasterizer.reset();\n-        try {\n-            theRasterizer.add_path(stroke);\n-        } catch (std::overflow_error &e) {\n-            throw Py::OverflowError(e.what());\n-        }\n-        agg::render_scanlines(theRasterizer, slineP8, scanlines);\n-        unsigned strokeSize = scanlines.byte_size();\n-        if (strokeSize >= MARKER_CACHE_SIZE)\n-        {\n-            strokeCache = new agg::int8u[strokeSize];\n-        }\n-        scanlines.serialize(strokeCache);\n-\n-        theRasterizer.reset_clipping();\n-        rendererBase.reset_clipping(true);\n-        set_clipbox(gc.cliprect, rendererBase);\n-        bool has_clippath = render_clippath(gc.clippath, gc.clippath_trans);\n-\n-        double x, y;\n-\n-        agg::serialized_scanlines_adaptor_aa8 sa;\n-        agg::serialized_scanlines_adaptor_aa8::embedded_scanline sl;\n-\n-        agg::rect_d clipping_rect(\n-            -1.0 - scanlines.max_x(),\n-            -1.0 - scanlines.max_y(),\n-            1.0 + width - scanlines.min_x(),\n-            1.0 + height - scanlines.min_y());\n-\n-        if (has_clippath)\n-        {\n-            while (path_curve.vertex(&x, &y) != agg::path_cmd_stop)\n-            {\n-                if (MPL_notisfinite64(x) || MPL_notisfinite64(y))\n-                {\n-                    continue;\n-                }\n-\n-                /* These values are correctly snapped above -- so we don't want\n-                   to round here, we really only want to truncate */\n-                x = floor(x);\n-                y = floor(y);\n-\n-                // Cull points outside the boundary of the image.\n-                // Values that are too large may overflow and create\n-                // segfaults.\n-                // http://sourceforge.net/tracker/?func=detail&aid=2865490&group_id=80706&atid=560720\n-                if (!clipping_rect.hit_test(x, y))\n-                {\n-                    continue;\n-                }\n-\n-                pixfmt_amask_type pfa(pixFmt, alphaMask);\n-                amask_ren_type r(pfa);\n-                amask_aa_renderer_type ren(r);\n-\n-                if (face.first)\n-                {\n-                    ren.color(face.second);\n-                    sa.init(fillCache, fillSize, x, y);\n-                    agg::render_scanlines(sa, sl, ren);\n-                }\n-                ren.color(gc.color);\n-                sa.init(strokeCache, strokeSize, x, y);\n-                agg::render_scanlines(sa, sl, ren);\n-            }\n-        }\n-        else\n-        {\n-            while (path_curve.vertex(&x, &y) != agg::path_cmd_stop)\n-            {\n-                if (MPL_notisfinite64(x) || MPL_notisfinite64(y))\n-                {\n-                    continue;\n-                }\n-\n-                /* These values are correctly snapped above -- so we don't want\n-                   to round here, we really only want to truncate */\n-                x = floor(x);\n-                y = floor(y);\n-\n-                // Cull points outside the boundary of the image.\n-                // Values that are too large may overflow and create\n-                // segfaults.\n-                // http://sourceforge.net/tracker/?func=detail&aid=2865490&group_id=80706&atid=560720\n-                if (!clipping_rect.hit_test(x, y))\n-                {\n-                    continue;\n-                }\n-\n-                if (face.first)\n-                {\n-                    rendererAA.color(face.second);\n-                    sa.init(fillCache, fillSize, x, y);\n-                    agg::render_scanlines(sa, sl, rendererAA);\n-                }\n-\n-                rendererAA.color(gc.color);\n-                sa.init(strokeCache, strokeSize, x, y);\n-                agg::render_scanlines(sa, sl, rendererAA);\n-            }\n-        }\n-    }\n-    catch (...)\n-    {\n-        if (fillCache != staticFillCache)\n-            delete[] fillCache;\n-        if (strokeCache != staticStrokeCache)\n-            delete[] strokeCache;\n-        theRasterizer.reset_clipping();\n-        rendererBase.reset_clipping(true);\n-        throw;\n-    }\n-\n-    if (fillCache != staticFillCache)\n-        delete[] fillCache;\n-    if (strokeCache != staticStrokeCache)\n-        delete[] strokeCache;\n+    int row_len = width * 3;\n \n-    theRasterizer.reset_clipping();\n-    rendererBase.reset_clipping(true);\n+    agg::rendering_buffer renderingBufferTmp;\n+    renderingBufferTmp.attach(buf, width, height, row_len);\n \n-    return Py::Object();\n+    agg::color_conv(&renderingBufferTmp, &renderingBuffer, agg::color_conv_rgba32_to_rgb24());\n }\n \n-\n-/**\n- * This is a custom span generator that converts spans in the\n- * 8-bit inverted greyscale font buffer to rgba that agg can use.\n- */\n-template<class ChildGenerator>\n-class font_to_rgba\n+void RendererAgg::tostring_argb(uint8_t *buf)\n {\n-public:\n-    typedef ChildGenerator child_type;\n-    typedef agg::rgba8 color_type;\n-    typedef typename child_type::color_type child_color_type;\n-    typedef agg::span_allocator<child_color_type> span_alloc_type;\n-\n-private:\n-    child_type* _gen;\n-    color_type _color;\n-    span_alloc_type _allocator;\n+    //\"Return the rendered buffer as an RGB string\";\n \n-public:\n-    font_to_rgba(child_type* gen, color_type color) :\n-        _gen(gen),\n-        _color(color)\n-    {\n+    int row_len = width * 4;\n \n-    }\n+    agg::rendering_buffer renderingBufferTmp;\n+    renderingBufferTmp.attach(buf, width, height, row_len);\n+    agg::color_conv(&renderingBufferTmp, &renderingBuffer, agg::color_conv_rgba32_to_argb32());\n+}\n \n-    inline void\n-    generate(color_type* output_span, int x, int y, unsigned len)\n-    {\n-        _allocator.allocate(len);\n-        child_color_type* input_span = _allocator.span();\n-        _gen->generate(input_span, x, y, len);\n+void RendererAgg::tostring_bgra(uint8_t *buf)\n+{\n+    //\"Return the rendered buffer as an RGB string\";\n \n-        do\n-        {\n-            *output_span = _color;\n-            output_span->a = ((unsigned int)_color.a *\n-                              (unsigned int)input_span->v) >> 8;\n-            ++output_span;\n-            ++input_span;\n-        }\n-        while (--len);\n-    }\n+    int row_len = width * 4;\n \n-    void\n-    prepare()\n-    {\n-        _gen->prepare();\n-    }\n-};\n+    agg::rendering_buffer renderingBufferTmp;\n+    renderingBufferTmp.attach(buf, width, height, row_len);\n \n+    agg::color_conv(&renderingBufferTmp, &renderingBuffer, agg::color_conv_rgba32_to_bgra32());\n+}\n \n-// MGDTODO: Support clip paths\n-Py::Object\n-RendererAgg::draw_text_image(const Py::Tuple& args)\n+agg::rect_i RendererAgg::get_content_extents()\n {\n-    _VERBOSE(\"RendererAgg::draw_text\");\n-\n-    typedef agg::span_allocator<agg::rgba8> color_span_alloc_type;\n-    typedef agg::span_interpolator_linear<> interpolator_type;\n-    typedef agg::image_accessor_clip<agg::pixfmt_gray8> image_accessor_type;\n-    typedef agg::span_image_filter_gray<image_accessor_type,\n-                                        interpolator_type> image_span_gen_type;\n-    typedef font_to_rgba<image_span_gen_type> span_gen_type;\n-    typedef agg::renderer_scanline_aa<renderer_base, color_span_alloc_type,\n-                                      span_gen_type> renderer_type;\n-\n-    args.verify_length(5);\n-\n-    const unsigned char* buffer = NULL;\n-    int width, height;\n-    Py::Object image_obj = args[0];\n+    agg::rect_i r(width, height, 0, 0);\n \n-    if (PyArray_Check(image_obj.ptr()))\n-    {\n-        PyObject* image_array = PyArray_FromObject(\n-            image_obj.ptr(), NPY_UBYTE, 2, 2);\n-        if (!image_array)\n-        {\n-            throw Py::ValueError(\n-                \"First argument to draw_text_image must be a FT2Font.Image object or a Nx2 uint8 numpy array.\");\n-        }\n-        image_obj = Py::Object(image_array, true);\n-        buffer = (unsigned char *)PyArray_DATA((PyArrayObject*)image_array);\n-        width = PyArray_DIM((PyArrayObject*)image_array, 1);\n-        height = PyArray_DIM((PyArrayObject*)image_array, 0);\n-    }\n-    else\n-    {\n-        FT2Image* image = static_cast<FT2Image *>(\n-            Py::getPythonExtensionBase(image_obj.ptr()));\n-        if (!image->get_buffer())\n-        {\n-            throw Py::ValueError(\n-                \"First argument to draw_text_image must be a FT2Font.Image object or a Nx2 uint8 numpy array.\");\n+    // Looks at the alpha channel to find the minimum extents of the image\n+    unsigned char *pixel = pixBuffer + 3;\n+    for (int y = 0; y < (int)height; ++y) {\n+        for (int x = 0; x < (int)width; ++x) {\n+            if (*pixel) {\n+                if (x < r.x1)\n+                    r.x1 = x;\n+                if (y < r.y1)\n+                    r.y1 = y;\n+                if (x > r.x2)\n+                    r.x2 = x;\n+                if (y > r.y2)\n+                    r.y2 = y;\n+            }\n+            pixel += 4;\n         }\n-        buffer = image->get_buffer();\n-        width = image->get_width();\n-        height = image->get_height();\n-    }\n-\n-    int x(0), y(0);\n-    try\n-    {\n-        x = Py::Int(args[1]);\n-        y = Py::Int(args[2]);\n-    }\n-    catch (Py::TypeError)\n-    {\n-        throw Py::TypeError(\"Invalid input arguments to draw_text_image\");\n     }\n \n-    double angle = Py::Float(args[3]);\n+    r.x1 = std::max(0, r.x1 - 1);\n+    r.y1 = std::max(0, r.y1 - 1);\n+    r.x2 = std::max(r.x2 + 1, (int)width);\n+    r.y2 = std::max(r.y2 + 1, (int)height);\n \n-    GCAgg gc(args[4], dpi);\n-\n-    theRasterizer.reset_clipping();\n-    rendererBase.reset_clipping(true);\n-    set_clipbox(gc.cliprect, theRasterizer);\n-\n-    agg::rendering_buffer srcbuf((agg::int8u*)buffer, width, height, width);\n-    agg::pixfmt_gray8 pixf_img(srcbuf);\n-\n-    agg::trans_affine mtx;\n-    mtx *= agg::trans_affine_translation(0, -height);\n-    mtx *= agg::trans_affine_rotation(-angle * agg::pi / 180.0);\n-    mtx *= agg::trans_affine_translation(x, y);\n-\n-    agg::path_storage rect;\n-    rect.move_to(0, 0);\n-    rect.line_to(width, 0);\n-    rect.line_to(width, height);\n-    rect.line_to(0, height);\n-    rect.line_to(0, 0);\n-    agg::conv_transform<agg::path_storage> rect2(rect, mtx);\n-\n-    agg::trans_affine inv_mtx(mtx);\n-    inv_mtx.invert();\n-\n-    agg::image_filter_lut filter;\n-    filter.calculate(agg::image_filter_spline36());\n-    interpolator_type interpolator(inv_mtx);\n-    color_span_alloc_type sa;\n-    image_accessor_type ia(pixf_img, 0);\n-    image_span_gen_type image_span_generator(ia, interpolator, filter);\n-    span_gen_type output_span_generator(&image_span_generator, gc.color);\n-    renderer_type ri(rendererBase, sa, output_span_generator);\n-\n-    try {\n-        theRasterizer.add_path(rect2);\n-    } catch (std::overflow_error &e) {\n-        throw Py::OverflowError(e.what());\n-    }\n-    agg::render_scanlines(theRasterizer, slineP8, ri);\n-\n-    return Py::Object();\n+    return r;\n }\n \n-class span_conv_alpha\n+void RendererAgg::clear()\n {\n-public:\n-    typedef agg::rgba8 color_type;\n-\n-    double m_alpha;\n-\n-    span_conv_alpha(double alpha) :\n-        m_alpha(alpha)\n-    {\n-    }\n-\n-    void prepare() {}\n-    void generate(color_type* span, int x, int y, unsigned len) const\n-    {\n-        do\n-            {\n-                span->a = (agg::int8u)((double)span->a * m_alpha);\n-                ++span;\n-            }\n-        while(--len);\n-    }\n-};\n+    //\"clear the rendered buffer\";\n \n-\n-Py::Object\n-RendererAgg::draw_image(const Py::Tuple& args)\n-{\n-    _VERBOSE(\"RendererAgg::draw_image\");\n-\n-    args.verify_length(4, 7); // 7 if affine matrix if given\n-\n-    GCAgg gc(args[0], dpi);\n-    Image *image = static_cast<Image*>(args[3].ptr());\n-    bool has_clippath = false;\n-    agg::trans_affine affine_trans;\n-    bool has_affine = false;\n-    double x, y, w, h;\n-    double alpha;\n-\n-    if (args.size() == 7)\n-    {\n-        has_affine = true;\n-        x = Py::Float(args[1]);\n-        y = Py::Float(args[2]);\n-        w = Py::Float(args[4]);\n-        h = Py::Float(args[5]);\n-        affine_trans = py_to_agg_transformation_matrix(args[6].ptr());\n-    }\n-    else\n-    {\n-        x = mpl_round(Py::Float(args[1]));\n-        y = mpl_round(Py::Float(args[2]));\n-        w = h = 0; /* w and h not used in this case, but assign to prevent\n-                  warnings from the compiler */\n-    }\n-\n-    alpha = gc.alpha;\n-\n-    theRasterizer.reset_clipping();\n-    rendererBase.reset_clipping(true);\n-    set_clipbox(gc.cliprect, theRasterizer);\n-    has_clippath = render_clippath(gc.clippath, gc.clippath_trans);\n-\n-    Py::Tuple empty;\n-    image->flipud_out(empty);\n-    pixfmt pixf(*(image->rbufOut));\n-\n-    if (has_affine | has_clippath)\n-    {\n-        agg::trans_affine mtx;\n-        agg::path_storage rect;\n-\n-        if (has_affine)\n-        {\n-            mtx *= agg::trans_affine_scaling(1, -1);\n-            mtx *= agg::trans_affine_translation(0, image->rowsOut);\n-            mtx *= agg::trans_affine_scaling(w / (image->colsOut),\n-                                             h / (image->rowsOut));\n-            mtx *= agg::trans_affine_translation(x, y);\n-            mtx *= affine_trans;\n-            mtx *= agg::trans_affine_scaling(1.0, -1.0);\n-            mtx *= agg::trans_affine_translation(0.0, (double) height);\n-        }\n-        else\n-        {\n-            mtx *= agg::trans_affine_translation(\n-                (int)x,\n-                (int)(height - (y + image->rowsOut)));\n-        }\n-\n-        rect.move_to(0, 0);\n-        rect.line_to(image->colsOut, 0);\n-        rect.line_to(image->colsOut, image->rowsOut);\n-        rect.line_to(0, image->rowsOut);\n-        rect.line_to(0, 0);\n-\n-        agg::conv_transform<agg::path_storage> rect2(rect, mtx);\n-\n-        agg::trans_affine inv_mtx(mtx);\n-        inv_mtx.invert();\n-\n-        typedef agg::span_allocator<agg::rgba8> color_span_alloc_type;\n-        typedef agg::image_accessor_clip<agg::pixfmt_rgba32_plain>\n-            image_accessor_type;\n-        typedef agg::span_interpolator_linear<> interpolator_type;\n-        typedef agg::span_image_filter_rgba_nn<image_accessor_type,\n-                                               interpolator_type> image_span_gen_type;\n-        typedef agg::span_converter<image_span_gen_type, span_conv_alpha> span_conv;\n-\n-        color_span_alloc_type sa;\n-        image_accessor_type ia(pixf, agg::rgba8(0, 0, 0, 0));\n-        interpolator_type interpolator(inv_mtx);\n-        image_span_gen_type image_span_generator(ia, interpolator);\n-        span_conv_alpha conv_alpha(alpha);\n-        span_conv spans(image_span_generator, conv_alpha);\n-\n-        if (has_clippath)\n-        {\n-            typedef agg::pixfmt_amask_adaptor<pixfmt, alpha_mask_type>\n-                pixfmt_amask_type;\n-            typedef agg::renderer_base<pixfmt_amask_type> amask_ren_type;\n-            typedef agg::renderer_scanline_aa<amask_ren_type,\n-                                              color_span_alloc_type,\n-                                              span_conv>\n-                renderer_type_alpha;\n-\n-            pixfmt_amask_type pfa(pixFmt, alphaMask);\n-            amask_ren_type r(pfa);\n-            renderer_type_alpha ri(r, sa, spans);\n-\n-            try {\n-                theRasterizer.add_path(rect2);\n-            } catch (std::overflow_error &e) {\n-                throw Py::OverflowError(e.what());\n-            }\n-            agg::render_scanlines(theRasterizer, scanlineAlphaMask, ri);\n-        }\n-        else\n-        {\n-            typedef agg::renderer_base<pixfmt> ren_type;\n-            typedef agg::renderer_scanline_aa<ren_type,\n-                                              color_span_alloc_type,\n-                                              span_conv>\n-                renderer_type;\n-\n-            ren_type r(pixFmt);\n-            renderer_type ri(r, sa, spans);\n-\n-            try {\n-                theRasterizer.add_path(rect2);\n-            } catch (std::overflow_error &e) {\n-                throw Py::OverflowError(e.what());\n-            }\n-            agg::render_scanlines(theRasterizer, slineP8, ri);\n-        }\n-\n-    }\n-    else\n-    {\n-        set_clipbox(gc.cliprect, rendererBase);\n-        rendererBase.blend_from(\n-            pixf, 0, (int)x, (int)(height - (y + image->rowsOut)),\n-            (agg::int8u)(alpha * 255));\n-    }\n-\n-    rendererBase.reset_clipping(true);\n-    image->flipud_out(empty);\n-\n-    return Py::Object();\n-}\n-\n-\n-template<class path_t>\n-void RendererAgg::_draw_path(path_t& path, bool has_clippath,\n-                             const facepair_t& face, const GCAgg& gc)\n-{\n-    typedef agg::conv_stroke<path_t>                           stroke_t;\n-    typedef agg::conv_dash<path_t>                             dash_t;\n-    typedef agg::conv_stroke<dash_t>                           stroke_dash_t;\n-    typedef agg::pixfmt_amask_adaptor<pixfmt, alpha_mask_type> pixfmt_amask_type;\n-    typedef agg::renderer_base<pixfmt_amask_type>              amask_ren_type;\n-    typedef agg::renderer_scanline_aa_solid<amask_ren_type>    amask_aa_renderer_type;\n-    typedef agg::renderer_scanline_bin_solid<amask_ren_type>   amask_bin_renderer_type;\n-\n-    // Render face\n-    if (face.first)\n-    {\n-        try {\n-            theRasterizer.add_path(path);\n-        } catch (std::overflow_error &e) {\n-            throw Py::OverflowError(e.what());\n-        }\n-\n-        if (gc.isaa)\n-        {\n-            if (has_clippath)\n-            {\n-                pixfmt_amask_type pfa(pixFmt, alphaMask);\n-                amask_ren_type r(pfa);\n-                amask_aa_renderer_type ren(r);\n-                ren.color(face.second);\n-                agg::render_scanlines(theRasterizer, scanlineAlphaMask, ren);\n-            }\n-            else\n-            {\n-                rendererAA.color(face.second);\n-                agg::render_scanlines(theRasterizer, slineP8, rendererAA);\n-            }\n-        }\n-        else\n-        {\n-            if (has_clippath)\n-            {\n-                pixfmt_amask_type pfa(pixFmt, alphaMask);\n-                amask_ren_type r(pfa);\n-                amask_bin_renderer_type ren(r);\n-                ren.color(face.second);\n-                agg::render_scanlines(theRasterizer, scanlineAlphaMask, ren);\n-            }\n-            else\n-            {\n-                rendererBin.color(face.second);\n-                agg::render_scanlines(theRasterizer, slineP8, rendererBin);\n-            }\n-        }\n-    }\n-\n-    // Render hatch\n-    if (!gc.hatchpath.isNone())\n-    {\n-        // Reset any clipping that may be in effect, since we'll be\n-        // drawing the hatch in a scratch buffer at origin (0, 0)\n-        theRasterizer.reset_clipping();\n-        rendererBase.reset_clipping(true);\n-\n-        // Create and transform the path\n-        typedef agg::conv_transform<PathIterator> hatch_path_trans_t;\n-        typedef agg::conv_curve<hatch_path_trans_t> hatch_path_curve_t;\n-        typedef agg::conv_stroke<hatch_path_curve_t> hatch_path_stroke_t;\n-\n-        PathIterator hatch_path(gc.hatchpath);\n-        agg::trans_affine hatch_trans;\n-        hatch_trans *= agg::trans_affine_scaling(1.0, -1.0);\n-        hatch_trans *= agg::trans_affine_translation(0.0, 1.0);\n-        hatch_trans *= agg::trans_affine_scaling(HATCH_SIZE, HATCH_SIZE);\n-        hatch_path_trans_t hatch_path_trans(hatch_path, hatch_trans);\n-        hatch_path_curve_t hatch_path_curve(hatch_path_trans);\n-        hatch_path_stroke_t hatch_path_stroke(hatch_path_curve);\n-        hatch_path_stroke.width(1.0);\n-        hatch_path_stroke.line_cap(agg::square_cap);\n-\n-        // Render the path into the hatch buffer\n-        pixfmt hatch_img_pixf(hatchRenderingBuffer);\n-        renderer_base rb(hatch_img_pixf);\n-        renderer_aa rs(rb);\n-        rb.clear(_fill_color);\n-        rs.color(gc.color);\n-\n-        try {\n-            theRasterizer.add_path(hatch_path_curve);\n-        } catch (std::overflow_error &e) {\n-            throw Py::OverflowError(e.what());\n-        }\n-        agg::render_scanlines(theRasterizer, slineP8, rs);\n-        try {\n-            theRasterizer.add_path(hatch_path_stroke);\n-        } catch (std::overflow_error &e) {\n-            throw Py::OverflowError(e.what());\n-        }\n-        agg::render_scanlines(theRasterizer, slineP8, rs);\n-\n-        // Put clipping back on, if originally set on entry to this\n-        // function\n-        set_clipbox(gc.cliprect, theRasterizer);\n-        if (has_clippath)\n-            render_clippath(gc.clippath, gc.clippath_trans);\n-\n-        // Transfer the hatch to the main image buffer\n-        typedef agg::image_accessor_wrap < pixfmt,\n-        agg::wrap_mode_repeat_auto_pow2,\n-        agg::wrap_mode_repeat_auto_pow2 > img_source_type;\n-        typedef agg::span_pattern_rgba<img_source_type> span_gen_type;\n-        agg::span_allocator<agg::rgba8> sa;\n-        img_source_type img_src(hatch_img_pixf);\n-        span_gen_type sg(img_src, 0, 0);\n-        try {\n-            theRasterizer.add_path(path);\n-        } catch (std::overflow_error &e) {\n-            throw Py::OverflowError(e.what());\n-        }\n-\n-        if (has_clippath)\n-        {\n-           pixfmt_amask_type pfa(pixFmt, alphaMask);\n-           amask_ren_type ren(pfa);\n-           agg::render_scanlines_aa(theRasterizer, slineP8, ren, sa, sg);\n-        }\n-        else\n-        {\n-           agg::render_scanlines_aa(theRasterizer, slineP8, rendererBase, sa, sg);\n-        }\n-    }\n-\n-    // Render stroke\n-    if (gc.linewidth != 0.0)\n-    {\n-        double linewidth = gc.linewidth;\n-        if (!gc.isaa)\n-        {\n-            linewidth = (linewidth < 0.5) ? 0.5 : mpl_round(linewidth);\n-        }\n-        if (gc.dashes.size() == 0)\n-        {\n-            stroke_t stroke(path);\n-            stroke.width(linewidth);\n-            stroke.line_cap(gc.cap);\n-            stroke.line_join(gc.join);\n-            try {\n-                theRasterizer.add_path(stroke);\n-            } catch (std::overflow_error &e) {\n-                throw Py::OverflowError(e.what());\n-            }\n-        }\n-        else\n-        {\n-            dash_t dash(path);\n-            for (GCAgg::dash_t::const_iterator i = gc.dashes.begin();\n-                    i != gc.dashes.end(); ++i)\n-            {\n-                double val0 = i->first;\n-                double val1 = i->second;\n-                if (!gc.isaa)\n-                {\n-                    val0 = (int)val0 + 0.5;\n-                    val1 = (int)val1 + 0.5;\n-                }\n-                dash.add_dash(val0, val1);\n-            }\n-            stroke_dash_t stroke(dash);\n-            stroke.line_cap(gc.cap);\n-            stroke.line_join(gc.join);\n-            stroke.width(linewidth);\n-            try {\n-                theRasterizer.add_path(stroke);\n-            } catch (std::overflow_error &e) {\n-                throw Py::OverflowError(e.what());\n-            }\n-        }\n-\n-        if (gc.isaa)\n-        {\n-            if (has_clippath)\n-            {\n-                pixfmt_amask_type pfa(pixFmt, alphaMask);\n-                amask_ren_type r(pfa);\n-                amask_aa_renderer_type ren(r);\n-                ren.color(gc.color);\n-                agg::render_scanlines(theRasterizer, scanlineAlphaMask, ren);\n-            }\n-            else\n-            {\n-                rendererAA.color(gc.color);\n-                agg::render_scanlines(theRasterizer, slineP8, rendererAA);\n-            }\n-        }\n-        else\n-        {\n-            if (has_clippath)\n-            {\n-                pixfmt_amask_type pfa(pixFmt, alphaMask);\n-                amask_ren_type r(pfa);\n-                amask_bin_renderer_type ren(r);\n-                ren.color(gc.color);\n-                agg::render_scanlines(theRasterizer, scanlineAlphaMask, ren);\n-            }\n-            else\n-            {\n-                rendererBin.color(gc.color);\n-                agg::render_scanlines(theRasterizer, slineBin, rendererBin);\n-            }\n-        }\n-    }\n-}\n-\n-\n-Py::Object\n-RendererAgg::draw_path(const Py::Tuple& args)\n-{\n-    typedef agg::conv_transform<PathIterator>  transformed_path_t;\n-    typedef PathNanRemover<transformed_path_t> nan_removed_t;\n-    typedef PathClipper<nan_removed_t>         clipped_t;\n-    typedef PathSnapper<clipped_t>             snapped_t;\n-    typedef PathSimplifier<snapped_t>          simplify_t;\n-    typedef agg::conv_curve<simplify_t>        curve_t;\n-    typedef Sketch<curve_t>                    sketch_t;\n-\n-    _VERBOSE(\"RendererAgg::draw_path\");\n-    args.verify_length(3, 4);\n-\n-    GCAgg gc(args[0], dpi);\n-    PathIterator path(args[1]);\n-    agg::trans_affine trans = py_to_agg_transformation_matrix(args[2].ptr());\n-    Py::Object face_obj;\n-    if (args.size() == 4)\n-        face_obj = args[3];\n-\n-    facepair_t face = _get_rgba_face(face_obj, gc.alpha, gc.forced_alpha);\n-\n-    theRasterizer.reset_clipping();\n-    rendererBase.reset_clipping(true);\n-    set_clipbox(gc.cliprect, theRasterizer);\n-    bool has_clippath = render_clippath(gc.clippath, gc.clippath_trans);\n-\n-    trans *= agg::trans_affine_scaling(1.0, -1.0);\n-    trans *= agg::trans_affine_translation(0.0, (double)height);\n-    bool clip = !face.first && gc.hatchpath.isNone() && !path.has_curves();\n-    bool simplify = path.should_simplify() && clip;\n-    double snapping_linewidth = gc.linewidth;\n-    if (gc.color.a == 0.0) {\n-        snapping_linewidth = 0.0;\n-    }\n-\n-    transformed_path_t tpath(path, trans);\n-    nan_removed_t      nan_removed(tpath, true, path.has_curves());\n-    clipped_t          clipped(nan_removed, clip, width, height);\n-    snapped_t          snapped(clipped, gc.snap_mode, path.total_vertices(), snapping_linewidth);\n-    simplify_t         simplified(snapped, simplify, path.simplify_threshold());\n-    curve_t            curve(simplified);\n-    sketch_t           sketch(curve, gc.sketch_scale, gc.sketch_length, gc.sketch_randomness);\n-\n-    try\n-    {\n-        _draw_path(sketch, has_clippath, face, gc);\n-    }\n-    catch (const char* e)\n-    {\n-        throw Py::RuntimeError(e);\n-    }\n-\n-    return Py::Object();\n-}\n-\n-\n-template<class PathGenerator, int check_snap, int has_curves>\n-Py::Object\n-RendererAgg::_draw_path_collection_generic\n-(GCAgg&                         gc,\n- agg::trans_affine              master_transform,\n- const Py::Object&              cliprect,\n- const Py::Object&              clippath,\n- const agg::trans_affine&       clippath_trans,\n- const PathGenerator&           path_generator,\n- const Py::Object&              transforms_obj,\n- const Py::Object&              offsets_obj,\n- const agg::trans_affine&       offset_trans,\n- const Py::Object&              facecolors_obj,\n- const Py::Object&              edgecolors_obj,\n- const Py::SeqBase<Py::Float>&  linewidths,\n- const Py::SeqBase<Py::Object>& linestyles_obj,\n- const Py::SeqBase<Py::Int>&    antialiaseds,\n- const bool                     data_offsets)\n-{\n-    typedef agg::conv_transform<typename PathGenerator::path_iterator> transformed_path_t;\n-    typedef PathNanRemover<transformed_path_t>                         nan_removed_t;\n-    typedef PathClipper<nan_removed_t>                                 clipped_t;\n-    typedef PathSnapper<clipped_t>                                     snapped_t;\n-    typedef agg::conv_curve<snapped_t>                                 snapped_curve_t;\n-    typedef agg::conv_curve<clipped_t>                                 curve_t;\n-\n-    PyArrayObject* offsets = (PyArrayObject*)PyArray_FromObject\n-        (offsets_obj.ptr(), NPY_DOUBLE, 0, 2);\n-    if (!offsets ||\n-        (PyArray_NDIM(offsets) == 2 && PyArray_DIM(offsets, 1) != 2) ||\n-        (PyArray_NDIM(offsets) == 1 && PyArray_DIM(offsets, 0) != 0))\n-    {\n-        Py_XDECREF(offsets);\n-        throw Py::ValueError(\"Offsets array must be Nx2\");\n-    }\n-    Py::Object offsets_arr_obj((PyObject*)offsets, true);\n-\n-    PyArrayObject* facecolors = (PyArrayObject*)PyArray_FromObject\n-        (facecolors_obj.ptr(), NPY_DOUBLE, 1, 2);\n-    if (!facecolors ||\n-        (PyArray_NDIM(facecolors) == 1 && PyArray_DIM(facecolors, 0) != 0) ||\n-        (PyArray_NDIM(facecolors) == 2 && PyArray_DIM(facecolors, 1) != 4))\n-    {\n-        Py_XDECREF(facecolors);\n-        throw Py::ValueError(\"Facecolors must be a Nx4 numpy array or empty\");\n-    }\n-    Py::Object facecolors_arr_obj((PyObject*)facecolors, true);\n-\n-    PyArrayObject* edgecolors = (PyArrayObject*)PyArray_FromObject\n-        (edgecolors_obj.ptr(), NPY_DOUBLE, 1, 2);\n-    if (!edgecolors ||\n-        (PyArray_NDIM(edgecolors) == 1 && PyArray_DIM(edgecolors, 0) != 0) ||\n-        (PyArray_NDIM(edgecolors) == 2 && PyArray_DIM(edgecolors, 1) != 4))\n-    {\n-        Py_XDECREF(edgecolors);\n-        throw Py::ValueError(\"Edgecolors must be a Nx4 numpy array\");\n-    }\n-    Py::Object edgecolors_arr_obj((PyObject*)edgecolors, true);\n-\n-    PyArrayObject* transforms_arr = (PyArrayObject*)PyArray_FromObject\n-        (transforms_obj.ptr(), NPY_DOUBLE, 1, 3);\n-    if (!transforms_arr ||\n-        (PyArray_NDIM(transforms_arr) == 1 && PyArray_DIM(transforms_arr, 0) != 0) ||\n-        (PyArray_NDIM(transforms_arr) == 2) ||\n-        (PyArray_NDIM(transforms_arr) == 3 &&\n-         ((PyArray_DIM(transforms_arr, 1) != 3) ||\n-          (PyArray_DIM(transforms_arr, 2) != 3))))\n-    {\n-        Py_XDECREF(transforms_arr);\n-        throw Py::ValueError(\"Transforms must be a Nx3x3 numpy array\");\n-    }\n-\n-    size_t Npaths      = path_generator.num_paths();\n-    size_t Noffsets    = PyArray_DIM(offsets, 0);\n-    size_t N           = std::max(Npaths, Noffsets);\n-    size_t Ntransforms = PyArray_DIM(transforms_arr, 0);\n-    size_t Nfacecolors = PyArray_DIM(facecolors, 0);\n-    size_t Nedgecolors = PyArray_DIM(edgecolors, 0);\n-    size_t Nlinewidths = linewidths.length();\n-    size_t Nlinestyles = std::min(linestyles_obj.length(), N);\n-    size_t Naa         = antialiaseds.length();\n-\n-    if ((Nfacecolors == 0 && Nedgecolors == 0) || Npaths == 0)\n-    {\n-        Py_XDECREF(transforms_arr);\n-        return Py::Object();\n-    }\n-\n-    size_t i = 0;\n-\n-    // Convert all of the transforms up front\n-    typedef std::vector<agg::trans_affine> transforms_t;\n-    transforms_t transforms;\n-    transforms.reserve(Ntransforms);\n-    for (i = 0; i < Ntransforms; ++i)\n-    {\n-        /* TODO: Use a Numpy iterator */\n-        agg::trans_affine trans(\n-            *(double *)PyArray_GETPTR3(transforms_arr, i, 0, 0),\n-            *(double *)PyArray_GETPTR3(transforms_arr, i, 1, 0),\n-            *(double *)PyArray_GETPTR3(transforms_arr, i, 0, 1),\n-            *(double *)PyArray_GETPTR3(transforms_arr, i, 1, 1),\n-            *(double *)PyArray_GETPTR3(transforms_arr, i, 0, 2),\n-            *(double *)PyArray_GETPTR3(transforms_arr, i, 1, 2));\n-        trans *= master_transform;\n-\n-        transforms.push_back(trans);\n-    }\n-\n-    // Convert all the dashes up front\n-    typedef std::vector<std::pair<double, GCAgg::dash_t> > dashes_t;\n-    dashes_t dashes;\n-    dashes.resize(Nlinestyles);\n-    i = 0;\n-    for (dashes_t::iterator d = dashes.begin();\n-         d != dashes.end(); ++d, ++i)\n-    {\n-        convert_dashes(Py::Tuple(linestyles_obj[i]), dpi, d->second,\n-                       d->first);\n-    }\n-\n-    // Handle any clipping globally\n-    theRasterizer.reset_clipping();\n-    rendererBase.reset_clipping(true);\n-    set_clipbox(cliprect, theRasterizer);\n-    bool has_clippath = render_clippath(clippath, clippath_trans);\n-\n-    // Set some defaults, assuming no face or edge\n-    gc.linewidth = 0.0;\n-    facepair_t face;\n-    face.first = Nfacecolors != 0;\n-    agg::trans_affine trans;\n-\n-    for (i = 0; i < N; ++i)\n-    {\n-        typename PathGenerator::path_iterator path = path_generator(i);\n-\n-        if (Ntransforms)\n-        {\n-            trans = transforms[i % Ntransforms];\n-        }\n-        else\n-        {\n-            trans = master_transform;\n-        }\n-\n-        if (Noffsets)\n-        {\n-            double xo = *(double*)PyArray_GETPTR2(offsets, i % Noffsets, 0);\n-            double yo = *(double*)PyArray_GETPTR2(offsets, i % Noffsets, 1);\n-            offset_trans.transform(&xo, &yo);\n-            if (data_offsets) {\n-                trans = agg::trans_affine_translation(xo, yo) * trans;\n-            } else {\n-                trans *= agg::trans_affine_translation(xo, yo);\n-            }\n-        }\n-\n-        // These transformations must be done post-offsets\n-        trans *= agg::trans_affine_scaling(1.0, -1.0);\n-        trans *= agg::trans_affine_translation(0.0, (double)height);\n-\n-        if (Nfacecolors)\n-        {\n-            size_t fi = i % Nfacecolors;\n-            face.second = agg::rgba(\n-                *(double*)PyArray_GETPTR2(facecolors, fi, 0),\n-                *(double*)PyArray_GETPTR2(facecolors, fi, 1),\n-                *(double*)PyArray_GETPTR2(facecolors, fi, 2),\n-                *(double*)PyArray_GETPTR2(facecolors, fi, 3));\n-        }\n-\n-        if (Nedgecolors)\n-        {\n-            size_t ei = i % Nedgecolors;\n-            gc.color = agg::rgba(\n-                *(double*)PyArray_GETPTR2(edgecolors, ei, 0),\n-                *(double*)PyArray_GETPTR2(edgecolors, ei, 1),\n-                *(double*)PyArray_GETPTR2(edgecolors, ei, 2),\n-                *(double*)PyArray_GETPTR2(edgecolors, ei, 3));\n-\n-            if (Nlinewidths)\n-            {\n-                gc.linewidth = double(Py::Float(linewidths[i % Nlinewidths])) * dpi / 72.0;\n-            }\n-            else\n-            {\n-                gc.linewidth = 1.0;\n-            }\n-            if (Nlinestyles)\n-            {\n-                gc.dashes = dashes[i % Nlinestyles].second;\n-                gc.dashOffset = dashes[i % Nlinestyles].first;\n-            }\n-        }\n-\n-        bool do_clip = !face.first && gc.hatchpath.isNone() && !has_curves;\n-\n-        if (check_snap)\n-        {\n-            gc.isaa = Py::Boolean(antialiaseds[i % Naa]);\n-\n-            transformed_path_t tpath(path, trans);\n-            nan_removed_t      nan_removed(tpath, true, has_curves);\n-            clipped_t          clipped(nan_removed, do_clip, width, height);\n-            snapped_t          snapped(clipped, gc.snap_mode,\n-                                       path.total_vertices(), gc.linewidth);\n-            if (has_curves)\n-            {\n-                snapped_curve_t curve(snapped);\n-                _draw_path(curve, has_clippath, face, gc);\n-            }\n-            else\n-            {\n-                _draw_path(snapped, has_clippath, face, gc);\n-            }\n-        }\n-        else\n-        {\n-            gc.isaa = Py::Boolean(antialiaseds[i % Naa]);\n-\n-            transformed_path_t tpath(path, trans);\n-            nan_removed_t      nan_removed(tpath, true, has_curves);\n-            clipped_t          clipped(nan_removed, do_clip, width, height);\n-            if (has_curves)\n-            {\n-                curve_t curve(clipped);\n-                _draw_path(curve, has_clippath, face, gc);\n-            }\n-            else\n-            {\n-                _draw_path(clipped, has_clippath, face, gc);\n-            }\n-        }\n-    }\n-\n-    Py_XDECREF(transforms_arr);\n-\n-    return Py::Object();\n-}\n-\n-\n-class PathListGenerator\n-{\n-    const Py::SeqBase<Py::Object>& m_paths;\n-    size_t m_npaths;\n-\n-public:\n-    typedef PathIterator path_iterator;\n-\n-    inline\n-    PathListGenerator(const Py::SeqBase<Py::Object>& paths) :\n-        m_paths(paths), m_npaths(paths.size())\n-    {\n-\n-    }\n-\n-    inline size_t\n-    num_paths() const\n-    {\n-        return m_npaths;\n-    }\n-\n-    inline path_iterator\n-    operator()(size_t i) const\n-    {\n-        return PathIterator(m_paths[i % m_npaths]);\n-    }\n-};\n-\n-\n-Py::Object\n-RendererAgg::draw_path_collection(const Py::Tuple& args)\n-{\n-    _VERBOSE(\"RendererAgg::draw_path_collection\");\n-    args.verify_length(13);\n-\n-    Py::Object gc_obj = args[0];\n-    GCAgg gc(gc_obj, dpi);\n-    agg::trans_affine       master_transform = py_to_agg_transformation_matrix(args[1].ptr());\n-    Py::SeqBase<Py::Object> path   = args[2];\n-    PathListGenerator       path_generator(path);\n-    Py::Object              transforms_obj   = args[3];\n-    Py::Object              offsets_obj      = args[4];\n-    agg::trans_affine       offset_trans     = py_to_agg_transformation_matrix(args[5].ptr());\n-    Py::Object              facecolors_obj   = args[6];\n-    Py::Object              edgecolors_obj   = args[7];\n-    Py::SeqBase<Py::Float>  linewidths       = args[8];\n-    Py::SeqBase<Py::Object> linestyles_obj   = args[9];\n-    Py::SeqBase<Py::Int>    antialiaseds     = args[10];\n-    // We don't actually care about urls for Agg, so just ignore it.\n-    // Py::SeqBase<Py::Object> urls             = args[11];\n-    std::string             offset_position  = Py::String(args[12]).encode(\"utf-8\");\n-\n-    bool data_offsets = (offset_position == \"data\");\n-\n-    try\n-    {\n-        _draw_path_collection_generic<PathListGenerator, 1, 1>\n-        (gc,\n-         master_transform,\n-         gc.cliprect,\n-         gc.clippath,\n-         gc.clippath_trans,\n-         path_generator,\n-         transforms_obj,\n-         offsets_obj,\n-         offset_trans,\n-         facecolors_obj,\n-         edgecolors_obj,\n-         linewidths,\n-         linestyles_obj,\n-         antialiaseds,\n-         data_offsets);\n-    }\n-    catch (const char *e)\n-    {\n-        throw Py::RuntimeError(e);\n-    }\n-\n-    return Py::Object();\n-}\n-\n-\n-class QuadMeshGenerator\n-{\n-    size_t m_meshWidth;\n-    size_t m_meshHeight;\n-    PyArrayObject* m_coordinates;\n-\n-    class QuadMeshPathIterator\n-    {\n-        size_t m_iterator;\n-        size_t m_m, m_n;\n-        PyArrayObject* m_coordinates;\n-\n-    public:\n-        QuadMeshPathIterator(size_t m, size_t n, PyArrayObject* coordinates) :\n-            m_iterator(0), m_m(m), m_n(n), m_coordinates(coordinates)\n-        {\n-\n-        }\n-\n-    private:\n-        inline unsigned\n-        vertex(unsigned idx, double* x, double* y)\n-        {\n-            size_t m = m_m + ((idx     & 0x2) >> 1);\n-            size_t n = m_n + (((idx + 1) & 0x2) >> 1);\n-            double* pair = (double*)PyArray_GETPTR2(m_coordinates, n, m);\n-            *x = *pair++;\n-            *y = *pair;\n-            return (idx) ? agg::path_cmd_line_to : agg::path_cmd_move_to;\n-        }\n-\n-    public:\n-        inline unsigned\n-        vertex(double* x, double* y)\n-        {\n-            if (m_iterator >= total_vertices())\n-            {\n-                return agg::path_cmd_stop;\n-            }\n-            return vertex(m_iterator++, x, y);\n-        }\n-\n-        inline void\n-        rewind(unsigned path_id)\n-        {\n-            m_iterator = path_id;\n-        }\n-\n-        inline unsigned\n-        total_vertices()\n-        {\n-            return 5;\n-        }\n-\n-        inline bool\n-        should_simplify()\n-        {\n-            return false;\n-        }\n-    };\n-\n-public:\n-    typedef QuadMeshPathIterator path_iterator;\n-\n-    inline\n-    QuadMeshGenerator(size_t meshWidth, size_t meshHeight, PyObject* coordinates) :\n-        m_meshWidth(meshWidth), m_meshHeight(meshHeight), m_coordinates(NULL)\n-    {\n-        PyArrayObject* coordinates_array = \\\n-            (PyArrayObject*)PyArray_ContiguousFromObject(\n-                coordinates, NPY_DOUBLE, 3, 3);\n-\n-        if (!coordinates_array)\n-        {\n-            throw Py::ValueError(\"Invalid coordinates array.\");\n-        }\n-\n-        m_coordinates = coordinates_array;\n-    }\n-\n-    inline\n-    ~QuadMeshGenerator()\n-    {\n-        Py_XDECREF(m_coordinates);\n-    }\n-\n-    inline size_t\n-    num_paths() const\n-    {\n-        return m_meshWidth * m_meshHeight;\n-    }\n-\n-    inline path_iterator\n-    operator()(size_t i) const\n-    {\n-        return QuadMeshPathIterator(i % m_meshWidth, i / m_meshWidth, m_coordinates);\n-    }\n-};\n-\n-Py::Object\n-RendererAgg::draw_quad_mesh(const Py::Tuple& args)\n-{\n-    _VERBOSE(\"RendererAgg::draw_quad_mesh\");\n-    args.verify_length(10);\n-\n-    //segments, trans, clipbox, colors, linewidths, antialiaseds\n-    GCAgg gc(args[0], dpi);\n-    agg::trans_affine master_transform = py_to_agg_transformation_matrix(args[1].ptr());\n-    size_t            mesh_width       = (long)Py::Int(args[2]);\n-    size_t            mesh_height      = (long)Py::Int(args[3]);\n-    Py::Object        coordinates      = args[4];\n-    Py::Object        offsets_obj      = args[5];\n-    agg::trans_affine offset_trans     = py_to_agg_transformation_matrix(args[6].ptr());\n-    Py::Object        facecolors_obj   = args[7];\n-    bool              antialiased      = (bool)Py::Boolean(args[8]);\n-    Py::Object        edgecolors_obj   = args[9];\n-\n-    QuadMeshGenerator path_generator(mesh_width, mesh_height, coordinates.ptr());\n-\n-    Py::Object transforms_obj = Py::List(0);\n-    Py::Tuple linewidths(1);\n-    linewidths[0] = Py::Float(gc.linewidth);\n-    Py::SeqBase<Py::Object> linestyles_obj;\n-    Py::Tuple antialiaseds(1);\n-    antialiaseds[0] = Py::Int(antialiased ? 1 : 0);\n-\n-    if (edgecolors_obj.isNone()) {\n-        if (antialiased)\n-        {\n-            edgecolors_obj = facecolors_obj;\n-        }\n-        else\n-        {\n-            npy_intp dims[] = { 0, 0 };\n-            edgecolors_obj = PyArray_SimpleNew(1, dims, NPY_DOUBLE);\n-        }\n-    }\n-\n-    try\n-    {\n-        _draw_path_collection_generic<QuadMeshGenerator, 0, 0>\n-            (gc,\n-             master_transform,\n-             gc.cliprect,\n-             gc.clippath,\n-             gc.clippath_trans,\n-             path_generator,\n-             transforms_obj,\n-             offsets_obj,\n-             offset_trans,\n-             facecolors_obj,\n-             edgecolors_obj,\n-             linewidths,\n-             linestyles_obj,\n-             antialiaseds,\n-             false);\n-    }\n-    catch (const char* e)\n-    {\n-        throw Py::RuntimeError(e);\n-    }\n-\n-    return Py::Object();\n-}\n-\n-void\n-RendererAgg::_draw_gouraud_triangle(const double* points,\n-                                    const double* colors,\n-                                    agg::trans_affine trans,\n-                                    bool has_clippath)\n-{\n-    typedef agg::rgba8                                         color_t;\n-    typedef agg::span_gouraud_rgba<color_t>                    span_gen_t;\n-    typedef agg::span_allocator<color_t>                       span_alloc_t;\n-\n-    trans *= agg::trans_affine_scaling(1.0, -1.0);\n-    trans *= agg::trans_affine_translation(0.0, (double)height);\n-\n-    double tpoints[6];\n-\n-    for (int i = 0; i < 6; i += 2)\n-    {\n-        tpoints[i] = points[i];\n-        tpoints[i+1] = points[i+1];\n-        trans.transform(&tpoints[i], &tpoints[i+1]);\n-    }\n-\n-    span_alloc_t span_alloc;\n-    span_gen_t span_gen;\n-\n-    span_gen.colors(\n-        agg::rgba(colors[0], colors[1], colors[2], colors[3]),\n-        agg::rgba(colors[4], colors[5], colors[6], colors[7]),\n-        agg::rgba(colors[8], colors[9], colors[10], colors[11]));\n-    span_gen.triangle(\n-        tpoints[0], tpoints[1],\n-        tpoints[2], tpoints[3],\n-        tpoints[4], tpoints[5],\n-        0.5);\n-\n-    try {\n-        theRasterizer.add_path(span_gen);\n-    } catch (std::overflow_error &e) {\n-        throw Py::OverflowError(e.what()\n-                                );\n-    }\n-\n-    if (has_clippath)\n-    {\n-        typedef agg::pixfmt_amask_adaptor<pixfmt, alpha_mask_type> pixfmt_amask_type;\n-        typedef agg::renderer_base<pixfmt_amask_type>              amask_ren_type;\n-        typedef agg::renderer_scanline_aa<amask_ren_type, span_alloc_t, span_gen_t>\n-        amask_aa_renderer_type;\n-\n-        pixfmt_amask_type pfa(pixFmt, alphaMask);\n-        amask_ren_type r(pfa);\n-        amask_aa_renderer_type ren(r, span_alloc, span_gen);\n-        agg::render_scanlines(theRasterizer, scanlineAlphaMask, ren);\n-    }\n-    else\n-    {\n-        agg::render_scanlines_aa(theRasterizer, slineP8, rendererBase, span_alloc, span_gen);\n-    }\n-}\n-\n-\n-Py::Object\n-RendererAgg::draw_gouraud_triangle(const Py::Tuple& args)\n-{\n-    _VERBOSE(\"RendererAgg::draw_gouraud_triangle\");\n-    args.verify_length(4);\n-\n-    GCAgg             gc(args[0], dpi);\n-    Py::Object        points_obj = args[1];\n-    Py::Object        colors_obj = args[2];\n-    agg::trans_affine trans      = py_to_agg_transformation_matrix(args[3].ptr());\n-\n-    theRasterizer.reset_clipping();\n-    rendererBase.reset_clipping(true);\n-    set_clipbox(gc.cliprect, theRasterizer);\n-    bool has_clippath = render_clippath(gc.clippath, gc.clippath_trans);\n-\n-    PyArrayObject* points = (PyArrayObject*)PyArray_ContiguousFromAny\n-        (points_obj.ptr(), NPY_DOUBLE, 2, 2);\n-    if (!points ||\n-        PyArray_DIM(points, 0) != 3 || PyArray_DIM(points, 1) != 2)\n-    {\n-        Py_XDECREF(points);\n-        throw Py::ValueError(\"points must be a 3x2 numpy array\");\n-    }\n-    points_obj = Py::Object((PyObject*)points, true);\n-\n-    PyArrayObject* colors = (PyArrayObject*)PyArray_ContiguousFromAny\n-        (colors_obj.ptr(), NPY_DOUBLE, 2, 2);\n-    if (!colors ||\n-        PyArray_DIM(colors, 0) != 3 || PyArray_DIM(colors, 1) != 4)\n-    {\n-        Py_XDECREF(colors);\n-        throw Py::ValueError(\"colors must be a 3x4 numpy array\");\n-    }\n-    colors_obj = Py::Object((PyObject*)colors, true);\n-\n-    _draw_gouraud_triangle(\n-        (double*)PyArray_DATA(points), (double*)PyArray_DATA(colors),\n-        trans, has_clippath);\n-\n-    return Py::Object();\n-}\n-\n-\n-Py::Object\n-RendererAgg::draw_gouraud_triangles(const Py::Tuple& args)\n-{\n-    _VERBOSE(\"RendererAgg::draw_gouraud_triangles\");\n-    args.verify_length(4);\n-\n-    typedef agg::rgba8                      color_t;\n-    typedef agg::span_gouraud_rgba<color_t> span_gen_t;\n-\n-    GCAgg             gc(args[0], dpi);\n-    Py::Object        points_obj = args[1];\n-    Py::Object        colors_obj = args[2];\n-    agg::trans_affine trans      = py_to_agg_transformation_matrix(args[3].ptr());\n-    double            c_points[6];\n-    double            c_colors[12];\n-\n-    theRasterizer.reset_clipping();\n-    rendererBase.reset_clipping(true);\n-    set_clipbox(gc.cliprect, theRasterizer);\n-    bool has_clippath = render_clippath(gc.clippath, gc.clippath_trans);\n-\n-    PyArrayObject* points = (PyArrayObject*)PyArray_FromObject\n-        (points_obj.ptr(), NPY_DOUBLE, 3, 3);\n-    if (!points ||\n-        PyArray_DIM(points, 1) != 3 || PyArray_DIM(points, 2) != 2)\n-    {\n-        Py_XDECREF(points);\n-        throw Py::ValueError(\"points must be a Nx3x2 numpy array\");\n-    }\n-    points_obj = Py::Object((PyObject*)points, true);\n-\n-    PyArrayObject* colors = (PyArrayObject*)PyArray_FromObject\n-        (colors_obj.ptr(), NPY_DOUBLE, 3, 3);\n-    if (!colors ||\n-        PyArray_DIM(colors, 1) != 3 || PyArray_DIM(colors, 2) != 4)\n-    {\n-        Py_XDECREF(colors);\n-        throw Py::ValueError(\"colors must be a Nx3x4 numpy array\");\n-    }\n-    colors_obj = Py::Object((PyObject*)colors, true);\n-\n-    if (PyArray_DIM(points, 0) != PyArray_DIM(colors, 0))\n-    {\n-        throw Py::ValueError(\"points and colors arrays must be the same length\");\n-    }\n-\n-    for (int i = 0; i < PyArray_DIM(points, 0); ++i)\n-    {\n-        for (int j = 0; j < 3; ++j) {\n-            for (int k = 0; k < 2; ++k) {\n-                c_points[j*2+k] = *(double *)PyArray_GETPTR3(points, i, j, k);\n-            }\n-        }\n-\n-        for (int j = 0; j < 3; ++j) {\n-            for (int k = 0; k < 4; ++k) {\n-                c_colors[j*4+k] = *(double *)PyArray_GETPTR3(colors, i, j, k);\n-            }\n-        }\n-\n-        _draw_gouraud_triangle(\n-                c_points, c_colors, trans, has_clippath);\n-    }\n-\n-    return Py::Object();\n-}\n-\n-\n-Py::Object\n-RendererAgg::write_rgba(const Py::Tuple& args)\n-{\n-    _VERBOSE(\"RendererAgg::write_rgba\");\n-\n-    args.verify_length(1);\n-\n-    FILE *fp = NULL;\n-    mpl_off_t offset;\n-    Py::Object py_fileobj = Py::Object(args[0]);\n-    PyObject* py_file = NULL;\n-    bool close_file = false;\n-\n-    if (py_fileobj.isString())\n-    {\n-        if ((py_file = mpl_PyFile_OpenFile(py_fileobj.ptr(), (char *)\"wb\")) == NULL) {\n-            throw Py::Exception();\n-        }\n-    }\n-    else\n-    {\n-        py_file = py_fileobj.ptr();\n-    }\n-\n-    if ((fp = mpl_PyFile_Dup(py_file, (char *)\"wb\", &offset)))\n-    {\n-        if (fwrite(pixBuffer, 1, NUMBYTES, fp) != NUMBYTES)\n-        {\n-            if (mpl_PyFile_DupClose(py_file, fp, offset)) {\n-              throw Py::RuntimeError(\"Error closing dupe file handle\");\n-            }\n-\n-            if (close_file) {\n-                mpl_PyFile_CloseFile(py_file);\n-                Py_DECREF(py_file);\n-            }\n-\n-            throw Py::RuntimeError(\"Error writing to file\");\n-        }\n-\n-        if (mpl_PyFile_DupClose(py_file, fp, offset)) {\n-          throw Py::RuntimeError(\"Error closing dupe file handle\");\n-        }\n-\n-        if (close_file) {\n-            mpl_PyFile_CloseFile(py_file);\n-            Py_DECREF(py_file);\n-        }\n-    }\n-    else\n-    {\n-        PyErr_Clear();\n-        PyObject* write_method = PyObject_GetAttrString(py_fileobj.ptr(),\n-                                                        \"write\");\n-        if (!(write_method && PyCallable_Check(write_method)))\n-        {\n-            Py_XDECREF(write_method);\n-            throw Py::TypeError(\n-                \"Object does not appear to be a 8-bit string path or a Python file-like object\");\n-        }\n-\n-        #if PY3K\n-        PyObject_CallFunction(write_method, (char *)\"y#\", pixBuffer, NUMBYTES);\n-        #else\n-        PyObject_CallFunction(write_method, (char *)\"s#\", pixBuffer, NUMBYTES);\n-        #endif\n-\n-        Py_XDECREF(write_method);\n-    }\n-\n-    return Py::Object();\n-}\n-\n-\n-Py::Object\n-RendererAgg::tostring_rgb(const Py::Tuple& args)\n-{\n-    //\"Return the rendered buffer as an RGB string\";\n-\n-    _VERBOSE(\"RendererAgg::tostring_rgb\");\n-\n-    args.verify_length(0);\n-    int row_len = width * 3;\n-    unsigned char* buf_tmp = new unsigned char[row_len * height];\n-    if (buf_tmp == NULL)\n-    {\n-        //todo: also handle allocation throw\n-        throw Py::MemoryError(\n-            \"RendererAgg::tostring_rgb could not allocate memory\");\n-    }\n-\n-    try\n-    {\n-        agg::rendering_buffer renderingBufferTmp;\n-        renderingBufferTmp.attach(buf_tmp,\n-                                  width,\n-                                  height,\n-                                  row_len);\n-\n-        agg::color_conv(&renderingBufferTmp, &renderingBuffer,\n-                        agg::color_conv_rgba32_to_rgb24());\n-    }\n-    catch (...)\n-    {\n-        delete [] buf_tmp;\n-        throw Py::RuntimeError(\"Unknown exception occurred in tostring_rgb\");\n-    }\n-\n-    //todo: how to do this with native CXX\n-    #if PY3K\n-    PyObject* o = Py_BuildValue(\"y#\", buf_tmp, row_len * height);\n-    #else\n-    PyObject* o = Py_BuildValue(\"s#\", buf_tmp, row_len * height);\n-    #endif\n-\n-    delete [] buf_tmp;\n-    return Py::asObject(o);\n-}\n-\n-\n-Py::Object\n-RendererAgg::tostring_argb(const Py::Tuple& args)\n-{\n-    //\"Return the rendered buffer as an RGB string\";\n-\n-    _VERBOSE(\"RendererAgg::tostring_argb\");\n-\n-    args.verify_length(0);\n-    int row_len = width * 4;\n-    unsigned char* buf_tmp = new unsigned char[row_len * height];\n-    if (buf_tmp == NULL)\n-    {\n-        //todo: also handle allocation throw\n-        throw Py::MemoryError(\"RendererAgg::tostring_argb could not allocate memory\");\n-    }\n-\n-    try\n-    {\n-        agg::rendering_buffer renderingBufferTmp;\n-        renderingBufferTmp.attach(buf_tmp, width, height, row_len);\n-        agg::color_conv(&renderingBufferTmp, &renderingBuffer, agg::color_conv_rgba32_to_argb32());\n-    }\n-    catch (...)\n-    {\n-        delete [] buf_tmp;\n-        throw Py::RuntimeError(\"Unknown exception occurred in tostring_argb\");\n-    }\n-\n-    //todo: how to do this with native CXX\n-\n-    #if PY3K\n-    PyObject* o = Py_BuildValue(\"y#\", buf_tmp, row_len * height);\n-    #else\n-    PyObject* o = Py_BuildValue(\"s#\", buf_tmp, row_len * height);\n-    #endif\n-    delete [] buf_tmp;\n-    return Py::asObject(o);\n-}\n-\n-\n-Py::Object\n-RendererAgg::tostring_bgra(const Py::Tuple& args)\n-{\n-    //\"Return the rendered buffer as an RGB string\";\n-\n-    _VERBOSE(\"RendererAgg::tostring_bgra\");\n-\n-    args.verify_length(0);\n-    int row_len = width * 4;\n-    unsigned char* buf_tmp = new unsigned char[row_len * height];\n-    if (buf_tmp == NULL)\n-    {\n-        //todo: also handle allocation throw\n-        throw Py::MemoryError(\"RendererAgg::tostring_bgra could not allocate memory\");\n-    }\n-\n-    try\n-    {\n-        agg::rendering_buffer renderingBufferTmp;\n-        renderingBufferTmp.attach(buf_tmp,\n-                                  width,\n-                                  height,\n-                                  row_len);\n-\n-        agg::color_conv(&renderingBufferTmp, &renderingBuffer, agg::color_conv_rgba32_to_bgra32());\n-    }\n-    catch (...)\n-    {\n-        delete [] buf_tmp;\n-        throw Py::RuntimeError(\"Unknown exception occurred in tostring_bgra\");\n-    }\n-\n-    //todo: how to do this with native CXX\n-    #if PY3K\n-    PyObject* o = Py_BuildValue(\"y#\", buf_tmp, row_len * height);\n-    #else\n-    PyObject* o = Py_BuildValue(\"s#\", buf_tmp, row_len * height);\n-    #endif\n-    delete [] buf_tmp;\n-    return Py::asObject(o);\n-}\n-\n-\n-Py::Object\n-RendererAgg::buffer_rgba(const Py::Tuple& args)\n-{\n-    //\"expose the rendered buffer as Python buffer object, starting from postion x,y\";\n-\n-    _VERBOSE(\"RendererAgg::buffer_rgba\");\n-\n-    args.verify_length(0);\n-\n-    #if PY3K\n-    return Py::asObject(PyMemoryView_FromObject(this));\n-    #else\n-    int row_len = width * 4;\n-    return Py::asObject(PyBuffer_FromReadWriteMemory(\n-                            pixBuffer, row_len*height));\n-    #endif\n-}\n-\n-\n-Py::Object\n-RendererAgg::tostring_rgba_minimized(const Py::Tuple& args)\n-{\n-    args.verify_length(0);\n-\n-    int xmin = width;\n-    int ymin = height;\n-    int xmax = 0;\n-    int ymax = 0;\n-\n-    // Looks at the alpha channel to find the minimum extents of the image\n-    unsigned char* pixel = pixBuffer + 3;\n-    for (int y = 0; y < (int)height; ++y)\n-    {\n-        for (int x = 0; x < (int)width; ++x)\n-        {\n-            if (*pixel)\n-            {\n-                if (x < xmin) xmin = x;\n-                if (y < ymin) ymin = y;\n-                if (x > xmax) xmax = x;\n-                if (y > ymax) ymax = y;\n-            }\n-            pixel += 4;\n-        }\n-    }\n-\n-    int newwidth = 0;\n-    int newheight = 0;\n-    PyObject *data;\n-\n-    if (xmin < xmax && ymin < ymax)\n-    {\n-        // Expand the bounds by 1 pixel on all sides\n-        xmin = std::max(0, xmin - 1);\n-        ymin = std::max(0, ymin - 1);\n-        xmax = std::min(xmax, (int)width);\n-        ymax = std::min(ymax, (int)height);\n-\n-        newwidth    = xmax - xmin;\n-        newheight   = ymax - ymin;\n-        int newsize = newwidth * newheight * 4;\n-\n-        // NULL pointer causes Python to allocate uninitialized memory.\n-        // We then grab Python's pointer to uninitialized memory using\n-        // the _AsString() API.\n-        unsigned int* dst;\n-\n-        data = PyBytes_FromStringAndSize(NULL, newsize);\n-        if (data == NULL)\n-        {\n-            throw Py::MemoryError(\"RendererAgg::tostring_rgba_minimized could not allocate memory\");\n-        }\n-        dst = (unsigned int *)PyBytes_AsString(data);\n-\n-        unsigned int*  src = (unsigned int*)pixBuffer;\n-        for (int y = ymin; y < ymax; ++y)\n-        {\n-            for (int x = xmin; x < xmax; ++x, ++dst)\n-            {\n-                *dst = src[y * width + x];\n-            }\n-        }\n-    } else {\n-        data = PyBytes_FromStringAndSize(NULL, 0);\n-        if (data == NULL)\n-        {\n-            throw Py::MemoryError(\"RendererAgg::tostring_rgba_minimized could not allocate memory\");\n-        }\n-    }\n-\n-    Py::Tuple bounds(4);\n-    bounds[0] = Py::Int(xmin);\n-    bounds[1] = Py::Int(ymin);\n-    bounds[2] = Py::Int(newwidth);\n-    bounds[3] = Py::Int(newheight);\n-\n-    Py::Tuple result(2);\n-    result[0] = Py::Object(data, true);\n-    result[1] = bounds;\n-\n-    return result;\n-}\n-\n-\n-Py::Object\n-RendererAgg::clear(const Py::Tuple& args)\n-{\n-    //\"clear the rendered buffer\";\n-\n-    _VERBOSE(\"RendererAgg::clear\");\n-\n-    args.verify_length(0);\n     rendererBase.clear(_fill_color);\n-\n-    return Py::Object();\n-}\n-\n-\n-agg::rgba\n-RendererAgg::rgb_to_color(const Py::SeqBase<Py::Object>& rgb, double alpha)\n-{\n-    _VERBOSE(\"RendererAgg::rgb_to_color\");\n-\n-    double r = Py::Float(rgb[0]);\n-    double g = Py::Float(rgb[1]);\n-    double b = Py::Float(rgb[2]);\n-    return agg::rgba(r, g, b, alpha);\n-}\n-\n-\n-double\n-RendererAgg::points_to_pixels(const Py::Object& points)\n-{\n-    _VERBOSE(\"RendererAgg::points_to_pixels\");\n-    double p = Py::Float(points) ;\n-    return p * dpi / 72.0;\n-}\n-\n-#if PY3K\n-int\n-RendererAgg::buffer_get( Py_buffer* buf, int flags )\n-{\n-    return PyBuffer_FillInfo(buf, this, pixBuffer, width * height * 4, 1,\n-                             PyBUF_SIMPLE);\n-}\n-#endif\n-\n-RendererAgg::~RendererAgg()\n-{\n-\n-    _VERBOSE(\"RendererAgg::~RendererAgg\");\n-\n-    delete [] alphaBuffer;\n-    delete [] pixBuffer;\n-}\n-\n-/* ------------ module methods ------------- */\n-Py::Object _backend_agg_module::new_renderer(const Py::Tuple &args,\n-        const Py::Dict &kws)\n-{\n-\n-    if (args.length() != 3)\n-    {\n-        throw Py::RuntimeError(\"Incorrect # of args to RendererAgg(width, height, dpi).\");\n-    }\n-\n-    int debug;\n-    if (kws.hasKey(\"debug\"))\n-    {\n-        debug = Py::Int(kws[\"debug\"]);\n-    }\n-    else\n-    {\n-        debug = 0;\n-    }\n-\n-    unsigned int width = (int)Py::Int(args[0]);\n-    unsigned int height = (int)Py::Int(args[1]);\n-    double dpi = Py::Float(args[2]);\n-\n-    if (width > 1 << 15 || height > 1 << 15)\n-    {\n-        throw Py::ValueError(\"width and height must each be below 32768\");\n-    }\n-\n-    if (dpi <= 0.0)\n-    {\n-        throw Py::ValueError(\"dpi must be positive\");\n-    }\n-\n-    RendererAgg* renderer = NULL;\n-    try\n-    {\n-        renderer = new RendererAgg(width, height, dpi, debug);\n-    }\n-    catch (std::bad_alloc)\n-    {\n-        throw Py::RuntimeError(\"Could not allocate memory for image\");\n-    }\n-\n-    return Py::asObject(renderer);\n-}\n-\n-\n-void BufferRegion::init_type()\n-{\n-    behaviors().name(\"BufferRegion\");\n-    behaviors().doc(\"A wrapper to pass agg buffer objects to and from the python level\");\n-\n-\n-    add_varargs_method(\"set_x\", &BufferRegion::set_x,\n-                       \"set_x(x)\");\n-\n-    add_varargs_method(\"set_y\", &BufferRegion::set_y,\n-                       \"set_y(y)\");\n-\n-    add_varargs_method(\"get_extents\", &BufferRegion::get_extents,\n-                       \"get_extents()\");\n-\n-    add_varargs_method(\"to_string\", &BufferRegion::to_string,\n-                       \"to_string()\");\n-    add_varargs_method(\"to_string_argb\", &BufferRegion::to_string_argb,\n-                       \"to_string_argb()\");\n-}\n-\n-\n-void RendererAgg::init_type()\n-{\n-    behaviors().name(\"RendererAgg\");\n-    behaviors().doc(\"The agg backend extension module\");\n-\n-    add_varargs_method(\"draw_path\", &RendererAgg::draw_path,\n-                       \"draw_path(gc, path, transform, rgbFace)\\n\");\n-    add_varargs_method(\"draw_path_collection\", &RendererAgg::draw_path_collection,\n-                       \"draw_path_collection(gc, master_transform, paths, transforms, offsets, offsetTrans, facecolors, edgecolors, linewidths, linestyles, antialiaseds)\\n\");\n-    add_varargs_method(\"draw_quad_mesh\", &RendererAgg::draw_quad_mesh,\n-                       \"draw_quad_mesh(gc, master_transform, meshWidth, meshHeight, coordinates, offsets, offsetTrans, facecolors, antialiaseds, showedges)\\n\");\n-    add_varargs_method(\"draw_gouraud_triangle\", &RendererAgg::draw_gouraud_triangle,\n-                       \"draw_gouraud_triangle(gc, points, colors, master_transform)\\n\");\n-    add_varargs_method(\"draw_gouraud_triangles\", &RendererAgg::draw_gouraud_triangles,\n-                       \"draw_gouraud_triangles(gc, points, colors, master_transform)\\n\");\n-    add_varargs_method(\"draw_markers\", &RendererAgg::draw_markers,\n-                       \"draw_markers(gc, marker_path, marker_trans, path, rgbFace)\\n\");\n-    add_varargs_method(\"draw_text_image\", &RendererAgg::draw_text_image,\n-                       \"draw_text_image(font_image, x, y, r, g, b, a)\\n\");\n-    add_varargs_method(\"draw_image\", &RendererAgg::draw_image,\n-                       \"draw_image(gc, x, y, im)\");\n-    add_varargs_method(\"write_rgba\", &RendererAgg::write_rgba,\n-                       \"write_rgba(fname)\");\n-    add_varargs_method(\"tostring_rgb\", &RendererAgg::tostring_rgb,\n-                       \"s = tostring_rgb()\");\n-    add_varargs_method(\"tostring_argb\", &RendererAgg::tostring_argb,\n-                       \"s = tostring_argb()\");\n-    add_varargs_method(\"tostring_bgra\", &RendererAgg::tostring_bgra,\n-                       \"s = tostring_bgra()\");\n-    add_varargs_method(\"tostring_rgba_minimized\", &RendererAgg::tostring_rgba_minimized,\n-                       \"s = tostring_rgba_minimized()\");\n-    add_varargs_method(\"buffer_rgba\", &RendererAgg::buffer_rgba,\n-                       \"buffer = buffer_rgba()\");\n-    add_varargs_method(\"clear\", &RendererAgg::clear,\n-                       \"clear()\");\n-    add_varargs_method(\"copy_from_bbox\", &RendererAgg::copy_from_bbox,\n-                       \"copy_from_bbox(bbox)\");\n-    add_varargs_method(\"restore_region\", &RendererAgg::restore_region,\n-                       \"restore_region(region)\");\n-    add_varargs_method(\"restore_region2\", &RendererAgg::restore_region2,\n-                       \"restore_region(region, x1, y1, x2, y2, x3, y3)\");\n-\n-    #if PY3K\n-    behaviors().supportBufferType();\n-    #endif\n-}\n-\n-PyMODINIT_FUNC\n-#if PY3K\n-PyInit__backend_agg(void)\n-#else\n-init_backend_agg(void)\n-#endif\n-{\n-    //static _backend_agg_module* _backend_agg = new _backend_agg_module;\n-\n-    _VERBOSE(\"init_backend_agg\");\n-\n-    import_array();\n-\n-    static _backend_agg_module* _backend_agg = NULL;\n-    _backend_agg = new _backend_agg_module;\n-\n-    #if PY3K\n-    return _backend_agg->module().ptr();\n-    #endif\n }"}
{"patches_id": 2, "files_id": 29, "language": "h", "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_backend_agg.h", "raw_code": "/* -*- mode: c++; c-basic-offset: 4 -*- */\n\n/* _backend_agg.h\n*/\n\n#ifndef __BACKEND_AGG_H__\n#define __BACKEND_AGG_H__\n\n#include <vector>\n\n#include \"agg_alpha_mask_u8.h\"\n#include \"agg_conv_curve.h\"\n#include \"agg_conv_dash.h\"\n#include \"agg_conv_stroke.h\"\n#include \"agg_image_accessors.h\"\n#include \"agg_pixfmt_amask_adaptor.h\"\n#include \"agg_pixfmt_gray.h\"\n#include \"agg_pixfmt_rgba.h\"\n#include \"agg_rasterizer_scanline_aa.h\"\n#include \"agg_renderer_base.h\"\n#include \"agg_renderer_scanline.h\"\n#include \"agg_rendering_buffer.h\"\n#include \"agg_scanline_bin.h\"\n#include \"agg_scanline_p.h\"\n#include \"agg_scanline_storage_aa.h\"\n#include \"agg_scanline_storage_bin.h\"\n#include \"agg_scanline_u.h\"\n#include \"agg_span_allocator.h\"\n#include \"agg_span_converter.h\"\n#include \"agg_span_gouraud_rgba.h\"\n#include \"agg_span_image_filter_gray.h\"\n#include \"agg_span_image_filter_rgba.h\"\n#include \"agg_span_interpolator_linear.h\"\n#include \"agg_span_pattern_rgba.h\"\n#include \"util/agg_color_conv_rgb8.h\"\n\n#include \"_backend_agg_basic_types.h\"\n#include \"path_converters.h\"\n#include \"array.h\"\n\ntypedef agg::pixfmt_rgba32_plain pixfmt;\ntypedef agg::renderer_base<pixfmt> renderer_base;\ntypedef agg::renderer_scanline_aa_solid<renderer_base> renderer_aa;\ntypedef agg::renderer_scanline_bin_solid<renderer_base> renderer_bin;\ntypedef agg::rasterizer_scanline_aa<agg::rasterizer_sl_clip_dbl> rasterizer;\n\ntypedef agg::scanline_p8 scanline_p8;\ntypedef agg::scanline_bin scanline_bin;\ntypedef agg::amask_no_clip_gray8 alpha_mask_type;\ntypedef agg::scanline_u8_am<alpha_mask_type> scanline_am;\n\ntypedef agg::renderer_base<agg::pixfmt_gray8> renderer_base_alpha_mask_type;\ntypedef agg::renderer_scanline_aa_solid<renderer_base_alpha_mask_type> renderer_alpha_mask_type;\n\n// a helper class to pass agg::buffer objects around.  agg::buffer is\n// a class in the swig wrapper\nclass BufferRegion\n{\n  public:\n    BufferRegion(const agg::rect_i &r) : rect(r)\n    {\n        width = r.x2 - r.x1;\n        height = r.y2 - r.y1;\n        stride = width * 4;\n        data = new agg::int8u[stride * height];\n    }\n\n    virtual ~BufferRegion()\n    {\n        delete[] data;\n    };\n\n    agg::int8u *get_data()\n    {\n        return data;\n    }\n\n    agg::rect_i &get_rect()\n    {\n        return rect;\n    }\n\n    int get_width()\n    {\n        return width;\n    }\n\n    int get_height()\n    {\n        return height;\n    }\n\n    int get_stride()\n    {\n        return stride;\n    }\n\n    void to_string_argb(uint8_t *buf);\n\n  private:\n    agg::int8u *data;\n    agg::rect_i rect;\n    int width;\n    int height;\n    int stride;\n\n  private:\n    // prevent copying\n    BufferRegion(const BufferRegion &);\n    BufferRegion &operator=(const BufferRegion &);\n};\n\n#define MARKER_CACHE_SIZE 512\n\n// the renderer\nclass RendererAgg\n{\n    /* TODO: Remove facepair_t */\n    typedef std::pair<bool, agg::rgba> facepair_t;\n\n  public:\n    RendererAgg(unsigned int width, unsigned int height, double dpi);\n\n    virtual ~RendererAgg();\n\n    unsigned int get_width()\n    {\n        return width;\n    }\n\n    unsigned int get_height()\n    {\n        return height;\n    }\n\n    template <class PathIterator>\n    void draw_path(GCAgg &gc, PathIterator &path, agg::trans_affine &trans, agg::rgba &color);\n\n    template <class PathIterator>\n    void draw_markers(GCAgg &gc,\n                      PathIterator &marker_path,\n                      agg::trans_affine &marker_path_trans,\n                      PathIterator &path,\n                      agg::trans_affine &trans,\n                      agg::rgba face);\n\n    template <class ImageArray>\n    void draw_text_image(GCAgg &gc, ImageArray &image, int x, int y, double angle);\n\n    template <class ImageArray>\n    void draw_image(GCAgg &gc,\n                    double x,\n                    double y,\n                    ImageArray &image,\n                    double w,\n                    double h,\n                    agg::trans_affine trans,\n                    bool resize);\n\n    template <class PathGenerator,\n              class TransformArray,\n              class OffsetArray,\n              class ColorArray,\n              class LineWidthArray,\n              class AntialiasedArray>\n    void draw_path_collection(GCAgg &gc,\n                              agg::trans_affine &master_transform,\n                              PathGenerator &path,\n                              TransformArray &transforms,\n                              OffsetArray &offsets,\n                              agg::trans_affine &offset_trans,\n                              ColorArray &facecolors,\n                              ColorArray &edgecolors,\n                              LineWidthArray &linewidths,\n                              DashesVector &linestyles,\n                              AntialiasedArray &antialiaseds,\n                              e_offset_position offset_position);\n\n    template <class CoordinateArray, class OffsetArray, class ColorArray>\n    void draw_quad_mesh(GCAgg &gc,\n                        agg::trans_affine &master_transform,\n                        size_t mesh_width,\n                        size_t mesh_height,\n                        CoordinateArray &coordinates,\n                        OffsetArray &offsets,\n                        agg::trans_affine &offset_trans,\n                        ColorArray &facecolors,\n                        bool antialiased,\n                        ColorArray &edgecolors);\n\n    template <class PointArray, class ColorArray>\n    void draw_gouraud_triangle(GCAgg &gc,\n                               PointArray &points,\n                               ColorArray &colors,\n                               agg::trans_affine &trans);\n\n    template <class PointArray, class ColorArray>\n    void draw_gouraud_triangles(GCAgg &gc,\n                                PointArray &points,\n                                ColorArray &colors,\n                                agg::trans_affine &trans);\n\n    void tostring_rgb(uint8_t *buf);\n    void tostring_argb(uint8_t *buf);\n    void tostring_bgra(uint8_t *buf);\n    agg::rect_i get_content_extents();\n    void clear();\n\n    BufferRegion *copy_from_bbox(agg::rect_d in_rect);\n    void restore_region(BufferRegion &reg);\n    void restore_region(BufferRegion &region, int x, int y, int xx1, int yy1, int xx2, int yy2);\n\n    unsigned int width, height;\n    double dpi;\n    size_t NUMBYTES; // the number of bytes in buffer\n\n    agg::int8u *pixBuffer;\n    agg::rendering_buffer renderingBuffer;\n\n    agg::int8u *alphaBuffer;\n    agg::rendering_buffer alphaMaskRenderingBuffer;\n    alpha_mask_type alphaMask;\n    agg::pixfmt_gray8 pixfmtAlphaMask;\n    renderer_base_alpha_mask_type rendererBaseAlphaMask;\n    renderer_alpha_mask_type rendererAlphaMask;\n    scanline_am scanlineAlphaMask;\n\n    scanline_p8 slineP8;\n    scanline_bin slineBin;\n    pixfmt pixFmt;\n    renderer_base rendererBase;\n    renderer_aa rendererAA;\n    renderer_bin rendererBin;\n    rasterizer theRasterizer;\n\n    void *lastclippath;\n    agg::trans_affine lastclippath_transform;\n\n    static const size_t HATCH_SIZE = 72;\n    agg::int8u hatchBuffer[HATCH_SIZE * HATCH_SIZE * 4];\n    agg::rendering_buffer hatchRenderingBuffer;\n\n    agg::rgba _fill_color;\n\n  protected:\n    inline double points_to_pixels(double points)\n    {\n        return points * dpi / 72.0;\n    }\n\n    template <class R>\n    void set_clipbox(const agg::rect_d &cliprect, R &rasterizer);\n\n    bool render_clippath(py::PathIterator &clippath, const agg::trans_affine &clippath_trans);\n\n    template <class PathIteratorType>\n    void _draw_path(PathIteratorType &path, bool has_clippath, const facepair_t &face, GCAgg &gc);\n\n    template <class PathIterator,\n              class PathGenerator,\n              class TransformArray,\n              class OffsetArray,\n              class ColorArray,\n              class LineWidthArray,\n              class AntialiasedArray>\n    void _draw_path_collection_generic(GCAgg &gc,\n                                       agg::trans_affine master_transform,\n                                       const agg::rect_d &cliprect,\n                                       PathIterator &clippath,\n                                       const agg::trans_affine &clippath_trans,\n                                       PathGenerator &path_generator,\n                                       TransformArray &transforms,\n                                       OffsetArray &offsets,\n                                       const agg::trans_affine &offset_trans,\n                                       ColorArray &facecolors,\n                                       ColorArray &edgecolors,\n                                       LineWidthArray &linewidths,\n                                       DashesVector &linestyles,\n                                       AntialiasedArray &antialiaseds,\n                                       e_offset_position offset_position,\n                                       int check_snap,\n                                       int has_curves);\n\n    template <class PointArray, class ColorArray>\n    void _draw_gouraud_triangle(PointArray &points,\n                                ColorArray &colors,\n                                agg::trans_affine trans,\n                                bool has_clippath);\n\n  private:\n    void create_alpha_buffers();\n\n    // prevent copying\n    RendererAgg(const RendererAgg &);\n    RendererAgg &operator=(const RendererAgg &);\n};\n\n/***************************************************************************\n * Implementation\n */\n\ntemplate <class path_t>\ninline void\nRendererAgg::_draw_path(path_t &path, bool has_clippath, const facepair_t &face, GCAgg &gc)\n{\n    typedef agg::conv_stroke<path_t> stroke_t;\n    typedef agg::conv_dash<path_t> dash_t;\n    typedef agg::conv_stroke<dash_t> stroke_dash_t;\n    typedef agg::pixfmt_amask_adaptor<pixfmt, alpha_mask_type> pixfmt_amask_type;\n    typedef agg::renderer_base<pixfmt_amask_type> amask_ren_type;\n    typedef agg::renderer_scanline_aa_solid<amask_ren_type> amask_aa_renderer_type;\n    typedef agg::renderer_scanline_bin_solid<amask_ren_type> amask_bin_renderer_type;\n\n    // Render face\n    if (face.first) {\n        theRasterizer.add_path(path);\n\n        if (gc.isaa) {\n            if (has_clippath) {\n                pixfmt_amask_type pfa(pixFmt, alphaMask);\n                amask_ren_type r(pfa);\n                amask_aa_renderer_type ren(r);\n                ren.color(face.second);\n                agg::render_scanlines(theRasterizer, scanlineAlphaMask, ren);\n            } else {\n                rendererAA.color(face.second);\n                agg::render_scanlines(theRasterizer, slineP8, rendererAA);\n            }\n        } else {\n            if (has_clippath) {\n                pixfmt_amask_type pfa(pixFmt, alphaMask);\n                amask_ren_type r(pfa);\n                amask_bin_renderer_type ren(r);\n                ren.color(face.second);\n                agg::render_scanlines(theRasterizer, scanlineAlphaMask, ren);\n            } else {\n                rendererBin.color(face.second);\n                agg::render_scanlines(theRasterizer, slineP8, rendererBin);\n            }\n        }\n    }\n\n    // Render hatch\n    if (gc.has_hatchpath()) {\n        // Reset any clipping that may be in effect, since we'll be\n        // drawing the hatch in a scratch buffer at origin (0, 0)\n        theRasterizer.reset_clipping();\n        rendererBase.reset_clipping(true);\n\n        // Create and transform the path\n        typedef agg::conv_transform<py::PathIterator> hatch_path_trans_t;\n        typedef agg::conv_curve<hatch_path_trans_t> hatch_path_curve_t;\n        typedef agg::conv_stroke<hatch_path_curve_t> hatch_path_stroke_t;\n\n        py::PathIterator hatch_path(gc.hatchpath);\n        agg::trans_affine hatch_trans;\n        hatch_trans *= agg::trans_affine_scaling(1.0, -1.0);\n        hatch_trans *= agg::trans_affine_translation(0.0, 1.0);\n        hatch_trans *= agg::trans_affine_scaling(HATCH_SIZE, HATCH_SIZE);\n        hatch_path_trans_t hatch_path_trans(hatch_path, hatch_trans);\n        hatch_path_curve_t hatch_path_curve(hatch_path_trans);\n        hatch_path_stroke_t hatch_path_stroke(hatch_path_curve);\n        hatch_path_stroke.width(1.0);\n        hatch_path_stroke.line_cap(agg::square_cap);\n\n        // Render the path into the hatch buffer\n        pixfmt hatch_img_pixf(hatchRenderingBuffer);\n        renderer_base rb(hatch_img_pixf);\n        renderer_aa rs(rb);\n        rb.clear(_fill_color);\n        rs.color(gc.color);\n\n        theRasterizer.add_path(hatch_path_curve);\n        agg::render_scanlines(theRasterizer, slineP8, rs);\n        theRasterizer.add_path(hatch_path_stroke);\n        agg::render_scanlines(theRasterizer, slineP8, rs);\n\n        // Put clipping back on, if originally set on entry to this\n        // function\n        set_clipbox(gc.cliprect, theRasterizer);\n        if (has_clippath) {\n            render_clippath(gc.clippath.path, gc.clippath.trans);\n        }\n\n        // Transfer the hatch to the main image buffer\n        typedef agg::image_accessor_wrap<pixfmt,\n                                         agg::wrap_mode_repeat_auto_pow2,\n                                         agg::wrap_mode_repeat_auto_pow2> img_source_type;\n        typedef agg::span_pattern_rgba<img_source_type> span_gen_type;\n        agg::span_allocator<agg::rgba8> sa;\n        img_source_type img_src(hatch_img_pixf);\n        span_gen_type sg(img_src, 0, 0);\n        theRasterizer.add_path(path);\n\n        if (has_clippath) {\n            pixfmt_amask_type pfa(pixFmt, alphaMask);\n            amask_ren_type ren(pfa);\n            agg::render_scanlines_aa(theRasterizer, slineP8, ren, sa, sg);\n        } else {\n            agg::render_scanlines_aa(theRasterizer, slineP8, rendererBase, sa, sg);\n        }\n    }\n\n    // Render stroke\n    if (gc.linewidth != 0.0) {\n        double linewidth = points_to_pixels(gc.linewidth);\n        if (!gc.isaa) {\n            linewidth = (linewidth < 0.5) ? 0.5 : mpl_round(linewidth);\n        }\n        if (gc.dashes.size() == 0) {\n            stroke_t stroke(path);\n            stroke.width(points_to_pixels(gc.linewidth));\n            stroke.line_cap(gc.cap);\n            stroke.line_join(gc.join);\n            theRasterizer.add_path(stroke);\n        } else {\n            dash_t dash(path);\n            gc.dashes.dash_to_stroke(dash, dpi, gc.isaa);\n            stroke_dash_t stroke(dash);\n            stroke.line_cap(gc.cap);\n            stroke.line_join(gc.join);\n            stroke.width(linewidth);\n            theRasterizer.add_path(stroke);\n        }\n\n        if (gc.isaa) {\n            if (has_clippath) {\n                pixfmt_amask_type pfa(pixFmt, alphaMask);\n                amask_ren_type r(pfa);\n                amask_aa_renderer_type ren(r);\n                ren.color(gc.color);\n                agg::render_scanlines(theRasterizer, scanlineAlphaMask, ren);\n            } else {\n                rendererAA.color(gc.color);\n                agg::render_scanlines(theRasterizer, slineP8, rendererAA);\n            }\n        } else {\n            if (has_clippath) {\n                pixfmt_amask_type pfa(pixFmt, alphaMask);\n                amask_ren_type r(pfa);\n                amask_bin_renderer_type ren(r);\n                ren.color(gc.color);\n                agg::render_scanlines(theRasterizer, scanlineAlphaMask, ren);\n            } else {\n                rendererBin.color(gc.color);\n                agg::render_scanlines(theRasterizer, slineBin, rendererBin);\n            }\n        }\n    }\n}\n\ntemplate <class PathIterator>\ninline void\nRendererAgg::draw_path(GCAgg &gc, PathIterator &path, agg::trans_affine &trans, agg::rgba &color)\n{\n    typedef agg::conv_transform<py::PathIterator> transformed_path_t;\n    typedef PathNanRemover<transformed_path_t> nan_removed_t;\n    typedef PathClipper<nan_removed_t> clipped_t;\n    typedef PathSnapper<clipped_t> snapped_t;\n    typedef PathSimplifier<snapped_t> simplify_t;\n    typedef agg::conv_curve<simplify_t> curve_t;\n    typedef Sketch<curve_t> sketch_t;\n\n    facepair_t face(color.a != 0.0, color);\n\n    theRasterizer.reset_clipping();\n    rendererBase.reset_clipping(true);\n    set_clipbox(gc.cliprect, theRasterizer);\n    bool has_clippath = render_clippath(gc.clippath.path, gc.clippath.trans);\n\n    trans *= agg::trans_affine_scaling(1.0, -1.0);\n    trans *= agg::trans_affine_translation(0.0, (double)height);\n    bool clip = !face.first && gc.has_hatchpath() && !path.has_curves();\n    bool simplify = path.should_simplify() && clip;\n    double snapping_linewidth = points_to_pixels(gc.linewidth);\n    if (gc.color.a == 0.0) {\n        snapping_linewidth = 0.0;\n    }\n\n    transformed_path_t tpath(path, trans);\n    nan_removed_t nan_removed(tpath, true, path.has_curves());\n    clipped_t clipped(nan_removed, clip, width, height);\n    snapped_t snapped(clipped, gc.snap_mode, path.total_vertices(), snapping_linewidth);\n    simplify_t simplified(snapped, simplify, path.simplify_threshold());\n    curve_t curve(simplified);\n    sketch_t sketch(curve, gc.sketch.scale, gc.sketch.length, gc.sketch.randomness);\n\n    _draw_path(sketch, has_clippath, face, gc);\n}\n\ntemplate <class PathIterator>\ninline void RendererAgg::draw_markers(GCAgg &gc,\n                                      PathIterator &marker_path,\n                                      agg::trans_affine &marker_trans,\n                                      PathIterator &path,\n                                      agg::trans_affine &trans,\n                                      agg::rgba color)\n{\n    typedef agg::conv_transform<py::PathIterator> transformed_path_t;\n    typedef PathSnapper<transformed_path_t> snap_t;\n    typedef agg::conv_curve<snap_t> curve_t;\n    typedef agg::conv_stroke<curve_t> stroke_t;\n    typedef agg::pixfmt_amask_adaptor<pixfmt, alpha_mask_type> pixfmt_amask_type;\n    typedef agg::renderer_base<pixfmt_amask_type> amask_ren_type;\n    typedef agg::renderer_scanline_aa_solid<amask_ren_type> amask_aa_renderer_type;\n\n    // Deal with the difference in y-axis direction\n    marker_trans *= agg::trans_affine_scaling(1.0, -1.0);\n    trans *= agg::trans_affine_scaling(1.0, -1.0);\n    trans *= agg::trans_affine_translation(0.5, (double)height + 0.5);\n\n    transformed_path_t marker_path_transformed(marker_path, marker_trans);\n    snap_t marker_path_snapped(marker_path_transformed,\n                               gc.snap_mode,\n                               marker_path.total_vertices(),\n                               points_to_pixels(gc.linewidth));\n    curve_t marker_path_curve(marker_path_snapped);\n\n    transformed_path_t path_transformed(path, trans);\n    snap_t path_snapped(path_transformed, SNAP_FALSE, path.total_vertices(), 0.0);\n    curve_t path_curve(path_snapped);\n    path_curve.rewind(0);\n\n    facepair_t face(color.a != 0.0, color);\n\n    // maxim's suggestions for cached scanlines\n    agg::scanline_storage_aa8 scanlines;\n    theRasterizer.reset();\n    theRasterizer.reset_clipping();\n    rendererBase.reset_clipping(true);\n\n    agg::int8u staticFillCache[MARKER_CACHE_SIZE];\n    agg::int8u staticStrokeCache[MARKER_CACHE_SIZE];\n    agg::int8u *fillCache = staticFillCache;\n    agg::int8u *strokeCache = staticStrokeCache;\n\n    try\n    {\n        unsigned fillSize = 0;\n        if (face.first) {\n            theRasterizer.add_path(marker_path_curve);\n            agg::render_scanlines(theRasterizer, slineP8, scanlines);\n            fillSize = scanlines.byte_size();\n            if (fillSize >= MARKER_CACHE_SIZE) {\n                fillCache = new agg::int8u[fillSize];\n            }\n            scanlines.serialize(fillCache);\n        }\n\n        stroke_t stroke(marker_path_curve);\n        stroke.width(points_to_pixels(gc.linewidth));\n        stroke.line_cap(gc.cap);\n        stroke.line_join(gc.join);\n        theRasterizer.reset();\n        theRasterizer.add_path(stroke);\n        agg::render_scanlines(theRasterizer, slineP8, scanlines);\n        unsigned strokeSize = scanlines.byte_size();\n        if (strokeSize >= MARKER_CACHE_SIZE) {\n            strokeCache = new agg::int8u[strokeSize];\n        }\n        scanlines.serialize(strokeCache);\n\n        theRasterizer.reset_clipping();\n        rendererBase.reset_clipping(true);\n        set_clipbox(gc.cliprect, rendererBase);\n        bool has_clippath = render_clippath(gc.clippath.path, gc.clippath.trans);\n\n        double x, y;\n\n        agg::serialized_scanlines_adaptor_aa8 sa;\n        agg::serialized_scanlines_adaptor_aa8::embedded_scanline sl;\n\n        agg::rect_d clipping_rect(-1.0 - scanlines.max_x(),\n                                  -1.0 - scanlines.max_y(),\n                                  1.0 + width - scanlines.min_x(),\n                                  1.0 + height - scanlines.min_y());\n\n        if (has_clippath) {\n            while (path_curve.vertex(&x, &y) != agg::path_cmd_stop) {\n                if (MPL_notisfinite64(x) || MPL_notisfinite64(y)) {\n                    continue;\n                }\n\n                /* These values are correctly snapped above -- so we don't want\n                   to round here, we really only want to truncate */\n                x = floor(x);\n                y = floor(y);\n\n                // Cull points outside the boundary of the image.\n                // Values that are too large may overflow and create\n                // segfaults.\n                // http://sourceforge.net/tracker/?func=detail&aid=2865490&group_id=80706&atid=560720\n                if (!clipping_rect.hit_test(x, y)) {\n                    continue;\n                }\n\n                pixfmt_amask_type pfa(pixFmt, alphaMask);\n                amask_ren_type r(pfa);\n                amask_aa_renderer_type ren(r);\n\n                if (face.first) {\n                    ren.color(face.second);\n                    sa.init(fillCache, fillSize, x, y);\n                    agg::render_scanlines(sa, sl, ren);\n                }\n                ren.color(gc.color);\n                sa.init(strokeCache, strokeSize, x, y);\n                agg::render_scanlines(sa, sl, ren);\n            }\n        } else {\n            while (path_curve.vertex(&x, &y) != agg::path_cmd_stop) {\n                if (MPL_notisfinite64(x) || MPL_notisfinite64(y)) {\n                    continue;\n                }\n\n                /* These values are correctly snapped above -- so we don't want\n                   to round here, we really only want to truncate */\n                x = floor(x);\n                y = floor(y);\n\n                // Cull points outside the boundary of the image.\n                // Values that are too large may overflow and create\n                // segfaults.\n                // http://sourceforge.net/tracker/?func=detail&aid=2865490&group_id=80706&atid=560720\n                if (!clipping_rect.hit_test(x, y)) {\n                    continue;\n                }\n\n                if (face.first) {\n                    rendererAA.color(face.second);\n                    sa.init(fillCache, fillSize, x, y);\n                    agg::render_scanlines(sa, sl, rendererAA);\n                }\n\n                rendererAA.color(gc.color);\n                sa.init(strokeCache, strokeSize, x, y);\n                agg::render_scanlines(sa, sl, rendererAA);\n            }\n        }\n    }\n    catch (...)\n    {\n        if (fillCache != staticFillCache)\n            delete[] fillCache;\n        if (strokeCache != staticStrokeCache)\n            delete[] strokeCache;\n        theRasterizer.reset_clipping();\n        rendererBase.reset_clipping(true);\n        throw;\n    }\n\n    if (fillCache != staticFillCache)\n        delete[] fillCache;\n    if (strokeCache != staticStrokeCache)\n        delete[] strokeCache;\n\n    theRasterizer.reset_clipping();\n    rendererBase.reset_clipping(true);\n}\n\n/**\n * This is a custom span generator that converts spans in the\n * 8-bit inverted greyscale font buffer to rgba that agg can use.\n */\ntemplate <class ChildGenerator>\nclass font_to_rgba\n{\n  public:\n    typedef ChildGenerator child_type;\n    typedef agg::rgba8 color_type;\n    typedef typename child_type::color_type child_color_type;\n    typedef agg::span_allocator<child_color_type> span_alloc_type;\n\n  private:\n    child_type *_gen;\n    color_type _color;\n    span_alloc_type _allocator;\n\n  public:\n    font_to_rgba(child_type *gen, color_type color) : _gen(gen), _color(color)\n    {\n    }\n\n    inline void generate(color_type *output_span, int x, int y, unsigned len)\n    {\n        _allocator.allocate(len);\n        child_color_type *input_span = _allocator.span();\n        _gen->generate(input_span, x, y, len);\n\n        do {\n            *output_span = _color;\n            output_span->a = ((unsigned int)_color.a * (unsigned int)input_span->v) >> 8;\n            ++output_span;\n            ++input_span;\n        } while (--len);\n    }\n\n    void prepare()\n    {\n        _gen->prepare();\n    }\n};\n\ntemplate <class ImageArray>\ninline void RendererAgg::draw_text_image(GCAgg &gc, ImageArray &image, int x, int y, double angle)\n{\n    typedef agg::span_allocator<agg::rgba8> color_span_alloc_type;\n    typedef agg::span_interpolator_linear<> interpolator_type;\n    typedef agg::image_accessor_clip<agg::pixfmt_gray8> image_accessor_type;\n    typedef agg::span_image_filter_gray<image_accessor_type, interpolator_type> image_span_gen_type;\n    typedef font_to_rgba<image_span_gen_type> span_gen_type;\n    typedef agg::renderer_scanline_aa<renderer_base, color_span_alloc_type, span_gen_type>\n    renderer_type;\n\n    theRasterizer.reset_clipping();\n    rendererBase.reset_clipping(true);\n    set_clipbox(gc.cliprect, theRasterizer);\n\n    agg::rendering_buffer srcbuf(\n        image.data(), (unsigned)image.dim(1), (unsigned)image.dim(0), (unsigned)image.dim(1));\n    agg::pixfmt_gray8 pixf_img(srcbuf);\n\n    agg::trans_affine mtx;\n    mtx *= agg::trans_affine_translation(0, -image.dim(0));\n    mtx *= agg::trans_affine_rotation(-angle * agg::pi / 180.0);\n    mtx *= agg::trans_affine_translation(x, y);\n\n    agg::path_storage rect;\n    rect.move_to(0, 0);\n    rect.line_to(image.dim(1), 0);\n    rect.line_to(image.dim(1), image.dim(0));\n    rect.line_to(0, image.dim(0));\n    rect.line_to(0, 0);\n    agg::conv_transform<agg::path_storage> rect2(rect, mtx);\n\n    agg::trans_affine inv_mtx(mtx);\n    inv_mtx.invert();\n\n    agg::image_filter_lut filter;\n    filter.calculate(agg::image_filter_spline36());\n    interpolator_type interpolator(inv_mtx);\n    color_span_alloc_type sa;\n    image_accessor_type ia(pixf_img, 0);\n    image_span_gen_type image_span_generator(ia, interpolator, filter);\n    span_gen_type output_span_generator(&image_span_generator, gc.color);\n    renderer_type ri(rendererBase, sa, output_span_generator);\n\n    theRasterizer.add_path(rect2);\n    agg::render_scanlines(theRasterizer, slineP8, ri);\n}\n\nclass span_conv_alpha\n{\n  public:\n    typedef agg::rgba8 color_type;\n\n    double m_alpha;\n\n    span_conv_alpha(double alpha) : m_alpha(alpha)\n    {\n    }\n\n    void prepare()\n    {\n    }\n    void generate(color_type *span, int x, int y, unsigned len) const\n    {\n        do {\n            span->a = (agg::int8u)((double)span->a * m_alpha);\n            ++span;\n        } while (--len);\n    }\n};\n\ntemplate <class ImageArray>\ninline void RendererAgg::draw_image(GCAgg &gc,\n                                    double x,\n                                    double y,\n                                    ImageArray &image,\n                                    double w,\n                                    double h,\n                                    agg::trans_affine trans,\n                                    bool resize)\n{\n    double alpha = gc.alpha;\n\n    theRasterizer.reset_clipping();\n    rendererBase.reset_clipping(true);\n    set_clipbox(gc.cliprect, theRasterizer);\n    bool has_clippath = render_clippath(gc.clippath.path, gc.clippath.trans);\n\n    agg::rendering_buffer buffer;\n    buffer.attach(\n        image.data(), (unsigned)image.dim(1), (unsigned)image.dim(0), -(int)image.dim(1) * 4);\n    pixfmt pixf(buffer);\n\n    if (resize | has_clippath) {\n        agg::trans_affine mtx;\n        agg::path_storage rect;\n\n        if (resize) {\n            mtx *= agg::trans_affine_scaling(1, -1);\n            mtx *= agg::trans_affine_translation(0, image.dim(0));\n            mtx *= agg::trans_affine_scaling(w / (image.dim(1)), h / (image.dim(0)));\n            mtx *= agg::trans_affine_translation(x, y);\n            mtx *= trans;\n            mtx *= agg::trans_affine_scaling(1.0, -1.0);\n            mtx *= agg::trans_affine_translation(0.0, (double)height);\n        } else {\n            mtx *= agg::trans_affine_translation((int)x, (int)(height - (y + image.dim(0))));\n        }\n\n        rect.move_to(0, 0);\n        rect.line_to(image.dim(1), 0);\n        rect.line_to(image.dim(1), image.dim(0));\n        rect.line_to(0, image.dim(0));\n        rect.line_to(0, 0);\n\n        agg::conv_transform<agg::path_storage> rect2(rect, mtx);\n\n        agg::trans_affine inv_mtx(mtx);\n        inv_mtx.invert();\n\n        typedef agg::span_allocator<agg::rgba8> color_span_alloc_type;\n        typedef agg::image_accessor_clip<agg::pixfmt_rgba32_plain> image_accessor_type;\n        typedef agg::span_interpolator_linear<> interpolator_type;\n        typedef agg::span_image_filter_rgba_nn<image_accessor_type, interpolator_type>\n        image_span_gen_type;\n        typedef agg::span_converter<image_span_gen_type, span_conv_alpha> span_conv;\n\n        color_span_alloc_type sa;\n        image_accessor_type ia(pixf, agg::rgba8(0, 0, 0, 0));\n        interpolator_type interpolator(inv_mtx);\n        image_span_gen_type image_span_generator(ia, interpolator);\n        span_conv_alpha conv_alpha(alpha);\n        span_conv spans(image_span_generator, conv_alpha);\n\n        if (has_clippath) {\n            typedef agg::pixfmt_amask_adaptor<pixfmt, alpha_mask_type> pixfmt_amask_type;\n            typedef agg::renderer_base<pixfmt_amask_type> amask_ren_type;\n            typedef agg::renderer_scanline_aa<amask_ren_type, color_span_alloc_type, span_conv>\n            renderer_type_alpha;\n\n            pixfmt_amask_type pfa(pixFmt, alphaMask);\n            amask_ren_type r(pfa);\n            renderer_type_alpha ri(r, sa, spans);\n\n            theRasterizer.add_path(rect2);\n            agg::render_scanlines(theRasterizer, scanlineAlphaMask, ri);\n        } else {\n            typedef agg::renderer_base<pixfmt> ren_type;\n            typedef agg::renderer_scanline_aa<ren_type, color_span_alloc_type, span_conv>\n            renderer_type;\n\n            ren_type r(pixFmt);\n            renderer_type ri(r, sa, spans);\n\n            theRasterizer.add_path(rect2);\n            agg::render_scanlines(theRasterizer, slineP8, ri);\n        }\n\n    } else {\n        set_clipbox(gc.cliprect, rendererBase);\n        rendererBase.blend_from(\n            pixf, 0, (int)x, (int)(height - (y + image.dim(0))), (agg::int8u)(alpha * 255));\n    }\n\n    rendererBase.reset_clipping(true);\n}\n\ntemplate <class PathIterator,\n          class PathGenerator,\n          class TransformArray,\n          class OffsetArray,\n          class ColorArray,\n          class LineWidthArray,\n          class AntialiasedArray>\ninline void RendererAgg::_draw_path_collection_generic(GCAgg &gc,\n                                                       agg::trans_affine master_transform,\n                                                       const agg::rect_d &cliprect,\n                                                       PathIterator &clippath,\n                                                       const agg::trans_affine &clippath_trans,\n                                                       PathGenerator &path_generator,\n                                                       TransformArray &transforms,\n                                                       OffsetArray &offsets,\n                                                       const agg::trans_affine &offset_trans,\n                                                       ColorArray &facecolors,\n                                                       ColorArray &edgecolors,\n                                                       LineWidthArray &linewidths,\n                                                       DashesVector &linestyles,\n                                                       AntialiasedArray &antialiaseds,\n                                                       e_offset_position offset_position,\n                                                       int check_snap,\n                                                       int has_curves)\n{\n    typedef agg::conv_transform<typename PathGenerator::path_iterator> transformed_path_t;\n    typedef PathNanRemover<transformed_path_t> nan_removed_t;\n    typedef PathClipper<nan_removed_t> clipped_t;\n    typedef PathSnapper<clipped_t> snapped_t;\n    typedef agg::conv_curve<snapped_t> snapped_curve_t;\n    typedef agg::conv_curve<clipped_t> curve_t;\n\n    if (offsets.dim(0) != 0 && offsets.dim(1) != 2) {\n        throw \"Offsets array must be Nx2 or empty\";\n    }\n\n    if (facecolors.dim(0) != 0 && facecolors.dim(1) != 4) {\n        throw \"Facecolors array must be a Nx4 array or empty\";\n    }\n\n    if (edgecolors.dim(0) != 0 && edgecolors.dim(1) != 4) {\n        throw \"Edgecolors array must by Nx4 or empty\";\n    }\n\n    if (transforms.dim(0) != 0 && (transforms.dim(1) != 3 || transforms.dim(2) != 3)) {\n        throw \"Transforms array must by Nx3x3 or empty\";\n    }\n\n    size_t Npaths = path_generator.num_paths();\n    size_t Noffsets = offsets.size();\n    size_t N = std::max(Npaths, Noffsets);\n\n    size_t Ntransforms = transforms.size();\n    size_t Nfacecolors = facecolors.size();\n    size_t Nedgecolors = edgecolors.size();\n    size_t Nlinewidths = linewidths.size();\n    size_t Nlinestyles = std::min(linestyles.size(), N);\n    size_t Naa = antialiaseds.size();\n\n    if ((Nfacecolors == 0 && Nedgecolors == 0) || Npaths == 0) {\n        return;\n    }\n\n    // Handle any clipping globally\n    theRasterizer.reset_clipping();\n    rendererBase.reset_clipping(true);\n    set_clipbox(cliprect, theRasterizer);\n    bool has_clippath = render_clippath(clippath, clippath_trans);\n\n    // Set some defaults, assuming no face or edge\n    gc.linewidth = 0.0;\n    facepair_t face;\n    face.first = Nfacecolors != 0;\n    agg::trans_affine trans;\n\n    for (int i = 0; i < (int)N; ++i) {\n        typename PathGenerator::path_iterator path = path_generator(i);\n\n        if (Ntransforms) {\n            typename TransformArray::sub_t subtrans = transforms[i % Ntransforms];\n            trans = agg::trans_affine(subtrans(0, 0),\n                                      subtrans(1, 0),\n                                      subtrans(0, 1),\n                                      subtrans(1, 1),\n                                      subtrans(0, 2),\n                                      subtrans(1, 2));\n        } else {\n            trans = master_transform;\n        }\n\n        if (Noffsets) {\n            double xo = offsets(i % Noffsets, 0);\n            double yo = offsets(i % Noffsets, 1);\n            offset_trans.transform(&xo, &yo);\n            if (offset_position == OFFSET_POSITION_DATA) {\n                trans = agg::trans_affine_translation(xo, yo) * trans;\n            } else {\n                trans *= agg::trans_affine_translation(xo, yo);\n            }\n        }\n\n        // These transformations must be done post-offsets\n        trans *= agg::trans_affine_scaling(1.0, -1.0);\n        trans *= agg::trans_affine_translation(0.0, (double)height);\n\n        if (Nfacecolors) {\n            typename ColorArray::sub_t facecolor = facecolors[i % Nfacecolors];\n            face.second = agg::rgba(facecolor(0), facecolor(1), facecolor(2), facecolor(3));\n        }\n\n        if (Nedgecolors) {\n            typename ColorArray::sub_t edgecolor = edgecolors[i % Nedgecolors];\n            gc.color = agg::rgba(edgecolor(0), edgecolor(1), edgecolor(2), edgecolor(3));\n\n            if (Nlinewidths) {\n                gc.linewidth = linewidths(i % Nlinewidths);\n            } else {\n                gc.linewidth = 1.0;\n            }\n            if (Nlinestyles) {\n                gc.dashes = linestyles[i % Nlinestyles];\n            }\n        }\n\n        bool do_clip = !face.first && !gc.has_hatchpath() && !has_curves;\n\n        if (check_snap) {\n            gc.isaa = antialiaseds(i % Naa);\n\n            transformed_path_t tpath(path, trans);\n            nan_removed_t nan_removed(tpath, true, has_curves);\n            clipped_t clipped(nan_removed, do_clip, width, height);\n            snapped_t snapped(\n                clipped, gc.snap_mode, path.total_vertices(), points_to_pixels(gc.linewidth));\n            if (has_curves) {\n                snapped_curve_t curve(snapped);\n                _draw_path(curve, has_clippath, face, gc);\n            } else {\n                _draw_path(snapped, has_clippath, face, gc);\n            }\n        } else {\n            gc.isaa = antialiaseds(i % Naa);\n\n            transformed_path_t tpath(path, trans);\n            nan_removed_t nan_removed(tpath, true, has_curves);\n            clipped_t clipped(nan_removed, do_clip, width, height);\n            if (has_curves) {\n                curve_t curve(clipped);\n                _draw_path(curve, has_clippath, face, gc);\n            } else {\n                _draw_path(clipped, has_clippath, face, gc);\n            }\n        }\n    }\n}\n\ntemplate <class PathGenerator,\n          class TransformArray,\n          class OffsetArray,\n          class ColorArray,\n          class LineWidthArray,\n          class AntialiasedArray>\ninline void RendererAgg::draw_path_collection(GCAgg &gc,\n                                              agg::trans_affine &master_transform,\n                                              PathGenerator &path,\n                                              TransformArray &transforms,\n                                              OffsetArray &offsets,\n                                              agg::trans_affine &offset_trans,\n                                              ColorArray &facecolors,\n                                              ColorArray &edgecolors,\n                                              LineWidthArray &linewidths,\n                                              DashesVector &linestyles,\n                                              AntialiasedArray &antialiaseds,\n                                              e_offset_position offset_position)\n{\n    _draw_path_collection_generic(gc,\n                                  master_transform,\n                                  gc.cliprect,\n                                  gc.clippath.path,\n                                  gc.clippath.trans,\n                                  path,\n                                  transforms,\n                                  offsets,\n                                  offset_trans,\n                                  facecolors,\n                                  edgecolors,\n                                  linewidths,\n                                  linestyles,\n                                  antialiaseds,\n                                  offset_position,\n                                  1,\n                                  1);\n}\n\ntemplate <class CoordinateArray>\nclass QuadMeshGenerator\n{\n    unsigned m_meshWidth;\n    unsigned m_meshHeight;\n    CoordinateArray m_coordinates;\n\n    class QuadMeshPathIterator\n    {\n        unsigned m_iterator;\n        unsigned m_m, m_n;\n        const CoordinateArray *m_coordinates;\n\n      public:\n        QuadMeshPathIterator(unsigned m, unsigned n, const CoordinateArray *coordinates)\n            : m_iterator(0), m_m(m), m_n(n), m_coordinates(coordinates)\n        {\n        }\n\n      private:\n        inline unsigned vertex(unsigned idx, double *x, double *y)\n        {\n            size_t m = m_m + ((idx & 0x2) >> 1);\n            size_t n = m_n + (((idx + 1) & 0x2) >> 1);\n            *x = (*m_coordinates)(n, m, 0);\n            *y = (*m_coordinates)(n, m, 1);\n            return (idx) ? agg::path_cmd_line_to : agg::path_cmd_move_to;\n        }\n\n      public:\n        inline unsigned vertex(double *x, double *y)\n        {\n            if (m_iterator >= total_vertices()) {\n                return agg::path_cmd_stop;\n            }\n            return vertex(m_iterator++, x, y);\n        }\n\n        inline void rewind(unsigned path_id)\n        {\n            m_iterator = path_id;\n        }\n\n        inline unsigned total_vertices()\n        {\n            return 5;\n        }\n\n        inline bool should_simplify()\n        {\n            return false;\n        }\n    };\n\n  public:\n    typedef QuadMeshPathIterator path_iterator;\n\n    inline QuadMeshGenerator(unsigned meshWidth, unsigned meshHeight, CoordinateArray &coordinates)\n        : m_meshWidth(meshWidth), m_meshHeight(meshHeight), m_coordinates(coordinates)\n    {\n    }\n\n    inline size_t num_paths() const\n    {\n        return m_meshWidth * m_meshHeight;\n    }\n\n    inline path_iterator operator()(size_t i) const\n    {\n        return QuadMeshPathIterator(i % m_meshWidth, i / m_meshWidth, &m_coordinates);\n    }\n};\n\ntemplate <class CoordinateArray, class OffsetArray, class ColorArray>\ninline void RendererAgg::draw_quad_mesh(GCAgg &gc,\n                                        agg::trans_affine &master_transform,\n                                        size_t mesh_width,\n                                        size_t mesh_height,\n                                        CoordinateArray &coordinates,\n                                        OffsetArray &offsets,\n                                        agg::trans_affine &offset_trans,\n                                        ColorArray &facecolors,\n                                        bool antialiased,\n                                        ColorArray &edgecolors)\n{\n    QuadMeshGenerator<CoordinateArray> path_generator(mesh_width, mesh_height, coordinates);\n\n    array::empty<double> transforms;\n    array::scalar<double, 1> linewidths(points_to_pixels(gc.linewidth));\n    array::scalar<uint8_t, 1> antialiaseds(antialiased);\n    DashesVector linestyles;\n    ColorArray *edgecolors_ptr = &edgecolors;\n\n    if (edgecolors.size() == 0) {\n        if (antialiased) {\n            edgecolors_ptr = &facecolors;\n        }\n    }\n\n    _draw_path_collection_generic(gc,\n                                  master_transform,\n                                  gc.cliprect,\n                                  gc.clippath.path,\n                                  gc.clippath.trans,\n                                  path_generator,\n                                  transforms,\n                                  offsets,\n                                  offset_trans,\n                                  facecolors,\n                                  *edgecolors_ptr,\n                                  linewidths,\n                                  linestyles,\n                                  antialiaseds,\n                                  OFFSET_POSITION_FIGURE,\n                                  0,\n                                  0);\n}\n\ntemplate <class PointArray, class ColorArray>\ninline void RendererAgg::_draw_gouraud_triangle(PointArray &points,\n                                                ColorArray &colors,\n                                                agg::trans_affine trans,\n                                                bool has_clippath)\n{\n    typedef agg::rgba8 color_t;\n    typedef agg::span_gouraud_rgba<color_t> span_gen_t;\n    typedef agg::span_allocator<color_t> span_alloc_t;\n\n    trans *= agg::trans_affine_scaling(1.0, -1.0);\n    trans *= agg::trans_affine_translation(0.0, (double)height);\n\n    double tpoints[3][2];\n\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 2; ++j) {\n            tpoints[i][j] = points(i, j);\n        }\n        trans.transform(&tpoints[i][0], &tpoints[i][1]);\n    }\n\n    span_alloc_t span_alloc;\n    span_gen_t span_gen;\n\n    span_gen.colors(agg::rgba(colors(0, 0), colors(0, 1), colors(0, 2), colors(0, 3)),\n                    agg::rgba(colors(1, 0), colors(1, 1), colors(1, 2), colors(1, 3)),\n                    agg::rgba(colors(2, 0), colors(2, 1), colors(2, 2), colors(2, 3)));\n    span_gen.triangle(tpoints[0][0],\n                      tpoints[0][1],\n                      tpoints[1][0],\n                      tpoints[1][1],\n                      tpoints[2][0],\n                      tpoints[2][1],\n                      0.5);\n\n    theRasterizer.add_path(span_gen);\n\n    if (has_clippath) {\n        typedef agg::pixfmt_amask_adaptor<pixfmt, alpha_mask_type> pixfmt_amask_type;\n        typedef agg::renderer_base<pixfmt_amask_type> amask_ren_type;\n        typedef agg::renderer_scanline_aa<amask_ren_type, span_alloc_t, span_gen_t>\n        amask_aa_renderer_type;\n\n        pixfmt_amask_type pfa(pixFmt, alphaMask);\n        amask_ren_type r(pfa);\n        amask_aa_renderer_type ren(r, span_alloc, span_gen);\n        agg::render_scanlines(theRasterizer, scanlineAlphaMask, ren);\n    } else {\n        agg::render_scanlines_aa(theRasterizer, slineP8, rendererBase, span_alloc, span_gen);\n    }\n}\n\ntemplate <class PointArray, class ColorArray>\ninline void RendererAgg::draw_gouraud_triangle(GCAgg &gc,\n                                               PointArray &points,\n                                               ColorArray &colors,\n                                               agg::trans_affine &trans)\n{\n    theRasterizer.reset_clipping();\n    rendererBase.reset_clipping(true);\n    set_clipbox(gc.cliprect, theRasterizer);\n    bool has_clippath = render_clippath(gc.clippath.path, gc.clippath.trans);\n\n    if (points.dim(0) != 3 || points.dim(1) != 2) {\n        throw \"points must be a 3x2 array\";\n    }\n\n    if (colors.dim(0) != 3 || colors.dim(1) != 4) {\n        throw \"colors must be a 3x4 array\";\n    }\n\n    _draw_gouraud_triangle(points, colors, trans, has_clippath);\n}\n\ntemplate <class PointArray, class ColorArray>\ninline void RendererAgg::draw_gouraud_triangles(GCAgg &gc,\n                                                PointArray &points,\n                                                ColorArray &colors,\n                                                agg::trans_affine &trans)\n{\n    theRasterizer.reset_clipping();\n    rendererBase.reset_clipping(true);\n    set_clipbox(gc.cliprect, theRasterizer);\n    bool has_clippath = render_clippath(gc.clippath.path, gc.clippath.trans);\n\n    if (points.dim(1) != 3 || points.dim(2) != 2) {\n        throw \"points must be a Nx3x2 array\";\n    }\n\n    if (colors.dim(1) != 3 || colors.dim(2) != 4) {\n        throw \"colors must be a Nx3x4 array\";\n    }\n\n    if (points.dim(0) != colors.dim(0)) {\n        throw \"points and colors arrays must be the same length\";\n    }\n\n    for (int i = 0; i < points.dim(0); ++i) {\n        typename PointArray::sub_t point = points[i];\n        typename ColorArray::sub_t color = colors[i];\n\n        _draw_gouraud_triangle(point, color, trans, has_clippath);\n    }\n}\n\ntemplate <class R>\nvoid RendererAgg::set_clipbox(const agg::rect_d &cliprect, R &rasterizer)\n{\n    // set the clip rectangle from the gc\n\n    if (cliprect.x1 != 0.0 || cliprect.y1 != 0.0 || cliprect.x2 != 0.0 || cliprect.y2 != 0.0) {\n        rasterizer.clip_box(std::max(int(floor(cliprect.x1 + 0.5)), 0),\n                            std::max(int(floor(height - cliprect.y1 + 0.5)), 0),\n                            std::min(int(floor(cliprect.x2 + 0.5)), int(width)),\n                            std::min(int(floor(height - cliprect.y2 + 0.5)), int(height)));\n    } else {\n        rasterizer.clip_box(0, 0, width, height);\n    }\n}\n\n#endif\n", "patch": "@@ -1,57 +1,42 @@\n /* -*- mode: c++; c-basic-offset: 4 -*- */\n \n-/* _backend_agg.h - A rewrite of _backend_agg using PyCXX to handle\n-   ref counting, etc..\n+/* _backend_agg.h\n */\n \n-#ifndef __BACKEND_AGG_H\n-#define __BACKEND_AGG_H\n-#include <utility>\n-#include \"CXX/Extensions.hxx\"\n-\n-#include \"agg_arrowhead.h\"\n-#include \"agg_basics.h\"\n-#include \"agg_bezier_arc.h\"\n-#include \"agg_color_rgba.h\"\n-#include \"agg_conv_concat.h\"\n-#include \"agg_conv_contour.h\"\n+#ifndef __BACKEND_AGG_H__\n+#define __BACKEND_AGG_H__\n+\n+#include <vector>\n+\n+#include \"agg_alpha_mask_u8.h\"\n #include \"agg_conv_curve.h\"\n #include \"agg_conv_dash.h\"\n-#include \"agg_conv_marker.h\"\n-#include \"agg_conv_marker_adaptor.h\"\n-#include \"agg_math_stroke.h\"\n #include \"agg_conv_stroke.h\"\n-#include \"agg_ellipse.h\"\n-#include \"agg_embedded_raster_fonts.h\"\n-#include \"agg_path_storage.h\"\n-#include \"agg_pixfmt_rgb.h\"\n-#include \"agg_pixfmt_rgba.h\"\n-#include \"agg_pixfmt_gray.h\"\n-#include \"agg_alpha_mask_u8.h\"\n+#include \"agg_image_accessors.h\"\n #include \"agg_pixfmt_amask_adaptor.h\"\n-#include \"agg_rasterizer_outline.h\"\n+#include \"agg_pixfmt_gray.h\"\n+#include \"agg_pixfmt_rgba.h\"\n #include \"agg_rasterizer_scanline_aa.h\"\n-#include \"agg_renderer_outline_aa.h\"\n-#include \"agg_renderer_raster_text.h\"\n+#include \"agg_renderer_base.h\"\n #include \"agg_renderer_scanline.h\"\n #include \"agg_rendering_buffer.h\"\n #include \"agg_scanline_bin.h\"\n-#include \"agg_scanline_u.h\"\n #include \"agg_scanline_p.h\"\n-#include \"agg_vcgen_markers_term.h\"\n+#include \"agg_scanline_storage_aa.h\"\n+#include \"agg_scanline_storage_bin.h\"\n+#include \"agg_scanline_u.h\"\n+#include \"agg_span_allocator.h\"\n+#include \"agg_span_converter.h\"\n+#include \"agg_span_gouraud_rgba.h\"\n+#include \"agg_span_image_filter_gray.h\"\n+#include \"agg_span_image_filter_rgba.h\"\n+#include \"agg_span_interpolator_linear.h\"\n+#include \"agg_span_pattern_rgba.h\"\n+#include \"util/agg_color_conv_rgb8.h\"\n \n-#include \"agg_py_path_iterator.h\"\n+#include \"_backend_agg_basic_types.h\"\n #include \"path_converters.h\"\n-\n-// These are copied directly from path.py, and must be kept in sync\n-#define STOP   0\n-#define MOVETO 1\n-#define LINETO 2\n-#define CURVE3 3\n-#define CURVE4 4\n-#define CLOSEPOLY 5\n-\n-const size_t NUM_VERTICES[] = { 1, 1, 1, 2, 3, 1 };\n+#include \"array.h\"\n \n typedef agg::pixfmt_rgba32_plain pixfmt;\n typedef agg::renderer_base<pixfmt> renderer_base;\n@@ -69,109 +54,74 @@ typedef agg::renderer_scanline_aa_solid<renderer_base_alpha_mask_type> renderer_\n \n // a helper class to pass agg::buffer objects around.  agg::buffer is\n // a class in the swig wrapper\n-class BufferRegion : public Py::PythonExtension<BufferRegion>\n+class BufferRegion\n {\n-public:\n-    BufferRegion(const agg::rect_i &r, bool freemem = true) :\n-        rect(r), freemem(freemem)\n+  public:\n+    BufferRegion(const agg::rect_i &r) : rect(r)\n     {\n         width = r.x2 - r.x1;\n         height = r.y2 - r.y1;\n         stride = width * 4;\n         data = new agg::int8u[stride * height];\n     }\n \n-    agg::int8u* data;\n-    agg::rect_i rect;\n-    int width;\n-    int height;\n-    int stride;\n+    virtual ~BufferRegion()\n+    {\n+        delete[] data;\n+    };\n \n-    bool freemem;\n+    agg::int8u *get_data()\n+    {\n+        return data;\n+    }\n \n-    // set the x and y corners of the rectangle\n-    Py::Object set_x(const Py::Tuple &args);\n-    Py::Object set_y(const Py::Tuple &args);\n+    agg::rect_i &get_rect()\n+    {\n+        return rect;\n+    }\n \n-    Py::Object get_extents(const Py::Tuple &args);\n+    int get_width()\n+    {\n+        return width;\n+    }\n \n-    Py::Object to_string(const Py::Tuple &args);\n-    Py::Object to_string_argb(const Py::Tuple &args);\n-    static void init_type(void);\n+    int get_height()\n+    {\n+        return height;\n+    }\n \n-    virtual ~BufferRegion()\n+    int get_stride()\n     {\n-        if (freemem)\n-        {\n-            delete [] data;\n-            data = NULL;\n-        }\n-    };\n+        return stride;\n+    }\n \n-private:\n-    // prevent copying\n-    BufferRegion(const BufferRegion&);\n-    BufferRegion& operator=(const BufferRegion&);\n-};\n+    void to_string_argb(uint8_t *buf);\n \n-class GCAgg\n-{\n-public:\n-    GCAgg(const Py::Object& gc, double dpi);\n+  private:\n+    agg::int8u *data;\n+    agg::rect_i rect;\n+    int width;\n+    int height;\n+    int stride;\n \n-    double dpi;\n-    bool isaa;\n-\n-    agg::line_cap_e cap;\n-    agg::line_join_e join;\n-\n-    double linewidth;\n-    double alpha;\n-    bool forced_alpha;\n-    agg::rgba color;\n-\n-    Py::Object cliprect;\n-    Py::Object clippath;\n-    agg::trans_affine clippath_trans;\n-\n-    //dashes\n-    typedef std::vector<std::pair<double, double> > dash_t;\n-    double dashOffset;\n-    dash_t dashes;\n-    e_snap_mode snap_mode;\n-\n-    Py::Object hatchpath;\n-\n-    double sketch_scale;\n-    double sketch_length;\n-    double sketch_randomness;\n-\n-protected:\n-    agg::rgba get_color(const Py::Object& gc);\n-    double points_to_pixels(const Py::Object& points);\n-    void _set_linecap(const Py::Object& gc) ;\n-    void _set_joinstyle(const Py::Object& gc) ;\n-    void _set_dashes(const Py::Object& gc) ;\n-    void _set_clip_rectangle(const Py::Object& gc);\n-    void _set_clip_path(const Py::Object& gc);\n-    void _set_antialiased(const Py::Object& gc);\n-    void _set_snap(const Py::Object& gc);\n-    void _set_hatch_path(const Py::Object& gc);\n-    void _set_sketch_params(const Py::Object& gc);\n+  private:\n+    // prevent copying\n+    BufferRegion(const BufferRegion &);\n+    BufferRegion &operator=(const BufferRegion &);\n };\n \n-\n-//struct AMRenderer {\n-//\n-//}\n+#define MARKER_CACHE_SIZE 512\n \n // the renderer\n-class RendererAgg: public Py::PythonExtension<RendererAgg>\n+class RendererAgg\n {\n+    /* TODO: Remove facepair_t */\n     typedef std::pair<bool, agg::rgba> facepair_t;\n-public:\n-    RendererAgg(unsigned int width, unsigned int height, double dpi, int debug);\n-    static void init_type(void);\n+\n+  public:\n+    RendererAgg(unsigned int width, unsigned int height, double dpi);\n+\n+    virtual ~RendererAgg();\n \n     unsigned int get_width()\n     {\n@@ -183,40 +133,86 @@ class RendererAgg: public Py::PythonExtension<RendererAgg>\n         return height;\n     }\n \n-    // the drawing methods\n-    //Py::Object _draw_markers_nocache(const Py::Tuple & args);\n-    //Py::Object _draw_markers_cache(const Py::Tuple & args);\n-    Py::Object draw_markers(const Py::Tuple & args);\n-    Py::Object draw_text_image(const Py::Tuple & args);\n-    Py::Object draw_image(const Py::Tuple & args);\n-    Py::Object draw_path(const Py::Tuple & args);\n-    Py::Object draw_path_collection(const Py::Tuple & args);\n-    Py::Object draw_quad_mesh(const Py::Tuple& args);\n-    Py::Object draw_gouraud_triangle(const Py::Tuple& args);\n-    Py::Object draw_gouraud_triangles(const Py::Tuple& args);\n-\n-    Py::Object write_rgba(const Py::Tuple & args);\n-    Py::Object tostring_rgb(const Py::Tuple & args);\n-    Py::Object tostring_argb(const Py::Tuple & args);\n-    Py::Object tostring_bgra(const Py::Tuple & args);\n-    Py::Object tostring_rgba_minimized(const Py::Tuple & args);\n-    Py::Object buffer_rgba(const Py::Tuple & args);\n-    Py::Object clear(const Py::Tuple & args);\n-\n-    Py::Object copy_from_bbox(const Py::Tuple & args);\n-    Py::Object restore_region(const Py::Tuple & args);\n-    Py::Object restore_region2(const Py::Tuple & args);\n-\n-    #if PY3K\n-    virtual int buffer_get( Py_buffer *, int flags );\n-    #endif\n+    template <class PathIterator>\n+    void draw_path(GCAgg &gc, PathIterator &path, agg::trans_affine &trans, agg::rgba &color);\n \n-    virtual ~RendererAgg();\n+    template <class PathIterator>\n+    void draw_markers(GCAgg &gc,\n+                      PathIterator &marker_path,\n+                      agg::trans_affine &marker_path_trans,\n+                      PathIterator &path,\n+                      agg::trans_affine &trans,\n+                      agg::rgba face);\n+\n+    template <class ImageArray>\n+    void draw_text_image(GCAgg &gc, ImageArray &image, int x, int y, double angle);\n+\n+    template <class ImageArray>\n+    void draw_image(GCAgg &gc,\n+                    double x,\n+                    double y,\n+                    ImageArray &image,\n+                    double w,\n+                    double h,\n+                    agg::trans_affine trans,\n+                    bool resize);\n+\n+    template <class PathGenerator,\n+              class TransformArray,\n+              class OffsetArray,\n+              class ColorArray,\n+              class LineWidthArray,\n+              class AntialiasedArray>\n+    void draw_path_collection(GCAgg &gc,\n+                              agg::trans_affine &master_transform,\n+                              PathGenerator &path,\n+                              TransformArray &transforms,\n+                              OffsetArray &offsets,\n+                              agg::trans_affine &offset_trans,\n+                              ColorArray &facecolors,\n+                              ColorArray &edgecolors,\n+                              LineWidthArray &linewidths,\n+                              DashesVector &linestyles,\n+                              AntialiasedArray &antialiaseds,\n+                              e_offset_position offset_position);\n+\n+    template <class CoordinateArray, class OffsetArray, class ColorArray>\n+    void draw_quad_mesh(GCAgg &gc,\n+                        agg::trans_affine &master_transform,\n+                        size_t mesh_width,\n+                        size_t mesh_height,\n+                        CoordinateArray &coordinates,\n+                        OffsetArray &offsets,\n+                        agg::trans_affine &offset_trans,\n+                        ColorArray &facecolors,\n+                        bool antialiased,\n+                        ColorArray &edgecolors);\n+\n+    template <class PointArray, class ColorArray>\n+    void draw_gouraud_triangle(GCAgg &gc,\n+                               PointArray &points,\n+                               ColorArray &colors,\n+                               agg::trans_affine &trans);\n+\n+    template <class PointArray, class ColorArray>\n+    void draw_gouraud_triangles(GCAgg &gc,\n+                                PointArray &points,\n+                                ColorArray &colors,\n+                                agg::trans_affine &trans);\n+\n+    void tostring_rgb(uint8_t *buf);\n+    void tostring_argb(uint8_t *buf);\n+    void tostring_bgra(uint8_t *buf);\n+    agg::rect_i get_content_extents();\n+    void clear();\n+\n+    BufferRegion *copy_from_bbox(agg::rect_d in_rect);\n+    void restore_region(BufferRegion &reg);\n+    void restore_region(BufferRegion &region, int x, int y, int xx1, int yy1, int xx2, int yy2);\n \n-    static const size_t PIXELS_PER_INCH;\n     unsigned int width, height;\n     double dpi;\n-    size_t NUMBYTES;  //the number of bytes in buffer\n+    size_t NUMBYTES; // the number of bytes in buffer\n \n     agg::int8u *pixBuffer;\n     agg::rendering_buffer renderingBuffer;\n@@ -237,90 +233,1072 @@ class RendererAgg: public Py::PythonExtension<RendererAgg>\n     renderer_bin rendererBin;\n     rasterizer theRasterizer;\n \n-    Py::Object lastclippath;\n+    void *lastclippath;\n     agg::trans_affine lastclippath_transform;\n \n     static const size_t HATCH_SIZE = 72;\n     agg::int8u hatchBuffer[HATCH_SIZE * HATCH_SIZE * 4];\n     agg::rendering_buffer hatchRenderingBuffer;\n \n-    const int debug;\n-\n     agg::rgba _fill_color;\n \n+  protected:\n+    inline double points_to_pixels(double points)\n+    {\n+        return points * dpi / 72.0;\n+    }\n+\n+    template <class R>\n+    void set_clipbox(const agg::rect_d &cliprect, R &rasterizer);\n+\n+    bool render_clippath(py::PathIterator &clippath, const agg::trans_affine &clippath_trans);\n+\n+    template <class PathIteratorType>\n+    void _draw_path(PathIteratorType &path, bool has_clippath, const facepair_t &face, GCAgg &gc);\n+\n+    template <class PathIterator,\n+              class PathGenerator,\n+              class TransformArray,\n+              class OffsetArray,\n+              class ColorArray,\n+              class LineWidthArray,\n+              class AntialiasedArray>\n+    void _draw_path_collection_generic(GCAgg &gc,\n+                                       agg::trans_affine master_transform,\n+                                       const agg::rect_d &cliprect,\n+                                       PathIterator &clippath,\n+                                       const agg::trans_affine &clippath_trans,\n+                                       PathGenerator &path_generator,\n+                                       TransformArray &transforms,\n+                                       OffsetArray &offsets,\n+                                       const agg::trans_affine &offset_trans,\n+                                       ColorArray &facecolors,\n+                                       ColorArray &edgecolors,\n+                                       LineWidthArray &linewidths,\n+                                       DashesVector &linestyles,\n+                                       AntialiasedArray &antialiaseds,\n+                                       e_offset_position offset_position,\n+                                       int check_snap,\n+                                       int has_curves);\n \n-protected:\n-    double points_to_pixels(const Py::Object& points);\n-    agg::rgba rgb_to_color(const Py::SeqBase<Py::Object>& rgb, double alpha);\n-    facepair_t _get_rgba_face(const Py::Object& rgbFace, double alpha, bool forced_alpha);\n-\n-    template<class R>\n-    void set_clipbox(const Py::Object& cliprect, R& rasterizer);\n-\n-    bool render_clippath(const Py::Object& clippath, const agg::trans_affine& clippath_trans);\n-\n-    template<class PathIteratorType>\n-    void _draw_path(PathIteratorType& path, bool has_clippath,\n-                    const facepair_t& face, const GCAgg& gc);\n-\n-    template<class PathGenerator, int check_snap, int has_curves>\n-    Py::Object\n-    _draw_path_collection_generic\n-    (GCAgg&                         gc,\n-     agg::trans_affine              master_transform,\n-     const Py::Object&              cliprect,\n-     const Py::Object&              clippath,\n-     const agg::trans_affine&       clippath_trans,\n-     const PathGenerator&           path_generator,\n-     const Py::Object&              transforms_obj,\n-     const Py::Object&              offsets_obj,\n-     const agg::trans_affine&       offset_trans,\n-     const Py::Object&              facecolors_obj,\n-     const Py::Object&              edgecolors_obj,\n-     const Py::SeqBase<Py::Float>&  linewidths,\n-     const Py::SeqBase<Py::Object>& linestyles_obj,\n-     const Py::SeqBase<Py::Int>&    antialiaseds,\n-     const bool                     data_offsets);\n-\n-    void\n-    _draw_gouraud_triangle(\n-        const double* points, const double* colors,\n-        agg::trans_affine trans, bool has_clippath);\n-\n-private:\n+    template <class PointArray, class ColorArray>\n+    void _draw_gouraud_triangle(PointArray &points,\n+                                ColorArray &colors,\n+                                agg::trans_affine trans,\n+                                bool has_clippath);\n+\n+  private:\n     void create_alpha_buffers();\n \n     // prevent copying\n-    RendererAgg(const RendererAgg&);\n-    RendererAgg& operator=(const RendererAgg&);\n+    RendererAgg(const RendererAgg &);\n+    RendererAgg &operator=(const RendererAgg &);\n };\n \n-// the extension module\n-class _backend_agg_module : public Py::ExtensionModule<_backend_agg_module>\n+/***************************************************************************\n+ * Implementation\n+ */\n+\n+template <class path_t>\n+inline void\n+RendererAgg::_draw_path(path_t &path, bool has_clippath, const facepair_t &face, GCAgg &gc)\n+{\n+    typedef agg::conv_stroke<path_t> stroke_t;\n+    typedef agg::conv_dash<path_t> dash_t;\n+    typedef agg::conv_stroke<dash_t> stroke_dash_t;\n+    typedef agg::pixfmt_amask_adaptor<pixfmt, alpha_mask_type> pixfmt_amask_type;\n+    typedef agg::renderer_base<pixfmt_amask_type> amask_ren_type;\n+    typedef agg::renderer_scanline_aa_solid<amask_ren_type> amask_aa_renderer_type;\n+    typedef agg::renderer_scanline_bin_solid<amask_ren_type> amask_bin_renderer_type;\n+\n+    // Render face\n+    if (face.first) {\n+        theRasterizer.add_path(path);\n+\n+        if (gc.isaa) {\n+            if (has_clippath) {\n+                pixfmt_amask_type pfa(pixFmt, alphaMask);\n+                amask_ren_type r(pfa);\n+                amask_aa_renderer_type ren(r);\n+                ren.color(face.second);\n+                agg::render_scanlines(theRasterizer, scanlineAlphaMask, ren);\n+            } else {\n+                rendererAA.color(face.second);\n+                agg::render_scanlines(theRasterizer, slineP8, rendererAA);\n+            }\n+        } else {\n+            if (has_clippath) {\n+                pixfmt_amask_type pfa(pixFmt, alphaMask);\n+                amask_ren_type r(pfa);\n+                amask_bin_renderer_type ren(r);\n+                ren.color(face.second);\n+                agg::render_scanlines(theRasterizer, scanlineAlphaMask, ren);\n+            } else {\n+                rendererBin.color(face.second);\n+                agg::render_scanlines(theRasterizer, slineP8, rendererBin);\n+            }\n+        }\n+    }\n+\n+    // Render hatch\n+    if (gc.has_hatchpath()) {\n+        // Reset any clipping that may be in effect, since we'll be\n+        // drawing the hatch in a scratch buffer at origin (0, 0)\n+        theRasterizer.reset_clipping();\n+        rendererBase.reset_clipping(true);\n+\n+        // Create and transform the path\n+        typedef agg::conv_transform<py::PathIterator> hatch_path_trans_t;\n+        typedef agg::conv_curve<hatch_path_trans_t> hatch_path_curve_t;\n+        typedef agg::conv_stroke<hatch_path_curve_t> hatch_path_stroke_t;\n+\n+        py::PathIterator hatch_path(gc.hatchpath);\n+        agg::trans_affine hatch_trans;\n+        hatch_trans *= agg::trans_affine_scaling(1.0, -1.0);\n+        hatch_trans *= agg::trans_affine_translation(0.0, 1.0);\n+        hatch_trans *= agg::trans_affine_scaling(HATCH_SIZE, HATCH_SIZE);\n+        hatch_path_trans_t hatch_path_trans(hatch_path, hatch_trans);\n+        hatch_path_curve_t hatch_path_curve(hatch_path_trans);\n+        hatch_path_stroke_t hatch_path_stroke(hatch_path_curve);\n+        hatch_path_stroke.width(1.0);\n+        hatch_path_stroke.line_cap(agg::square_cap);\n+\n+        // Render the path into the hatch buffer\n+        pixfmt hatch_img_pixf(hatchRenderingBuffer);\n+        renderer_base rb(hatch_img_pixf);\n+        renderer_aa rs(rb);\n+        rb.clear(_fill_color);\n+        rs.color(gc.color);\n+\n+        theRasterizer.add_path(hatch_path_curve);\n+        agg::render_scanlines(theRasterizer, slineP8, rs);\n+        theRasterizer.add_path(hatch_path_stroke);\n+        agg::render_scanlines(theRasterizer, slineP8, rs);\n+\n+        // Put clipping back on, if originally set on entry to this\n+        // function\n+        set_clipbox(gc.cliprect, theRasterizer);\n+        if (has_clippath) {\n+            render_clippath(gc.clippath.path, gc.clippath.trans);\n+        }\n+\n+        // Transfer the hatch to the main image buffer\n+        typedef agg::image_accessor_wrap<pixfmt,\n+                                         agg::wrap_mode_repeat_auto_pow2,\n+                                         agg::wrap_mode_repeat_auto_pow2> img_source_type;\n+        typedef agg::span_pattern_rgba<img_source_type> span_gen_type;\n+        agg::span_allocator<agg::rgba8> sa;\n+        img_source_type img_src(hatch_img_pixf);\n+        span_gen_type sg(img_src, 0, 0);\n+        theRasterizer.add_path(path);\n+\n+        if (has_clippath) {\n+            pixfmt_amask_type pfa(pixFmt, alphaMask);\n+            amask_ren_type ren(pfa);\n+            agg::render_scanlines_aa(theRasterizer, slineP8, ren, sa, sg);\n+        } else {\n+            agg::render_scanlines_aa(theRasterizer, slineP8, rendererBase, sa, sg);\n+        }\n+    }\n+\n+    // Render stroke\n+    if (gc.linewidth != 0.0) {\n+        double linewidth = points_to_pixels(gc.linewidth);\n+        if (!gc.isaa) {\n+            linewidth = (linewidth < 0.5) ? 0.5 : mpl_round(linewidth);\n+        }\n+        if (gc.dashes.size() == 0) {\n+            stroke_t stroke(path);\n+            stroke.width(points_to_pixels(gc.linewidth));\n+            stroke.line_cap(gc.cap);\n+            stroke.line_join(gc.join);\n+            theRasterizer.add_path(stroke);\n+        } else {\n+            dash_t dash(path);\n+            gc.dashes.dash_to_stroke(dash, dpi, gc.isaa);\n+            stroke_dash_t stroke(dash);\n+            stroke.line_cap(gc.cap);\n+            stroke.line_join(gc.join);\n+            stroke.width(linewidth);\n+            theRasterizer.add_path(stroke);\n+        }\n+\n+        if (gc.isaa) {\n+            if (has_clippath) {\n+                pixfmt_amask_type pfa(pixFmt, alphaMask);\n+                amask_ren_type r(pfa);\n+                amask_aa_renderer_type ren(r);\n+                ren.color(gc.color);\n+                agg::render_scanlines(theRasterizer, scanlineAlphaMask, ren);\n+            } else {\n+                rendererAA.color(gc.color);\n+                agg::render_scanlines(theRasterizer, slineP8, rendererAA);\n+            }\n+        } else {\n+            if (has_clippath) {\n+                pixfmt_amask_type pfa(pixFmt, alphaMask);\n+                amask_ren_type r(pfa);\n+                amask_bin_renderer_type ren(r);\n+                ren.color(gc.color);\n+                agg::render_scanlines(theRasterizer, scanlineAlphaMask, ren);\n+            } else {\n+                rendererBin.color(gc.color);\n+                agg::render_scanlines(theRasterizer, slineBin, rendererBin);\n+            }\n+        }\n+    }\n+}\n+\n+template <class PathIterator>\n+inline void\n+RendererAgg::draw_path(GCAgg &gc, PathIterator &path, agg::trans_affine &trans, agg::rgba &color)\n+{\n+    typedef agg::conv_transform<py::PathIterator> transformed_path_t;\n+    typedef PathNanRemover<transformed_path_t> nan_removed_t;\n+    typedef PathClipper<nan_removed_t> clipped_t;\n+    typedef PathSnapper<clipped_t> snapped_t;\n+    typedef PathSimplifier<snapped_t> simplify_t;\n+    typedef agg::conv_curve<simplify_t> curve_t;\n+    typedef Sketch<curve_t> sketch_t;\n+\n+    facepair_t face(color.a != 0.0, color);\n+\n+    theRasterizer.reset_clipping();\n+    rendererBase.reset_clipping(true);\n+    set_clipbox(gc.cliprect, theRasterizer);\n+    bool has_clippath = render_clippath(gc.clippath.path, gc.clippath.trans);\n+\n+    trans *= agg::trans_affine_scaling(1.0, -1.0);\n+    trans *= agg::trans_affine_translation(0.0, (double)height);\n+    bool clip = !face.first && gc.has_hatchpath() && !path.has_curves();\n+    bool simplify = path.should_simplify() && clip;\n+    double snapping_linewidth = points_to_pixels(gc.linewidth);\n+    if (gc.color.a == 0.0) {\n+        snapping_linewidth = 0.0;\n+    }\n+\n+    transformed_path_t tpath(path, trans);\n+    nan_removed_t nan_removed(tpath, true, path.has_curves());\n+    clipped_t clipped(nan_removed, clip, width, height);\n+    snapped_t snapped(clipped, gc.snap_mode, path.total_vertices(), snapping_linewidth);\n+    simplify_t simplified(snapped, simplify, path.simplify_threshold());\n+    curve_t curve(simplified);\n+    sketch_t sketch(curve, gc.sketch.scale, gc.sketch.length, gc.sketch.randomness);\n+\n+    _draw_path(sketch, has_clippath, face, gc);\n+}\n+\n+template <class PathIterator>\n+inline void RendererAgg::draw_markers(GCAgg &gc,\n+                                      PathIterator &marker_path,\n+                                      agg::trans_affine &marker_trans,\n+                                      PathIterator &path,\n+                                      agg::trans_affine &trans,\n+                                      agg::rgba color)\n {\n-public:\n-    _backend_agg_module()\n-        : Py::ExtensionModule<_backend_agg_module>(\"_backend_agg\")\n+    typedef agg::conv_transform<py::PathIterator> transformed_path_t;\n+    typedef PathSnapper<transformed_path_t> snap_t;\n+    typedef agg::conv_curve<snap_t> curve_t;\n+    typedef agg::conv_stroke<curve_t> stroke_t;\n+    typedef agg::pixfmt_amask_adaptor<pixfmt, alpha_mask_type> pixfmt_amask_type;\n+    typedef agg::renderer_base<pixfmt_amask_type> amask_ren_type;\n+    typedef agg::renderer_scanline_aa_solid<amask_ren_type> amask_aa_renderer_type;\n+\n+    // Deal with the difference in y-axis direction\n+    marker_trans *= agg::trans_affine_scaling(1.0, -1.0);\n+    trans *= agg::trans_affine_scaling(1.0, -1.0);\n+    trans *= agg::trans_affine_translation(0.5, (double)height + 0.5);\n+\n+    transformed_path_t marker_path_transformed(marker_path, marker_trans);\n+    snap_t marker_path_snapped(marker_path_transformed,\n+                               gc.snap_mode,\n+                               marker_path.total_vertices(),\n+                               points_to_pixels(gc.linewidth));\n+    curve_t marker_path_curve(marker_path_snapped);\n+\n+    transformed_path_t path_transformed(path, trans);\n+    snap_t path_snapped(path_transformed, SNAP_FALSE, path.total_vertices(), 0.0);\n+    curve_t path_curve(path_snapped);\n+    path_curve.rewind(0);\n+\n+    facepair_t face(color.a != 0.0, color);\n+\n+    // maxim's suggestions for cached scanlines\n+    agg::scanline_storage_aa8 scanlines;\n+    theRasterizer.reset();\n+    theRasterizer.reset_clipping();\n+    rendererBase.reset_clipping(true);\n+\n+    agg::int8u staticFillCache[MARKER_CACHE_SIZE];\n+    agg::int8u staticStrokeCache[MARKER_CACHE_SIZE];\n+    agg::int8u *fillCache = staticFillCache;\n+    agg::int8u *strokeCache = staticStrokeCache;\n+\n+    try\n     {\n-        RendererAgg::init_type();\n-        BufferRegion::init_type();\n+        unsigned fillSize = 0;\n+        if (face.first) {\n+            theRasterizer.add_path(marker_path_curve);\n+            agg::render_scanlines(theRasterizer, slineP8, scanlines);\n+            fillSize = scanlines.byte_size();\n+            if (fillSize >= MARKER_CACHE_SIZE) {\n+                fillCache = new agg::int8u[fillSize];\n+            }\n+            scanlines.serialize(fillCache);\n+        }\n+\n+        stroke_t stroke(marker_path_curve);\n+        stroke.width(points_to_pixels(gc.linewidth));\n+        stroke.line_cap(gc.cap);\n+        stroke.line_join(gc.join);\n+        theRasterizer.reset();\n+        theRasterizer.add_path(stroke);\n+        agg::render_scanlines(theRasterizer, slineP8, scanlines);\n+        unsigned strokeSize = scanlines.byte_size();\n+        if (strokeSize >= MARKER_CACHE_SIZE) {\n+            strokeCache = new agg::int8u[strokeSize];\n+        }\n+        scanlines.serialize(strokeCache);\n+\n+        theRasterizer.reset_clipping();\n+        rendererBase.reset_clipping(true);\n+        set_clipbox(gc.cliprect, rendererBase);\n+        bool has_clippath = render_clippath(gc.clippath.path, gc.clippath.trans);\n \n-        add_keyword_method(\"RendererAgg\", &_backend_agg_module::new_renderer,\n-                           \"RendererAgg(width, height, dpi)\");\n-        initialize(\"The agg rendering backend\");\n+        double x, y;\n+\n+        agg::serialized_scanlines_adaptor_aa8 sa;\n+        agg::serialized_scanlines_adaptor_aa8::embedded_scanline sl;\n+\n+        agg::rect_d clipping_rect(-1.0 - scanlines.max_x(),\n+                                  -1.0 - scanlines.max_y(),\n+                                  1.0 + width - scanlines.min_x(),\n+                                  1.0 + height - scanlines.min_y());\n+\n+        if (has_clippath) {\n+            while (path_curve.vertex(&x, &y) != agg::path_cmd_stop) {\n+                if (MPL_notisfinite64(x) || MPL_notisfinite64(y)) {\n+                    continue;\n+                }\n+\n+                /* These values are correctly snapped above -- so we don't want\n+                   to round here, we really only want to truncate */\n+                x = floor(x);\n+                y = floor(y);\n+\n+                // Cull points outside the boundary of the image.\n+                // Values that are too large may overflow and create\n+                // segfaults.\n+                // http://sourceforge.net/tracker/?func=detail&aid=2865490&group_id=80706&atid=560720\n+                if (!clipping_rect.hit_test(x, y)) {\n+                    continue;\n+                }\n+\n+                pixfmt_amask_type pfa(pixFmt, alphaMask);\n+                amask_ren_type r(pfa);\n+                amask_aa_renderer_type ren(r);\n+\n+                if (face.first) {\n+                    ren.color(face.second);\n+                    sa.init(fillCache, fillSize, x, y);\n+                    agg::render_scanlines(sa, sl, ren);\n+                }\n+                ren.color(gc.color);\n+                sa.init(strokeCache, strokeSize, x, y);\n+                agg::render_scanlines(sa, sl, ren);\n+            }\n+        } else {\n+            while (path_curve.vertex(&x, &y) != agg::path_cmd_stop) {\n+                if (MPL_notisfinite64(x) || MPL_notisfinite64(y)) {\n+                    continue;\n+                }\n+\n+                /* These values are correctly snapped above -- so we don't want\n+                   to round here, we really only want to truncate */\n+                x = floor(x);\n+                y = floor(y);\n+\n+                // Cull points outside the boundary of the image.\n+                // Values that are too large may overflow and create\n+                // segfaults.\n+                // http://sourceforge.net/tracker/?func=detail&aid=2865490&group_id=80706&atid=560720\n+                if (!clipping_rect.hit_test(x, y)) {\n+                    continue;\n+                }\n+\n+                if (face.first) {\n+                    rendererAA.color(face.second);\n+                    sa.init(fillCache, fillSize, x, y);\n+                    agg::render_scanlines(sa, sl, rendererAA);\n+                }\n+\n+                rendererAA.color(gc.color);\n+                sa.init(strokeCache, strokeSize, x, y);\n+                agg::render_scanlines(sa, sl, rendererAA);\n+            }\n+        }\n+    }\n+    catch (...)\n+    {\n+        if (fillCache != staticFillCache)\n+            delete[] fillCache;\n+        if (strokeCache != staticStrokeCache)\n+            delete[] strokeCache;\n+        theRasterizer.reset_clipping();\n+        rendererBase.reset_clipping(true);\n+        throw;\n     }\n \n-    virtual ~_backend_agg_module() {}\n+    if (fillCache != staticFillCache)\n+        delete[] fillCache;\n+    if (strokeCache != staticStrokeCache)\n+        delete[] strokeCache;\n \n-private:\n+    theRasterizer.reset_clipping();\n+    rendererBase.reset_clipping(true);\n+}\n \n-    Py::Object new_renderer(const Py::Tuple &args, const Py::Dict &kws);\n+/**\n+ * This is a custom span generator that converts spans in the\n+ * 8-bit inverted greyscale font buffer to rgba that agg can use.\n+ */\n+template <class ChildGenerator>\n+class font_to_rgba\n+{\n+  public:\n+    typedef ChildGenerator child_type;\n+    typedef agg::rgba8 color_type;\n+    typedef typename child_type::color_type child_color_type;\n+    typedef agg::span_allocator<child_color_type> span_alloc_type;\n \n-    // prevent copying\n-    _backend_agg_module(const _backend_agg_module&);\n-    _backend_agg_module& operator=(const _backend_agg_module&);\n+  private:\n+    child_type *_gen;\n+    color_type _color;\n+    span_alloc_type _allocator;\n+\n+  public:\n+    font_to_rgba(child_type *gen, color_type color) : _gen(gen), _color(color)\n+    {\n+    }\n+\n+    inline void generate(color_type *output_span, int x, int y, unsigned len)\n+    {\n+        _allocator.allocate(len);\n+        child_color_type *input_span = _allocator.span();\n+        _gen->generate(input_span, x, y, len);\n+\n+        do {\n+            *output_span = _color;\n+            output_span->a = ((unsigned int)_color.a * (unsigned int)input_span->v) >> 8;\n+            ++output_span;\n+            ++input_span;\n+        } while (--len);\n+    }\n+\n+    void prepare()\n+    {\n+        _gen->prepare();\n+    }\n+};\n+\n+template <class ImageArray>\n+inline void RendererAgg::draw_text_image(GCAgg &gc, ImageArray &image, int x, int y, double angle)\n+{\n+    typedef agg::span_allocator<agg::rgba8> color_span_alloc_type;\n+    typedef agg::span_interpolator_linear<> interpolator_type;\n+    typedef agg::image_accessor_clip<agg::pixfmt_gray8> image_accessor_type;\n+    typedef agg::span_image_filter_gray<image_accessor_type, interpolator_type> image_span_gen_type;\n+    typedef font_to_rgba<image_span_gen_type> span_gen_type;\n+    typedef agg::renderer_scanline_aa<renderer_base, color_span_alloc_type, span_gen_type>\n+    renderer_type;\n+\n+    theRasterizer.reset_clipping();\n+    rendererBase.reset_clipping(true);\n+    set_clipbox(gc.cliprect, theRasterizer);\n+\n+    agg::rendering_buffer srcbuf(\n+        image.data(), (unsigned)image.dim(1), (unsigned)image.dim(0), (unsigned)image.dim(1));\n+    agg::pixfmt_gray8 pixf_img(srcbuf);\n+\n+    agg::trans_affine mtx;\n+    mtx *= agg::trans_affine_translation(0, -image.dim(0));\n+    mtx *= agg::trans_affine_rotation(-angle * agg::pi / 180.0);\n+    mtx *= agg::trans_affine_translation(x, y);\n+\n+    agg::path_storage rect;\n+    rect.move_to(0, 0);\n+    rect.line_to(image.dim(1), 0);\n+    rect.line_to(image.dim(1), image.dim(0));\n+    rect.line_to(0, image.dim(0));\n+    rect.line_to(0, 0);\n+    agg::conv_transform<agg::path_storage> rect2(rect, mtx);\n+\n+    agg::trans_affine inv_mtx(mtx);\n+    inv_mtx.invert();\n+\n+    agg::image_filter_lut filter;\n+    filter.calculate(agg::image_filter_spline36());\n+    interpolator_type interpolator(inv_mtx);\n+    color_span_alloc_type sa;\n+    image_accessor_type ia(pixf_img, 0);\n+    image_span_gen_type image_span_generator(ia, interpolator, filter);\n+    span_gen_type output_span_generator(&image_span_generator, gc.color);\n+    renderer_type ri(rendererBase, sa, output_span_generator);\n+\n+    theRasterizer.add_path(rect2);\n+    agg::render_scanlines(theRasterizer, slineP8, ri);\n+}\n+\n+class span_conv_alpha\n+{\n+  public:\n+    typedef agg::rgba8 color_type;\n+\n+    double m_alpha;\n+\n+    span_conv_alpha(double alpha) : m_alpha(alpha)\n+    {\n+    }\n+\n+    void prepare()\n+    {\n+    }\n+    void generate(color_type *span, int x, int y, unsigned len) const\n+    {\n+        do {\n+            span->a = (agg::int8u)((double)span->a * m_alpha);\n+            ++span;\n+        } while (--len);\n+    }\n+};\n+\n+template <class ImageArray>\n+inline void RendererAgg::draw_image(GCAgg &gc,\n+                                    double x,\n+                                    double y,\n+                                    ImageArray &image,\n+                                    double w,\n+                                    double h,\n+                                    agg::trans_affine trans,\n+                                    bool resize)\n+{\n+    double alpha = gc.alpha;\n+\n+    theRasterizer.reset_clipping();\n+    rendererBase.reset_clipping(true);\n+    set_clipbox(gc.cliprect, theRasterizer);\n+    bool has_clippath = render_clippath(gc.clippath.path, gc.clippath.trans);\n+\n+    agg::rendering_buffer buffer;\n+    buffer.attach(\n+        image.data(), (unsigned)image.dim(1), (unsigned)image.dim(0), -(int)image.dim(1) * 4);\n+    pixfmt pixf(buffer);\n+\n+    if (resize | has_clippath) {\n+        agg::trans_affine mtx;\n+        agg::path_storage rect;\n+\n+        if (resize) {\n+            mtx *= agg::trans_affine_scaling(1, -1);\n+            mtx *= agg::trans_affine_translation(0, image.dim(0));\n+            mtx *= agg::trans_affine_scaling(w / (image.dim(1)), h / (image.dim(0)));\n+            mtx *= agg::trans_affine_translation(x, y);\n+            mtx *= trans;\n+            mtx *= agg::trans_affine_scaling(1.0, -1.0);\n+            mtx *= agg::trans_affine_translation(0.0, (double)height);\n+        } else {\n+            mtx *= agg::trans_affine_translation((int)x, (int)(height - (y + image.dim(0))));\n+        }\n+\n+        rect.move_to(0, 0);\n+        rect.line_to(image.dim(1), 0);\n+        rect.line_to(image.dim(1), image.dim(0));\n+        rect.line_to(0, image.dim(0));\n+        rect.line_to(0, 0);\n+\n+        agg::conv_transform<agg::path_storage> rect2(rect, mtx);\n+\n+        agg::trans_affine inv_mtx(mtx);\n+        inv_mtx.invert();\n+\n+        typedef agg::span_allocator<agg::rgba8> color_span_alloc_type;\n+        typedef agg::image_accessor_clip<agg::pixfmt_rgba32_plain> image_accessor_type;\n+        typedef agg::span_interpolator_linear<> interpolator_type;\n+        typedef agg::span_image_filter_rgba_nn<image_accessor_type, interpolator_type>\n+        image_span_gen_type;\n+        typedef agg::span_converter<image_span_gen_type, span_conv_alpha> span_conv;\n+\n+        color_span_alloc_type sa;\n+        image_accessor_type ia(pixf, agg::rgba8(0, 0, 0, 0));\n+        interpolator_type interpolator(inv_mtx);\n+        image_span_gen_type image_span_generator(ia, interpolator);\n+        span_conv_alpha conv_alpha(alpha);\n+        span_conv spans(image_span_generator, conv_alpha);\n+\n+        if (has_clippath) {\n+            typedef agg::pixfmt_amask_adaptor<pixfmt, alpha_mask_type> pixfmt_amask_type;\n+            typedef agg::renderer_base<pixfmt_amask_type> amask_ren_type;\n+            typedef agg::renderer_scanline_aa<amask_ren_type, color_span_alloc_type, span_conv>\n+            renderer_type_alpha;\n+\n+            pixfmt_amask_type pfa(pixFmt, alphaMask);\n+            amask_ren_type r(pfa);\n+            renderer_type_alpha ri(r, sa, spans);\n+\n+            theRasterizer.add_path(rect2);\n+            agg::render_scanlines(theRasterizer, scanlineAlphaMask, ri);\n+        } else {\n+            typedef agg::renderer_base<pixfmt> ren_type;\n+            typedef agg::renderer_scanline_aa<ren_type, color_span_alloc_type, span_conv>\n+            renderer_type;\n+\n+            ren_type r(pixFmt);\n+            renderer_type ri(r, sa, spans);\n+\n+            theRasterizer.add_path(rect2);\n+            agg::render_scanlines(theRasterizer, slineP8, ri);\n+        }\n+\n+    } else {\n+        set_clipbox(gc.cliprect, rendererBase);\n+        rendererBase.blend_from(\n+            pixf, 0, (int)x, (int)(height - (y + image.dim(0))), (agg::int8u)(alpha * 255));\n+    }\n+\n+    rendererBase.reset_clipping(true);\n+}\n+\n+template <class PathIterator,\n+          class PathGenerator,\n+          class TransformArray,\n+          class OffsetArray,\n+          class ColorArray,\n+          class LineWidthArray,\n+          class AntialiasedArray>\n+inline void RendererAgg::_draw_path_collection_generic(GCAgg &gc,\n+                                                       agg::trans_affine master_transform,\n+                                                       const agg::rect_d &cliprect,\n+                                                       PathIterator &clippath,\n+                                                       const agg::trans_affine &clippath_trans,\n+                                                       PathGenerator &path_generator,\n+                                                       TransformArray &transforms,\n+                                                       OffsetArray &offsets,\n+                                                       const agg::trans_affine &offset_trans,\n+                                                       ColorArray &facecolors,\n+                                                       ColorArray &edgecolors,\n+                                                       LineWidthArray &linewidths,\n+                                                       DashesVector &linestyles,\n+                                                       AntialiasedArray &antialiaseds,\n+                                                       e_offset_position offset_position,\n+                                                       int check_snap,\n+                                                       int has_curves)\n+{\n+    typedef agg::conv_transform<typename PathGenerator::path_iterator> transformed_path_t;\n+    typedef PathNanRemover<transformed_path_t> nan_removed_t;\n+    typedef PathClipper<nan_removed_t> clipped_t;\n+    typedef PathSnapper<clipped_t> snapped_t;\n+    typedef agg::conv_curve<snapped_t> snapped_curve_t;\n+    typedef agg::conv_curve<clipped_t> curve_t;\n+\n+    if (offsets.dim(0) != 0 && offsets.dim(1) != 2) {\n+        throw \"Offsets array must be Nx2 or empty\";\n+    }\n+\n+    if (facecolors.dim(0) != 0 && facecolors.dim(1) != 4) {\n+        throw \"Facecolors array must be a Nx4 array or empty\";\n+    }\n+\n+    if (edgecolors.dim(0) != 0 && edgecolors.dim(1) != 4) {\n+        throw \"Edgecolors array must by Nx4 or empty\";\n+    }\n+\n+    if (transforms.dim(0) != 0 && (transforms.dim(1) != 3 || transforms.dim(2) != 3)) {\n+        throw \"Transforms array must by Nx3x3 or empty\";\n+    }\n+\n+    size_t Npaths = path_generator.num_paths();\n+    size_t Noffsets = offsets.size();\n+    size_t N = std::max(Npaths, Noffsets);\n+\n+    size_t Ntransforms = transforms.size();\n+    size_t Nfacecolors = facecolors.size();\n+    size_t Nedgecolors = edgecolors.size();\n+    size_t Nlinewidths = linewidths.size();\n+    size_t Nlinestyles = std::min(linestyles.size(), N);\n+    size_t Naa = antialiaseds.size();\n+\n+    if ((Nfacecolors == 0 && Nedgecolors == 0) || Npaths == 0) {\n+        return;\n+    }\n+\n+    // Handle any clipping globally\n+    theRasterizer.reset_clipping();\n+    rendererBase.reset_clipping(true);\n+    set_clipbox(cliprect, theRasterizer);\n+    bool has_clippath = render_clippath(clippath, clippath_trans);\n+\n+    // Set some defaults, assuming no face or edge\n+    gc.linewidth = 0.0;\n+    facepair_t face;\n+    face.first = Nfacecolors != 0;\n+    agg::trans_affine trans;\n+\n+    for (int i = 0; i < (int)N; ++i) {\n+        typename PathGenerator::path_iterator path = path_generator(i);\n+\n+        if (Ntransforms) {\n+            typename TransformArray::sub_t subtrans = transforms[i % Ntransforms];\n+            trans = agg::trans_affine(subtrans(0, 0),\n+                                      subtrans(1, 0),\n+                                      subtrans(0, 1),\n+                                      subtrans(1, 1),\n+                                      subtrans(0, 2),\n+                                      subtrans(1, 2));\n+        } else {\n+            trans = master_transform;\n+        }\n+\n+        if (Noffsets) {\n+            double xo = offsets(i % Noffsets, 0);\n+            double yo = offsets(i % Noffsets, 1);\n+            offset_trans.transform(&xo, &yo);\n+            if (offset_position == OFFSET_POSITION_DATA) {\n+                trans = agg::trans_affine_translation(xo, yo) * trans;\n+            } else {\n+                trans *= agg::trans_affine_translation(xo, yo);\n+            }\n+        }\n+\n+        // These transformations must be done post-offsets\n+        trans *= agg::trans_affine_scaling(1.0, -1.0);\n+        trans *= agg::trans_affine_translation(0.0, (double)height);\n+\n+        if (Nfacecolors) {\n+            typename ColorArray::sub_t facecolor = facecolors[i % Nfacecolors];\n+            face.second = agg::rgba(facecolor(0), facecolor(1), facecolor(2), facecolor(3));\n+        }\n+\n+        if (Nedgecolors) {\n+            typename ColorArray::sub_t edgecolor = edgecolors[i % Nedgecolors];\n+            gc.color = agg::rgba(edgecolor(0), edgecolor(1), edgecolor(2), edgecolor(3));\n+\n+            if (Nlinewidths) {\n+                gc.linewidth = linewidths(i % Nlinewidths);\n+            } else {\n+                gc.linewidth = 1.0;\n+            }\n+            if (Nlinestyles) {\n+                gc.dashes = linestyles[i % Nlinestyles];\n+            }\n+        }\n+\n+        bool do_clip = !face.first && !gc.has_hatchpath() && !has_curves;\n+\n+        if (check_snap) {\n+            gc.isaa = antialiaseds(i % Naa);\n+\n+            transformed_path_t tpath(path, trans);\n+            nan_removed_t nan_removed(tpath, true, has_curves);\n+            clipped_t clipped(nan_removed, do_clip, width, height);\n+            snapped_t snapped(\n+                clipped, gc.snap_mode, path.total_vertices(), points_to_pixels(gc.linewidth));\n+            if (has_curves) {\n+                snapped_curve_t curve(snapped);\n+                _draw_path(curve, has_clippath, face, gc);\n+            } else {\n+                _draw_path(snapped, has_clippath, face, gc);\n+            }\n+        } else {\n+            gc.isaa = antialiaseds(i % Naa);\n+\n+            transformed_path_t tpath(path, trans);\n+            nan_removed_t nan_removed(tpath, true, has_curves);\n+            clipped_t clipped(nan_removed, do_clip, width, height);\n+            if (has_curves) {\n+                curve_t curve(clipped);\n+                _draw_path(curve, has_clippath, face, gc);\n+            } else {\n+                _draw_path(clipped, has_clippath, face, gc);\n+            }\n+        }\n+    }\n+}\n+\n+template <class PathGenerator,\n+          class TransformArray,\n+          class OffsetArray,\n+          class ColorArray,\n+          class LineWidthArray,\n+          class AntialiasedArray>\n+inline void RendererAgg::draw_path_collection(GCAgg &gc,\n+                                              agg::trans_affine &master_transform,\n+                                              PathGenerator &path,\n+                                              TransformArray &transforms,\n+                                              OffsetArray &offsets,\n+                                              agg::trans_affine &offset_trans,\n+                                              ColorArray &facecolors,\n+                                              ColorArray &edgecolors,\n+                                              LineWidthArray &linewidths,\n+                                              DashesVector &linestyles,\n+                                              AntialiasedArray &antialiaseds,\n+                                              e_offset_position offset_position)\n+{\n+    _draw_path_collection_generic(gc,\n+                                  master_transform,\n+                                  gc.cliprect,\n+                                  gc.clippath.path,\n+                                  gc.clippath.trans,\n+                                  path,\n+                                  transforms,\n+                                  offsets,\n+                                  offset_trans,\n+                                  facecolors,\n+                                  edgecolors,\n+                                  linewidths,\n+                                  linestyles,\n+                                  antialiaseds,\n+                                  offset_position,\n+                                  1,\n+                                  1);\n+}\n+\n+template <class CoordinateArray>\n+class QuadMeshGenerator\n+{\n+    unsigned m_meshWidth;\n+    unsigned m_meshHeight;\n+    CoordinateArray m_coordinates;\n+\n+    class QuadMeshPathIterator\n+    {\n+        unsigned m_iterator;\n+        unsigned m_m, m_n;\n+        const CoordinateArray *m_coordinates;\n+\n+      public:\n+        QuadMeshPathIterator(unsigned m, unsigned n, const CoordinateArray *coordinates)\n+            : m_iterator(0), m_m(m), m_n(n), m_coordinates(coordinates)\n+        {\n+        }\n+\n+      private:\n+        inline unsigned vertex(unsigned idx, double *x, double *y)\n+        {\n+            size_t m = m_m + ((idx & 0x2) >> 1);\n+            size_t n = m_n + (((idx + 1) & 0x2) >> 1);\n+            *x = (*m_coordinates)(n, m, 0);\n+            *y = (*m_coordinates)(n, m, 1);\n+            return (idx) ? agg::path_cmd_line_to : agg::path_cmd_move_to;\n+        }\n+\n+      public:\n+        inline unsigned vertex(double *x, double *y)\n+        {\n+            if (m_iterator >= total_vertices()) {\n+                return agg::path_cmd_stop;\n+            }\n+            return vertex(m_iterator++, x, y);\n+        }\n+\n+        inline void rewind(unsigned path_id)\n+        {\n+            m_iterator = path_id;\n+        }\n+\n+        inline unsigned total_vertices()\n+        {\n+            return 5;\n+        }\n+\n+        inline bool should_simplify()\n+        {\n+            return false;\n+        }\n+    };\n+\n+  public:\n+    typedef QuadMeshPathIterator path_iterator;\n+\n+    inline QuadMeshGenerator(unsigned meshWidth, unsigned meshHeight, CoordinateArray &coordinates)\n+        : m_meshWidth(meshWidth), m_meshHeight(meshHeight), m_coordinates(coordinates)\n+    {\n+    }\n+\n+    inline size_t num_paths() const\n+    {\n+        return m_meshWidth * m_meshHeight;\n+    }\n+\n+    inline path_iterator operator()(size_t i) const\n+    {\n+        return QuadMeshPathIterator(i % m_meshWidth, i / m_meshWidth, &m_coordinates);\n+    }\n };\n \n+template <class CoordinateArray, class OffsetArray, class ColorArray>\n+inline void RendererAgg::draw_quad_mesh(GCAgg &gc,\n+                                        agg::trans_affine &master_transform,\n+                                        size_t mesh_width,\n+                                        size_t mesh_height,\n+                                        CoordinateArray &coordinates,\n+                                        OffsetArray &offsets,\n+                                        agg::trans_affine &offset_trans,\n+                                        ColorArray &facecolors,\n+                                        bool antialiased,\n+                                        ColorArray &edgecolors)\n+{\n+    QuadMeshGenerator<CoordinateArray> path_generator(mesh_width, mesh_height, coordinates);\n+\n+    array::empty<double> transforms;\n+    array::scalar<double, 1> linewidths(points_to_pixels(gc.linewidth));\n+    array::scalar<uint8_t, 1> antialiaseds(antialiased);\n+    DashesVector linestyles;\n+    ColorArray *edgecolors_ptr = &edgecolors;\n+\n+    if (edgecolors.size() == 0) {\n+        if (antialiased) {\n+            edgecolors_ptr = &facecolors;\n+        }\n+    }\n \n+    _draw_path_collection_generic(gc,\n+                                  master_transform,\n+                                  gc.cliprect,\n+                                  gc.clippath.path,\n+                                  gc.clippath.trans,\n+                                  path_generator,\n+                                  transforms,\n+                                  offsets,\n+                                  offset_trans,\n+                                  facecolors,\n+                                  *edgecolors_ptr,\n+                                  linewidths,\n+                                  linestyles,\n+                                  antialiaseds,\n+                                  OFFSET_POSITION_FIGURE,\n+                                  0,\n+                                  0);\n+}\n+\n+template <class PointArray, class ColorArray>\n+inline void RendererAgg::_draw_gouraud_triangle(PointArray &points,\n+                                                ColorArray &colors,\n+                                                agg::trans_affine trans,\n+                                                bool has_clippath)\n+{\n+    typedef agg::rgba8 color_t;\n+    typedef agg::span_gouraud_rgba<color_t> span_gen_t;\n+    typedef agg::span_allocator<color_t> span_alloc_t;\n+\n+    trans *= agg::trans_affine_scaling(1.0, -1.0);\n+    trans *= agg::trans_affine_translation(0.0, (double)height);\n+\n+    double tpoints[3][2];\n+\n+    for (int i = 0; i < 3; ++i) {\n+        for (int j = 0; j < 2; ++j) {\n+            tpoints[i][j] = points(i, j);\n+        }\n+        trans.transform(&tpoints[i][0], &tpoints[i][1]);\n+    }\n+\n+    span_alloc_t span_alloc;\n+    span_gen_t span_gen;\n+\n+    span_gen.colors(agg::rgba(colors(0, 0), colors(0, 1), colors(0, 2), colors(0, 3)),\n+                    agg::rgba(colors(1, 0), colors(1, 1), colors(1, 2), colors(1, 3)),\n+                    agg::rgba(colors(2, 0), colors(2, 1), colors(2, 2), colors(2, 3)));\n+    span_gen.triangle(tpoints[0][0],\n+                      tpoints[0][1],\n+                      tpoints[1][0],\n+                      tpoints[1][1],\n+                      tpoints[2][0],\n+                      tpoints[2][1],\n+                      0.5);\n+\n+    theRasterizer.add_path(span_gen);\n+\n+    if (has_clippath) {\n+        typedef agg::pixfmt_amask_adaptor<pixfmt, alpha_mask_type> pixfmt_amask_type;\n+        typedef agg::renderer_base<pixfmt_amask_type> amask_ren_type;\n+        typedef agg::renderer_scanline_aa<amask_ren_type, span_alloc_t, span_gen_t>\n+        amask_aa_renderer_type;\n+\n+        pixfmt_amask_type pfa(pixFmt, alphaMask);\n+        amask_ren_type r(pfa);\n+        amask_aa_renderer_type ren(r, span_alloc, span_gen);\n+        agg::render_scanlines(theRasterizer, scanlineAlphaMask, ren);\n+    } else {\n+        agg::render_scanlines_aa(theRasterizer, slineP8, rendererBase, span_alloc, span_gen);\n+    }\n+}\n+\n+template <class PointArray, class ColorArray>\n+inline void RendererAgg::draw_gouraud_triangle(GCAgg &gc,\n+                                               PointArray &points,\n+                                               ColorArray &colors,\n+                                               agg::trans_affine &trans)\n+{\n+    theRasterizer.reset_clipping();\n+    rendererBase.reset_clipping(true);\n+    set_clipbox(gc.cliprect, theRasterizer);\n+    bool has_clippath = render_clippath(gc.clippath.path, gc.clippath.trans);\n+\n+    if (points.dim(0) != 3 || points.dim(1) != 2) {\n+        throw \"points must be a 3x2 array\";\n+    }\n+\n+    if (colors.dim(0) != 3 || colors.dim(1) != 4) {\n+        throw \"colors must be a 3x4 array\";\n+    }\n+\n+    _draw_gouraud_triangle(points, colors, trans, has_clippath);\n+}\n+\n+template <class PointArray, class ColorArray>\n+inline void RendererAgg::draw_gouraud_triangles(GCAgg &gc,\n+                                                PointArray &points,\n+                                                ColorArray &colors,\n+                                                agg::trans_affine &trans)\n+{\n+    theRasterizer.reset_clipping();\n+    rendererBase.reset_clipping(true);\n+    set_clipbox(gc.cliprect, theRasterizer);\n+    bool has_clippath = render_clippath(gc.clippath.path, gc.clippath.trans);\n+\n+    if (points.dim(1) != 3 || points.dim(2) != 2) {\n+        throw \"points must be a Nx3x2 array\";\n+    }\n+\n+    if (colors.dim(1) != 3 || colors.dim(2) != 4) {\n+        throw \"colors must be a Nx3x4 array\";\n+    }\n+\n+    if (points.dim(0) != colors.dim(0)) {\n+        throw \"points and colors arrays must be the same length\";\n+    }\n+\n+    for (int i = 0; i < points.dim(0); ++i) {\n+        typename PointArray::sub_t point = points[i];\n+        typename ColorArray::sub_t color = colors[i];\n+\n+        _draw_gouraud_triangle(point, color, trans, has_clippath);\n+    }\n+}\n+\n+template <class R>\n+void RendererAgg::set_clipbox(const agg::rect_d &cliprect, R &rasterizer)\n+{\n+    // set the clip rectangle from the gc\n+\n+    if (cliprect.x1 != 0.0 || cliprect.y1 != 0.0 || cliprect.x2 != 0.0 || cliprect.y2 != 0.0) {\n+        rasterizer.clip_box(std::max(int(floor(cliprect.x1 + 0.5)), 0),\n+                            std::max(int(floor(height - cliprect.y1 + 0.5)), 0),\n+                            std::min(int(floor(cliprect.x2 + 0.5)), int(width)),\n+                            std::min(int(floor(height - cliprect.y2 + 0.5)), int(height)));\n+    } else {\n+        rasterizer.clip_box(0, 0, width, height);\n+    }\n+}\n \n #endif"}
{"patches_id": 2, "files_id": 30, "language": "h", "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_backend_agg_basic_types.h", "raw_code": "#ifndef __BACKEND_AGG_BASIC_TYPES_H__\n#define __BACKEND_AGG_BASIC_TYPES_H__\n\n/* Contains some simple types from the Agg backend that are also used\n   by other modules */\n\n#include <vector>\n\n#include \"agg_color_rgba.h\"\n#include \"agg_math_stroke.h\"\n#include \"path_converters.h\"\n\n#include \"py_adaptors.h\"\n\nstruct ClipPath\n{\n    py::PathIterator path;\n    agg::trans_affine trans;\n};\n\nstruct SketchParams\n{\n    double scale;\n    double length;\n    double randomness;\n};\n\nclass Dashes\n{\n    typedef std::vector<std::pair<double, double> > dash_t;\n    double dash_offset;\n    dash_t dashes;\n\n  public:\n    double get_dash_offset() const\n    {\n        return dash_offset;\n    }\n    void set_dash_offset(double x)\n    {\n        dash_offset = x;\n    }\n    void add_dash_pair(double length, double skip)\n    {\n        dashes.push_back(std::make_pair(length, skip));\n    }\n    size_t size() const\n    {\n        return dashes.size();\n    }\n\n    template <class T>\n    void dash_to_stroke(T &stroke, double dpi, bool isaa)\n    {\n        for (dash_t::const_iterator i = dashes.begin(); i != dashes.end(); ++i) {\n            double val0 = i->first;\n            double val1 = i->second;\n            val0 = val0 * dpi / 72.0;\n            val1 = val1 * dpi / 72.0;\n            if (!isaa) {\n                val0 = (int)val0 + 0.5;\n                val1 = (int)val1 + 0.5;\n            }\n            stroke.add_dash(val0, val1);\n        }\n    }\n};\n\ntypedef std::vector<Dashes> DashesVector;\n\nenum e_offset_position {\n    OFFSET_POSITION_FIGURE,\n    OFFSET_POSITION_DATA\n};\n\nclass GCAgg\n{\n  public:\n    GCAgg()\n        : linewidth(1.0),\n          alpha(1.0),\n          cap(agg::butt_cap),\n          join(agg::round_join),\n          snap_mode(SNAP_FALSE)\n    {\n    }\n\n    ~GCAgg()\n    {\n    }\n\n    double linewidth;\n    double alpha;\n    bool forced_alpha;\n    agg::rgba color;\n    bool isaa;\n\n    agg::line_cap_e cap;\n    agg::line_join_e join;\n\n    agg::rect_d cliprect;\n\n    ClipPath clippath;\n\n    Dashes dashes;\n\n    e_snap_mode snap_mode;\n\n    py::PathIterator hatchpath;\n\n    SketchParams sketch;\n\n    bool has_hatchpath()\n    {\n        return hatchpath.total_vertices();\n    }\n\n  private:\n    // prevent copying\n    GCAgg(const GCAgg &);\n    GCAgg &operator=(const GCAgg &);\n};\n\n#endif\n", "patch": "@@ -0,0 +1,124 @@\n+#ifndef __BACKEND_AGG_BASIC_TYPES_H__\n+#define __BACKEND_AGG_BASIC_TYPES_H__\n+\n+/* Contains some simple types from the Agg backend that are also used\n+   by other modules */\n+\n+#include <vector>\n+\n+#include \"agg_color_rgba.h\"\n+#include \"agg_math_stroke.h\"\n+#include \"path_converters.h\"\n+\n+#include \"py_adaptors.h\"\n+\n+struct ClipPath\n+{\n+    py::PathIterator path;\n+    agg::trans_affine trans;\n+};\n+\n+struct SketchParams\n+{\n+    double scale;\n+    double length;\n+    double randomness;\n+};\n+\n+class Dashes\n+{\n+    typedef std::vector<std::pair<double, double> > dash_t;\n+    double dash_offset;\n+    dash_t dashes;\n+\n+  public:\n+    double get_dash_offset() const\n+    {\n+        return dash_offset;\n+    }\n+    void set_dash_offset(double x)\n+    {\n+        dash_offset = x;\n+    }\n+    void add_dash_pair(double length, double skip)\n+    {\n+        dashes.push_back(std::make_pair(length, skip));\n+    }\n+    size_t size() const\n+    {\n+        return dashes.size();\n+    }\n+\n+    template <class T>\n+    void dash_to_stroke(T &stroke, double dpi, bool isaa)\n+    {\n+        for (dash_t::const_iterator i = dashes.begin(); i != dashes.end(); ++i) {\n+            double val0 = i->first;\n+            double val1 = i->second;\n+            val0 = val0 * dpi / 72.0;\n+            val1 = val1 * dpi / 72.0;\n+            if (!isaa) {\n+                val0 = (int)val0 + 0.5;\n+                val1 = (int)val1 + 0.5;\n+            }\n+            stroke.add_dash(val0, val1);\n+        }\n+    }\n+};\n+\n+typedef std::vector<Dashes> DashesVector;\n+\n+enum e_offset_position {\n+    OFFSET_POSITION_FIGURE,\n+    OFFSET_POSITION_DATA\n+};\n+\n+class GCAgg\n+{\n+  public:\n+    GCAgg()\n+        : linewidth(1.0),\n+          alpha(1.0),\n+          cap(agg::butt_cap),\n+          join(agg::round_join),\n+          snap_mode(SNAP_FALSE)\n+    {\n+    }\n+\n+    ~GCAgg()\n+    {\n+    }\n+\n+    double linewidth;\n+    double alpha;\n+    bool forced_alpha;\n+    agg::rgba color;\n+    bool isaa;\n+\n+    agg::line_cap_e cap;\n+    agg::line_join_e join;\n+\n+    agg::rect_d cliprect;\n+\n+    ClipPath clippath;\n+\n+    Dashes dashes;\n+\n+    e_snap_mode snap_mode;\n+\n+    py::PathIterator hatchpath;\n+\n+    SketchParams sketch;\n+\n+    bool has_hatchpath()\n+    {\n+        return hatchpath.total_vertices();\n+    }\n+\n+  private:\n+    // prevent copying\n+    GCAgg(const GCAgg &);\n+    GCAgg &operator=(const GCAgg &);\n+};\n+\n+#endif"}
{"patches_id": 2, "files_id": 31, "language": "cpp", "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_backend_agg_wrapper.cpp", "raw_code": "#include \"_backend_agg_wrapper.h\"\n\n/**********************************************************************\n * BufferRegion\n * */\n\nstatic PyObject *PyBufferRegion_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    PyBufferRegion *self;\n    self = (PyBufferRegion *)type->tp_alloc(type, 0);\n    self->x = NULL;\n    return (PyObject *)self;\n}\n\nstatic void PyBufferRegion_dealloc(PyBufferRegion *self)\n{\n    delete self->x;\n    Py_TYPE(self)->tp_free((PyObject *)self);\n}\n\nstatic PyObject *PyBufferRegion_to_string(PyBufferRegion *self, PyObject *args, PyObject *kwds)\n{\n    return PyBytes_FromStringAndSize((const char *)self->x->get_data(),\n                                     self->x->get_height() * self->x->get_stride());\n}\n\n/* TODO: This doesn't seem to be used internally.  Remove? */\n\nstatic PyObject *PyBufferRegion_set_x(PyBufferRegion *self, PyObject *args, PyObject *kwds)\n{\n    int x;\n    if (!PyArg_ParseTuple(args, \"i:set_x\", &x)) {\n        return NULL;\n    }\n    self->x->get_rect().x1 = x;\n\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *PyBufferRegion_set_y(PyBufferRegion *self, PyObject *args, PyObject *kwds)\n{\n    int y;\n    if (!PyArg_ParseTuple(args, \"i:set_y\", &y)) {\n        return NULL;\n    }\n    self->x->get_rect().y1 = y;\n\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *PyBufferRegion_get_extents(PyBufferRegion *self, PyObject *args, PyObject *kwds)\n{\n    agg::rect_i rect = self->x->get_rect();\n\n    return Py_BuildValue(\"IIII\", rect.x1, rect.y1, rect.x2, rect.y2);\n}\n\nstatic PyObject *PyBufferRegion_to_string_argb(PyBufferRegion *self, PyObject *args, PyObject *kwds)\n{\n    PyObject *bufobj;\n    uint8_t *buf;\n\n    bufobj = PyBytes_FromStringAndSize(NULL, self->x->get_height() * self->x->get_stride());\n    buf = (uint8_t *)PyBytes_AS_STRING(bufobj);\n\n    CALL_CPP_CLEANUP(\"to_string_argb\", (self->x->to_string_argb(buf)), Py_DECREF(bufobj));\n\n    return bufobj;\n}\n\nint PyBufferRegion_get_buffer(PyBufferRegion *self, Py_buffer *buf, int flags)\n{\n    Py_INCREF(self);\n    buf->obj = (PyObject *)self;\n    buf->buf = self->x->get_data();\n    buf->len = self->x->get_width() * self->x->get_height() * 4;\n    buf->readonly = 0;\n    buf->format = (char *)\"B\";\n    buf->ndim = 3;\n    self->shape[0] = self->x->get_height();\n    self->shape[1] = self->x->get_width();\n    self->shape[2] = 4;\n    buf->shape = self->shape;\n    self->strides[0] = self->x->get_width() * 4;\n    self->strides[1] = 4;\n    self->strides[2] = 1;\n    buf->strides = self->strides;\n    buf->suboffsets = NULL;\n    buf->itemsize = 1;\n    buf->internal = NULL;\n\n    return 1;\n}\n\nstatic PyTypeObject PyBufferRegionType;\n\nstatic PyTypeObject *PyBufferRegion_init_type(PyObject *m, PyTypeObject *type)\n{\n    static PyMethodDef methods[] = {\n        { \"to_string\", (PyCFunction)PyBufferRegion_to_string, METH_NOARGS, NULL },\n        { \"to_string_argb\", (PyCFunction)PyBufferRegion_to_string_argb, METH_NOARGS, NULL },\n        { \"set_x\", (PyCFunction)PyBufferRegion_set_x, METH_VARARGS, NULL },\n        { \"set_y\", (PyCFunction)PyBufferRegion_set_y, METH_VARARGS, NULL },\n        { \"get_extents\", (PyCFunction)PyBufferRegion_get_extents, METH_NOARGS, NULL },\n        { NULL }\n    };\n\n    static PyBufferProcs buffer_procs;\n    memset(&buffer_procs, 0, sizeof(PyBufferProcs));\n    buffer_procs.bf_getbuffer = (getbufferproc)PyBufferRegion_get_buffer;\n\n    memset(type, 0, sizeof(PyTypeObject));\n    type->tp_name = \"matplotlib.backends._backend_agg.BufferRegion\";\n    type->tp_basicsize = sizeof(PyBufferRegion);\n    type->tp_dealloc = (destructor)PyBufferRegion_dealloc;\n    type->tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_NEWBUFFER;\n    type->tp_methods = methods;\n    type->tp_new = PyBufferRegion_new;\n    type->tp_as_buffer = &buffer_procs;\n\n    if (PyType_Ready(type) < 0) {\n        return NULL;\n    }\n\n    /* Don't need to add to module, since you can't create buffer\n       regions directly from Python */\n\n    return type;\n}\n\n/**********************************************************************\n * RendererAgg\n * */\n\nstatic PyObject *PyRendererAgg_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    PyRendererAgg *self;\n    self = (PyRendererAgg *)type->tp_alloc(type, 0);\n    self->x = NULL;\n    return (PyObject *)self;\n}\n\nstatic int PyRendererAgg_init(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n{\n    unsigned int width;\n    unsigned int height;\n    double dpi;\n    int debug = 0;\n\n    if (!PyArg_ParseTuple(args, \"IId|i:RendererAgg\", &width, &height, &dpi, &debug)) {\n        return -1;\n    }\n\n    if (dpi <= 0.0) {\n        PyErr_SetString(PyExc_ValueError, \"dpi must be positive\");\n        return -1;\n    }\n\n    CALL_CPP_INIT(\"RendererAgg\", self->x = new RendererAgg(width, height, dpi))\n\n    return 0;\n}\n\nstatic void PyRendererAgg_dealloc(PyRendererAgg *self)\n{\n    delete self->x;\n    Py_TYPE(self)->tp_free((PyObject *)self);\n}\n\nstatic PyObject *PyRendererAgg_draw_path(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n{\n    GCAgg gc;\n    py::PathIterator path;\n    agg::trans_affine trans;\n    PyObject *faceobj = NULL;\n    agg::rgba face;\n\n    if (!PyArg_ParseTuple(args,\n                          \"O&O&O&|O:draw_path\",\n                          &convert_gcagg,\n                          &gc,\n                          &convert_path,\n                          &path,\n                          &convert_trans_affine,\n                          &trans,\n                          &faceobj)) {\n        return NULL;\n    }\n\n    if (!convert_face(faceobj, gc, &face)) {\n        return NULL;\n    }\n\n    CALL_CPP(\"draw_path\", (self->x->draw_path(gc, path, trans, face)));\n\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *PyRendererAgg_draw_text_image(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n{\n    numpy::array_view<agg::int8u, 2> image;\n    double x;\n    double y;\n    double angle;\n    GCAgg gc;\n\n    if (!PyArg_ParseTuple(args,\n                          \"O&dddO&:draw_text_image\",\n                          &numpy::convert_array_contiguous<agg::int8u, 2>,\n                          &image,\n                          &x,\n                          &y,\n                          &angle,\n                          &convert_gcagg,\n                          &gc)) {\n        return NULL;\n    }\n\n    CALL_CPP(\"draw_text_image\", (self->x->draw_text_image(gc, image, x, y, angle)));\n\n    Py_RETURN_NONE;\n}\n\nPyObject *PyRendererAgg_draw_markers(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n{\n    GCAgg gc;\n    py::PathIterator marker_path;\n    agg::trans_affine marker_path_trans;\n    py::PathIterator path;\n    agg::trans_affine trans;\n    PyObject *faceobj = NULL;\n    agg::rgba face;\n\n    if (!PyArg_ParseTuple(args,\n                          \"O&O&O&O&O&|O:draw_markers\",\n                          &convert_gcagg,\n                          &gc,\n                          &convert_path,\n                          &marker_path,\n                          &convert_trans_affine,\n                          &marker_path_trans,\n                          &convert_path,\n                          &path,\n                          &convert_trans_affine,\n                          &trans,\n                          &faceobj)) {\n        return NULL;\n    }\n\n    if (!convert_face(faceobj, gc, &face)) {\n        return NULL;\n    }\n\n    CALL_CPP(\"draw_markers\",\n             (self->x->draw_markers(gc, marker_path, marker_path_trans, path, trans, face)));\n\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *PyRendererAgg_draw_image(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n{\n    GCAgg gc;\n    double x;\n    double y;\n    numpy::array_view<agg::int8u, 3> image;\n    double w = 0;\n    double h = 0;\n    agg::trans_affine trans;\n    bool resize = false;\n\n    if (!PyArg_ParseTuple(args,\n                          \"O&ddO&|ddO&:draw_image\",\n                          &convert_gcagg,\n                          &gc,\n                          &x,\n                          &y,\n                          &numpy::convert_array_contiguous<agg::int8u, 3>,\n                          &image,\n                          &w,\n                          &h,\n                          &convert_trans_affine,\n                          &trans)) {\n        return NULL;\n    }\n\n    if (PyTuple_Size(args) == 4) {\n        x = mpl_round(x);\n        y = mpl_round(y);\n    } else {\n        resize = true;\n    }\n\n    CALL_CPP(\"draw_image\", (self->x->draw_image(gc, x, y, image, w, h, trans, resize)));\n\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *\nPyRendererAgg_draw_path_collection(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n{\n    GCAgg gc;\n    agg::trans_affine master_transform;\n    PyObject *pathobj;\n    numpy::array_view<const double, 3> transforms;\n    numpy::array_view<const double, 2> offsets;\n    agg::trans_affine offset_trans;\n    numpy::array_view<const double, 2> facecolors;\n    numpy::array_view<const double, 2> edgecolors;\n    numpy::array_view<const double, 1> linewidths;\n    DashesVector dashes;\n    numpy::array_view<const uint8_t, 1> antialiaseds;\n    PyObject *ignored;\n    e_offset_position offset_position;\n\n    if (!PyArg_ParseTuple(args,\n                          \"O&O&OO&O&O&O&O&O&O&O&OO&:draw_path_collection\",\n                          &convert_gcagg,\n                          &gc,\n                          &convert_trans_affine,\n                          &master_transform,\n                          &pathobj,\n                          &numpy::convert_array<const double, 3>,\n                          &transforms,\n                          &numpy::convert_array<const double, 2>,\n                          &offsets,\n                          &convert_trans_affine,\n                          &offset_trans,\n                          &numpy::convert_array<const double, 2>,\n                          &facecolors,\n                          &numpy::convert_array<const double, 2>,\n                          &edgecolors,\n                          &numpy::convert_array<const double, 1>,\n                          &linewidths,\n                          &convert_dashes_vector,\n                          &dashes,\n                          &numpy::convert_array<const uint8_t, 1>,\n                          &antialiaseds,\n                          &ignored,\n                          &convert_offset_position,\n                          &offset_position)) {\n        return NULL;\n    }\n\n    try\n    {\n        py::PathGenerator path(pathobj);\n\n        CALL_CPP(\"draw_path_collection\",\n                 (self->x->draw_path_collection(gc,\n                                                master_transform,\n                                                path,\n                                                transforms,\n                                                offsets,\n                                                offset_trans,\n                                                facecolors,\n                                                edgecolors,\n                                                linewidths,\n                                                dashes,\n                                                antialiaseds,\n                                                offset_position)));\n    }\n    catch (py::exception &e)\n    {\n        return NULL;\n    }\n\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *PyRendererAgg_draw_quad_mesh(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n{\n    GCAgg gc;\n    agg::trans_affine master_transform;\n    size_t mesh_width;\n    size_t mesh_height;\n    numpy::array_view<const double, 3> coordinates;\n    numpy::array_view<const double, 2> offsets;\n    agg::trans_affine offset_trans;\n    numpy::array_view<const double, 2> facecolors;\n    int antialiased;\n    numpy::array_view<const double, 2> edgecolors;\n\n    if (!PyArg_ParseTuple(args,\n                          \"O&O&IIO&O&O&O&iO&:draw_quad_mesh\",\n                          &convert_gcagg,\n                          &gc,\n                          &convert_trans_affine,\n                          &master_transform,\n                          &mesh_width,\n                          &mesh_height,\n                          &numpy::convert_array<const double, 3>,\n                          &coordinates,\n                          &numpy::convert_array<const double, 2>,\n                          &offsets,\n                          &convert_trans_affine,\n                          &offset_trans,\n                          &numpy::convert_array<const double, 2>,\n                          &facecolors,\n                          &antialiased,\n                          &numpy::convert_array<const double, 2>,\n                          &edgecolors)) {\n        return NULL;\n    }\n\n    CALL_CPP(\"draw_quad_mesh\",\n             (self->x->draw_quad_mesh(gc,\n                                      master_transform,\n                                      mesh_width,\n                                      mesh_height,\n                                      coordinates,\n                                      offsets,\n                                      offset_trans,\n                                      facecolors,\n                                      antialiased,\n                                      edgecolors)));\n\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *\nPyRendererAgg_draw_gouraud_triangle(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n{\n    GCAgg gc;\n    numpy::array_view<const double, 2> points;\n    numpy::array_view<const double, 2> colors;\n    agg::trans_affine trans;\n\n    if (!PyArg_ParseTuple(args,\n                          \"O&O&O&O&|O:draw_gouraud_triangle\",\n                          &convert_gcagg,\n                          &gc,\n                          &numpy::convert_array<const double, 2>,\n                          &points,\n                          &numpy::convert_array<const double, 2>,\n                          &colors,\n                          &convert_trans_affine,\n                          &trans)) {\n        return NULL;\n    }\n\n    CALL_CPP(\"draw_gouraud_triangle\", (self->x->draw_gouraud_triangle(gc, points, colors, trans)));\n\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *\nPyRendererAgg_draw_gouraud_triangles(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n{\n    GCAgg gc;\n    numpy::array_view<const double, 3> points;\n    numpy::array_view<const double, 3> colors;\n    agg::trans_affine trans;\n\n    if (!PyArg_ParseTuple(args,\n                          \"O&O&O&O&|O:draw_gouraud_triangles\",\n                          &convert_gcagg,\n                          &gc,\n                          &numpy::convert_array<const double, 3>,\n                          &points,\n                          &numpy::convert_array<const double, 3>,\n                          &colors,\n                          &convert_trans_affine,\n                          &trans)) {\n        return NULL;\n    }\n\n    CALL_CPP(\"draw_gouraud_triangles\", self->x->draw_gouraud_triangles(gc, points, colors, trans));\n\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *PyRendererAgg_tostring_rgb(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n{\n    PyObject *buffobj = NULL;\n\n    buffobj = PyBytes_FromStringAndSize(NULL, self->x->get_width() * self->x->get_height() * 3);\n    if (buffobj == NULL) {\n        return NULL;\n    }\n\n    CALL_CPP_CLEANUP(\"tostring_rgb\",\n                     (self->x->tostring_rgb((uint8_t *)PyBytes_AS_STRING(buffobj))),\n                     Py_DECREF(buffobj));\n\n    return buffobj;\n}\n\nstatic PyObject *PyRendererAgg_tostring_argb(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n{\n    PyObject *buffobj = NULL;\n\n    buffobj = PyBytes_FromStringAndSize(NULL, self->x->get_width() * self->x->get_height() * 4);\n    if (buffobj == NULL) {\n        return NULL;\n    }\n\n    CALL_CPP_CLEANUP(\"tostring_argb\",\n                     (self->x->tostring_argb((uint8_t *)PyBytes_AS_STRING(buffobj))),\n                     Py_DECREF(buffobj));\n\n    return buffobj;\n}\n\nstatic PyObject *PyRendererAgg_tostring_bgra(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n{\n    PyObject *buffobj = NULL;\n\n    buffobj = PyBytes_FromStringAndSize(NULL, self->x->get_width() * self->x->get_height() * 4);\n    if (buffobj == NULL) {\n        return NULL;\n    }\n\n    CALL_CPP_CLEANUP(\"to_string_bgra\",\n                     (self->x->tostring_bgra((uint8_t *)PyBytes_AS_STRING(buffobj))),\n                     Py_DECREF(buffobj));\n\n    return buffobj;\n}\n\nstatic PyObject *\nPyRendererAgg_get_content_extents(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n{\n    agg::rect_i extents;\n\n    CALL_CPP(\"get_content_extents\", (extents = self->x->get_content_extents()));\n\n    return Py_BuildValue(\n        \"iiii\", extents.x1, extents.y1, extents.x2 - extents.x1, extents.y2 - extents.y1);\n}\n\nstatic PyObject *PyRendererAgg_buffer_rgba(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n{\n#if PY3K\n    return PyBytes_FromStringAndSize((const char *)self->x->pixBuffer,\n                                     self->x->get_width() * self->x->get_height() * 4);\n#else\n    return PyBuffer_FromReadWriteMemory(self->x->pixBuffer,\n                                        self->x->get_width() * self->x->get_height() * 4);\n#endif\n}\n\nint PyRendererAgg_get_buffer(PyRendererAgg *self, Py_buffer *buf, int flags)\n{\n    Py_INCREF(self);\n    buf->obj = (PyObject *)self;\n    buf->buf = self->x->pixBuffer;\n    buf->len = self->x->get_width() * self->x->get_height() * 4;\n    buf->readonly = 0;\n    buf->format = (char *)\"B\";\n    buf->ndim = 3;\n    self->shape[0] = self->x->get_height();\n    self->shape[1] = self->x->get_width();\n    self->shape[2] = 4;\n    buf->shape = self->shape;\n    self->strides[0] = self->x->get_width() * 4;\n    self->strides[1] = 4;\n    self->strides[2] = 1;\n    buf->strides = self->strides;\n    buf->suboffsets = NULL;\n    buf->itemsize = 1;\n    buf->internal = NULL;\n\n    return 1;\n}\n\nstatic PyObject *PyRendererAgg_clear(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n{\n    CALL_CPP(\"clear\", self->x->clear());\n\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *PyRendererAgg_copy_from_bbox(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n{\n    agg::rect_d bbox;\n    BufferRegion *reg;\n    PyObject *regobj;\n\n    if (!PyArg_ParseTuple(args, \"O&:copy_from_bbox\", &convert_rect, &bbox)) {\n        return 0;\n    }\n\n    CALL_CPP(\"copy_from_bbox\", (reg = self->x->copy_from_bbox(bbox)));\n\n    regobj = PyBufferRegion_new(&PyBufferRegionType, NULL, NULL);\n    ((PyBufferRegion *)regobj)->x = reg;\n\n    return regobj;\n}\n\nstatic PyObject *PyRendererAgg_restore_region(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n{\n    PyBufferRegion *regobj;\n    int xx1 = 0, yy1 = 0, xx2 = 0, yy2 = 0, x = 0, y = 0;\n\n    if (!PyArg_ParseTuple(args,\n                          \"O!|iiiiii:restore_region\",\n                          &PyBufferRegionType,\n                          &regobj,\n                          &xx1,\n                          &yy1,\n                          &xx2,\n                          &yy2,\n                          &x,\n                          &y)) {\n        return 0;\n    }\n\n    if (PySequence_Size(args) == 1) {\n        CALL_CPP(\"restore_region\", (self->x->restore_region(*(regobj->x))));\n    } else {\n        CALL_CPP(\"restore_region\", self->x->restore_region(*(regobj->x), xx1, yy1, xx2, yy2, x, y));\n    }\n\n    Py_RETURN_NONE;\n}\n\nPyTypeObject PyRendererAggType;\n\nstatic PyTypeObject *PyRendererAgg_init_type(PyObject *m, PyTypeObject *type)\n{\n    static PyMethodDef methods[] = {\n        {\"draw_path\", (PyCFunction)PyRendererAgg_draw_path, METH_VARARGS, NULL},\n        {\"draw_markers\", (PyCFunction)PyRendererAgg_draw_markers, METH_VARARGS, NULL},\n        {\"draw_text_image\", (PyCFunction)PyRendererAgg_draw_text_image, METH_VARARGS, NULL},\n        {\"draw_image\", (PyCFunction)PyRendererAgg_draw_image, METH_VARARGS, NULL},\n        {\"draw_path_collection\", (PyCFunction)PyRendererAgg_draw_path_collection, METH_VARARGS, NULL},\n        {\"draw_quad_mesh\", (PyCFunction)PyRendererAgg_draw_quad_mesh, METH_VARARGS, NULL},\n        {\"draw_gouraud_triangle\", (PyCFunction)PyRendererAgg_draw_gouraud_triangle, METH_VARARGS, NULL},\n        {\"draw_gouraud_triangles\", (PyCFunction)PyRendererAgg_draw_gouraud_triangles, METH_VARARGS, NULL},\n\n        {\"tostring_rgb\", (PyCFunction)PyRendererAgg_tostring_rgb, METH_NOARGS, NULL},\n        {\"tostring_argb\", (PyCFunction)PyRendererAgg_tostring_argb, METH_NOARGS, NULL},\n        {\"tostring_bgra\", (PyCFunction)PyRendererAgg_tostring_bgra, METH_NOARGS, NULL},\n        {\"get_content_extents\", (PyCFunction)PyRendererAgg_get_content_extents, METH_NOARGS, NULL},\n        {\"buffer_rgba\", (PyCFunction)PyRendererAgg_buffer_rgba, METH_NOARGS, NULL},\n        {\"clear\", (PyCFunction)PyRendererAgg_clear, METH_NOARGS, NULL},\n\n        {\"copy_from_bbox\", (PyCFunction)PyRendererAgg_copy_from_bbox, METH_VARARGS, NULL},\n        {\"restore_region\", (PyCFunction)PyRendererAgg_restore_region, METH_VARARGS, NULL},\n        {NULL}\n    };\n\n    static PyBufferProcs buffer_procs;\n    memset(&buffer_procs, 0, sizeof(PyBufferProcs));\n    buffer_procs.bf_getbuffer = (getbufferproc)PyRendererAgg_get_buffer;\n\n    memset(type, 0, sizeof(PyTypeObject));\n    type->tp_name = \"matplotlib.backends._backend_agg.RendererAgg\";\n    type->tp_basicsize = sizeof(PyRendererAgg);\n    type->tp_dealloc = (destructor)PyRendererAgg_dealloc;\n    type->tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_NEWBUFFER;\n    type->tp_methods = methods;\n    type->tp_init = (initproc)PyRendererAgg_init;\n    type->tp_new = PyRendererAgg_new;\n    type->tp_as_buffer = &buffer_procs;\n\n    if (PyType_Ready(type) < 0) {\n        return NULL;\n    }\n\n    if (PyModule_AddObject(m, \"RendererAgg\", (PyObject *)type)) {\n        return NULL;\n    }\n\n    return type;\n}\n\nextern \"C\" {\n\nstruct module_state\n{\n/* The Sun compiler can't handle empty structs */\n#if defined(__SUNPRO_C) || defined(_MSC_VER)\n    int _dummy;\n#endif\n};\n\n#if PY3K\nstatic struct PyModuleDef moduledef = {\n    PyModuleDef_HEAD_INIT,\n    \"_backend_agg\",\n    NULL,\n    sizeof(struct module_state),\n    NULL,\n    NULL,\n    NULL,\n    NULL,\n    NULL\n};\n\n#define INITERROR return NULL\n\nPyMODINIT_FUNC PyInit__backend_agg(void)\n\n#else\n#define INITERROR return\n\nPyMODINIT_FUNC init_backend_agg(void)\n#endif\n\n{\n    PyObject *m;\n\n#if PY3K\n    m = PyModule_Create(&moduledef);\n#else\n    m = Py_InitModule3(\"_backend_agg\", NULL, NULL);\n#endif\n\n    if (m == NULL) {\n        INITERROR;\n    }\n\n    import_array();\n\n    if (!PyRendererAgg_init_type(m, &PyRendererAggType)) {\n        INITERROR;\n    }\n\n    if (!PyBufferRegion_init_type(m, &PyBufferRegionType)) {\n        INITERROR;\n    }\n\n#if PY3K\n    return m;\n#endif\n}\n\n} // extern \"C\"\n", "patch": "@@ -0,0 +1,730 @@\n+#include \"_backend_agg_wrapper.h\"\n+\n+/**********************************************************************\n+ * BufferRegion\n+ * */\n+\n+static PyObject *PyBufferRegion_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n+{\n+    PyBufferRegion *self;\n+    self = (PyBufferRegion *)type->tp_alloc(type, 0);\n+    self->x = NULL;\n+    return (PyObject *)self;\n+}\n+\n+static void PyBufferRegion_dealloc(PyBufferRegion *self)\n+{\n+    delete self->x;\n+    Py_TYPE(self)->tp_free((PyObject *)self);\n+}\n+\n+static PyObject *PyBufferRegion_to_string(PyBufferRegion *self, PyObject *args, PyObject *kwds)\n+{\n+    return PyBytes_FromStringAndSize((const char *)self->x->get_data(),\n+                                     self->x->get_height() * self->x->get_stride());\n+}\n+\n+/* TODO: This doesn't seem to be used internally.  Remove? */\n+\n+static PyObject *PyBufferRegion_set_x(PyBufferRegion *self, PyObject *args, PyObject *kwds)\n+{\n+    int x;\n+    if (!PyArg_ParseTuple(args, \"i:set_x\", &x)) {\n+        return NULL;\n+    }\n+    self->x->get_rect().x1 = x;\n+\n+    Py_RETURN_NONE;\n+}\n+\n+static PyObject *PyBufferRegion_set_y(PyBufferRegion *self, PyObject *args, PyObject *kwds)\n+{\n+    int y;\n+    if (!PyArg_ParseTuple(args, \"i:set_y\", &y)) {\n+        return NULL;\n+    }\n+    self->x->get_rect().y1 = y;\n+\n+    Py_RETURN_NONE;\n+}\n+\n+static PyObject *PyBufferRegion_get_extents(PyBufferRegion *self, PyObject *args, PyObject *kwds)\n+{\n+    agg::rect_i rect = self->x->get_rect();\n+\n+    return Py_BuildValue(\"IIII\", rect.x1, rect.y1, rect.x2, rect.y2);\n+}\n+\n+static PyObject *PyBufferRegion_to_string_argb(PyBufferRegion *self, PyObject *args, PyObject *kwds)\n+{\n+    PyObject *bufobj;\n+    uint8_t *buf;\n+\n+    bufobj = PyBytes_FromStringAndSize(NULL, self->x->get_height() * self->x->get_stride());\n+    buf = (uint8_t *)PyBytes_AS_STRING(bufobj);\n+\n+    CALL_CPP_CLEANUP(\"to_string_argb\", (self->x->to_string_argb(buf)), Py_DECREF(bufobj));\n+\n+    return bufobj;\n+}\n+\n+int PyBufferRegion_get_buffer(PyBufferRegion *self, Py_buffer *buf, int flags)\n+{\n+    Py_INCREF(self);\n+    buf->obj = (PyObject *)self;\n+    buf->buf = self->x->get_data();\n+    buf->len = self->x->get_width() * self->x->get_height() * 4;\n+    buf->readonly = 0;\n+    buf->format = (char *)\"B\";\n+    buf->ndim = 3;\n+    self->shape[0] = self->x->get_height();\n+    self->shape[1] = self->x->get_width();\n+    self->shape[2] = 4;\n+    buf->shape = self->shape;\n+    self->strides[0] = self->x->get_width() * 4;\n+    self->strides[1] = 4;\n+    self->strides[2] = 1;\n+    buf->strides = self->strides;\n+    buf->suboffsets = NULL;\n+    buf->itemsize = 1;\n+    buf->internal = NULL;\n+\n+    return 1;\n+}\n+\n+static PyTypeObject PyBufferRegionType;\n+\n+static PyTypeObject *PyBufferRegion_init_type(PyObject *m, PyTypeObject *type)\n+{\n+    static PyMethodDef methods[] = {\n+        { \"to_string\", (PyCFunction)PyBufferRegion_to_string, METH_NOARGS, NULL },\n+        { \"to_string_argb\", (PyCFunction)PyBufferRegion_to_string_argb, METH_NOARGS, NULL },\n+        { \"set_x\", (PyCFunction)PyBufferRegion_set_x, METH_VARARGS, NULL },\n+        { \"set_y\", (PyCFunction)PyBufferRegion_set_y, METH_VARARGS, NULL },\n+        { \"get_extents\", (PyCFunction)PyBufferRegion_get_extents, METH_NOARGS, NULL },\n+        { NULL }\n+    };\n+\n+    static PyBufferProcs buffer_procs;\n+    memset(&buffer_procs, 0, sizeof(PyBufferProcs));\n+    buffer_procs.bf_getbuffer = (getbufferproc)PyBufferRegion_get_buffer;\n+\n+    memset(type, 0, sizeof(PyTypeObject));\n+    type->tp_name = \"matplotlib.backends._backend_agg.BufferRegion\";\n+    type->tp_basicsize = sizeof(PyBufferRegion);\n+    type->tp_dealloc = (destructor)PyBufferRegion_dealloc;\n+    type->tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_NEWBUFFER;\n+    type->tp_methods = methods;\n+    type->tp_new = PyBufferRegion_new;\n+    type->tp_as_buffer = &buffer_procs;\n+\n+    if (PyType_Ready(type) < 0) {\n+        return NULL;\n+    }\n+\n+    /* Don't need to add to module, since you can't create buffer\n+       regions directly from Python */\n+\n+    return type;\n+}\n+\n+/**********************************************************************\n+ * RendererAgg\n+ * */\n+\n+static PyObject *PyRendererAgg_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n+{\n+    PyRendererAgg *self;\n+    self = (PyRendererAgg *)type->tp_alloc(type, 0);\n+    self->x = NULL;\n+    return (PyObject *)self;\n+}\n+\n+static int PyRendererAgg_init(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n+{\n+    unsigned int width;\n+    unsigned int height;\n+    double dpi;\n+    int debug = 0;\n+\n+    if (!PyArg_ParseTuple(args, \"IId|i:RendererAgg\", &width, &height, &dpi, &debug)) {\n+        return -1;\n+    }\n+\n+    if (dpi <= 0.0) {\n+        PyErr_SetString(PyExc_ValueError, \"dpi must be positive\");\n+        return -1;\n+    }\n+\n+    CALL_CPP_INIT(\"RendererAgg\", self->x = new RendererAgg(width, height, dpi))\n+\n+    return 0;\n+}\n+\n+static void PyRendererAgg_dealloc(PyRendererAgg *self)\n+{\n+    delete self->x;\n+    Py_TYPE(self)->tp_free((PyObject *)self);\n+}\n+\n+static PyObject *PyRendererAgg_draw_path(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n+{\n+    GCAgg gc;\n+    py::PathIterator path;\n+    agg::trans_affine trans;\n+    PyObject *faceobj = NULL;\n+    agg::rgba face;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"O&O&O&|O:draw_path\",\n+                          &convert_gcagg,\n+                          &gc,\n+                          &convert_path,\n+                          &path,\n+                          &convert_trans_affine,\n+                          &trans,\n+                          &faceobj)) {\n+        return NULL;\n+    }\n+\n+    if (!convert_face(faceobj, gc, &face)) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP(\"draw_path\", (self->x->draw_path(gc, path, trans, face)));\n+\n+    Py_RETURN_NONE;\n+}\n+\n+static PyObject *PyRendererAgg_draw_text_image(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n+{\n+    numpy::array_view<agg::int8u, 2> image;\n+    double x;\n+    double y;\n+    double angle;\n+    GCAgg gc;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"O&dddO&:draw_text_image\",\n+                          &numpy::convert_array_contiguous<agg::int8u, 2>,\n+                          &image,\n+                          &x,\n+                          &y,\n+                          &angle,\n+                          &convert_gcagg,\n+                          &gc)) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP(\"draw_text_image\", (self->x->draw_text_image(gc, image, x, y, angle)));\n+\n+    Py_RETURN_NONE;\n+}\n+\n+PyObject *PyRendererAgg_draw_markers(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n+{\n+    GCAgg gc;\n+    py::PathIterator marker_path;\n+    agg::trans_affine marker_path_trans;\n+    py::PathIterator path;\n+    agg::trans_affine trans;\n+    PyObject *faceobj = NULL;\n+    agg::rgba face;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"O&O&O&O&O&|O:draw_markers\",\n+                          &convert_gcagg,\n+                          &gc,\n+                          &convert_path,\n+                          &marker_path,\n+                          &convert_trans_affine,\n+                          &marker_path_trans,\n+                          &convert_path,\n+                          &path,\n+                          &convert_trans_affine,\n+                          &trans,\n+                          &faceobj)) {\n+        return NULL;\n+    }\n+\n+    if (!convert_face(faceobj, gc, &face)) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP(\"draw_markers\",\n+             (self->x->draw_markers(gc, marker_path, marker_path_trans, path, trans, face)));\n+\n+    Py_RETURN_NONE;\n+}\n+\n+static PyObject *PyRendererAgg_draw_image(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n+{\n+    GCAgg gc;\n+    double x;\n+    double y;\n+    numpy::array_view<agg::int8u, 3> image;\n+    double w = 0;\n+    double h = 0;\n+    agg::trans_affine trans;\n+    bool resize = false;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"O&ddO&|ddO&:draw_image\",\n+                          &convert_gcagg,\n+                          &gc,\n+                          &x,\n+                          &y,\n+                          &numpy::convert_array_contiguous<agg::int8u, 3>,\n+                          &image,\n+                          &w,\n+                          &h,\n+                          &convert_trans_affine,\n+                          &trans)) {\n+        return NULL;\n+    }\n+\n+    if (PyTuple_Size(args) == 4) {\n+        x = mpl_round(x);\n+        y = mpl_round(y);\n+    } else {\n+        resize = true;\n+    }\n+\n+    CALL_CPP(\"draw_image\", (self->x->draw_image(gc, x, y, image, w, h, trans, resize)));\n+\n+    Py_RETURN_NONE;\n+}\n+\n+static PyObject *\n+PyRendererAgg_draw_path_collection(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n+{\n+    GCAgg gc;\n+    agg::trans_affine master_transform;\n+    PyObject *pathobj;\n+    numpy::array_view<const double, 3> transforms;\n+    numpy::array_view<const double, 2> offsets;\n+    agg::trans_affine offset_trans;\n+    numpy::array_view<const double, 2> facecolors;\n+    numpy::array_view<const double, 2> edgecolors;\n+    numpy::array_view<const double, 1> linewidths;\n+    DashesVector dashes;\n+    numpy::array_view<const uint8_t, 1> antialiaseds;\n+    PyObject *ignored;\n+    e_offset_position offset_position;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"O&O&OO&O&O&O&O&O&O&O&OO&:draw_path_collection\",\n+                          &convert_gcagg,\n+                          &gc,\n+                          &convert_trans_affine,\n+                          &master_transform,\n+                          &pathobj,\n+                          &numpy::convert_array<const double, 3>,\n+                          &transforms,\n+                          &numpy::convert_array<const double, 2>,\n+                          &offsets,\n+                          &convert_trans_affine,\n+                          &offset_trans,\n+                          &numpy::convert_array<const double, 2>,\n+                          &facecolors,\n+                          &numpy::convert_array<const double, 2>,\n+                          &edgecolors,\n+                          &numpy::convert_array<const double, 1>,\n+                          &linewidths,\n+                          &convert_dashes_vector,\n+                          &dashes,\n+                          &numpy::convert_array<const uint8_t, 1>,\n+                          &antialiaseds,\n+                          &ignored,\n+                          &convert_offset_position,\n+                          &offset_position)) {\n+        return NULL;\n+    }\n+\n+    try\n+    {\n+        py::PathGenerator path(pathobj);\n+\n+        CALL_CPP(\"draw_path_collection\",\n+                 (self->x->draw_path_collection(gc,\n+                                                master_transform,\n+                                                path,\n+                                                transforms,\n+                                                offsets,\n+                                                offset_trans,\n+                                                facecolors,\n+                                                edgecolors,\n+                                                linewidths,\n+                                                dashes,\n+                                                antialiaseds,\n+                                                offset_position)));\n+    }\n+    catch (py::exception &e)\n+    {\n+        return NULL;\n+    }\n+\n+    Py_RETURN_NONE;\n+}\n+\n+static PyObject *PyRendererAgg_draw_quad_mesh(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n+{\n+    GCAgg gc;\n+    agg::trans_affine master_transform;\n+    size_t mesh_width;\n+    size_t mesh_height;\n+    numpy::array_view<const double, 3> coordinates;\n+    numpy::array_view<const double, 2> offsets;\n+    agg::trans_affine offset_trans;\n+    numpy::array_view<const double, 2> facecolors;\n+    int antialiased;\n+    numpy::array_view<const double, 2> edgecolors;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"O&O&IIO&O&O&O&iO&:draw_quad_mesh\",\n+                          &convert_gcagg,\n+                          &gc,\n+                          &convert_trans_affine,\n+                          &master_transform,\n+                          &mesh_width,\n+                          &mesh_height,\n+                          &numpy::convert_array<const double, 3>,\n+                          &coordinates,\n+                          &numpy::convert_array<const double, 2>,\n+                          &offsets,\n+                          &convert_trans_affine,\n+                          &offset_trans,\n+                          &numpy::convert_array<const double, 2>,\n+                          &facecolors,\n+                          &antialiased,\n+                          &numpy::convert_array<const double, 2>,\n+                          &edgecolors)) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP(\"draw_quad_mesh\",\n+             (self->x->draw_quad_mesh(gc,\n+                                      master_transform,\n+                                      mesh_width,\n+                                      mesh_height,\n+                                      coordinates,\n+                                      offsets,\n+                                      offset_trans,\n+                                      facecolors,\n+                                      antialiased,\n+                                      edgecolors)));\n+\n+    Py_RETURN_NONE;\n+}\n+\n+static PyObject *\n+PyRendererAgg_draw_gouraud_triangle(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n+{\n+    GCAgg gc;\n+    numpy::array_view<const double, 2> points;\n+    numpy::array_view<const double, 2> colors;\n+    agg::trans_affine trans;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"O&O&O&O&|O:draw_gouraud_triangle\",\n+                          &convert_gcagg,\n+                          &gc,\n+                          &numpy::convert_array<const double, 2>,\n+                          &points,\n+                          &numpy::convert_array<const double, 2>,\n+                          &colors,\n+                          &convert_trans_affine,\n+                          &trans)) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP(\"draw_gouraud_triangle\", (self->x->draw_gouraud_triangle(gc, points, colors, trans)));\n+\n+    Py_RETURN_NONE;\n+}\n+\n+static PyObject *\n+PyRendererAgg_draw_gouraud_triangles(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n+{\n+    GCAgg gc;\n+    numpy::array_view<const double, 3> points;\n+    numpy::array_view<const double, 3> colors;\n+    agg::trans_affine trans;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"O&O&O&O&|O:draw_gouraud_triangles\",\n+                          &convert_gcagg,\n+                          &gc,\n+                          &numpy::convert_array<const double, 3>,\n+                          &points,\n+                          &numpy::convert_array<const double, 3>,\n+                          &colors,\n+                          &convert_trans_affine,\n+                          &trans)) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP(\"draw_gouraud_triangles\", self->x->draw_gouraud_triangles(gc, points, colors, trans));\n+\n+    Py_RETURN_NONE;\n+}\n+\n+static PyObject *PyRendererAgg_tostring_rgb(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n+{\n+    PyObject *buffobj = NULL;\n+\n+    buffobj = PyBytes_FromStringAndSize(NULL, self->x->get_width() * self->x->get_height() * 3);\n+    if (buffobj == NULL) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP_CLEANUP(\"tostring_rgb\",\n+                     (self->x->tostring_rgb((uint8_t *)PyBytes_AS_STRING(buffobj))),\n+                     Py_DECREF(buffobj));\n+\n+    return buffobj;\n+}\n+\n+static PyObject *PyRendererAgg_tostring_argb(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n+{\n+    PyObject *buffobj = NULL;\n+\n+    buffobj = PyBytes_FromStringAndSize(NULL, self->x->get_width() * self->x->get_height() * 4);\n+    if (buffobj == NULL) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP_CLEANUP(\"tostring_argb\",\n+                     (self->x->tostring_argb((uint8_t *)PyBytes_AS_STRING(buffobj))),\n+                     Py_DECREF(buffobj));\n+\n+    return buffobj;\n+}\n+\n+static PyObject *PyRendererAgg_tostring_bgra(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n+{\n+    PyObject *buffobj = NULL;\n+\n+    buffobj = PyBytes_FromStringAndSize(NULL, self->x->get_width() * self->x->get_height() * 4);\n+    if (buffobj == NULL) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP_CLEANUP(\"to_string_bgra\",\n+                     (self->x->tostring_bgra((uint8_t *)PyBytes_AS_STRING(buffobj))),\n+                     Py_DECREF(buffobj));\n+\n+    return buffobj;\n+}\n+\n+static PyObject *\n+PyRendererAgg_get_content_extents(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n+{\n+    agg::rect_i extents;\n+\n+    CALL_CPP(\"get_content_extents\", (extents = self->x->get_content_extents()));\n+\n+    return Py_BuildValue(\n+        \"iiii\", extents.x1, extents.y1, extents.x2 - extents.x1, extents.y2 - extents.y1);\n+}\n+\n+static PyObject *PyRendererAgg_buffer_rgba(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n+{\n+#if PY3K\n+    return PyBytes_FromStringAndSize((const char *)self->x->pixBuffer,\n+                                     self->x->get_width() * self->x->get_height() * 4);\n+#else\n+    return PyBuffer_FromReadWriteMemory(self->x->pixBuffer,\n+                                        self->x->get_width() * self->x->get_height() * 4);\n+#endif\n+}\n+\n+int PyRendererAgg_get_buffer(PyRendererAgg *self, Py_buffer *buf, int flags)\n+{\n+    Py_INCREF(self);\n+    buf->obj = (PyObject *)self;\n+    buf->buf = self->x->pixBuffer;\n+    buf->len = self->x->get_width() * self->x->get_height() * 4;\n+    buf->readonly = 0;\n+    buf->format = (char *)\"B\";\n+    buf->ndim = 3;\n+    self->shape[0] = self->x->get_height();\n+    self->shape[1] = self->x->get_width();\n+    self->shape[2] = 4;\n+    buf->shape = self->shape;\n+    self->strides[0] = self->x->get_width() * 4;\n+    self->strides[1] = 4;\n+    self->strides[2] = 1;\n+    buf->strides = self->strides;\n+    buf->suboffsets = NULL;\n+    buf->itemsize = 1;\n+    buf->internal = NULL;\n+\n+    return 1;\n+}\n+\n+static PyObject *PyRendererAgg_clear(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n+{\n+    CALL_CPP(\"clear\", self->x->clear());\n+\n+    Py_RETURN_NONE;\n+}\n+\n+static PyObject *PyRendererAgg_copy_from_bbox(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n+{\n+    agg::rect_d bbox;\n+    BufferRegion *reg;\n+    PyObject *regobj;\n+\n+    if (!PyArg_ParseTuple(args, \"O&:copy_from_bbox\", &convert_rect, &bbox)) {\n+        return 0;\n+    }\n+\n+    CALL_CPP(\"copy_from_bbox\", (reg = self->x->copy_from_bbox(bbox)));\n+\n+    regobj = PyBufferRegion_new(&PyBufferRegionType, NULL, NULL);\n+    ((PyBufferRegion *)regobj)->x = reg;\n+\n+    return regobj;\n+}\n+\n+static PyObject *PyRendererAgg_restore_region(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n+{\n+    PyBufferRegion *regobj;\n+    int xx1 = 0, yy1 = 0, xx2 = 0, yy2 = 0, x = 0, y = 0;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"O!|iiiiii:restore_region\",\n+                          &PyBufferRegionType,\n+                          &regobj,\n+                          &xx1,\n+                          &yy1,\n+                          &xx2,\n+                          &yy2,\n+                          &x,\n+                          &y)) {\n+        return 0;\n+    }\n+\n+    if (PySequence_Size(args) == 1) {\n+        CALL_CPP(\"restore_region\", (self->x->restore_region(*(regobj->x))));\n+    } else {\n+        CALL_CPP(\"restore_region\", self->x->restore_region(*(regobj->x), xx1, yy1, xx2, yy2, x, y));\n+    }\n+\n+    Py_RETURN_NONE;\n+}\n+\n+PyTypeObject PyRendererAggType;\n+\n+static PyTypeObject *PyRendererAgg_init_type(PyObject *m, PyTypeObject *type)\n+{\n+    static PyMethodDef methods[] = {\n+        {\"draw_path\", (PyCFunction)PyRendererAgg_draw_path, METH_VARARGS, NULL},\n+        {\"draw_markers\", (PyCFunction)PyRendererAgg_draw_markers, METH_VARARGS, NULL},\n+        {\"draw_text_image\", (PyCFunction)PyRendererAgg_draw_text_image, METH_VARARGS, NULL},\n+        {\"draw_image\", (PyCFunction)PyRendererAgg_draw_image, METH_VARARGS, NULL},\n+        {\"draw_path_collection\", (PyCFunction)PyRendererAgg_draw_path_collection, METH_VARARGS, NULL},\n+        {\"draw_quad_mesh\", (PyCFunction)PyRendererAgg_draw_quad_mesh, METH_VARARGS, NULL},\n+        {\"draw_gouraud_triangle\", (PyCFunction)PyRendererAgg_draw_gouraud_triangle, METH_VARARGS, NULL},\n+        {\"draw_gouraud_triangles\", (PyCFunction)PyRendererAgg_draw_gouraud_triangles, METH_VARARGS, NULL},\n+\n+        {\"tostring_rgb\", (PyCFunction)PyRendererAgg_tostring_rgb, METH_NOARGS, NULL},\n+        {\"tostring_argb\", (PyCFunction)PyRendererAgg_tostring_argb, METH_NOARGS, NULL},\n+        {\"tostring_bgra\", (PyCFunction)PyRendererAgg_tostring_bgra, METH_NOARGS, NULL},\n+        {\"get_content_extents\", (PyCFunction)PyRendererAgg_get_content_extents, METH_NOARGS, NULL},\n+        {\"buffer_rgba\", (PyCFunction)PyRendererAgg_buffer_rgba, METH_NOARGS, NULL},\n+        {\"clear\", (PyCFunction)PyRendererAgg_clear, METH_NOARGS, NULL},\n+\n+        {\"copy_from_bbox\", (PyCFunction)PyRendererAgg_copy_from_bbox, METH_VARARGS, NULL},\n+        {\"restore_region\", (PyCFunction)PyRendererAgg_restore_region, METH_VARARGS, NULL},\n+        {NULL}\n+    };\n+\n+    static PyBufferProcs buffer_procs;\n+    memset(&buffer_procs, 0, sizeof(PyBufferProcs));\n+    buffer_procs.bf_getbuffer = (getbufferproc)PyRendererAgg_get_buffer;\n+\n+    memset(type, 0, sizeof(PyTypeObject));\n+    type->tp_name = \"matplotlib.backends._backend_agg.RendererAgg\";\n+    type->tp_basicsize = sizeof(PyRendererAgg);\n+    type->tp_dealloc = (destructor)PyRendererAgg_dealloc;\n+    type->tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_NEWBUFFER;\n+    type->tp_methods = methods;\n+    type->tp_init = (initproc)PyRendererAgg_init;\n+    type->tp_new = PyRendererAgg_new;\n+    type->tp_as_buffer = &buffer_procs;\n+\n+    if (PyType_Ready(type) < 0) {\n+        return NULL;\n+    }\n+\n+    if (PyModule_AddObject(m, \"RendererAgg\", (PyObject *)type)) {\n+        return NULL;\n+    }\n+\n+    return type;\n+}\n+\n+extern \"C\" {\n+\n+struct module_state\n+{\n+/* The Sun compiler can't handle empty structs */\n+#if defined(__SUNPRO_C) || defined(_MSC_VER)\n+    int _dummy;\n+#endif\n+};\n+\n+#if PY3K\n+static struct PyModuleDef moduledef = {\n+    PyModuleDef_HEAD_INIT,\n+    \"_backend_agg\",\n+    NULL,\n+    sizeof(struct module_state),\n+    NULL,\n+    NULL,\n+    NULL,\n+    NULL,\n+    NULL\n+};\n+\n+#define INITERROR return NULL\n+\n+PyMODINIT_FUNC PyInit__backend_agg(void)\n+\n+#else\n+#define INITERROR return\n+\n+PyMODINIT_FUNC init_backend_agg(void)\n+#endif\n+\n+{\n+    PyObject *m;\n+\n+#if PY3K\n+    m = PyModule_Create(&moduledef);\n+#else\n+    m = Py_InitModule3(\"_backend_agg\", NULL, NULL);\n+#endif\n+\n+    if (m == NULL) {\n+        INITERROR;\n+    }\n+\n+    import_array();\n+\n+    if (!PyRendererAgg_init_type(m, &PyRendererAggType)) {\n+        INITERROR;\n+    }\n+\n+    if (!PyBufferRegion_init_type(m, &PyBufferRegionType)) {\n+        INITERROR;\n+    }\n+\n+#if PY3K\n+    return m;\n+#endif\n+}\n+\n+} // extern \"C\""}
{"patches_id": 2, "files_id": 32, "language": "h", "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_backend_agg_wrapper.h", "raw_code": "#ifndef __BACKEND_AGG_WRAPPER_H__\n#define __BACKEND_AGG_WRAPPER_H__\n\n#include \"mplutils.h\"\n#include \"py_converters.h\"\n#include \"_backend_agg.h\"\n\nextern \"C\" {\n\ntypedef struct\n{\n    PyObject_HEAD;\n    RendererAgg *x;\n    Py_ssize_t shape[3];\n    Py_ssize_t strides[3];\n    Py_ssize_t suboffsets[3];\n} PyRendererAgg;\n\ntypedef struct\n{\n    PyObject_HEAD;\n    BufferRegion *x;\n    Py_ssize_t shape[3];\n    Py_ssize_t strides[3];\n    Py_ssize_t suboffsets[3];\n} PyBufferRegion;\n}\n\n#endif\n", "patch": "@@ -0,0 +1,29 @@\n+#ifndef __BACKEND_AGG_WRAPPER_H__\n+#define __BACKEND_AGG_WRAPPER_H__\n+\n+#include \"mplutils.h\"\n+#include \"py_converters.h\"\n+#include \"_backend_agg.h\"\n+\n+extern \"C\" {\n+\n+typedef struct\n+{\n+    PyObject_HEAD;\n+    RendererAgg *x;\n+    Py_ssize_t shape[3];\n+    Py_ssize_t strides[3];\n+    Py_ssize_t suboffsets[3];\n+} PyRendererAgg;\n+\n+typedef struct\n+{\n+    PyObject_HEAD;\n+    BufferRegion *x;\n+    Py_ssize_t shape[3];\n+    Py_ssize_t strides[3];\n+    Py_ssize_t suboffsets[3];\n+} PyBufferRegion;\n+}\n+\n+#endif"}
{"patches_id": 2, "files_id": 33, "language": "c", "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_backend_gdk.c", "raw_code": "/* -*- mode: C; c-basic-offset: 4 -*-\n * C extensions for backend_gdk\n */\n\n#include \"Python.h\"\n#include \"numpy/arrayobject.h\"\n\n#include <pygtk/pygtk.h>\n\nstatic PyTypeObject *_PyGdkPixbuf_Type;\n#define PyGdkPixbuf_Type (*_PyGdkPixbuf_Type)\n\nstatic PyObject *pixbuf_get_pixels_array(PyObject *self, PyObject *args)\n{\n    /* 1) read in Python pixbuf, get the underlying gdk_pixbuf */\n    PyGObject *py_pixbuf;\n    GdkPixbuf *gdk_pixbuf;\n    PyArrayObject *array;\n    npy_intp dims[3] = { 0, 0, 3 };\n\n    if (!PyArg_ParseTuple(args, \"O!:pixbuf_get_pixels_array\", &PyGdkPixbuf_Type, &py_pixbuf))\n        return NULL;\n\n    gdk_pixbuf = GDK_PIXBUF(py_pixbuf->obj);\n\n    /* 2) same as pygtk/gtk/gdk.c _wrap_gdk_pixbuf_get_pixels_array()\n     * with 'self' changed to py_pixbuf\n     */\n\n    dims[0] = gdk_pixbuf_get_height(gdk_pixbuf);\n    dims[1] = gdk_pixbuf_get_width(gdk_pixbuf);\n    if (gdk_pixbuf_get_has_alpha(gdk_pixbuf))\n        dims[2] = 4;\n\n    array = (PyArrayObject *)PyArray_SimpleNewFromData(\n        3, dims, PyArray_UBYTE, (char *)gdk_pixbuf_get_pixels(gdk_pixbuf));\n    if (array == NULL)\n        return NULL;\n\n    array->strides[0] = gdk_pixbuf_get_rowstride(gdk_pixbuf);\n    /* the array holds a ref to the pixbuf pixels through this wrapper*/\n    Py_INCREF(py_pixbuf);\n    array->base = (PyObject *)py_pixbuf;\n    return PyArray_Return(array);\n}\n\nstatic PyMethodDef _backend_gdk_functions[] = {\n    { \"pixbuf_get_pixels_array\", (PyCFunction)pixbuf_get_pixels_array, METH_VARARGS },\n    { NULL, NULL, 0 }\n};\n\nPyMODINIT_FUNC init_backend_gdk(void)\n{\n    PyObject *mod;\n    mod = Py_InitModule(\"matplotlib.backends._backend_gdk\", _backend_gdk_functions);\n    import_array();\n    init_pygtk();\n\n    mod = PyImport_ImportModule(\"gtk.gdk\");\n    _PyGdkPixbuf_Type = (PyTypeObject *)PyObject_GetAttrString(mod, \"Pixbuf\");\n}\n", "patch": "@@ -7,22 +7,19 @@\n \n #include <pygtk/pygtk.h>\n \n-\n static PyTypeObject *_PyGdkPixbuf_Type;\n #define PyGdkPixbuf_Type (*_PyGdkPixbuf_Type)\n \n-static PyObject *\n-pixbuf_get_pixels_array(PyObject *self, PyObject *args)\n+static PyObject *pixbuf_get_pixels_array(PyObject *self, PyObject *args)\n {\n     /* 1) read in Python pixbuf, get the underlying gdk_pixbuf */\n     PyGObject *py_pixbuf;\n     GdkPixbuf *gdk_pixbuf;\n     PyArrayObject *array;\n     npy_intp dims[3] = { 0, 0, 3 };\n \n-    if (!PyArg_ParseTuple(args, \"O!:pixbuf_get_pixels_array\",\n-\t\t\t  &PyGdkPixbuf_Type, &py_pixbuf))\n-\treturn NULL;\n+    if (!PyArg_ParseTuple(args, \"O!:pixbuf_get_pixels_array\", &PyGdkPixbuf_Type, &py_pixbuf))\n+        return NULL;\n \n     gdk_pixbuf = GDK_PIXBUF(py_pixbuf->obj);\n \n@@ -35,8 +32,8 @@ pixbuf_get_pixels_array(PyObject *self, PyObject *args)\n     if (gdk_pixbuf_get_has_alpha(gdk_pixbuf))\n         dims[2] = 4;\n \n-    array = (PyArrayObject *)PyArray_SimpleNewFromData(3, dims, NPY_UBYTE,\n-\t\t\t     (char *)gdk_pixbuf_get_pixels(gdk_pixbuf));\n+    array = (PyArrayObject *)PyArray_SimpleNewFromData(\n+        3, dims, PyArray_UBYTE, (char *)gdk_pixbuf_get_pixels(gdk_pixbuf));\n     if (array == NULL)\n         return NULL;\n \n@@ -52,12 +49,10 @@ static PyMethodDef _backend_gdk_functions[] = {\n     { NULL, NULL, 0 }\n };\n \n-PyMODINIT_FUNC\n-init_backend_gdk(void)\n+PyMODINIT_FUNC init_backend_gdk(void)\n {\n     PyObject *mod;\n-    mod = Py_InitModule(\"matplotlib.backends._backend_gdk\",\n-                                        _backend_gdk_functions);\n+    mod = Py_InitModule(\"matplotlib.backends._backend_gdk\", _backend_gdk_functions);\n     import_array();\n     init_pygtk();\n "}
{"patches_id": 2, "files_id": 34, "language": "cpp", "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_gtkagg.cpp", "raw_code": "\n/* -*- mode: c++; c-basic-offset: 4 -*- */\n\n#include <vector>\n\n#include <pygobject.h>\n#include <pygtk/pygtk.h>\n\n#include \"agg_basics.h\"\n#include \"agg_pixfmt_rgba.h\"\n#include \"agg_renderer_base.h\"\n#include \"agg_rendering_buffer.h\"\n\n#include \"numpy_cpp.h\"\n#include \"py_converters.h\"\n\nstatic PyObject *Py_agg_to_gtk_drawable(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    typedef agg::pixfmt_rgba32_plain pixfmt;\n    typedef agg::renderer_base<pixfmt> renderer_base;\n\n    PyGObject *py_drawable;\n    numpy::array_view<agg::int8u, 3> buffer;\n    agg::rect_d rect;\n\n    // args are gc, renderer, bbox where bbox is a transforms BBox\n    // (possibly None).  If bbox is None, blit the entire agg buffer\n    // to gtk.  If bbox is not None, blit only the region defined by\n    // the bbox\n\n    if (!PyArg_ParseTuple(args,\n                          \"OO&O&:agg_to_gtk_drawable\",\n                          &py_drawable,\n                          &numpy::convert_array<agg::int8u, 3>,\n                          &buffer,\n                          &convert_rect,\n                          &rect)) {\n        return NULL;\n    }\n\n    if (buffer.dim(2) != 4) {\n        PyErr_SetString(PyExc_ValueError, \"Invalid image buffer.  Must be NxMx4.\");\n        return NULL;\n    }\n\n    GdkDrawable *drawable = GDK_DRAWABLE(py_drawable->obj);\n    GdkGC *gc = gdk_gc_new(drawable);\n\n    int srcstride = buffer.dim(1) * 4;\n    int srcwidth = buffer.dim(1);\n    int srcheight = buffer.dim(0);\n\n    // these three will be overridden below\n    int destx = 0;\n    int desty = 0;\n    int destwidth = 1;\n    int destheight = 1;\n    int deststride = 1;\n\n    std::vector<agg::int8u> destbuffer;\n    agg::int8u *destbufferptr;\n\n    if (rect.x1 == 0.0 && rect.x2 == 0.0 && rect.y1 == 0.0 && rect.y2 == 0.0) {\n        // bbox is None; copy the entire image\n        destbufferptr = (agg::int8u *)buffer;\n        destwidth = srcwidth;\n        destheight = srcheight;\n        deststride = srcstride;\n    } else {\n        destx = (int)rect.x1;\n        desty = srcheight - (int)rect.y2;\n        destwidth = (int)(rect.x2 - rect.x1);\n        destheight = (int)(rect.y2 - rect.y1);\n        deststride = destwidth * 4;\n        destbuffer.reserve(destheight * deststride);\n        destbufferptr = &destbuffer[0];\n\n        agg::rendering_buffer destrbuf;\n        destrbuf.attach(destbufferptr, destwidth, destheight, deststride);\n        pixfmt destpf(destrbuf);\n        renderer_base destrb(destpf);\n\n        agg::rendering_buffer srcrbuf;\n        srcrbuf.attach((agg::int8u *)buffer, buffer.dim(1), buffer.dim(0), buffer.dim(1) * 4);\n\n        agg::rect_base<int> region(destx, desty, (int)rect.x2, srcheight - (int)rect.y1);\n        destrb.copy_from(srcrbuf, &region, -destx, -desty);\n    }\n\n    gdk_draw_rgb_32_image(drawable,\n                          gc,\n                          destx,\n                          desty,\n                          destwidth,\n                          destheight,\n                          GDK_RGB_DITHER_NORMAL,\n                          destbufferptr,\n                          deststride);\n\n    gdk_gc_destroy(gc);\n\n    Py_RETURN_NONE;\n}\n\nstatic PyMethodDef module_methods[] = {\n    {\"agg_to_gtk_drawable\", (PyCFunction)Py_agg_to_gtk_drawable, METH_VARARGS, NULL},\n    NULL\n};\n\nextern \"C\" {\n\n    struct module_state\n    {\n        /* The Sun compiler can't handle empty structs */\n#if defined(__SUNPRO_C) || defined(_MSC_VER)\n        int _dummy;\n#endif\n    };\n\n#if PY3K\n    static struct PyModuleDef moduledef = {\n        PyModuleDef_HEAD_INIT,\n        \"_gtkagg\",\n        NULL,\n        sizeof(struct module_state),\n        module_methods,\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    };\n\n#define INITERROR return NULL\n\n    PyMODINIT_FUNC PyInit__gtkagg(void)\n\n#else\n#define INITERROR return\n\n    PyMODINIT_FUNC init_gtkagg(void)\n#endif\n\n    {\n        PyObject *m;\n\n#if PY3K\n        m = PyModule_Create(&moduledef);\n#else\n        m = Py_InitModule3(\"_gtkagg\", module_methods, NULL);\n#endif\n\n        if (m == NULL) {\n            INITERROR;\n        }\n\n        init_pygobject();\n        init_pygtk();\n        import_array();\n\n#if PY3K\n        return m;\n#endif\n    }\n}\n", "patch": "@@ -1,153 +1,164 @@\n \n /* -*- mode: c++; c-basic-offset: 4 -*- */\n \n+#include <vector>\n+\n #include <pygobject.h>\n #include <pygtk/pygtk.h>\n \n-#include <cstring>\n-#include <cerrno>\n-#include <cstdio>\n-#include <iostream>\n-#include <cmath>\n-#include <utility>\n-#include <fstream>\n-\n #include \"agg_basics.h\"\n-#include \"numpy/arrayobject.h\"\n-#include \"_backend_agg.h\"\n-#include \"agg_py_transforms.h\"\n+#include \"agg_pixfmt_rgba.h\"\n+#include \"agg_renderer_base.h\"\n+#include \"agg_rendering_buffer.h\"\n \n-// the extension module\n-class _gtkagg_module : public Py::ExtensionModule<_gtkagg_module>\n+#include \"numpy_cpp.h\"\n+#include \"py_converters.h\"\n+\n+static PyObject *Py_agg_to_gtk_drawable(PyObject *self, PyObject *args, PyObject *kwds)\n {\n-public:\n-    _gtkagg_module()\n-        : Py::ExtensionModule<_gtkagg_module>(\"_gtkagg\")\n-    {\n-        add_varargs_method(\"agg_to_gtk_drawable\",\n-                           &_gtkagg_module::agg_to_gtk_drawable,\n-                           \"Draw to a gtk drawable from a agg buffer.\");\n-        initialize(\"The _gtkagg module\");\n+    typedef agg::pixfmt_rgba32_plain pixfmt;\n+    typedef agg::renderer_base<pixfmt> renderer_base;\n+\n+    PyGObject *py_drawable;\n+    numpy::array_view<agg::int8u, 3> buffer;\n+    agg::rect_d rect;\n+\n+    // args are gc, renderer, bbox where bbox is a transforms BBox\n+    // (possibly None).  If bbox is None, blit the entire agg buffer\n+    // to gtk.  If bbox is not None, blit only the region defined by\n+    // the bbox\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"OO&O&:agg_to_gtk_drawable\",\n+                          &py_drawable,\n+                          &numpy::convert_array<agg::int8u, 3>,\n+                          &buffer,\n+                          &convert_rect,\n+                          &rect)) {\n+        return NULL;\n     }\n \n-    virtual ~_gtkagg_module() {}\n-\n-private:\n-\n-    Py::Object agg_to_gtk_drawable(const Py::Tuple &args)\n-    {\n-        // args are gc, renderer, bbox where bbox is a transforms BBox\n-        // (possibly None).  If bbox is None, blit the entire agg buffer\n-        // to gtk.  If bbox is not None, blit only the region defined by\n-        // the bbox\n-        args.verify_length(3);\n-\n-        PyGObject *py_drawable = (PyGObject *)(args[0].ptr());\n-        RendererAgg* aggRenderer = static_cast<RendererAgg*>(args[1].ptr());\n-\n-        GdkDrawable *drawable = GDK_DRAWABLE(py_drawable->obj);\n-        GdkGC* gc = gdk_gc_new(drawable);\n+    if (buffer.dim(2) != 4) {\n+        PyErr_SetString(PyExc_ValueError, \"Invalid image buffer.  Must be NxMx4.\");\n+        return NULL;\n+    }\n \n-        int srcstride = aggRenderer->get_width() * 4;\n-        int srcwidth = (int)aggRenderer->get_width();\n-        int srcheight = (int)aggRenderer->get_height();\n+    GdkDrawable *drawable = GDK_DRAWABLE(py_drawable->obj);\n+    GdkGC *gc = gdk_gc_new(drawable);\n+\n+    int srcstride = buffer.dim(1) * 4;\n+    int srcwidth = buffer.dim(1);\n+    int srcheight = buffer.dim(0);\n+\n+    // these three will be overridden below\n+    int destx = 0;\n+    int desty = 0;\n+    int destwidth = 1;\n+    int destheight = 1;\n+    int deststride = 1;\n+\n+    std::vector<agg::int8u> destbuffer;\n+    agg::int8u *destbufferptr;\n+\n+    if (rect.x1 == 0.0 && rect.x2 == 0.0 && rect.y1 == 0.0 && rect.y2 == 0.0) {\n+        // bbox is None; copy the entire image\n+        destbufferptr = (agg::int8u *)buffer;\n+        destwidth = srcwidth;\n+        destheight = srcheight;\n+        deststride = srcstride;\n+    } else {\n+        destx = (int)rect.x1;\n+        desty = srcheight - (int)rect.y2;\n+        destwidth = (int)(rect.x2 - rect.x1);\n+        destheight = (int)(rect.y2 - rect.y1);\n+        deststride = destwidth * 4;\n+        destbuffer.reserve(destheight * deststride);\n+        destbufferptr = &destbuffer[0];\n+\n+        agg::rendering_buffer destrbuf;\n+        destrbuf.attach(destbufferptr, destwidth, destheight, deststride);\n+        pixfmt destpf(destrbuf);\n+        renderer_base destrb(destpf);\n+\n+        agg::rendering_buffer srcrbuf;\n+        srcrbuf.attach((agg::int8u *)buffer, buffer.dim(1), buffer.dim(0), buffer.dim(1) * 4);\n+\n+        agg::rect_base<int> region(destx, desty, (int)rect.x2, srcheight - (int)rect.y1);\n+        destrb.copy_from(srcrbuf, &region, -destx, -desty);\n+    }\n \n-        // these three will be overridden below\n-        int destx = 0;\n-        int desty = 0;\n-        int destwidth = 1;\n-        int destheight = 1;\n-        int deststride = 1;\n+    gdk_draw_rgb_32_image(drawable,\n+                          gc,\n+                          destx,\n+                          desty,\n+                          destwidth,\n+                          destheight,\n+                          GDK_RGB_DITHER_NORMAL,\n+                          destbufferptr,\n+                          deststride);\n \n+    gdk_gc_destroy(gc);\n \n-        bool needfree = false;\n+    Py_RETURN_NONE;\n+}\n \n-        agg::int8u *destbuffer = NULL;\n+static PyMethodDef module_methods[] = {\n+    {\"agg_to_gtk_drawable\", (PyCFunction)Py_agg_to_gtk_drawable, METH_VARARGS, NULL},\n+    NULL\n+};\n \n-        if (args[2].ptr() == Py_None)\n-        {\n-            //bbox is None; copy the entire image\n-            destbuffer = aggRenderer->pixBuffer;\n-            destwidth = srcwidth;\n-            destheight = srcheight;\n-            deststride = srcstride;\n-        }\n-        else\n-        {\n-            //bbox is not None; copy the image in the bbox\n-            PyObject* clipbox = args[2].ptr();\n-            double l, b, r, t;\n-\n-            if (!py_convert_bbox(clipbox, l, b, r, t))\n-            {\n-                throw Py::TypeError\n-                (\"Argument 3 to agg_to_gtk_drawable must be a Bbox object.\");\n-            }\n-\n-            destx = (int)l;\n-            desty = srcheight - (int)t;\n-            destwidth = (int)(r - l);\n-            destheight = (int)(t - b);\n-            deststride = destwidth * 4;\n-\n-            needfree = true;\n-            destbuffer = new agg::int8u[deststride*destheight];\n-            if (destbuffer == NULL)\n-            {\n-                throw Py::MemoryError(\"_gtkagg could not allocate memory for destbuffer\");\n-            }\n-\n-            agg::rendering_buffer destrbuf;\n-            destrbuf.attach(destbuffer, destwidth, destheight, deststride);\n-            pixfmt destpf(destrbuf);\n-            renderer_base destrb(destpf);\n-\n-            //destrb.clear(agg::rgba(1, 1, 1, 0));\n-\n-            agg::rect_base<int> region(destx, desty, (int)r, srcheight - (int)b);\n-            destrb.copy_from(aggRenderer->renderingBuffer, &region,\n-                             -destx, -desty);\n-        }\n+extern \"C\" {\n \n-        /*std::cout << desty << \" \"\n-              << destheight << \" \"\n-              << srcheight << std::endl;*/\n+    struct module_state\n+    {\n+        /* The Sun compiler can't handle empty structs */\n+#if defined(__SUNPRO_C) || defined(_MSC_VER)\n+        int _dummy;\n+#endif\n+    };\n+\n+#if PY3K\n+    static struct PyModuleDef moduledef = {\n+        PyModuleDef_HEAD_INIT,\n+        \"_gtkagg\",\n+        NULL,\n+        sizeof(struct module_state),\n+        module_methods,\n+        NULL,\n+        NULL,\n+        NULL,\n+        NULL\n+    };\n+\n+#define INITERROR return NULL\n+\n+    PyMODINIT_FUNC PyInit__gtkagg(void)\n+\n+#else\n+#define INITERROR return\n+\n+    PyMODINIT_FUNC init_gtkagg(void)\n+#endif\n \n+    {\n+        PyObject *m;\n \n-        //gdk_rgb_init();\n-        gdk_draw_rgb_32_image(drawable, gc, destx, desty,\n-                              destwidth,\n-                              destheight,\n-                              GDK_RGB_DITHER_NORMAL,\n-                              destbuffer,\n-                              deststride);\n+#if PY3K\n+        m = PyModule_Create(&moduledef);\n+#else\n+        m = Py_InitModule3(\"_gtkagg\", module_methods, NULL);\n+#endif\n \n-        gdk_gc_destroy(gc);\n-        if (needfree)\n-        {\n-            delete [] destbuffer;\n+        if (m == NULL) {\n+            INITERROR;\n         }\n \n-        return Py::Object();\n+        init_pygobject();\n+        init_pygtk();\n+        import_array();\n \n+#if PY3K\n+        return m;\n+#endif\n     }\n-};\n-\n-PyMODINIT_FUNC\n-init_gtkagg(void)\n-{\n-    init_pygobject();\n-    init_pygtk();\n-\n-    import_array();\n-    //suppress unused warning by creating in two lines\n-    static _gtkagg_module* _gtkagg = NULL;\n-    _gtkagg = new _gtkagg_module;\n }\n-\n-\n-\n-\n-\n-\n-"}
{"patches_id": 2, "files_id": 35, "language": "cpp", "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_image.cpp", "raw_code": "/* -*- mode: c++; c-basic-offset: 4 -*- */\n\n#define NO_IMPORT_ARRAY\n\n#include <vector>\n\n#include \"agg_color_rgba.h\"\n#include \"agg_conv_transform.h\"\n#include \"agg_image_accessors.h\"\n#include \"agg_path_storage.h\"\n#include \"agg_pixfmt_rgb.h\"\n#include \"agg_pixfmt_rgba.h\"\n#include \"agg_rasterizer_scanline_aa.h\"\n#include \"agg_rasterizer_sl_clip.h\"\n#include \"agg_renderer_scanline.h\"\n#include \"agg_rendering_buffer.h\"\n#include \"agg_scanline_bin.h\"\n#include \"agg_scanline_bin.h\"\n#include \"agg_scanline_u.h\"\n#include \"agg_span_allocator.h\"\n#include \"agg_span_image_filter_rgb.h\"\n#include \"agg_span_image_filter_rgba.h\"\n#include \"agg_span_interpolator_linear.h\"\n#include \"util/agg_color_conv_rgb8.h\"\n\n#include \"_image.h\"\n#include \"mplutils.h\"\n\ntypedef agg::pixfmt_rgba32_plain pixfmt;\ntypedef agg::pixfmt_rgba32_pre pixfmt_pre;\ntypedef agg::renderer_base<pixfmt> renderer_base;\ntypedef agg::span_interpolator_linear<> interpolator_type;\ntypedef agg::rasterizer_scanline_aa<agg::rasterizer_sl_clip_dbl> rasterizer;\n\nImage::Image()\n    : bufferIn(NULL),\n      rbufIn(NULL),\n      colsIn(0),\n      rowsIn(0),\n      bufferOut(NULL),\n      rbufOut(NULL),\n      colsOut(0),\n      rowsOut(0),\n      BPP(4),\n      interpolation(BILINEAR),\n      aspect(ASPECT_FREE),\n      bg(1, 1, 1, 0),\n      resample(true)\n{\n\n}\n\nImage::Image(unsigned numrows, unsigned numcols, bool isoutput)\n    : bufferIn(NULL),\n      rbufIn(NULL),\n      colsIn(0),\n      rowsIn(0),\n      bufferOut(NULL),\n      rbufOut(NULL),\n      colsOut(0),\n      rowsOut(0),\n      BPP(4),\n      interpolation(BILINEAR),\n      aspect(ASPECT_FREE),\n      bg(1, 1, 1, 0),\n      resample(true)\n{\n    if (isoutput) {\n        rowsOut = numrows;\n        colsOut = numcols;\n        unsigned NUMBYTES(numrows * numcols * BPP);\n        bufferOut = new agg::int8u[NUMBYTES];\n        rbufOut = new agg::rendering_buffer;\n        rbufOut->attach(bufferOut, colsOut, rowsOut, colsOut * BPP);\n    } else {\n        rowsIn = numrows;\n        colsIn = numcols;\n        unsigned NUMBYTES(numrows * numcols * BPP);\n        bufferIn = new agg::int8u[NUMBYTES];\n        rbufIn = new agg::rendering_buffer;\n        rbufIn->attach(bufferIn, colsIn, rowsIn, colsIn * BPP);\n    }\n}\n\nImage::~Image()\n{\n    delete[] bufferIn;\n    bufferIn = NULL;\n    delete rbufIn;\n    rbufIn = NULL;\n    delete rbufOut;\n    rbufOut = NULL;\n    delete[] bufferOut;\n    bufferOut = NULL;\n}\n\nvoid Image::apply_rotation(double r)\n{\n    agg::trans_affine M = agg::trans_affine_rotation(r * agg::pi / 180.0);\n    srcMatrix *= M;\n    imageMatrix *= M;\n}\n\nvoid Image::set_bg(double r, double g, double b, double a)\n{\n    bg.r = r;\n    bg.g = g;\n    bg.b = b;\n    bg.a = a;\n}\n\nvoid Image::apply_scaling(double sx, double sy)\n{\n    agg::trans_affine M = agg::trans_affine_scaling(sx, sy);\n    srcMatrix *= M;\n    imageMatrix *= M;\n}\n\nvoid Image::apply_translation(double tx, double ty)\n{\n    agg::trans_affine M = agg::trans_affine_translation(tx, ty);\n    srcMatrix *= M;\n    imageMatrix *= M;\n}\n\nvoid Image::as_rgba_str(agg::int8u *outbuf)\n{\n    agg::rendering_buffer rb;\n    rb.attach(outbuf, colsOut, rowsOut, colsOut * 4);\n    rb.copy_from(*rbufOut);\n}\n\nvoid Image::color_conv(int format, agg::int8u *outbuf)\n{\n    int row_len = colsOut * 4;\n\n    agg::rendering_buffer rtmp;\n    rtmp.attach(outbuf, colsOut, rowsOut, row_len);\n\n    switch (format) {\n    case 0:\n        agg::color_conv(&rtmp, rbufOut, agg::color_conv_rgba32_to_bgra32());\n        break;\n    case 1:\n        agg::color_conv(&rtmp, rbufOut, agg::color_conv_rgba32_to_argb32());\n        break;\n    default:\n        throw \"Image::color_conv unknown format\";\n    }\n}\n\nvoid Image::reset_matrix(void)\n{\n    srcMatrix.reset();\n    imageMatrix.reset();\n}\n\nvoid Image::resize(int numcols, int numrows, int norm, double radius)\n{\n    if (bufferIn == NULL) {\n        throw \"You must first load the image\";\n    }\n\n    if (numcols <= 0 || numrows <= 0) {\n        throw \"Width and height must have positive values\";\n    }\n\n    colsOut = numcols;\n    rowsOut = numrows;\n\n    size_t NUMBYTES(numrows * numcols * BPP);\n\n    delete[] bufferOut;\n    bufferOut = new agg::int8u[NUMBYTES];\n    if (bufferOut == NULL) // todo: also handle allocation throw\n    {\n        throw \"Image::resize could not allocate memory\";\n    }\n\n    delete rbufOut;\n    rbufOut = new agg::rendering_buffer;\n    rbufOut->attach(bufferOut, numcols, numrows, numcols * BPP);\n\n    // init the output rendering/rasterizing stuff\n    pixfmt pixf(*rbufOut);\n    renderer_base rb(pixf);\n    rb.clear(bg);\n    rasterizer ras;\n    agg::scanline_u8 sl;\n\n    ras.clip_box(0, 0, numcols, numrows);\n\n    imageMatrix.invert();\n    interpolator_type interpolator(imageMatrix);\n\n    typedef agg::span_allocator<agg::rgba8> span_alloc_type;\n    span_alloc_type sa;\n\n    // the image path\n    agg::path_storage path;\n    agg::rendering_buffer rbufPad;\n\n    double x0, y0, x1, y1;\n\n    x0 = 0.0;\n    x1 = colsIn;\n    y0 = 0.0;\n    y1 = rowsIn;\n\n    path.move_to(x0, y0);\n    path.line_to(x1, y0);\n    path.line_to(x1, y1);\n    path.line_to(x0, y1);\n    path.close_polygon();\n    agg::conv_transform<agg::path_storage> imageBox(path, srcMatrix);\n    ras.add_path(imageBox);\n\n    typedef agg::wrap_mode_reflect reflect_type;\n    typedef agg::image_accessor_wrap<pixfmt_pre, reflect_type, reflect_type> img_accessor_type;\n\n    pixfmt_pre pixfmtin(*rbufIn);\n    img_accessor_type ia(pixfmtin);\n    switch (interpolation) {\n\n    case NEAREST: {\n        typedef agg::span_image_filter_rgba_nn<img_accessor_type, interpolator_type> span_gen_type;\n        typedef agg::renderer_scanline_aa<renderer_base, span_alloc_type, span_gen_type>\n        renderer_type;\n        span_gen_type sg(ia, interpolator);\n        renderer_type ri(rb, sa, sg);\n        agg::render_scanlines(ras, sl, ri);\n    } break;\n\n    case HANNING:\n    case HAMMING:\n    case HERMITE: {\n        agg::image_filter_lut filter;\n        switch (interpolation) {\n        case HANNING:\n            filter.calculate(agg::image_filter_hanning(), norm);\n            break;\n        case HAMMING:\n            filter.calculate(agg::image_filter_hamming(), norm);\n            break;\n        case HERMITE:\n            filter.calculate(agg::image_filter_hermite(), norm);\n            break;\n        }\n        if (resample) {\n            typedef agg::span_image_resample_rgba_affine<img_accessor_type> span_gen_type;\n            typedef agg::renderer_scanline_aa<renderer_base, span_alloc_type, span_gen_type>\n            renderer_type;\n            span_gen_type sg(ia, interpolator, filter);\n            renderer_type ri(rb, sa, sg);\n            agg::render_scanlines(ras, sl, ri);\n        } else {\n            typedef agg::span_image_filter_rgba_2x2<img_accessor_type, interpolator_type>\n            span_gen_type;\n            typedef agg::renderer_scanline_aa<renderer_base, span_alloc_type, span_gen_type>\n            renderer_type;\n            span_gen_type sg(ia, interpolator, filter);\n            renderer_type ri(rb, sa, sg);\n            agg::render_scanlines(ras, sl, ri);\n        }\n    } break;\n    case BILINEAR:\n    case BICUBIC:\n    case SPLINE16:\n    case SPLINE36:\n    case KAISER:\n    case QUADRIC:\n    case CATROM:\n    case GAUSSIAN:\n    case BESSEL:\n    case MITCHELL:\n    case SINC:\n    case LANCZOS:\n    case BLACKMAN: {\n        agg::image_filter_lut filter;\n        switch (interpolation) {\n        case BILINEAR:\n            filter.calculate(agg::image_filter_bilinear(), norm);\n            break;\n        case BICUBIC:\n            filter.calculate(agg::image_filter_bicubic(), norm);\n            break;\n        case SPLINE16:\n            filter.calculate(agg::image_filter_spline16(), norm);\n            break;\n        case SPLINE36:\n            filter.calculate(agg::image_filter_spline36(), norm);\n            break;\n        case KAISER:\n            filter.calculate(agg::image_filter_kaiser(), norm);\n            break;\n        case QUADRIC:\n            filter.calculate(agg::image_filter_quadric(), norm);\n            break;\n        case CATROM:\n            filter.calculate(agg::image_filter_catrom(), norm);\n            break;\n        case GAUSSIAN:\n            filter.calculate(agg::image_filter_gaussian(), norm);\n            break;\n        case BESSEL:\n            filter.calculate(agg::image_filter_bessel(), norm);\n            break;\n        case MITCHELL:\n            filter.calculate(agg::image_filter_mitchell(), norm);\n            break;\n        case SINC:\n            filter.calculate(agg::image_filter_sinc(radius), norm);\n            break;\n        case LANCZOS:\n            filter.calculate(agg::image_filter_lanczos(radius), norm);\n            break;\n        case BLACKMAN:\n            filter.calculate(agg::image_filter_blackman(radius), norm);\n            break;\n        }\n        if (resample) {\n            typedef agg::span_image_resample_rgba_affine<img_accessor_type> span_gen_type;\n            typedef agg::renderer_scanline_aa<renderer_base, span_alloc_type, span_gen_type>\n            renderer_type;\n            span_gen_type sg(ia, interpolator, filter);\n            renderer_type ri(rb, sa, sg);\n            agg::render_scanlines(ras, sl, ri);\n        } else {\n            typedef agg::span_image_filter_rgba<img_accessor_type, interpolator_type> span_gen_type;\n            typedef agg::renderer_scanline_aa<renderer_base, span_alloc_type, span_gen_type>\n            renderer_type;\n            span_gen_type sg(ia, interpolator, filter);\n            renderer_type ri(rb, sa, sg);\n            agg::render_scanlines(ras, sl, ri);\n        }\n    } break;\n    }\n}\n\nvoid Image::clear()\n{\n    pixfmt pixf(*rbufOut);\n    renderer_base rb(pixf);\n    rb.clear(bg);\n}\n\nvoid Image::blend_image(Image &im, unsigned ox, unsigned oy, bool apply_alpha, float alpha)\n{\n    unsigned thisx = 0, thisy = 0;\n\n    pixfmt pixf(*rbufOut);\n    renderer_base rb(pixf);\n\n    bool isflip = (im.rbufOut->stride()) < 0;\n    size_t ind = 0;\n    for (unsigned j = 0; j < im.rowsOut; j++) {\n        if (isflip) {\n            thisy = im.rowsOut - j + oy;\n        } else {\n            thisy = j + oy;\n        }\n\n        for (unsigned i = 0; i < im.colsOut; i++) {\n            thisx = i + ox;\n\n            if (thisx >= colsOut || thisy >= rowsOut) {\n                ind += 4;\n                continue;\n            }\n\n            pixfmt::color_type p;\n            p.r = *(im.bufferOut + ind++);\n            p.g = *(im.bufferOut + ind++);\n            p.b = *(im.bufferOut + ind++);\n            if (apply_alpha) {\n                p.a = (pixfmt::value_type) * (im.bufferOut + ind++) * alpha;\n            } else {\n                p.a = *(im.bufferOut + ind++);\n            }\n            pixf.blend_pixel(thisx, thisy, p, 255);\n        }\n    }\n}\n\n// utilities for irregular grids\nvoid _bin_indices_middle(\n    unsigned int *irows, int nrows, const float *ys1, unsigned long ny, float dy, float y_min)\n{\n    int i, j, j_last;\n    unsigned int *rowstart = irows;\n    const float *ys2 = ys1 + 1;\n    const float *yl = ys1 + ny;\n    float yo = y_min + dy / 2.0;\n    float ym = 0.5f * (*ys1 + *ys2);\n    // y/rows\n    j = 0;\n    j_last = j;\n    for (i = 0; i < nrows; i++, yo += dy, rowstart++) {\n        while (ys2 != yl && yo > ym) {\n            ys1 = ys2;\n            ys2 = ys1 + 1;\n            ym = 0.5f * (*ys1 + *ys2);\n            j++;\n        }\n        *rowstart = j - j_last;\n        j_last = j;\n    }\n}\n\nvoid _bin_indices_middle_linear(float *arows,\n                                unsigned int *irows,\n                                int nrows,\n                                const float *y,\n                                unsigned long ny,\n                                float dy,\n                                float y_min)\n{\n    int i;\n    int ii = 0;\n    int iilast = (int)ny - 1;\n    float sc = 1 / dy;\n    int iy0 = (int)floor(sc * (y[ii] - y_min));\n    int iy1 = (int)floor(sc * (y[ii + 1] - y_min));\n    float invgap = 1.0f / (iy1 - iy0);\n    for (i = 0; i < nrows && i <= iy0; i++) {\n        irows[i] = 0;\n        arows[i] = 1.0;\n    }\n    for (; i < nrows; i++) {\n        while (i > iy1 && ii < iilast) {\n            ii++;\n            iy0 = iy1;\n            iy1 = (int)floor(sc * (y[ii + 1] - y_min));\n            invgap = 1.0f / (iy1 - iy0);\n        }\n        if (i >= iy0 && i <= iy1) {\n            irows[i] = ii;\n            arows[i] = (iy1 - i) * invgap;\n        } else\n            break;\n    }\n    for (; i < nrows; i++) {\n        irows[i] = iilast - 1;\n        arows[i] = 0.0;\n    }\n}\n\nvoid _bin_indices(int *irows, int nrows, const double *y, unsigned long ny, double sc, double offs)\n{\n    int i;\n    if (sc * (y[ny - 1] - y[0]) > 0) {\n        int ii = 0;\n        int iilast = (int)ny - 1;\n        int iy0 = (int)floor(sc * (y[ii] - offs));\n        int iy1 = (int)floor(sc * (y[ii + 1] - offs));\n        for (i = 0; i < nrows && i < iy0; i++) {\n            irows[i] = -1;\n        }\n        for (; i < nrows; i++) {\n            while (i > iy1 && ii < iilast) {\n                ii++;\n                iy0 = iy1;\n                iy1 = (int)floor(sc * (y[ii + 1] - offs));\n            }\n            if (i >= iy0 && i <= iy1)\n                irows[i] = ii;\n            else\n                break;\n        }\n        for (; i < nrows; i++) {\n            irows[i] = -1;\n        }\n    } else {\n        int iilast = (int)ny - 1;\n        int ii = iilast;\n        int iy0 = (int)floor(sc * (y[ii] - offs));\n        int iy1 = (int)floor(sc * (y[ii - 1] - offs));\n        for (i = 0; i < nrows && i < iy0; i++) {\n            irows[i] = -1;\n        }\n        for (; i < nrows; i++) {\n            while (i > iy1 && ii > 1) {\n                ii--;\n                iy0 = iy1;\n                iy1 = (int)floor(sc * (y[ii - 1] - offs));\n            }\n            if (i >= iy0 && i <= iy1)\n                irows[i] = ii - 1;\n            else\n                break;\n        }\n        for (; i < nrows; i++) {\n            irows[i] = -1;\n        }\n    }\n}\n\nvoid _bin_indices_linear(\n    float *arows, int *irows, int nrows, double *y, unsigned long ny, double sc, double offs)\n{\n    int i;\n    if (sc * (y[ny - 1] - y[0]) > 0) {\n        int ii = 0;\n        int iilast = (int)ny - 1;\n        int iy0 = (int)floor(sc * (y[ii] - offs));\n        int iy1 = (int)floor(sc * (y[ii + 1] - offs));\n        float invgap = 1.0 / (iy1 - iy0);\n        for (i = 0; i < nrows && i < iy0; i++) {\n            irows[i] = -1;\n        }\n        for (; i < nrows; i++) {\n            while (i > iy1 && ii < iilast) {\n                ii++;\n                iy0 = iy1;\n                iy1 = (int)floor(sc * (y[ii + 1] - offs));\n                invgap = 1.0 / (iy1 - iy0);\n            }\n            if (i >= iy0 && i <= iy1) {\n                irows[i] = ii;\n                arows[i] = (iy1 - i) * invgap;\n            } else\n                break;\n        }\n        for (; i < nrows; i++) {\n            irows[i] = -1;\n        }\n    } else {\n        int iilast = (int)ny - 1;\n        int ii = iilast;\n        int iy0 = (int)floor(sc * (y[ii] - offs));\n        int iy1 = (int)floor(sc * (y[ii - 1] - offs));\n        float invgap = 1.0 / (iy1 - iy0);\n        for (i = 0; i < nrows && i < iy0; i++) {\n            irows[i] = -1;\n        }\n        for (; i < nrows; i++) {\n            while (i > iy1 && ii > 1) {\n                ii--;\n                iy0 = iy1;\n                iy1 = (int)floor(sc * (y[ii - 1] - offs));\n                invgap = 1.0 / (iy1 - iy0);\n            }\n            if (i >= iy0 && i <= iy1) {\n                irows[i] = ii - 1;\n                arows[i] = (i - iy0) * invgap;\n            } else\n                break;\n        }\n        for (; i < nrows; i++) {\n            irows[i] = -1;\n        }\n    }\n}\n", "patch": "@@ -1,15 +1,8 @@\n /* -*- mode: c++; c-basic-offset: 4 -*- */\n \n-/* Python API mandates Python.h is included *first* */\n-#include \"Python.h\"\n-#include <string>\n+#define NO_IMPORT_ARRAY\n \n-#include <iostream>\n-#include <fstream>\n-#include <cmath>\n-#include <cstdio>\n-\n-#include \"numpy/arrayobject.h\"\n+#include <vector>\n \n #include \"agg_color_rgba.h\"\n #include \"agg_conv_transform.h\"\n@@ -18,6 +11,7 @@\n #include \"agg_pixfmt_rgb.h\"\n #include \"agg_pixfmt_rgba.h\"\n #include \"agg_rasterizer_scanline_aa.h\"\n+#include \"agg_rasterizer_sl_clip.h\"\n #include \"agg_renderer_scanline.h\"\n #include \"agg_rendering_buffer.h\"\n #include \"agg_scanline_bin.h\"\n@@ -27,369 +21,160 @@\n #include \"agg_span_image_filter_rgb.h\"\n #include \"agg_span_image_filter_rgba.h\"\n #include \"agg_span_interpolator_linear.h\"\n-#include \"agg_rasterizer_sl_clip.h\"\n #include \"util/agg_color_conv_rgb8.h\"\n+\n #include \"_image.h\"\n #include \"mplutils.h\"\n \n-\n typedef agg::pixfmt_rgba32_plain pixfmt;\n typedef agg::pixfmt_rgba32_pre pixfmt_pre;\n typedef agg::renderer_base<pixfmt> renderer_base;\n typedef agg::span_interpolator_linear<> interpolator_type;\n typedef agg::rasterizer_scanline_aa<agg::rasterizer_sl_clip_dbl> rasterizer;\n \n-\n-Image::Image() :\n-        bufferIn(NULL), rbufIn(NULL), colsIn(0), rowsIn(0),\n-        bufferOut(NULL), rbufOut(NULL), colsOut(0), rowsOut(0),  BPP(4),\n-        interpolation(BILINEAR), aspect(ASPECT_FREE), bg(1, 1, 1, 0), resample(true)\n-{\n-    _VERBOSE(\"Image::Image\");\n+Image::Image()\n+    : bufferIn(NULL),\n+      rbufIn(NULL),\n+      colsIn(0),\n+      rowsIn(0),\n+      bufferOut(NULL),\n+      rbufOut(NULL),\n+      colsOut(0),\n+      rowsOut(0),\n+      BPP(4),\n+      interpolation(BILINEAR),\n+      aspect(ASPECT_FREE),\n+      bg(1, 1, 1, 0),\n+      resample(true)\n+{\n+\n+}\n+\n+Image::Image(unsigned numrows, unsigned numcols, bool isoutput)\n+    : bufferIn(NULL),\n+      rbufIn(NULL),\n+      colsIn(0),\n+      rowsIn(0),\n+      bufferOut(NULL),\n+      rbufOut(NULL),\n+      colsOut(0),\n+      rowsOut(0),\n+      BPP(4),\n+      interpolation(BILINEAR),\n+      aspect(ASPECT_FREE),\n+      bg(1, 1, 1, 0),\n+      resample(true)\n+{\n+    if (isoutput) {\n+        rowsOut = numrows;\n+        colsOut = numcols;\n+        unsigned NUMBYTES(numrows * numcols * BPP);\n+        bufferOut = new agg::int8u[NUMBYTES];\n+        rbufOut = new agg::rendering_buffer;\n+        rbufOut->attach(bufferOut, colsOut, rowsOut, colsOut * BPP);\n+    } else {\n+        rowsIn = numrows;\n+        colsIn = numcols;\n+        unsigned NUMBYTES(numrows * numcols * BPP);\n+        bufferIn = new agg::int8u[NUMBYTES];\n+        rbufIn = new agg::rendering_buffer;\n+        rbufIn->attach(bufferIn, colsIn, rowsIn, colsIn * BPP);\n+    }\n }\n \n Image::~Image()\n {\n-    _VERBOSE(\"Image::~Image\");\n-    delete [] bufferIn;\n+    delete[] bufferIn;\n     bufferIn = NULL;\n     delete rbufIn;\n     rbufIn = NULL;\n     delete rbufOut;\n     rbufOut = NULL;\n-    delete [] bufferOut;\n+    delete[] bufferOut;\n     bufferOut = NULL;\n }\n \n-int\n-Image::setattr(const char * name, const Py::Object & value)\n+void Image::apply_rotation(double r)\n {\n-    _VERBOSE(\"Image::setattr\");\n-    __dict__[name] = value;\n-    return 0;\n-}\n-\n-Py::Object\n-Image::getattr(const char * name)\n-{\n-    _VERBOSE(\"Image::getattro\");\n-    if (__dict__.hasKey(name)) return __dict__[name];\n-    else return getattr_default(name);\n-}\n-\n-char Image::apply_rotation__doc__[] =\n-    \"apply_rotation(angle)\\n\"\n-    \"\\n\"\n-    \"Apply the rotation (degrees) to image\"\n-    ;\n-Py::Object\n-Image::apply_rotation(const Py::Tuple& args)\n-{\n-    _VERBOSE(\"Image::apply_rotation\");\n-\n-    args.verify_length(1);\n-    double r = Py::Float(args[0]);\n-\n-\n     agg::trans_affine M = agg::trans_affine_rotation(r * agg::pi / 180.0);\n     srcMatrix *= M;\n     imageMatrix *= M;\n-    return Py::Object();\n }\n \n-char Image::flipud_out__doc__[] =\n-    \"flipud()\\n\"\n-    \"\\n\"\n-    \"Flip the output image upside down\"\n-    ;\n-\n-char Image::flipud_in__doc__[] =\n-    \"flipud()\\n\"\n-    \"\\n\"\n-    \"Flip the input image upside down\"\n-    ;\n-Py::Object\n-Image::flipud_in(const Py::Tuple& args)\n+void Image::set_bg(double r, double g, double b, double a)\n {\n-    _VERBOSE(\"Image::flipud_in\");\n-\n-    args.verify_length(0);\n-    int stride = rbufIn->stride();\n-    rbufIn->attach(bufferIn, colsIn, rowsIn, -stride);\n-\n-    return Py::Object();\n+    bg.r = r;\n+    bg.g = g;\n+    bg.b = b;\n+    bg.a = a;\n }\n \n-char Image::set_bg__doc__[] =\n-    \"set_bg(r,g,b,a)\\n\"\n-    \"\\n\"\n-    \"Set the background color\"\n-    ;\n-\n-Py::Object\n-Image::set_bg(const Py::Tuple& args)\n+void Image::apply_scaling(double sx, double sy)\n {\n-    _VERBOSE(\"Image::set_bg\");\n-\n-    args.verify_length(4);\n-    bg.r = Py::Float(args[0]);\n-    bg.g = Py::Float(args[1]);\n-    bg.b = Py::Float(args[2]);\n-    bg.a = Py::Float(args[3]);\n-    return Py::Object();\n-}\n-\n-char Image::apply_scaling__doc__[] =\n-    \"apply_scaling(sx, sy)\\n\"\n-    \"\\n\"\n-    \"Apply the scale factors sx, sy to the transform matrix\"\n-    ;\n-\n-Py::Object\n-Image::apply_scaling(const Py::Tuple& args)\n-{\n-    _VERBOSE(\"Image::apply_scaling\");\n-\n-    args.verify_length(2);\n-    double sx = Py::Float(args[0]);\n-    double sy = Py::Float(args[1]);\n-\n-    //printf(\"applying scaling %1.2f, %1.2f\\n\", sx, sy);\n     agg::trans_affine M = agg::trans_affine_scaling(sx, sy);\n     srcMatrix *= M;\n     imageMatrix *= M;\n-\n-    return Py::Object();\n }\n \n-char Image::apply_translation__doc__[] =\n-    \"apply_translation(tx, ty)\\n\"\n-    \"\\n\"\n-    \"Apply the translation tx, ty to the transform matrix\"\n-    ;\n-\n-Py::Object\n-Image::apply_translation(const Py::Tuple& args)\n+void Image::apply_translation(double tx, double ty)\n {\n-    _VERBOSE(\"Image::apply_translation\");\n-\n-    args.verify_length(2);\n-    double tx = Py::Float(args[0]);\n-    double ty = Py::Float(args[1]);\n-\n-    //printf(\"applying translation %1.2f, %1.2f\\n\", tx, ty);\n     agg::trans_affine M = agg::trans_affine_translation(tx, ty);\n     srcMatrix *= M;\n     imageMatrix *= M;\n-\n-    return Py::Object();\n }\n \n-char Image::as_rgba_str__doc__[] =\n-    \"numrows, numcols, s = as_rgba_str()\"\n-    \"\\n\"\n-    \"Call this function after resize to get the data as string\\n\"\n-    \"The string is a numrows by numcols x 4 (RGBA) unsigned char buffer\\n\"\n-    ;\n-\n-Py::Object\n-Image::as_rgba_str(const Py::Tuple& args, const Py::Dict& kwargs)\n+void Image::as_rgba_str(agg::int8u *outbuf)\n {\n-    _VERBOSE(\"Image::as_rgba_str\");\n-\n-    args.verify_length(0);\n-\n-    std::pair<agg::int8u*, bool> bufpair = _get_output_buffer();\n-\n-    #if PY3K\n-    Py::Object ret =  Py::asObject(Py_BuildValue(\"nny#\", rowsOut, colsOut,\n-                                   bufpair.first, colsOut * rowsOut * 4));\n-    #else\n-    Py::Object ret =  Py::asObject(Py_BuildValue(\"nns#\", rowsOut, colsOut,\n-                                   bufpair.first, colsOut * rowsOut * 4));\n-    #endif\n-\n-    if (bufpair.second) delete [] bufpair.first;\n-    return ret;\n+    agg::rendering_buffer rb;\n+    rb.attach(outbuf, colsOut, rowsOut, colsOut * 4);\n+    rb.copy_from(*rbufOut);\n }\n \n-\n-char Image::color_conv__doc__[] =\n-    \"numrows, numcols, buffer = color_conv(format)\"\n-    \"\\n\"\n-    \"format 0(BGRA) or 1(ARGB)\\n\"\n-    \"Convert image to format and return in a writable buffer\\n\"\n-    ;\n-Py::Object\n-Image::color_conv(const Py::Tuple& args)\n+void Image::color_conv(int format, agg::int8u *outbuf)\n {\n-    _VERBOSE(\"Image::color_conv\");\n-\n-    args.verify_length(1);\n-    int format = Py::Int(args[0]);\n-    PyObject* py_buffer = NULL;\n     int row_len = colsOut * 4;\n-#if PY3K\n-    unsigned char* buf = (unsigned char *)malloc(row_len * rowsOut);\n-    if (buf == NULL)\n-        throw Py::MemoryError(\"Image::color_conv could not allocate memory\");\n-#else\n-    py_buffer = PyBuffer_New(row_len * rowsOut);\n-    if (py_buffer == NULL)\n-        throw Py::MemoryError(\"Image::color_conv could not allocate memory\");\n-\n-    void* buf;\n-    Py_ssize_t buffer_len;\n-    int ret = PyObject_AsWriteBuffer(py_buffer, &buf, &buffer_len);\n-    if (ret != 0)\n-    {\n-        Py_XDECREF(py_buffer);\n-        throw Py::MemoryError(\"Image::color_conv could not allocate memory\");\n-    }\n-#endif\n \n     agg::rendering_buffer rtmp;\n-    rtmp.attach(reinterpret_cast<unsigned char*>(buf), colsOut, rowsOut,\n-                row_len);\n+    rtmp.attach(outbuf, colsOut, rowsOut, row_len);\n \n-    switch (format)\n-    {\n+    switch (format) {\n     case 0:\n         agg::color_conv(&rtmp, rbufOut, agg::color_conv_rgba32_to_bgra32());\n         break;\n     case 1:\n         agg::color_conv(&rtmp, rbufOut, agg::color_conv_rgba32_to_argb32());\n         break;\n     default:\n-        Py_XDECREF(py_buffer);\n-        throw Py::ValueError(\"Image::color_conv unknown format\");\n-    }\n-\n-#if PY3K\n-    py_buffer = PyByteArray_FromStringAndSize((char *)buf, row_len * rowsOut);\n-    if (py_buffer == NULL) {\n-        free(buf);\n+        throw \"Image::color_conv unknown format\";\n     }\n-#endif\n-\n-    PyObject* o = Py_BuildValue(\"nnN\", rowsOut, colsOut, py_buffer);\n-    return Py::asObject(o);\n }\n \n-char Image::buffer_rgba__doc__[] =\n-    \"buffer = buffer_rgba()\"\n-    \"\\n\"\n-    \"Return the image buffer as rgba32\\n\"\n-    ;\n-Py::Object\n-Image::buffer_rgba(const Py::Tuple& args)\n+void Image::reset_matrix(void)\n {\n-    //\"Return the image object as rgba\";\n-\n-    _VERBOSE(\"RendererAgg::buffer_rgba\");\n-\n-    args.verify_length(0);\n-    int row_len = colsOut * 4;\n-    PyObject* o = Py_BuildValue(\"nns#\", rowsOut, colsOut,\n-                                rbufOut, row_len * rowsOut);\n-    return Py::asObject(o);\n-}\n-\n-char Image::reset_matrix__doc__[] =\n-    \"reset_matrix()\"\n-    \"\\n\"\n-    \"Reset the transformation matrix\"\n-    ;\n-\n-Py::Object\n-Image::reset_matrix(const Py::Tuple& args)\n-{\n-    _VERBOSE(\"Image::reset_matrix\");\n-\n-    args.verify_length(0);\n     srcMatrix.reset();\n     imageMatrix.reset();\n-\n-    return Py::Object();\n }\n \n-char Image::get_matrix__doc__[] =\n-    \"(m11,m21,m12,m22,m13,m23) = get_matrix()\\n\"\n-    \"\\n\"\n-    \"Get the affine transformation matrix\\n\"\n-    \"  /m11,m12,m13\\\\\\n\"\n-    \"  /m21,m22,m23|\\n\"\n-    \"  \\\\ 0 , 0 , 1 /\"\n-    ;\n-\n-Py::Object\n-Image::get_matrix(const Py::Tuple& args)\n+void Image::resize(int numcols, int numrows, int norm, double radius)\n {\n-    _VERBOSE(\"Image::get_matrix\");\n-\n-    args.verify_length(0);\n-\n-    double m[6];\n-    srcMatrix.store_to(m);\n-    Py::Tuple ret(6);\n-    for (int i = 0;i < 6;i++)\n-    {\n-        ret[i] = Py::Float(m[i]);\n+    if (bufferIn == NULL) {\n+        throw \"You must first load the image\";\n     }\n-    return ret;\n-}\n-\n-char Image::resize__doc__[] =\n-    \"resize(width, height, norm=1, radius=4.0)\\n\"\n-    \"\\n\"\n-    \"Resize the image to width, height using interpolation\\n\"\n-    \"norm and radius are optional args for some of the filters and must be\\n\"\n-    \"passed as kwargs\\n\"\n-    ;\n \n-Py::Object\n-Image::resize(const Py::Tuple& args, const Py::Dict& kwargs)\n-{\n-    _VERBOSE(\"Image::resize\");\n-\n-    args.verify_length(2);\n-\n-    int norm = 1;\n-    if (kwargs.hasKey(\"norm\"))\n-    {\n-        norm = Py::Int(kwargs[\"norm\"]);\n-    }\n-\n-    double radius = 4.0;\n-    if (kwargs.hasKey(\"radius\"))\n-    {\n-        radius = Py::Float(kwargs[\"radius\"]);\n-    }\n-\n-    if (bufferIn == NULL)\n-    {\n-        throw Py::RuntimeError(\"You must first load the image\");\n-    }\n-\n-    int numcols = Py::Int(args[0]);\n-    int numrows = Py::Int(args[1]);\n-\n-    if (numcols <= 0 || numrows <= 0)\n-    {\n-        throw Py::RuntimeError(\n-        \"Width and height must have positive values\");\n+    if (numcols <= 0 || numrows <= 0) {\n+        throw \"Width and height must have positive values\";\n     }\n \n     colsOut = numcols;\n     rowsOut = numrows;\n \n     size_t NUMBYTES(numrows * numcols * BPP);\n \n-    delete [] bufferOut;\n+    delete[] bufferOut;\n     bufferOut = new agg::int8u[NUMBYTES];\n-    if (bufferOut == NULL) //todo: also handle allocation throw\n+    if (bufferOut == NULL) // todo: also handle allocation throw\n     {\n-        throw Py::MemoryError(\"Image::resize could not allocate memory\");\n+        throw \"Image::resize could not allocate memory\";\n     }\n \n     delete rbufOut;\n@@ -405,8 +190,6 @@ Image::resize(const Py::Tuple& args, const Py::Dict& kwargs)\n \n     ras.clip_box(0, 0, numcols, numrows);\n \n-    //srcMatrix *= resizingMatrix;\n-    //imageMatrix *= resizingMatrix;\n     imageMatrix.invert();\n     interpolator_type interpolator(imageMatrix);\n \n@@ -437,26 +220,22 @@ Image::resize(const Py::Tuple& args, const Py::Dict& kwargs)\n \n     pixfmt_pre pixfmtin(*rbufIn);\n     img_accessor_type ia(pixfmtin);\n-    switch (interpolation)\n-    {\n+    switch (interpolation) {\n \n-    case NEAREST:\n-    {\n+    case NEAREST: {\n         typedef agg::span_image_filter_rgba_nn<img_accessor_type, interpolator_type> span_gen_type;\n-        typedef agg::renderer_scanline_aa<renderer_base, span_alloc_type, span_gen_type> renderer_type;\n+        typedef agg::renderer_scanline_aa<renderer_base, span_alloc_type, span_gen_type>\n+        renderer_type;\n         span_gen_type sg(ia, interpolator);\n         renderer_type ri(rb, sa, sg);\n         agg::render_scanlines(ras, sl, ri);\n-    }\n-    break;\n+    } break;\n \n     case HANNING:\n     case HAMMING:\n-    case HERMITE:\n-    {\n+    case HERMITE: {\n         agg::image_filter_lut filter;\n-        switch (interpolation)\n-        {\n+        switch (interpolation) {\n         case HANNING:\n             filter.calculate(agg::image_filter_hanning(), norm);\n             break;\n@@ -467,24 +246,23 @@ Image::resize(const Py::Tuple& args, const Py::Dict& kwargs)\n             filter.calculate(agg::image_filter_hermite(), norm);\n             break;\n         }\n-        if (resample)\n-        {\n+        if (resample) {\n             typedef agg::span_image_resample_rgba_affine<img_accessor_type> span_gen_type;\n-            typedef agg::renderer_scanline_aa<renderer_base, span_alloc_type, span_gen_type> renderer_type;\n+            typedef agg::renderer_scanline_aa<renderer_base, span_alloc_type, span_gen_type>\n+            renderer_type;\n             span_gen_type sg(ia, interpolator, filter);\n             renderer_type ri(rb, sa, sg);\n             agg::render_scanlines(ras, sl, ri);\n-        }\n-        else\n-        {\n-            typedef agg::span_image_filter_rgba_2x2<img_accessor_type, interpolator_type> span_gen_type;\n-            typedef agg::renderer_scanline_aa<renderer_base, span_alloc_type, span_gen_type> renderer_type;\n+        } else {\n+            typedef agg::span_image_filter_rgba_2x2<img_accessor_type, interpolator_type>\n+            span_gen_type;\n+            typedef agg::renderer_scanline_aa<renderer_base, span_alloc_type, span_gen_type>\n+            renderer_type;\n             span_gen_type sg(ia, interpolator, filter);\n             renderer_type ri(rb, sa, sg);\n             agg::render_scanlines(ras, sl, ri);\n         }\n-    }\n-    break;\n+    } break;\n     case BILINEAR:\n     case BICUBIC:\n     case SPLINE16:\n@@ -497,11 +275,9 @@ Image::resize(const Py::Tuple& args, const Py::Dict& kwargs)\n     case MITCHELL:\n     case SINC:\n     case LANCZOS:\n-    case BLACKMAN:\n-    {\n+    case BLACKMAN: {\n         agg::image_filter_lut filter;\n-        switch (interpolation)\n-        {\n+        switch (interpolation) {\n         case BILINEAR:\n             filter.calculate(agg::image_filter_bilinear(), norm);\n             break;\n@@ -542,801 +318,85 @@ Image::resize(const Py::Tuple& args, const Py::Dict& kwargs)\n             filter.calculate(agg::image_filter_blackman(radius), norm);\n             break;\n         }\n-        if (resample)\n-        {\n+        if (resample) {\n             typedef agg::span_image_resample_rgba_affine<img_accessor_type> span_gen_type;\n-            typedef agg::renderer_scanline_aa<renderer_base, span_alloc_type, span_gen_type> renderer_type;\n+            typedef agg::renderer_scanline_aa<renderer_base, span_alloc_type, span_gen_type>\n+            renderer_type;\n             span_gen_type sg(ia, interpolator, filter);\n             renderer_type ri(rb, sa, sg);\n             agg::render_scanlines(ras, sl, ri);\n-        }\n-        else\n-        {\n+        } else {\n             typedef agg::span_image_filter_rgba<img_accessor_type, interpolator_type> span_gen_type;\n-            typedef agg::renderer_scanline_aa<renderer_base, span_alloc_type, span_gen_type> renderer_type;\n+            typedef agg::renderer_scanline_aa<renderer_base, span_alloc_type, span_gen_type>\n+            renderer_type;\n             span_gen_type sg(ia, interpolator, filter);\n             renderer_type ri(rb, sa, sg);\n             agg::render_scanlines(ras, sl, ri);\n         }\n+    } break;\n     }\n-    break;\n-\n-    }\n-\n-    return Py::Object();\n }\n \n-\n-\n-char Image::get_interpolation__doc__[] =\n-    \"get_interpolation()\\n\"\n-    \"\\n\"\n-    \"Get the interpolation scheme to one of the module constants, \"\n-    \"one of image.NEAREST, image.BILINEAR, etc...\"\n-    ;\n-\n-Py::Object\n-Image::get_interpolation(const Py::Tuple& args)\n+void Image::clear()\n {\n-    _VERBOSE(\"Image::get_interpolation\");\n-\n-    args.verify_length(0);\n-    return Py::Int((int)interpolation);\n-}\n-\n-\n-char Image::get_aspect__doc__[] =\n-    \"get_aspect()\\n\"\n-    \"\\n\"\n-    \"Get the aspect constraint constants\"\n-    ;\n-\n-Py::Object\n-Image::get_aspect(const Py::Tuple& args)\n-{\n-    _VERBOSE(\"Image::get_aspect\");\n-\n-    args.verify_length(0);\n-    return Py::Int((int)aspect);\n-}\n-\n-char Image::get_size__doc__[] =\n-    \"numrows, numcols = get_size()\\n\"\n-    \"\\n\"\n-    \"Get the number or rows and columns of the input image\"\n-    ;\n-\n-Py::Object\n-Image::get_size(const Py::Tuple& args)\n-{\n-    _VERBOSE(\"Image::get_size\");\n-\n-    args.verify_length(0);\n-\n-    Py::Tuple ret(2);\n-    ret[0] = Py::Int((long)rowsIn);\n-    ret[1] = Py::Int((long)colsIn);\n-    return ret;\n-\n-}\n-\n-char Image::get_resample__doc__[] =\n-    \"get_resample()\\n\"\n-    \"\\n\"\n-    \"Get the resample flag.\"\n-    ;\n-\n-Py::Object\n-Image::get_resample(const Py::Tuple& args)\n-{\n-    _VERBOSE(\"Image::get_resample\");\n-\n-    args.verify_length(0);\n-    return Py::Int((int)resample);\n-}\n-\n-char Image::get_size_out__doc__[] =\n-    \"numrows, numcols = get_size()\\n\"\n-    \"\\n\"\n-    \"Get the number or rows and columns of the output image\"\n-    ;\n-\n-Py::Object\n-Image::get_size_out(const Py::Tuple& args)\n-{\n-    _VERBOSE(\"Image::get_size_out\");\n-\n-    args.verify_length(0);\n-\n-    Py::Tuple ret(2);\n-    ret[0] = Py::Int((long)rowsOut);\n-    ret[1] = Py::Int((long)colsOut);\n-    return ret;\n-}\n-\n-//get the output buffer, flipped if necessary.  The second element of\n-//the pair is a bool that indicates whether you need to free the\n-//memory\n-std::pair<agg::int8u*, bool>\n-Image::_get_output_buffer()\n-{\n-    _VERBOSE(\"Image::_get_output_buffer\");\n-    std::pair<agg::int8u*, bool> ret;\n-    bool flipy = rbufOut->stride() < 0;\n-    if (flipy)\n-    {\n-        agg::int8u* buffer = new agg::int8u[rowsOut*colsOut*4];\n-        agg::rendering_buffer rb;\n-        rb.attach(buffer, colsOut, rowsOut, colsOut*4);\n-        rb.copy_from(*rbufOut);\n-        ret.first = buffer;\n-        ret.second = true;\n-    }\n-    else\n-    {\n-        ret.first = bufferOut;\n-        ret.second = false;\n-    }\n-    return ret;\n-\n-}\n-\n-char Image::set_interpolation__doc__[] =\n-    \"set_interpolation(scheme)\\n\"\n-    \"\\n\"\n-    \"Set the interpolation scheme to one of the module constants, \"\n-    \"eg, image.NEAREST, image.BILINEAR, etc...\"\n-    ;\n-\n-Py::Object\n-Image::set_interpolation(const Py::Tuple& args)\n-{\n-    _VERBOSE(\"Image::set_interpolation\");\n-\n-    args.verify_length(1);\n-\n-    size_t method = (long)Py::Int(args[0]);\n-    interpolation = (unsigned)method;\n-    return Py::Object();\n-}\n-\n-char Image::set_resample__doc__[] =\n-    \"set_resample(boolean)\\n\"\n-    \"\\n\"\n-    \"Set the resample flag.\"\n-    ;\n-\n-Py::Object\n-Image::set_resample(const Py::Tuple& args)\n-{\n-    _VERBOSE(\"Image::set_resample\");\n-    args.verify_length(1);\n-    int flag = Py::Int(args[0]);\n-    resample = (bool)flag;\n-    return Py::Object();\n-}\n-\n-\n-char Image::set_aspect__doc__[] =\n-    \"set_aspect(scheme)\\n\"\n-    \"\\n\"\n-    \"Set the aspect ration to one of the image module constant.\"\n-    \"eg, one of image.ASPECT_PRESERVE, image.ASPECT_FREE\"\n-    ;\n-Py::Object\n-Image::set_aspect(const Py::Tuple& args)\n-{\n-    _VERBOSE(\"Image::set_aspect\");\n-\n-    args.verify_length(1);\n-    size_t method = (long)Py::Int(args[0]);\n-    aspect = (unsigned)method;\n-    return Py::Object();\n-\n-}\n-\n-void\n-Image::init_type()\n-{\n-    _VERBOSE(\"Image::init_type\");\n-\n-    behaviors().name(\"Image\");\n-    behaviors().doc(\"Image\");\n-    behaviors().supportGetattr();\n-    behaviors().supportSetattr();\n-\n-    add_varargs_method(\"apply_rotation\", &Image::apply_rotation, Image::apply_rotation__doc__);\n-    add_varargs_method(\"apply_scaling\",  &Image::apply_scaling, Image::apply_scaling__doc__);\n-    add_varargs_method(\"apply_translation\", &Image::apply_translation, Image::apply_translation__doc__);\n-    add_keyword_method(\"as_rgba_str\", &Image::as_rgba_str, Image::as_rgba_str__doc__);\n-    add_varargs_method(\"color_conv\", &Image::color_conv, Image::color_conv__doc__);\n-    add_varargs_method(\"buffer_rgba\", &Image::buffer_rgba, Image::buffer_rgba__doc__);\n-    add_varargs_method(\"get_aspect\", &Image::get_aspect, Image::get_aspect__doc__);\n-    add_varargs_method(\"get_interpolation\", &Image::get_interpolation, Image::get_interpolation__doc__);\n-    add_varargs_method(\"get_resample\", &Image::get_resample, Image::get_resample__doc__);\n-    add_varargs_method(\"get_size\", &Image::get_size, Image::get_size__doc__);\n-    add_varargs_method(\"get_size_out\", &Image::get_size_out, Image::get_size_out__doc__);\n-    add_varargs_method(\"reset_matrix\", &Image::reset_matrix, Image::reset_matrix__doc__);\n-    add_varargs_method(\"get_matrix\", &Image::get_matrix, Image::get_matrix__doc__);\n-    add_keyword_method(\"resize\", &Image::resize, Image::resize__doc__);\n-    add_varargs_method(\"set_interpolation\", &Image::set_interpolation, Image::set_interpolation__doc__);\n-    add_varargs_method(\"set_resample\", &Image::set_resample, Image::set_resample__doc__);\n-    add_varargs_method(\"set_aspect\", &Image::set_aspect, Image::set_aspect__doc__);\n-    add_varargs_method(\"set_bg\", &Image::set_bg, Image::set_bg__doc__);\n-    add_varargs_method(\"flipud_out\", &Image::flipud_out, Image::flipud_out__doc__);\n-    add_varargs_method(\"flipud_in\", &Image::flipud_in, Image::flipud_in__doc__);\n-}\n-\n-\n-\n-\n-char _image_module_from_images__doc__[] =\n-    \"from_images(numrows, numcols, seq)\\n\"\n-    \"\\n\"\n-    \"return an image instance with numrows, numcols from a seq of image\\n\"\n-    \"instances using alpha blending.  seq is a list of (Image, ox, oy)\"\n-    ;\n-Py::Object\n-_image_module::from_images(const Py::Tuple& args)\n-{\n-    _VERBOSE(\"_image_module::from_images\");\n-\n-    args.verify_length(3);\n-\n-    size_t numrows = (long)Py::Int(args[0]);\n-    size_t numcols = (long)Py::Int(args[1]);\n-\n-    if (numrows >= 32768 || numcols >= 32768)\n-    {\n-        throw Py::RuntimeError(\"numrows and numcols must both be less than 32768\");\n-    }\n-\n-    Py::SeqBase<Py::Object> tups = args[2];\n-    size_t N = tups.length();\n-\n-    if (N == 0)\n-    {\n-        throw Py::RuntimeError(\"Empty list of images\");\n-    }\n-\n-    Py::Tuple tup;\n-\n-    size_t ox(0), oy(0), thisx(0), thisy(0);\n-    float alpha;\n-    bool apply_alpha;\n-\n-    //copy image 0 output buffer into return images output buffer\n-    Image* imo = new Image;\n-    imo->rowsOut  = numrows;\n-    imo->colsOut  = numcols;\n-\n-    size_t NUMBYTES(numrows * numcols * imo->BPP);\n-    imo->bufferOut = new agg::int8u[NUMBYTES];\n-    if (imo->bufferOut == NULL) //todo: also handle allocation throw\n-    {\n-        throw Py::MemoryError(\"_image_module::from_images could not allocate memory\");\n-    }\n-\n-    delete imo->rbufOut;\n-    imo->rbufOut = new agg::rendering_buffer;\n-    imo->rbufOut->attach(imo->bufferOut, imo->colsOut, imo->rowsOut, imo->colsOut * imo->BPP);\n-\n-    pixfmt pixf(*imo->rbufOut);\n+    pixfmt pixf(*rbufOut);\n     renderer_base rb(pixf);\n-\n-    rb.clear(agg::rgba(0, 0, 0, 0));\n-    for (size_t imnum = 0; imnum < N; imnum++)\n-    {\n-        tup = Py::Tuple(tups[imnum]);\n-        Image* thisim = static_cast<Image*>(tup[0].ptr());\n-        ox = (long)Py::Int(tup[1]);\n-        oy = (long)Py::Int(tup[2]);\n-        if (tup.size() <= 3 || tup[3].ptr() == Py_None)\n-        {\n-            apply_alpha = false;\n-        }\n-        else\n-        {\n-            apply_alpha = true;\n-            alpha = Py::Float(tup[3]);\n-        }\n-\n-        bool isflip = (thisim->rbufOut->stride()) < 0;\n-        //std::cout << \"from images \" << isflip << \"; stride=\" << thisim->rbufOut->stride() << std::endl;\n-        size_t ind = 0;\n-        for (size_t j = 0; j < thisim->rowsOut; j++)\n-        {\n-            for (size_t i = 0; i < thisim->colsOut; i++)\n-            {\n-                thisx = i + ox;\n-\n-                if (isflip)\n-                {\n-                    thisy = thisim->rowsOut - j + oy;\n-                }\n-                else\n-                {\n-                    thisy = j + oy;\n-                }\n-\n-                if (thisx >= numcols || thisy >= numrows)\n-                {\n-                    ind += 4;\n-                    continue;\n-                }\n-\n-                pixfmt::color_type p;\n-                p.r = *(thisim->bufferOut + ind++);\n-                p.g = *(thisim->bufferOut + ind++);\n-                p.b = *(thisim->bufferOut + ind++);\n-                if (apply_alpha)\n-                {\n-                    p.a = (pixfmt::value_type) *(thisim->bufferOut + ind++) * alpha;\n-                }\n-                else\n-                {\n-                    p.a = *(thisim->bufferOut + ind++);\n-                }\n-                pixf.blend_pixel(thisx, thisy, p, 255);\n-            }\n-        }\n-    }\n-\n-    return Py::asObject(imo);\n-}\n-\n-\n-char _image_module_fromarray__doc__[] =\n-    \"fromarray(A, isoutput)\\n\"\n-    \"\\n\"\n-    \"Load the image from a numpy array\\n\"\n-    \"By default this function fills the input buffer, which can subsequently\\n\"\n-    \"be resampled using resize.  If isoutput=1, fill the output buffer.\\n\"\n-    \"This is used to support raw pixel images w/o resampling\"\n-    ;\n-Py::Object\n-_image_module::fromarray(const Py::Tuple& args)\n-{\n-    _VERBOSE(\"_image_module::fromarray\");\n-\n-    args.verify_length(2);\n-\n-    Py::Object x = args[0];\n-    int isoutput = Py::Int(args[1]);\n-    PyArrayObject *A = (PyArrayObject *) PyArray_FromObject(x.ptr(), NPY_DOUBLE, 2, 3);\n-    if (A == NULL)\n-    {\n-        throw Py::ValueError(\"Array must be rank 2 or 3 of doubles\");\n-    }\n-    Py::Object A_obj((PyObject *)A, true);\n-\n-    Image* imo = new Image;\n-\n-    imo->rowsIn  = PyArray_DIM(A, 0);\n-    imo->colsIn  = PyArray_DIM(A, 1);\n-\n-    size_t NUMBYTES(imo->colsIn * imo->rowsIn * imo->BPP);\n-    agg::int8u *buffer = new agg::int8u[NUMBYTES];\n-    if (buffer == NULL) //todo: also handle allocation throw\n-    {\n-        throw Py::MemoryError(\"_image_module::fromarray could not allocate memory\");\n-    }\n-\n-    if (isoutput)\n-    {\n-        // make the output buffer point to the input buffer\n-        imo->rowsOut  = imo->rowsIn;\n-        imo->colsOut  = imo->colsIn;\n-\n-        imo->rbufOut = new agg::rendering_buffer;\n-        imo->bufferOut = buffer;\n-        imo->rbufOut->attach(imo->bufferOut, imo->colsOut, imo->rowsOut, imo->colsOut * imo->BPP);\n-    }\n-    else\n-    {\n-        imo->bufferIn = buffer;\n-        imo->rbufIn = new agg::rendering_buffer;\n-        imo->rbufIn->attach(buffer, imo->colsIn, imo->rowsIn, imo->colsIn*imo->BPP);\n-    }\n-\n-    if (PyArray_NDIM(A) == 2)     //assume luminance for now;\n-    {\n-        agg::int8u gray;\n-        for (size_t rownum = 0; rownum < imo->rowsIn; rownum++)\n-        {\n-            for (size_t colnum = 0; colnum < imo->colsIn; colnum++)\n-            {\n-                double val = *(double *)PyArray_GETPTR2(A, rownum, colnum);\n-\n-                gray = int(255 * val);\n-                *buffer++ = gray;       // red\n-                *buffer++ = gray;       // green\n-                *buffer++ = gray;       // blue\n-                *buffer++   = 255;        // alpha\n-            }\n-        }\n-    }\n-    else if (PyArray_NDIM(A) == 3)     // assume RGB\n-    {\n-\n-        if (PyArray_DIM(A, 2) != 3 && PyArray_DIM(A, 2) != 4)\n-        {\n-            throw Py::ValueError(Printf(\"3rd dimension must be length 3 (RGB) or 4 (RGBA); found %d\",\n-                                        PyArray_DIM(A, 2)).str());\n-        }\n-\n-        int rgba = PyArray_DIM(A, 2) == 4;\n-        double r, g, b, alpha;\n-        size_t offset = 0;\n-\n-        for (size_t rownum = 0; rownum < imo->rowsIn; rownum++)\n-        {\n-            for (size_t colnum = 0; colnum < imo->colsIn; colnum++)\n-            {\n-                r = *(double*)PyArray_GETPTR3(A, rownum, colnum, 0);\n-                g = *(double*)PyArray_GETPTR3(A, rownum, colnum, 1);\n-                b = *(double*)PyArray_GETPTR3(A, rownum, colnum, 2);\n-\n-                if (rgba)\n-                {\n-                    alpha = *(double*)PyArray_GETPTR3(A, rownum, colnum, 3);\n-                }\n-                else\n-                {\n-                    alpha = 1.0;\n-                }\n-\n-                *buffer++ = int(255 * r);       // red\n-                *buffer++ = int(255 * g);       // green\n-                *buffer++ = int(255 * b);       // blue\n-                *buffer++ = int(255 * alpha);   // alpha\n-            }\n-        }\n-    }\n-    else     // error\n-    {\n-        throw Py::ValueError(\"Illegal array rank; must be rank; must 2 or 3\");\n-    }\n-\n-    return Py::asObject(imo);\n+    rb.clear(bg);\n }\n \n-char _image_module_fromarray2__doc__[] =\n-    \"fromarray2(A, isoutput)\\n\"\n-    \"\\n\"\n-    \"Load the image from a numpy array\\n\"\n-    \"By default this function fills the input buffer, which can subsequently\\n\"\n-    \"be resampled using resize.  If isoutput=1, fill the output buffer.\\n\"\n-    \"This is used to support raw pixel images w/o resampling\"\n-    ;\n-Py::Object\n-_image_module::fromarray2(const Py::Tuple& args)\n+void Image::blend_image(Image &im, unsigned ox, unsigned oy, bool apply_alpha, float alpha)\n {\n-    _VERBOSE(\"_image_module::fromarray2\");\n-\n-    args.verify_length(2);\n-\n-    Py::Object x = args[0];\n-    int isoutput = Py::Int(args[1]);\n-    PyArrayObject *A = (PyArrayObject *) PyArray_ContiguousFromObject(x.ptr(), NPY_DOUBLE, 2, 3);\n-    if (A == NULL)\n-    {\n-        throw Py::ValueError(\"Array must be rank 2 or 3 of doubles\");\n-    }\n-    Py::Object A_obj((PyObject*)A, true);\n-\n-    Image* imo = new Image;\n-\n-    imo->rowsIn  = PyArray_DIM(A, 0);\n-    imo->colsIn  = PyArray_DIM(A, 1);\n-\n-    size_t NUMBYTES(imo->colsIn * imo->rowsIn * imo->BPP);\n-    agg::int8u *buffer = new agg::int8u[NUMBYTES];\n-    if (buffer == NULL) //todo: also handle allocation throw\n-    {\n-        throw Py::MemoryError(\"_image_module::fromarray could not allocate memory\");\n-    }\n-\n-    if (isoutput)\n-    {\n-        // make the output buffer point to the input buffer\n-        imo->rowsOut  = imo->rowsIn;\n-        imo->colsOut  = imo->colsIn;\n+    unsigned thisx = 0, thisy = 0;\n \n-        imo->rbufOut = new agg::rendering_buffer;\n-        imo->bufferOut = buffer;\n-        imo->rbufOut->attach(imo->bufferOut, imo->colsOut, imo->rowsOut, imo->colsOut * imo->BPP);\n-    }\n-    else\n-    {\n-        imo->bufferIn = buffer;\n-        imo->rbufIn = new agg::rendering_buffer;\n-        imo->rbufIn->attach(buffer, imo->colsIn, imo->rowsIn, imo->colsIn*imo->BPP);\n-    }\n+    pixfmt pixf(*rbufOut);\n+    renderer_base rb(pixf);\n \n-    if (PyArray_NDIM(A) == 2)     //assume luminance for now;\n-    {\n-        agg::int8u gray;\n-        for (size_t row = 0; row < imo->rowsIn; row++) {\n-            for (size_t col = 0; col < imo->colsIn; col++) {\n-                const double val = *(double*)PyArray_GETPTR2(A, row, col);\n-                gray = int(255 * val);\n-                *buffer++ = gray;  // red\n-                *buffer++ = gray;  // green\n-                *buffer++ = gray;  // blue\n-                *buffer++ = 255;   // alpha\n-            }\n+    bool isflip = (im.rbufOut->stride()) < 0;\n+    size_t ind = 0;\n+    for (unsigned j = 0; j < im.rowsOut; j++) {\n+        if (isflip) {\n+            thisy = im.rowsOut - j + oy;\n+        } else {\n+            thisy = j + oy;\n         }\n-    }\n-    else if (PyArray_NDIM(A) == 3)     // assume RGB\n-    {\n-        if (PyArray_DIM(A, 2) != 3 && PyArray_DIM(A, 2) != 4)\n-        {\n-            throw Py::ValueError(Printf(\"3rd dimension must be length 3 (RGB) or 4 (RGBA); found %d\",\n-                                        PyArray_DIM(A, 2)).str());\n \n-        }\n+        for (unsigned i = 0; i < im.colsOut; i++) {\n+            thisx = i + ox;\n \n-        int rgba = PyArray_DIM(A, 2) == 4;\n-        double r, g, b, alpha;\n-        for (size_t row = 0; row < imo->rowsIn; row++) {\n-            for (size_t col = 0; col < imo->colsIn; col++) {\n-                r = *(double*)PyArray_GETPTR3(A, row, col, 0);\n-                g = *(double*)PyArray_GETPTR3(A, row, col, 1);\n-                b = *(double*)PyArray_GETPTR3(A, row, col, 2);\n-                if (rgba)\n-                    alpha = *(double*)PyArray_GETPTR3(A, row, col, 3);\n-                else\n-                    alpha = 1.0;\n-                *buffer++ = int(255 * r);       // red\n-                *buffer++ = int(255 * g);       // green\n-                *buffer++ = int(255 * b);       // blue\n-                *buffer++ = int(255 * alpha);   // alpha\n+            if (thisx >= colsOut || thisy >= rowsOut) {\n+                ind += 4;\n+                continue;\n             }\n-        }\n-    }\n-    else     // error\n-    {\n-        throw Py::ValueError(\"Illegal array rank; must be rank; must 2 or 3\");\n-    }\n-\n-    return Py::asObject(imo);\n-}\n-\n-char _image_module_frombyte__doc__[] =\n-    \"frombyte(A, isoutput)\\n\"\n-    \"\\n\"\n-    \"Load the image from a byte array.\\n\"\n-    \"By default this function fills the input buffer, which can subsequently\\n\"\n-    \"be resampled using resize.  If isoutput=1, fill the output buffer.\\n\"\n-    \"This is used to support raw pixel images w/o resampling.\"\n-    ;\n-Py::Object\n-_image_module::frombyte(const Py::Tuple& args)\n-{\n-    _VERBOSE(\"_image_module::frombyte\");\n-\n-    args.verify_length(2);\n-\n-    Py::Object x = args[0];\n-    int isoutput = Py::Int(args[1]);\n-\n-    PyArrayObject *A = (PyArrayObject *) PyArray_FromObject(x.ptr(), NPY_UBYTE, 3, 3);\n-    if (A == NULL)\n-    {\n-        throw Py::ValueError(\"Array must have 3 dimensions\");\n-    }\n-    Py::Object A_obj((PyObject*)A, true);\n-\n-    if (PyArray_DIM(A, 2) < 3 || PyArray_DIM(A, 2) > 4)\n-    {\n-        throw Py::ValueError(\"Array dimension 3 must have size 3 or 4\");\n-    }\n-\n-    Image* imo = new Image;\n-\n-    imo->rowsIn = PyArray_DIM(A, 0);\n-    imo->colsIn = PyArray_DIM(A, 1);\n-\n-    agg::int8u *arrbuf;\n-    agg::int8u *buffer;\n-    agg::int8u *dstbuf;\n-\n-    arrbuf = reinterpret_cast<agg::int8u *>(PyArray_DATA(A));\n-\n-    size_t NUMBYTES(imo->colsIn * imo->rowsIn * imo->BPP);\n-    buffer = dstbuf = new agg::int8u[NUMBYTES];\n \n-    if (buffer == NULL) //todo: also handle allocation throw\n-    {\n-        throw Py::MemoryError(\"_image_module::frombyte could not allocate memory\");\n-    }\n-\n-    if (PyArray_ISCONTIGUOUS(A))\n-    {\n-        if (PyArray_DIM(A, 2) == 4)\n-        {\n-            memmove(dstbuf, arrbuf, imo->rowsIn * imo->colsIn * 4);\n-        }\n-        else\n-        {\n-            size_t i = imo->rowsIn * imo->colsIn;\n-            while (i--)\n-            {\n-                *dstbuf++ = *arrbuf++;\n-                *dstbuf++ = *arrbuf++;\n-                *dstbuf++ = *arrbuf++;\n-                *dstbuf++ = 255;\n-            }\n-        }\n-    }\n-    else if ((PyArray_STRIDE(A, 1) == 4) && (PyArray_STRIDE(A, 2) == 1))\n-    {\n-        const size_t N = imo->colsIn * 4;\n-        const size_t stride = PyArray_STRIDE(A, 0);\n-        for (size_t rownum = 0; rownum < imo->rowsIn; rownum++)\n-        {\n-            memmove(dstbuf, arrbuf, N);\n-            arrbuf += stride;\n-            dstbuf += N;\n-        }\n-    }\n-    else if ((PyArray_STRIDE(A, 1) == 3) && (PyArray_STRIDE(A, 2) == 1))\n-    {\n-        const size_t stride = PyArray_STRIDE(A, 0) - imo->colsIn * 3;\n-        for (size_t rownum = 0; rownum < imo->rowsIn; rownum++)\n-        {\n-            for (size_t colnum = 0; colnum < imo->colsIn; colnum++)\n-            {\n-                *dstbuf++ = *arrbuf++;\n-                *dstbuf++ = *arrbuf++;\n-                *dstbuf++ = *arrbuf++;\n-                *dstbuf++ = 255;\n-            }\n-            arrbuf += stride;\n-        }\n-    }\n-    else\n-    {\n-        PyArrayIterObject *iter;\n-        iter = (PyArrayIterObject *)PyArray_IterNew((PyObject *)A);\n-        if (PyArray_DIM(A, 2) == 4)\n-        {\n-            while (iter->index < iter->size) {\n-                *dstbuf++ = *((unsigned char *)iter->dataptr);\n-                PyArray_ITER_NEXT(iter);\n-            }\n-        }\n-        else\n-        {\n-            while (iter->index < iter->size) {\n-                *dstbuf++ = *((unsigned char *)iter->dataptr);\n-                PyArray_ITER_NEXT(iter);\n-                *dstbuf++ = *((unsigned char *)iter->dataptr);\n-                PyArray_ITER_NEXT(iter);\n-                *dstbuf++ = *((unsigned char *)iter->dataptr);\n-                PyArray_ITER_NEXT(iter);\n-                *dstbuf++ = 255;\n+            pixfmt::color_type p;\n+            p.r = *(im.bufferOut + ind++);\n+            p.g = *(im.bufferOut + ind++);\n+            p.b = *(im.bufferOut + ind++);\n+            if (apply_alpha) {\n+                p.a = (pixfmt::value_type) * (im.bufferOut + ind++) * alpha;\n+            } else {\n+                p.a = *(im.bufferOut + ind++);\n             }\n+            pixf.blend_pixel(thisx, thisy, p, 255);\n         }\n-        Py_DECREF(iter);\n-    }\n-\n-    if (isoutput)\n-    {\n-        // make the output buffer point to the input buffer\n-\n-        imo->rowsOut  = imo->rowsIn;\n-        imo->colsOut  = imo->colsIn;\n-\n-        imo->rbufOut = new agg::rendering_buffer;\n-        imo->bufferOut = buffer;\n-        imo->rbufOut->attach(imo->bufferOut, imo->colsOut, imo->rowsOut, imo->colsOut * imo->BPP);\n-\n-    }\n-    else\n-    {\n-        imo->bufferIn = buffer;\n-        imo->rbufIn = new agg::rendering_buffer;\n-        imo->rbufIn->attach(buffer, imo->colsIn, imo->rowsIn, imo->colsIn*imo->BPP);\n     }\n-\n-    return Py::asObject(imo);\n-}\n-\n-char _image_module_frombuffer__doc__[] =\n-    \"frombuffer(buffer, width, height, isoutput)\\n\"\n-    \"\\n\"\n-    \"Load the image from a character buffer\\n\"\n-    \"By default this function fills the input buffer, which can subsequently\\n\"\n-    \"be resampled using resize.  If isoutput=1, fill the output buffer.\\n\"\n-    \"This is used to support raw pixel images w/o resampling.\"\n-    ;\n-Py::Object\n-_image_module::frombuffer(const Py::Tuple& args)\n-{\n-    _VERBOSE(\"_image_module::frombuffer\");\n-\n-    args.verify_length(4);\n-\n-    PyObject *bufin = args[0].ptr();\n-    size_t x = (long)Py::Int(args[1]);\n-    size_t y = (long)Py::Int(args[2]);\n-\n-    if (x >= 32768 || y >= 32768)\n-    {\n-        throw Py::ValueError(\"x and y must both be less than 32768\");\n-    }\n-\n-    int isoutput = Py::Int(args[3]);\n-\n-    if (PyObject_CheckReadBuffer(bufin) != 1)\n-        throw Py::ValueError(\"First argument must be a buffer.\");\n-\n-    Image* imo = new Image;\n-\n-    imo->rowsIn = y;\n-    imo->colsIn = x;\n-    Py_ssize_t NUMBYTES(imo->colsIn * imo->rowsIn * imo->BPP);\n-\n-    Py_ssize_t buflen;\n-    const agg::int8u *rawbuf;\n-    if (PyObject_AsReadBuffer(bufin, reinterpret_cast<const void**>(&rawbuf), &buflen) != 0)\n-    {\n-        throw Py::ValueError(\"Cannot get buffer from object.\");\n-    }\n-\n-    // Check buffer is required size.\n-    if (buflen != NUMBYTES)\n-    {\n-        throw Py::ValueError(\"Buffer length must be width * height * 4.\");\n-    }\n-\n-    // Copy from input buffer to new buffer for agg.\n-    agg::int8u* buffer = new agg::int8u[NUMBYTES];\n-    if (buffer == NULL) //todo: also handle allocation throw\n-    {\n-        throw Py::MemoryError(\"_image_module::frombuffer could not allocate memory\");\n-    }\n-    memmove(buffer, rawbuf, NUMBYTES);\n-\n-    if (isoutput)\n-    {\n-        // make the output buffer point to the input buffer\n-        imo->rowsOut  = imo->rowsIn;\n-        imo->colsOut  = imo->colsIn;\n-\n-        imo->rbufOut = new agg::rendering_buffer;\n-        imo->bufferOut = buffer;\n-        imo->rbufOut->attach(imo->bufferOut, imo->colsOut, imo->rowsOut, imo->colsOut * imo->BPP);\n-\n-    }\n-    else\n-    {\n-        imo->bufferIn = buffer;\n-        imo->rbufIn = new agg::rendering_buffer;\n-        imo->rbufIn->attach(buffer, imo->colsIn, imo->rowsIn, imo->colsIn*imo->BPP);\n-    }\n-\n-    return Py::asObject(imo);\n }\n \n // utilities for irregular grids\n-void _bin_indices_middle(unsigned int *irows, int nrows, float *ys1, int ny, float dy, float y_min)\n+void _bin_indices_middle(\n+    unsigned int *irows, int nrows, const float *ys1, unsigned long ny, float dy, float y_min)\n {\n-    int  i, j, j_last;\n-    unsigned  int * rowstart = irows;\n-    float *ys2 = ys1 + 1;\n-    float *yl = ys1 + ny ;\n+    int i, j, j_last;\n+    unsigned int *rowstart = irows;\n+    const float *ys2 = ys1 + 1;\n+    const float *yl = ys1 + ny;\n     float yo = y_min + dy / 2.0;\n     float ym = 0.5f * (*ys1 + *ys2);\n     // y/rows\n     j = 0;\n     j_last = j;\n-    for (i = 0;i < nrows;i++, yo += dy, rowstart++)\n-    {\n-        while (ys2 != yl && yo > ym)\n-        {\n+    for (i = 0; i < nrows; i++, yo += dy, rowstart++) {\n+        while (ys2 != yl && yo > ym) {\n             ys1 = ys2;\n             ys2 = ys1 + 1;\n             ym = 0.5f * (*ys1 + *ys2);\n@@ -1347,658 +407,147 @@ void _bin_indices_middle(unsigned int *irows, int nrows, float *ys1, int ny, flo\n     }\n }\n \n-void _bin_indices_middle_linear(float *arows, unsigned int *irows, int nrows, float *y, int ny, float dy, float y_min)\n+void _bin_indices_middle_linear(float *arows,\n+                                unsigned int *irows,\n+                                int nrows,\n+                                const float *y,\n+                                unsigned long ny,\n+                                float dy,\n+                                float y_min)\n {\n     int i;\n     int ii = 0;\n-    int iilast = ny - 1;\n+    int iilast = (int)ny - 1;\n     float sc = 1 / dy;\n-    int iy0 = (int)floor(sc * (y[ii]  - y_min));\n-    int iy1 = (int)floor(sc * (y[ii+1]  - y_min));\n+    int iy0 = (int)floor(sc * (y[ii] - y_min));\n+    int iy1 = (int)floor(sc * (y[ii + 1] - y_min));\n     float invgap = 1.0f / (iy1 - iy0);\n-    for (i = 0; i < nrows && i <= iy0; i++)\n-    {\n+    for (i = 0; i < nrows && i <= iy0; i++) {\n         irows[i] = 0;\n         arows[i] = 1.0;\n-        //std::cerr<<\"i=\"<<i<<\"  ii=\"<<0<<\" a=\"<< arows[i]<< std::endl;\n     }\n-    for (; i < nrows; i++)\n-    {\n-        while (i > iy1 && ii < iilast)\n-        {\n+    for (; i < nrows; i++) {\n+        while (i > iy1 && ii < iilast) {\n             ii++;\n             iy0 = iy1;\n-            iy1 = (int)floor(sc * (y[ii+1] - y_min));\n+            iy1 = (int)floor(sc * (y[ii + 1] - y_min));\n             invgap = 1.0f / (iy1 - iy0);\n         }\n-        if (i >= iy0 && i <= iy1)\n-        {\n+        if (i >= iy0 && i <= iy1) {\n             irows[i] = ii;\n             arows[i] = (iy1 - i) * invgap;\n-            //std::cerr<<\"i=\"<<i<<\"  ii=\"<<ii<<\" a=\"<< arows[i]<< std::endl;\n-        }\n-        else break;\n+        } else\n+            break;\n     }\n-    for (; i < nrows; i++)\n-    {\n+    for (; i < nrows; i++) {\n         irows[i] = iilast - 1;\n         arows[i] = 0.0;\n-        //std::cerr<<\"i=\"<<i<<\"  ii=\"<<iilast-1<<\" a=\"<< arows[i]<< std::endl;\n     }\n }\n \n-void _bin_indices(int *irows, int nrows, double *y, int ny,\n-                  double sc, double offs)\n+void _bin_indices(int *irows, int nrows, const double *y, unsigned long ny, double sc, double offs)\n {\n     int i;\n-    if (sc*(y[ny-1] - y[0]) > 0)\n-    {\n+    if (sc * (y[ny - 1] - y[0]) > 0) {\n         int ii = 0;\n-        int iilast = ny - 1;\n-        int iy0 = (int)floor(sc * (y[ii]  - offs));\n-        int iy1 = (int)floor(sc * (y[ii+1]  - offs));\n-        for (i = 0; i < nrows && i < iy0; i++)\n-        {\n+        int iilast = (int)ny - 1;\n+        int iy0 = (int)floor(sc * (y[ii] - offs));\n+        int iy1 = (int)floor(sc * (y[ii + 1] - offs));\n+        for (i = 0; i < nrows && i < iy0; i++) {\n             irows[i] = -1;\n         }\n-        for (; i < nrows; i++)\n-        {\n-            while (i > iy1 && ii < iilast)\n-            {\n+        for (; i < nrows; i++) {\n+            while (i > iy1 && ii < iilast) {\n                 ii++;\n                 iy0 = iy1;\n-                iy1 = (int)floor(sc * (y[ii+1] - offs));\n+                iy1 = (int)floor(sc * (y[ii + 1] - offs));\n             }\n-            if (i >= iy0 && i <= iy1) irows[i] = ii;\n-            else break;\n+            if (i >= iy0 && i <= iy1)\n+                irows[i] = ii;\n+            else\n+                break;\n         }\n-        for (; i < nrows; i++)\n-        {\n+        for (; i < nrows; i++) {\n             irows[i] = -1;\n         }\n-    }\n-    else\n-    {\n-        int iilast = ny - 1;\n+    } else {\n+        int iilast = (int)ny - 1;\n         int ii = iilast;\n-        int iy0 = (int)floor(sc * (y[ii]  - offs));\n-        int iy1 = (int)floor(sc * (y[ii-1]  - offs));\n-        for (i = 0; i < nrows && i < iy0; i++)\n-        {\n+        int iy0 = (int)floor(sc * (y[ii] - offs));\n+        int iy1 = (int)floor(sc * (y[ii - 1] - offs));\n+        for (i = 0; i < nrows && i < iy0; i++) {\n             irows[i] = -1;\n         }\n-        for (; i < nrows; i++)\n-        {\n-            while (i > iy1 && ii > 1)\n-            {\n+        for (; i < nrows; i++) {\n+            while (i > iy1 && ii > 1) {\n                 ii--;\n                 iy0 = iy1;\n-                iy1 = (int)floor(sc * (y[ii-1] - offs));\n+                iy1 = (int)floor(sc * (y[ii - 1] - offs));\n             }\n-            if (i >= iy0 && i <= iy1) irows[i] = ii - 1;\n-            else break;\n+            if (i >= iy0 && i <= iy1)\n+                irows[i] = ii - 1;\n+            else\n+                break;\n         }\n-        for (; i < nrows; i++)\n-        {\n+        for (; i < nrows; i++) {\n             irows[i] = -1;\n         }\n     }\n }\n \n-void _bin_indices_linear(float *arows, int *irows, int nrows, double *y, int ny,\n-                         double sc, double offs)\n+void _bin_indices_linear(\n+    float *arows, int *irows, int nrows, double *y, unsigned long ny, double sc, double offs)\n {\n     int i;\n-    if (sc*(y[ny-1] - y[0]) > 0)\n-    {\n+    if (sc * (y[ny - 1] - y[0]) > 0) {\n         int ii = 0;\n-        int iilast = ny - 1;\n-        int iy0 = (int)floor(sc * (y[ii]  - offs));\n-        int iy1 = (int)floor(sc * (y[ii+1]  - offs));\n+        int iilast = (int)ny - 1;\n+        int iy0 = (int)floor(sc * (y[ii] - offs));\n+        int iy1 = (int)floor(sc * (y[ii + 1] - offs));\n         float invgap = 1.0 / (iy1 - iy0);\n-        for (i = 0; i < nrows && i < iy0; i++)\n-        {\n+        for (i = 0; i < nrows && i < iy0; i++) {\n             irows[i] = -1;\n         }\n-        for (; i < nrows; i++)\n-        {\n-            while (i > iy1 && ii < iilast)\n-            {\n+        for (; i < nrows; i++) {\n+            while (i > iy1 && ii < iilast) {\n                 ii++;\n                 iy0 = iy1;\n-                iy1 = (int)floor(sc * (y[ii+1] - offs));\n+                iy1 = (int)floor(sc * (y[ii + 1] - offs));\n                 invgap = 1.0 / (iy1 - iy0);\n             }\n-            if (i >= iy0 && i <= iy1)\n-            {\n+            if (i >= iy0 && i <= iy1) {\n                 irows[i] = ii;\n                 arows[i] = (iy1 - i) * invgap;\n-            }\n-            else break;\n+            } else\n+                break;\n         }\n-        for (; i < nrows; i++)\n-        {\n+        for (; i < nrows; i++) {\n             irows[i] = -1;\n         }\n-    }\n-    else\n-    {\n-        int iilast = ny - 1;\n+    } else {\n+        int iilast = (int)ny - 1;\n         int ii = iilast;\n-        int iy0 = (int)floor(sc * (y[ii]  - offs));\n-        int iy1 = (int)floor(sc * (y[ii-1]  - offs));\n+        int iy0 = (int)floor(sc * (y[ii] - offs));\n+        int iy1 = (int)floor(sc * (y[ii - 1] - offs));\n         float invgap = 1.0 / (iy1 - iy0);\n-        for (i = 0; i < nrows && i < iy0; i++)\n-        {\n+        for (i = 0; i < nrows && i < iy0; i++) {\n             irows[i] = -1;\n         }\n-        for (; i < nrows; i++)\n-        {\n-            while (i > iy1 && ii > 1)\n-            {\n+        for (; i < nrows; i++) {\n+            while (i > iy1 && ii > 1) {\n                 ii--;\n                 iy0 = iy1;\n-                iy1 = (int)floor(sc * (y[ii-1] - offs));\n+                iy1 = (int)floor(sc * (y[ii - 1] - offs));\n                 invgap = 1.0 / (iy1 - iy0);\n             }\n-            if (i >= iy0 && i <= iy1)\n-            {\n+            if (i >= iy0 && i <= iy1) {\n                 irows[i] = ii - 1;\n                 arows[i] = (i - iy0) * invgap;\n-            }\n-            else break;\n+            } else\n+                break;\n         }\n-        for (; i < nrows; i++)\n-        {\n+        for (; i < nrows; i++) {\n             irows[i] = -1;\n         }\n     }\n }\n-\n-\n-\n-char __image_module_pcolor__doc__[] =\n-    \"pcolor(x, y, data, rows, cols, bounds)\\n\"\n-    \"\\n\"\n-    \"Generate a pseudo-color image from data on a non-uniform grid using\\n\"\n-    \"nearest neighbour or linear interpolation.\\n\"\n-    \"bounds = (x_min, x_max, y_min, y_max)\\n\"\n-    \"interpolation = NEAREST or BILINEAR \\n\"\n-    ;\n-\n-void _pcolor_cleanup(PyArrayObject* x, PyArrayObject* y,  PyArrayObject *d,\n-                     unsigned int * rowstarts , unsigned int*colstarts ,\n-                     float *acols , float *arows)\n-{\n-    Py_XDECREF(x);\n-    Py_XDECREF(y);\n-    Py_XDECREF(d);\n-    if (rowstarts)\n-    {\n-        PyMem_Free(rowstarts);\n-    }\n-    if (colstarts)\n-    {\n-        PyMem_Free(colstarts);\n-    }\n-    if (acols)\n-    {\n-        PyMem_Free(acols);\n-    }\n-    if (arows)\n-    {\n-        PyMem_Free(arows);\n-    }\n-    return;\n-}\n-\n-Py::Object\n-_image_module::pcolor(const Py::Tuple& args)\n-{\n-    _VERBOSE(\"_image_module::pcolor\");\n-\n-\n-    if (args.length() != 7)\n-    {\n-        throw Py::TypeError(\"Incorrect number of arguments (7 expected)\");\n-    }\n-\n-    Py::Object xp = args[0];\n-    Py::Object yp = args[1];\n-    Py::Object dp = args[2];\n-    unsigned int rows = (unsigned long)Py::Int(args[3]);\n-    unsigned int cols = (unsigned long)Py::Int(args[4]);\n-    Py::Tuple bounds = args[5];\n-    unsigned int interpolation = (unsigned long)Py::Int(args[6]);\n-\n-    if (rows >= 32768 || cols >= 32768)\n-    {\n-        throw Py::ValueError(\"rows and cols must both be less than 32768\");\n-    }\n-\n-    if (bounds.length() != 4)\n-    {\n-        throw Py::TypeError(\"Incorrect number of bounds (4 expected)\");\n-    }\n-\n-    float x_min = Py::Float(bounds[0]);\n-    float x_max = Py::Float(bounds[1]);\n-    float y_min = Py::Float(bounds[2]);\n-    float y_max = Py::Float(bounds[3]);\n-    float width = x_max - x_min;\n-    float height = y_max - y_min;\n-    float dx = width / ((float) cols);\n-    float dy = height / ((float) rows);\n-\n-    // Check we have something to output to\n-    if (rows == 0 || cols == 0)\n-    {\n-        throw Py::ValueError(\"Cannot scale to zero size\");\n-    }\n-\n-    PyArrayObject *x = NULL;\n-    PyArrayObject *y = NULL;\n-    PyArrayObject *d = NULL;\n-    unsigned int *rowstarts = NULL;\n-    unsigned int *colstarts = NULL;\n-    float *acols = NULL;\n-    float *arows = NULL;\n-\n-    // Get numpy arrays\n-    x = (PyArrayObject *) PyArray_ContiguousFromObject(xp.ptr(), NPY_FLOAT, 1, 1);\n-    if (x == NULL)\n-    {\n-        _pcolor_cleanup(x, y, d, rowstarts, colstarts, acols, arows);\n-        throw Py::ValueError(\"x is of incorrect type (wanted 1D float)\");\n-    }\n-    y = (PyArrayObject *) PyArray_ContiguousFromObject(yp.ptr(), NPY_FLOAT, 1, 1);\n-    if (y == NULL)\n-    {\n-        _pcolor_cleanup(x, y, d, rowstarts, colstarts, acols, arows);\n-        throw Py::ValueError(\"y is of incorrect type (wanted 1D float)\");\n-    }\n-    d = (PyArrayObject *) PyArray_ContiguousFromObject(dp.ptr(), NPY_UBYTE, 3, 3);\n-    if (d == NULL)\n-    {\n-        _pcolor_cleanup(x, y, d, rowstarts, colstarts, acols, arows);\n-        throw Py::ValueError(\"data is of incorrect type (wanted 3D UInt8)\");\n-    }\n-    if (PyArray_DIM(d, 2) != 4)\n-    {\n-        _pcolor_cleanup(x, y, d, rowstarts, colstarts, acols, arows);\n-        throw Py::ValueError(\"data must be in RGBA format\");\n-    }\n-\n-    // Check dimensions match\n-    int nx = PyArray_DIM(x, 0);\n-    int ny = PyArray_DIM(y, 0);\n-    if (nx != PyArray_DIM(d, 1) || ny != PyArray_DIM(d, 0))\n-    {\n-        _pcolor_cleanup(x, y, d, rowstarts, colstarts, acols, arows);\n-        throw Py::ValueError(\"data and axis dimensions do not match\");\n-    }\n-\n-    // Allocate memory for pointer arrays\n-    rowstarts = reinterpret_cast<unsigned int*>(PyMem_Malloc(sizeof(unsigned int) * rows));\n-    if (rowstarts == NULL)\n-    {\n-        _pcolor_cleanup(x, y, d, rowstarts, colstarts, acols, arows);\n-        throw Py::MemoryError(\"Cannot allocate memory for lookup table\");\n-    }\n-    colstarts = reinterpret_cast<unsigned int*>(PyMem_Malloc(sizeof(unsigned int) * cols));\n-    if (colstarts == NULL)\n-    {\n-        _pcolor_cleanup(x, y, d, rowstarts, colstarts, acols, arows);\n-        throw Py::MemoryError(\"Cannot allocate memory for lookup table\");\n-    }\n-\n-    // Create output\n-    Image* imo = new Image;\n-    imo->rowsIn = rows;\n-    imo->colsIn = cols;\n-    imo->rowsOut = rows;\n-    imo->colsOut = cols;\n-    size_t NUMBYTES(rows * cols * 4);\n-    agg::int8u *buffer = new agg::int8u[NUMBYTES];\n-    if (buffer == NULL)\n-    {\n-        _pcolor_cleanup(x, y, d, rowstarts, colstarts, acols, arows);\n-        throw Py::MemoryError(\"Could not allocate memory for image\");\n-    }\n-\n-\n-    // Calculate the pointer arrays to map input x to output x\n-    unsigned int i, j;\n-    unsigned int * colstart = colstarts;\n-    unsigned int * rowstart = rowstarts;\n-    float *xs1 = reinterpret_cast<float*>(PyArray_DATA(x));\n-    float *ys1 = reinterpret_cast<float*>(PyArray_DATA(y));\n-\n-\n-    // Copy data to output buffer\n-    unsigned char *start;\n-    unsigned char *inposition;\n-    size_t inrowsize(nx*4);\n-    size_t rowsize(cols*4);\n-    agg::int8u * position = buffer;\n-    agg::int8u * oldposition = NULL;\n-    start = reinterpret_cast<unsigned char*>(PyArray_DATA(d));\n-    int s0 = PyArray_STRIDE(d, 0);\n-    int s1 = PyArray_STRIDE(d, 1);\n-\n-    if (interpolation == Image::NEAREST)\n-    {\n-        _bin_indices_middle(colstart, cols, xs1,  nx, dx, x_min);\n-        _bin_indices_middle(rowstart, rows, ys1,  ny, dy, y_min);\n-        for (i = 0;i < rows;i++, rowstart++)\n-        {\n-            if (i > 0 && *rowstart == 0)\n-            {\n-                memcpy(position, oldposition, rowsize*sizeof(agg::int8u));\n-                oldposition = position;\n-                position += rowsize;\n-            }\n-            else\n-            {\n-                oldposition = position;\n-                start += *rowstart * inrowsize;\n-                inposition = start;\n-                for (j = 0, colstart = colstarts;j < cols;j++, position += 4, colstart++)\n-                {\n-                    inposition += *colstart * 4;\n-                    memcpy(position, inposition, 4*sizeof(agg::int8u));\n-                }\n-            }\n-        }\n-    }\n-    else if (interpolation == Image::BILINEAR)\n-    {\n-        arows = reinterpret_cast<float *>(PyMem_Malloc(sizeof(float) * rows));\n-        if (arows == NULL)\n-        {\n-            _pcolor_cleanup(x, y, d, rowstarts, colstarts, acols, arows);\n-            throw Py::MemoryError(\"Cannot allocate memory for lookup table\");\n-        }\n-        acols = reinterpret_cast<float*>(PyMem_Malloc(sizeof(float) * cols));\n-        if (acols == NULL)\n-        {\n-            _pcolor_cleanup(x, y, d, rowstarts, colstarts, acols, arows);\n-            throw Py::MemoryError(\"Cannot allocate memory for lookup table\");\n-        }\n-\n-        _bin_indices_middle_linear(acols, colstart, cols, xs1,  nx, dx, x_min);\n-        _bin_indices_middle_linear(arows, rowstart, rows, ys1,  ny, dy, y_min);\n-        double a00, a01, a10, a11, alpha, beta;\n-\n-\n-        agg::int8u * start00;\n-        agg::int8u * start01;\n-        agg::int8u * start10;\n-        agg::int8u * start11;\n-        // Copy data to output buffer\n-        for (i = 0; i < rows; i++)\n-        {\n-            for (j = 0; j < cols; j++)\n-            {\n-                alpha = arows[i];\n-                beta = acols[j];\n-\n-                a00 = alpha * beta;\n-                a01 = alpha * (1.0 - beta);\n-                a10 = (1.0 - alpha) * beta;\n-                a11 = 1.0 - a00 - a01 - a10;\n-\n-                start00 = (agg::int8u *)(start + s0 * rowstart[i] + s1 * colstart[j]);\n-                start01 = start00 + s1;\n-                start10 = start00 + s0;\n-                start11 = start10 + s1;\n-                position[0] = (agg::int8u)(start00[0] * a00 + start01[0] * a01 + start10[0] * a10 + start11[0] * a11);\n-                position[1] = (agg::int8u)(start00[1] * a00 + start01[1] * a01 + start10[1] * a10 + start11[1] * a11);\n-                position[2] = (agg::int8u)(start00[2] * a00 + start01[2] * a01 + start10[2] * a10 + start11[2] * a11);\n-                position[3] = (agg::int8u)(start00[3] * a00 + start01[3] * a01 + start10[3] * a10 + start11[3] * a11);\n-                position += 4;\n-            }\n-        }\n-\n-    }\n-\n-    // Attach output buffer to output buffer\n-    imo->rbufOut = new agg::rendering_buffer;\n-    imo->bufferOut = buffer;\n-    imo->rbufOut->attach(imo->bufferOut, imo->colsOut, imo->rowsOut, imo->colsOut * imo->BPP);\n-\n-    _pcolor_cleanup(x, y, d, rowstarts, colstarts, acols, arows);\n-\n-    return Py::asObject(imo);\n-\n-}\n-\n-void _pcolor2_cleanup(PyArrayObject* x, PyArrayObject* y, PyArrayObject *d,\n-                      PyArrayObject* bg, int *irows, int*jcols)\n-{\n-    Py_XDECREF(x);\n-    Py_XDECREF(y);\n-    Py_XDECREF(d);\n-    Py_XDECREF(bg);\n-    if (irows)\n-    {\n-        PyMem_Free(irows);\n-    }\n-    if (jcols)\n-    {\n-        PyMem_Free(jcols);\n-    }\n-}\n-\n-\n-char __image_module_pcolor2__doc__[] =\n-    \"pcolor2(x, y, data, rows, cols, bounds, bg)\\n\"\n-    \"\\n\"\n-    \"Generate a pseudo-color image from data on a non-uniform grid\\n\"\n-    \"specified by its cell boundaries.\\n\"\n-    \"bounds = (x_left, x_right, y_bot, y_top)\\n\"\n-    \"bg = ndarray of 4 uint8 representing background rgba\\n\"\n-    ;\n-Py::Object\n-_image_module::pcolor2(const Py::Tuple& args)\n-{\n-    _VERBOSE(\"_image_module::pcolor2\");\n-\n-    if (args.length() != 7)\n-    {\n-        throw Py::TypeError(\"Incorrect number of arguments (6 expected)\");\n-    }\n-\n-    Py::Object xp = args[0];\n-    Py::Object yp = args[1];\n-    Py::Object dp = args[2];\n-    int rows = Py::Int(args[3]);\n-    int cols = Py::Int(args[4]);\n-    Py::Tuple bounds = args[5];\n-    Py::Object bgp = args[6];\n-\n-    if (rows >= 32768 || cols >= 32768)\n-    {\n-        throw Py::ValueError(\"rows and cols must both be less than 32768\");\n-    }\n-\n-    if (bounds.length() != 4)\n-    {\n-        throw Py::TypeError(\"Incorrect number of bounds (4 expected)\");\n-    }\n-\n-    double x_left = Py::Float(bounds[0]);\n-    double x_right = Py::Float(bounds[1]);\n-    double y_bot = Py::Float(bounds[2]);\n-    double y_top = Py::Float(bounds[3]);\n-\n-    // Check we have something to output to\n-    if (rows == 0 || cols == 0)\n-    {\n-        throw Py::ValueError(\"rows or cols is zero; there are no pixels\");\n-    }\n-\n-    PyArrayObject* x = NULL;\n-    PyArrayObject* y = NULL;\n-    PyArrayObject* d = NULL;\n-    PyArrayObject* bg = NULL;\n-    int* irows = NULL;\n-    int* jcols = NULL;\n-\n-    // Get numpy arrays\n-    x = (PyArrayObject *) PyArray_ContiguousFromObject(xp.ptr(), NPY_DOUBLE, 1, 1);\n-    if (x == NULL)\n-    {\n-        _pcolor2_cleanup(x, y, d, bg, irows, jcols);\n-        throw Py::ValueError(\"x is of incorrect type (wanted 1D double)\");\n-    }\n-    y = (PyArrayObject *) PyArray_ContiguousFromObject(yp.ptr(), NPY_DOUBLE, 1, 1);\n-    if (y == NULL)\n-    {\n-        _pcolor2_cleanup(x, y, d, bg, irows, jcols);\n-        throw Py::ValueError(\"y is of incorrect type (wanted 1D double)\");\n-    }\n-    d = (PyArrayObject *) PyArray_ContiguousFromObject(dp.ptr(), NPY_UBYTE, 3, 3);\n-    if (d == NULL)\n-    {\n-        _pcolor2_cleanup(x, y, d, bg, irows, jcols);\n-        throw Py::ValueError(\"data is of incorrect type (wanted 3D uint8)\");\n-    }\n-    if (PyArray_DIM(d, 2) != 4)\n-    {\n-        _pcolor2_cleanup(x, y, d, bg, irows, jcols);\n-        throw Py::ValueError(\"data must be in RGBA format\");\n-    }\n-\n-    // Check dimensions match\n-    int nx = PyArray_DIM(x, 0);\n-    int ny = PyArray_DIM(y, 0);\n-    if (nx != PyArray_DIM(d, 1) + 1 || ny != PyArray_DIM(d, 0) + 1)\n-    {\n-        _pcolor2_cleanup(x, y, d, bg, irows, jcols);\n-        throw Py::ValueError(\"data and axis bin boundary dimensions are incompatible\");\n-    }\n-\n-    bg = (PyArrayObject *) PyArray_ContiguousFromObject(bgp.ptr(), NPY_UBYTE, 1, 1);\n-    if (bg == NULL)\n-    {\n-        _pcolor2_cleanup(x, y, d, bg, irows, jcols);\n-        throw Py::ValueError(\"bg is of incorrect type (wanted 1D uint8)\");\n-    }\n-    if (PyArray_DIM(bg, 0) != 4)\n-    {\n-        _pcolor2_cleanup(x, y, d, bg, irows, jcols);\n-        throw Py::ValueError(\"bg must be in RGBA format\");\n-    }\n-\n-    // Allocate memory for pointer arrays\n-    irows = reinterpret_cast<int*>(PyMem_Malloc(sizeof(int) * rows));\n-    if (irows == NULL)\n-    {\n-        _pcolor2_cleanup(x, y, d, bg, irows, jcols);\n-        throw Py::MemoryError(\"Cannot allocate memory for lookup table\");\n-    }\n-    jcols = reinterpret_cast<int*>(PyMem_Malloc(sizeof(int) * cols));\n-    if (jcols == NULL)\n-    {\n-        _pcolor2_cleanup(x, y, d, bg, irows, jcols);\n-        throw Py::MemoryError(\"Cannot allocate memory for lookup table\");\n-    }\n-\n-    // Create output\n-    Image* imo = new Image;\n-    imo->rowsIn = rows;\n-    imo->rowsOut = rows;\n-    imo->colsIn = cols;\n-    imo->colsOut = cols;\n-    size_t NUMBYTES(rows * cols * 4);\n-    agg::int8u *buffer = new agg::int8u[NUMBYTES];\n-    if (buffer == NULL)\n-    {\n-        _pcolor2_cleanup(x, y, d, bg, irows, jcols);\n-        throw Py::MemoryError(\"Could not allocate memory for image\");\n-    }\n-\n-    // Calculate the pointer arrays to map input x to output x\n-    int i, j;\n-    double *x0 = reinterpret_cast<double*>(PyArray_DATA(x));\n-    double *y0 = reinterpret_cast<double*>(PyArray_DATA(y));\n-    double sx = cols / (x_right - x_left);\n-    double sy = rows / (y_top - y_bot);\n-    _bin_indices(jcols, cols, x0, nx, sx, x_left);\n-    _bin_indices(irows, rows, y0, ny, sy, y_bot);\n-\n-    // Copy data to output buffer\n-    agg::int8u * position = buffer;\n-    unsigned char *start = reinterpret_cast<unsigned char*>(PyArray_DATA(d));\n-    unsigned char *bgptr = reinterpret_cast<unsigned char*>(PyArray_DATA(bg));\n-    int s0 = PyArray_STRIDE(d, 0);\n-    int s1 = PyArray_STRIDE(d, 1);\n-\n-    for (i = 0; i < rows; i++)\n-    {\n-        for (j = 0; j < cols; j++)\n-        {\n-            if (irows[i] == -1 || jcols[j] == -1)\n-            {\n-                memcpy(position, bgptr, 4*sizeof(agg::int8u));\n-            }\n-            else\n-            {\n-                memcpy(position, (start + s0*irows[i] + s1*jcols[j]),\n-                       4*sizeof(agg::int8u));\n-            }\n-            position += 4;\n-        }\n-    }\n-\n-    // Attach output buffer to output buffer\n-    imo->rbufOut = new agg::rendering_buffer;\n-    imo->bufferOut = buffer;\n-    imo->rbufOut->attach(imo->bufferOut, imo->colsOut, imo->rowsOut, imo->colsOut * imo->BPP);\n-\n-    _pcolor2_cleanup(x, y, d, bg, irows, jcols);\n-\n-    return Py::asObject(imo);\n-}\n-\n-#if PY3K\n-PyMODINIT_FUNC\n-PyInit__image(void)\n-#else\n-PyMODINIT_FUNC\n-init_image(void)\n-#endif\n-{\n-    _VERBOSE(\"init_image\");\n-\n-    static _image_module* _image = new _image_module;\n-\n-    import_array();\n-    Py::Dict d = _image->moduleDictionary();\n-\n-    d[\"NEAREST\"] = Py::Int(Image::NEAREST);\n-    d[\"BILINEAR\"] = Py::Int(Image::BILINEAR);\n-    d[\"BICUBIC\"] = Py::Int(Image::BICUBIC);\n-    d[\"SPLINE16\"] = Py::Int(Image::SPLINE16);\n-    d[\"SPLINE36\"] = Py::Int(Image::SPLINE36);\n-    d[\"HANNING\"] = Py::Int(Image::HANNING);\n-    d[\"HAMMING\"] = Py::Int(Image::HAMMING);\n-    d[\"HERMITE\"] = Py::Int(Image::HERMITE);\n-    d[\"KAISER\"]   = Py::Int(Image::KAISER);\n-    d[\"QUADRIC\"]   = Py::Int(Image::QUADRIC);\n-    d[\"CATROM\"]  = Py::Int(Image::CATROM);\n-    d[\"GAUSSIAN\"]  = Py::Int(Image::GAUSSIAN);\n-    d[\"BESSEL\"]  = Py::Int(Image::BESSEL);\n-    d[\"MITCHELL\"]  = Py::Int(Image::MITCHELL);\n-    d[\"SINC\"]  = Py::Int(Image::SINC);\n-    d[\"LANCZOS\"]  = Py::Int(Image::LANCZOS);\n-    d[\"BLACKMAN\"] = Py::Int(Image::BLACKMAN);\n-\n-    d[\"ASPECT_FREE\"] = Py::Int(Image::ASPECT_FREE);\n-    d[\"ASPECT_PRESERVE\"] = Py::Int(Image::ASPECT_PRESERVE);\n-\n-#if PY3K\n-    return _image->module().ptr();\n-#endif\n-}"}
{"patches_id": 2, "files_id": 36, "language": "h", "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_image.h", "raw_code": "/* -*- mode: c++; c-basic-offset: 4 -*- */\n\n/* image.h\n *\n */\n\n#ifndef _IMAGE_H\n#define _IMAGE_H\n\n#include <vector>\n\n#include \"agg_trans_affine.h\"\n#include \"agg_rendering_buffer.h\"\n#include \"agg_color_rgba.h\"\n\nclass Image\n{\n  public:\n    Image();\n    Image(unsigned numrows, unsigned numcols, bool isoutput);\n    virtual ~Image();\n\n    static void init_type(void);\n\n    void apply_rotation(double r);\n    void apply_scaling(double sx, double sy);\n    void apply_translation(double tx, double ty);\n    void as_rgba_str(agg::int8u *outbuf);\n    void color_conv(int format, agg::int8u *outbuf);\n    void reset_matrix();\n    void clear();\n    void resize(int numcols, int numrows, int norm, double radius);\n    void blend_image(Image &im, unsigned ox, unsigned oy, bool apply_alpha, float alpha);\n    void set_bg(double r, double g, double b, double a);\n\n    enum {\n        NEAREST,\n        BILINEAR,\n        BICUBIC,\n        SPLINE16,\n        SPLINE36,\n        HANNING,\n        HAMMING,\n        HERMITE,\n        KAISER,\n        QUADRIC,\n        CATROM,\n        GAUSSIAN,\n        BESSEL,\n        MITCHELL,\n        SINC,\n        LANCZOS,\n        BLACKMAN\n    };\n\n    // enum { BICUBIC=0, BILINEAR, BLACKMAN100, BLACKMAN256, BLACKMAN64,\n    //   NEAREST, SINC144, SINC256, SINC64, SPLINE16, SPLINE36};\n    enum {\n        ASPECT_PRESERVE = 0,\n        ASPECT_FREE\n    };\n\n    agg::int8u *bufferIn;\n    agg::rendering_buffer *rbufIn;\n    unsigned colsIn, rowsIn;\n\n    agg::int8u *bufferOut;\n    agg::rendering_buffer *rbufOut;\n    unsigned colsOut, rowsOut;\n    unsigned BPP;\n\n    unsigned interpolation, aspect;\n    agg::rgba bg;\n    bool resample;\n    agg::trans_affine srcMatrix, imageMatrix;\n\n  private:\n    // prevent copying\n    Image(const Image &);\n    Image &operator=(const Image &);\n};\n\ntemplate <class ArrayType>\nImage *from_grey_array(ArrayType &array, bool isoutput)\n{\n    Image *im = new Image((unsigned)array.dim(0), (unsigned)array.dim(1), isoutput);\n\n    agg::int8u *buffer;\n    if (isoutput) {\n        buffer = im->bufferOut;\n    } else {\n        buffer = im->bufferIn;\n    }\n\n    agg::int8u gray;\n    for (size_t rownum = 0; rownum < (size_t)array.dim(0); rownum++) {\n        for (size_t colnum = 0; colnum < (size_t)array.dim(1); colnum++) {\n            double val = array(rownum, colnum);\n\n            gray = int(255 * val);\n            *buffer++ = gray; // red\n            *buffer++ = gray; // green\n            *buffer++ = gray; // blue\n            *buffer++ = 255;  // alpha\n        }\n    }\n\n    return im;\n}\n\ntemplate <class ArrayType>\nImage *from_color_array(ArrayType &array, bool isoutput)\n{\n    Image *im = new Image((unsigned)array.dim(0), (unsigned)array.dim(1), isoutput);\n\n    agg::int8u *buffer;\n    if (isoutput) {\n        buffer = im->bufferOut;\n    } else {\n        buffer = im->bufferIn;\n    }\n\n    int rgba = array.dim(2) >= 4;\n    double r, g, b;\n    double alpha = 1.0;\n\n    for (size_t rownum = 0; rownum < (size_t)array.dim(0); rownum++) {\n        for (size_t colnum = 0; colnum < (size_t)array.dim(1); colnum++) {\n            typename ArrayType::sub_t::sub_t color = array[rownum][colnum];\n\n            r = color(0);\n            g = color(1);\n            b = color(2);\n\n            if (rgba) {\n                alpha = color(3);\n            }\n\n            *buffer++ = int(255 * r);     // red\n            *buffer++ = int(255 * g);     // green\n            *buffer++ = int(255 * b);     // blue\n            *buffer++ = int(255 * alpha); // alpha\n        }\n    }\n\n    return im;\n}\n\ntemplate <class ArrayType>\nImage *frombyte(ArrayType &array, bool isoutput)\n{\n    Image *im = new Image((unsigned)array.dim(0), (unsigned)array.dim(1), isoutput);\n\n    agg::int8u *buffer;\n    if (isoutput) {\n        buffer = im->bufferOut;\n    } else {\n        buffer = im->bufferIn;\n    }\n\n    int rgba = array.dim(2) >= 4;\n    agg::int8u r, g, b;\n    agg::int8u alpha = 255;\n\n    for (size_t rownum = 0; rownum < (size_t)array.dim(0); rownum++) {\n        for (size_t colnum = 0; colnum < (size_t)array.dim(1); colnum++) {\n            typename ArrayType::sub_t::sub_t color = array[rownum][colnum];\n            r = color(0);\n            g = color(1);\n            b = color(2);\n\n            if (rgba) {\n                alpha = color(3);\n            }\n\n            *buffer++ = r;     // red\n            *buffer++ = g;     // green\n            *buffer++ = b;     // blue\n            *buffer++ = alpha; // alpha\n        }\n    }\n\n    return im;\n}\n\n// utilities for irregular grids\nvoid _bin_indices_middle(\n    unsigned int *irows, int nrows, const float *ys1, unsigned long ny, float dy, float y_min);\nvoid _bin_indices_middle_linear(float *arows,\n                                unsigned int *irows,\n                                int nrows,\n                                const float *y,\n                                unsigned long ny,\n                                float dy,\n                                float y_min);\nvoid _bin_indices(int *irows, int nrows, const double *y, unsigned long ny, double sc, double offs);\nvoid _bin_indices_linear(\n    float *arows, int *irows, int nrows, double *y, unsigned long ny, double sc, double offs);\n\ntemplate <class CoordinateArray, class ColorArray>\nImage *pcolor(CoordinateArray &x,\n              CoordinateArray &y,\n              ColorArray &d,\n              unsigned int rows,\n              unsigned int cols,\n              float bounds[4],\n              int interpolation)\n{\n    if (rows >= 32768 || cols >= 32768) {\n        throw \"rows and cols must both be less than 32768\";\n    }\n\n    float x_min = bounds[0];\n    float x_max = bounds[1];\n    float y_min = bounds[2];\n    float y_max = bounds[3];\n    float width = x_max - x_min;\n    float height = y_max - y_min;\n    float dx = width / ((float)cols);\n    float dy = height / ((float)rows);\n\n    // Check we have something to output to\n    if (rows == 0 || cols == 0) {\n        throw \"Cannot scale to zero size\";\n    }\n\n    if (d.dim(2) != 4) {\n        throw \"data must be in RGBA format\";\n    }\n\n    // Check dimensions match\n    unsigned long nx = x.dim(0);\n    unsigned long ny = y.dim(0);\n    if (nx != d.dim(1) || ny != d.dim(0)) {\n        throw \"data and axis dimensions do not match\";\n    }\n\n    // Allocate memory for pointer arrays\n    std::vector<unsigned int> rowstarts(rows);\n    std::vector<unsigned int> colstarts(cols);\n\n    // Create output\n    Image *imo = new Image(rows, cols, true);\n\n    // Calculate the pointer arrays to map input x to output x\n    unsigned int i, j;\n    unsigned int *colstart = &colstarts[0];\n    unsigned int *rowstart = &rowstarts[0];\n    const float *xs1 = x.data();\n    const float *ys1 = y.data();\n\n    // Copy data to output buffer\n    const unsigned char *start;\n    const unsigned char *inposition;\n    size_t inrowsize = nx * 4;\n    size_t rowsize = cols * 4;\n    agg::int8u *position = imo->bufferOut;\n    agg::int8u *oldposition = NULL;\n    start = d.data();\n\n    if (interpolation == Image::NEAREST) {\n        _bin_indices_middle(colstart, cols, xs1, nx, dx, x_min);\n        _bin_indices_middle(rowstart, rows, ys1, ny, dy, y_min);\n        for (i = 0; i < rows; i++, rowstart++) {\n            if (i > 0 && *rowstart == 0) {\n                memcpy(position, oldposition, rowsize * sizeof(agg::int8u));\n                oldposition = position;\n                position += rowsize;\n            } else {\n                oldposition = position;\n                start += *rowstart * inrowsize;\n                inposition = start;\n                for (j = 0, colstart = &colstarts[0]; j < cols; j++, position += 4, colstart++) {\n                    inposition += *colstart * 4;\n                    memcpy(position, inposition, 4 * sizeof(agg::int8u));\n                }\n            }\n        }\n    } else if (interpolation == Image::BILINEAR) {\n        std::vector<float> acols(cols);\n        std::vector<float> arows(rows);\n\n        _bin_indices_middle_linear(&acols[0], colstart, cols, xs1, nx, dx, x_min);\n        _bin_indices_middle_linear(&arows[0], rowstart, rows, ys1, ny, dy, y_min);\n        double a00, a01, a10, a11, alpha, beta;\n\n        // Copy data to output buffer\n        for (i = 0; i < rows; i++) {\n            for (j = 0; j < cols; j++) {\n                alpha = arows[i];\n                beta = acols[j];\n\n                a00 = alpha * beta;\n                a01 = alpha * (1.0 - beta);\n                a10 = (1.0 - alpha) * beta;\n                a11 = 1.0 - a00 - a01 - a10;\n\n                typename ColorArray::sub_t::sub_t start00 = d[rowstart[i]][colstart[j]];\n                typename ColorArray::sub_t::sub_t start01 = d[rowstart[i]][colstart[j] + 1];\n                typename ColorArray::sub_t::sub_t start10 = d[rowstart[i] + 1][colstart[j]];\n                typename ColorArray::sub_t::sub_t start11 = d[rowstart[i] + 1][colstart[j] + 1];\n                for (size_t k = 0; k < 4; ++k) {\n                    position[k] =\n                        start00(k) * a00 + start01(k) * a01 + start10(k) * a10 + start11(k) * a11;\n                }\n                position += 4;\n            }\n        }\n    }\n\n    return imo;\n}\n\ntemplate <class CoordinateArray, class ColorArray, class Color>\nImage *pcolor2(CoordinateArray &x,\n               CoordinateArray &y,\n               ColorArray &d,\n               unsigned int rows,\n               unsigned int cols,\n               float bounds[4],\n               Color &bg)\n{\n    double x_left = bounds[0];\n    double x_right = bounds[1];\n    double y_bot = bounds[2];\n    double y_top = bounds[3];\n\n    // Check we have something to output to\n    if (rows == 0 || cols == 0) {\n        throw \"rows or cols is zero; there are no pixels\";\n    }\n\n    if (d.dim(2) != 4) {\n        throw \"data must be in RGBA format\";\n    }\n\n    // Check dimensions match\n    unsigned long nx = x.dim(0);\n    unsigned long ny = y.dim(0);\n    if (nx != d.dim(1) + 1 || ny != d.dim(0) + 1) {\n        throw \"data and axis bin boundary dimensions are incompatible\";\n    }\n\n    if (bg.dim(0) != 4) {\n        throw \"bg must be in RGBA format\";\n    }\n\n    std::vector<int> irows(rows);\n    std::vector<int> jcols(cols);\n\n    // Create output\n    Image *imo = new Image(rows, cols, true);\n\n    // Calculate the pointer arrays to map input x to output x\n    size_t i, j;\n    const double *x0 = x.data();\n    const double *y0 = y.data();\n    double sx = cols / (x_right - x_left);\n    double sy = rows / (y_top - y_bot);\n    _bin_indices(&jcols[0], cols, x0, nx, sx, x_left);\n    _bin_indices(&irows[0], rows, y0, ny, sy, y_bot);\n\n    // Copy data to output buffer\n    agg::int8u *position = imo->bufferOut;\n\n    for (i = 0; i < rows; i++) {\n        for (j = 0; j < cols; j++) {\n            if (irows[i] == -1 || jcols[j] == -1) {\n                memcpy(position, (const agg::int8u *)bg.data(), 4 * sizeof(agg::int8u));\n            } else {\n                for (size_t k = 0; k < 4; ++k) {\n                    position[k] = d(irows[i], jcols[j], k);\n                }\n            }\n            position += 4;\n        }\n    }\n\n    return imo;\n}\n\n#endif\n", "patch": "@@ -6,182 +6,377 @@\n \n #ifndef _IMAGE_H\n #define _IMAGE_H\n-#include <utility>\n-#include \"Python.h\"\n+\n+#include <vector>\n \n #include \"agg_trans_affine.h\"\n #include \"agg_rendering_buffer.h\"\n #include \"agg_color_rgba.h\"\n-#include \"CXX/Extensions.hxx\"\n-\n-\n \n-class Image : public Py::PythonExtension<Image>\n+class Image\n {\n-public:\n+  public:\n     Image();\n+    Image(unsigned numrows, unsigned numcols, bool isoutput);\n     virtual ~Image();\n \n     static void init_type(void);\n-    int setattr(const char*, const Py::Object &);\n-    Py::Object getattr(const char * name);\n-\n-    Py::Object apply_rotation(const Py::Tuple& args);\n-    Py::Object apply_scaling(const Py::Tuple& args);\n-    Py::Object apply_translation(const Py::Tuple& args);\n-    Py::Object as_rgba_str(const Py::Tuple& args, const Py::Dict& kwargs);\n-    Py::Object color_conv(const Py::Tuple& args);\n-    Py::Object buffer_rgba(const Py::Tuple& args);\n-    Py::Object reset_matrix(const Py::Tuple& args);\n-    Py::Object get_matrix(const Py::Tuple& args);\n-    Py::Object resize(const Py::Tuple& args, const Py::Dict& kwargs);\n-    Py::Object get_aspect(const Py::Tuple& args);\n-    Py::Object get_size(const Py::Tuple& args);\n-    Py::Object get_size_out(const Py::Tuple& args);\n-    Py::Object get_interpolation(const Py::Tuple& args);\n-    Py::Object set_interpolation(const Py::Tuple& args);\n-    Py::Object set_aspect(const Py::Tuple& args);\n-    Py::Object set_bg(const Py::Tuple& args);\n-    inline Py::Object flipud_out(const Py::Tuple& args)\n-    {\n-        args.verify_length(0);\n-        if (colsOut <= 0 || rowsOut <= 0)\n-        {\n-            throw Py::RuntimeError(\n-            \"Width and height must have positive values\");\n-        }\n \n-        int stride = rbufOut->stride();\n-        //std::cout << \"flip before: \" << rbufOut->stride() << std::endl;\n-        rbufOut->attach(bufferOut, colsOut, rowsOut, -stride);\n-        //std::cout << \"flip after: \" << rbufOut->stride() << std::endl;\n-        return Py::Object();\n-    }\n-\n-    Py::Object flipud_in(const Py::Tuple& args);\n-    Py::Object set_resample(const Py::Tuple& args);\n-    Py::Object get_resample(const Py::Tuple& args);\n-\n-\n-    std::pair<agg::int8u*, bool> _get_output_buffer();\n-    enum {NEAREST,\n-          BILINEAR,\n-          BICUBIC,\n-          SPLINE16,\n-          SPLINE36,\n-          HANNING,\n-          HAMMING,\n-          HERMITE,\n-          KAISER,\n-          QUADRIC,\n-          CATROM,\n-          GAUSSIAN,\n-          BESSEL,\n-          MITCHELL,\n-          SINC,\n-          LANCZOS,\n-          BLACKMAN\n-         };\n-\n-    //enum { BICUBIC=0, BILINEAR, BLACKMAN100, BLACKMAN256, BLACKMAN64,\n+    void apply_rotation(double r);\n+    void apply_scaling(double sx, double sy);\n+    void apply_translation(double tx, double ty);\n+    void as_rgba_str(agg::int8u *outbuf);\n+    void color_conv(int format, agg::int8u *outbuf);\n+    void reset_matrix();\n+    void clear();\n+    void resize(int numcols, int numrows, int norm, double radius);\n+    void blend_image(Image &im, unsigned ox, unsigned oy, bool apply_alpha, float alpha);\n+    void set_bg(double r, double g, double b, double a);\n+\n+    enum {\n+        NEAREST,\n+        BILINEAR,\n+        BICUBIC,\n+        SPLINE16,\n+        SPLINE36,\n+        HANNING,\n+        HAMMING,\n+        HERMITE,\n+        KAISER,\n+        QUADRIC,\n+        CATROM,\n+        GAUSSIAN,\n+        BESSEL,\n+        MITCHELL,\n+        SINC,\n+        LANCZOS,\n+        BLACKMAN\n+    };\n+\n+    // enum { BICUBIC=0, BILINEAR, BLACKMAN100, BLACKMAN256, BLACKMAN64,\n     //   NEAREST, SINC144, SINC256, SINC64, SPLINE16, SPLINE36};\n-    enum { ASPECT_PRESERVE = 0, ASPECT_FREE};\n+    enum {\n+        ASPECT_PRESERVE = 0,\n+        ASPECT_FREE\n+    };\n \n     agg::int8u *bufferIn;\n     agg::rendering_buffer *rbufIn;\n-    size_t colsIn, rowsIn;\n+    unsigned colsIn, rowsIn;\n \n     agg::int8u *bufferOut;\n     agg::rendering_buffer *rbufOut;\n-    size_t colsOut, rowsOut;\n+    unsigned colsOut, rowsOut;\n     unsigned BPP;\n \n     unsigned interpolation, aspect;\n     agg::rgba bg;\n     bool resample;\n-private:\n-    Py::Dict __dict__;\n     agg::trans_affine srcMatrix, imageMatrix;\n \n-    static char apply_rotation__doc__[];\n-    static char apply_scaling__doc__[];\n-    static char apply_translation__doc__[];\n-    static char as_rgba_str__doc__[];\n-    static char color_conv__doc__[];\n-    static char buffer_rgba__doc__[];\n-    static char reset_matrix__doc__[];\n-    static char get_matrix__doc__[];\n-    static char resize__doc__[];\n-    static char get_aspect__doc__[];\n-    static char get_size__doc__[];\n-    static char get_size_out__doc__[];\n-    static char get_interpolation__doc__[];\n-    static char set_interpolation__doc__[];\n-    static char set_aspect__doc__[];\n-    static char set_bg__doc__[];\n-    static char flipud_out__doc__[];\n-    static char flipud_in__doc__[];\n-    static char get_resample__doc__[];\n-    static char set_resample__doc__[];\n-\n+  private:\n     // prevent copying\n-    Image(const Image&);\n-    Image& operator=(const Image&);\n+    Image(const Image &);\n+    Image &operator=(const Image &);\n };\n \n+template <class ArrayType>\n+Image *from_grey_array(ArrayType &array, bool isoutput)\n+{\n+    Image *im = new Image((unsigned)array.dim(0), (unsigned)array.dim(1), isoutput);\n+\n+    agg::int8u *buffer;\n+    if (isoutput) {\n+        buffer = im->bufferOut;\n+    } else {\n+        buffer = im->bufferIn;\n+    }\n+\n+    agg::int8u gray;\n+    for (size_t rownum = 0; rownum < (size_t)array.dim(0); rownum++) {\n+        for (size_t colnum = 0; colnum < (size_t)array.dim(1); colnum++) {\n+            double val = array(rownum, colnum);\n \n-/*\n-class ImageComposite : public Py::PythonExtension<ImageComposite> {\n+            gray = int(255 * val);\n+            *buffer++ = gray; // red\n+            *buffer++ = gray; // green\n+            *buffer++ = gray; // blue\n+            *buffer++ = 255;  // alpha\n+        }\n+    }\n \n+    return im;\n }\n-*/\n \n+template <class ArrayType>\n+Image *from_color_array(ArrayType &array, bool isoutput)\n+{\n+    Image *im = new Image((unsigned)array.dim(0), (unsigned)array.dim(1), isoutput);\n+\n+    agg::int8u *buffer;\n+    if (isoutput) {\n+        buffer = im->bufferOut;\n+    } else {\n+        buffer = im->bufferIn;\n+    }\n+\n+    int rgba = array.dim(2) >= 4;\n+    double r, g, b;\n+    double alpha = 1.0;\n+\n+    for (size_t rownum = 0; rownum < (size_t)array.dim(0); rownum++) {\n+        for (size_t colnum = 0; colnum < (size_t)array.dim(1); colnum++) {\n+            typename ArrayType::sub_t::sub_t color = array[rownum][colnum];\n+\n+            r = color(0);\n+            g = color(1);\n+            b = color(2);\n+\n+            if (rgba) {\n+                alpha = color(3);\n+            }\n \n-// the extension module\n-class _image_module : public Py::ExtensionModule<_image_module>\n+            *buffer++ = int(255 * r);     // red\n+            *buffer++ = int(255 * g);     // green\n+            *buffer++ = int(255 * b);     // blue\n+            *buffer++ = int(255 * alpha); // alpha\n+        }\n+    }\n+\n+    return im;\n+}\n+\n+template <class ArrayType>\n+Image *frombyte(ArrayType &array, bool isoutput)\n {\n-public:\n-    _image_module() : Py::ExtensionModule<_image_module>(\"_image\")\n-    {\n-        Image::init_type();\n-\n-        add_varargs_method(\"fromarray\", &_image_module::fromarray,\n-                           \"fromarray\");\n-        add_varargs_method(\"fromarray2\", &_image_module::fromarray2,\n-                           \"fromarray2\");\n-        add_varargs_method(\"frombyte\", &_image_module::frombyte,\n-                           \"frombyte\");\n-        add_varargs_method(\"frombuffer\", &_image_module::frombuffer,\n-                           \"frombuffer\");\n-        add_varargs_method(\"from_images\", &_image_module::from_images,\n-                           \"from_images\");\n-        add_varargs_method(\"pcolor\", &_image_module::pcolor,\n-                           \"pcolor\");\n-        add_varargs_method(\"pcolor2\", &_image_module::pcolor2,\n-                           \"pcolor2\");\n-        initialize(\"The _image module\");\n-    }\n-\n-    ~_image_module() {}\n-\n-private:\n-    Py::Object frombyte(const Py::Tuple &args);\n-    Py::Object frombuffer(const Py::Tuple &args);\n-    Py::Object fromarray(const Py::Tuple &args);\n-    Py::Object fromarray2(const Py::Tuple &args);\n-    Py::Object pcolor(const Py::Tuple &args);\n-    Py::Object pcolor2(const Py::Tuple &args);\n-    Py::Object from_images(const Py::Tuple &args);\n-\n-    static char _image_module_fromarray__doc__[];\n-    static char _image_module_pcolor__doc__[];\n-    static char _image_module_pcolor2__doc__[];\n-    static char _image_module_fromarray2__doc__[];\n-    static char _image_module_frombyte__doc__[];\n-    static char _image_module_frombuffer__doc__[];\n-};\n+    Image *im = new Image((unsigned)array.dim(0), (unsigned)array.dim(1), isoutput);\n \n+    agg::int8u *buffer;\n+    if (isoutput) {\n+        buffer = im->bufferOut;\n+    } else {\n+        buffer = im->bufferIn;\n+    }\n \n+    int rgba = array.dim(2) >= 4;\n+    agg::int8u r, g, b;\n+    agg::int8u alpha = 255;\n \n-#endif\n+    for (size_t rownum = 0; rownum < (size_t)array.dim(0); rownum++) {\n+        for (size_t colnum = 0; colnum < (size_t)array.dim(1); colnum++) {\n+            typename ArrayType::sub_t::sub_t color = array[rownum][colnum];\n+            r = color(0);\n+            g = color(1);\n+            b = color(2);\n+\n+            if (rgba) {\n+                alpha = color(3);\n+            }\n+\n+            *buffer++ = r;     // red\n+            *buffer++ = g;     // green\n+            *buffer++ = b;     // blue\n+            *buffer++ = alpha; // alpha\n+        }\n+    }\n+\n+    return im;\n+}\n+\n+// utilities for irregular grids\n+void _bin_indices_middle(\n+    unsigned int *irows, int nrows, const float *ys1, unsigned long ny, float dy, float y_min);\n+void _bin_indices_middle_linear(float *arows,\n+                                unsigned int *irows,\n+                                int nrows,\n+                                const float *y,\n+                                unsigned long ny,\n+                                float dy,\n+                                float y_min);\n+void _bin_indices(int *irows, int nrows, const double *y, unsigned long ny, double sc, double offs);\n+void _bin_indices_linear(\n+    float *arows, int *irows, int nrows, double *y, unsigned long ny, double sc, double offs);\n \n+template <class CoordinateArray, class ColorArray>\n+Image *pcolor(CoordinateArray &x,\n+              CoordinateArray &y,\n+              ColorArray &d,\n+              unsigned int rows,\n+              unsigned int cols,\n+              float bounds[4],\n+              int interpolation)\n+{\n+    if (rows >= 32768 || cols >= 32768) {\n+        throw \"rows and cols must both be less than 32768\";\n+    }\n+\n+    float x_min = bounds[0];\n+    float x_max = bounds[1];\n+    float y_min = bounds[2];\n+    float y_max = bounds[3];\n+    float width = x_max - x_min;\n+    float height = y_max - y_min;\n+    float dx = width / ((float)cols);\n+    float dy = height / ((float)rows);\n+\n+    // Check we have something to output to\n+    if (rows == 0 || cols == 0) {\n+        throw \"Cannot scale to zero size\";\n+    }\n+\n+    if (d.dim(2) != 4) {\n+        throw \"data must be in RGBA format\";\n+    }\n+\n+    // Check dimensions match\n+    unsigned long nx = x.dim(0);\n+    unsigned long ny = y.dim(0);\n+    if (nx != d.dim(1) || ny != d.dim(0)) {\n+        throw \"data and axis dimensions do not match\";\n+    }\n+\n+    // Allocate memory for pointer arrays\n+    std::vector<unsigned int> rowstarts(rows);\n+    std::vector<unsigned int> colstarts(cols);\n+\n+    // Create output\n+    Image *imo = new Image(rows, cols, true);\n+\n+    // Calculate the pointer arrays to map input x to output x\n+    unsigned int i, j;\n+    unsigned int *colstart = &colstarts[0];\n+    unsigned int *rowstart = &rowstarts[0];\n+    const float *xs1 = x.data();\n+    const float *ys1 = y.data();\n+\n+    // Copy data to output buffer\n+    const unsigned char *start;\n+    const unsigned char *inposition;\n+    size_t inrowsize = nx * 4;\n+    size_t rowsize = cols * 4;\n+    agg::int8u *position = imo->bufferOut;\n+    agg::int8u *oldposition = NULL;\n+    start = d.data();\n+\n+    if (interpolation == Image::NEAREST) {\n+        _bin_indices_middle(colstart, cols, xs1, nx, dx, x_min);\n+        _bin_indices_middle(rowstart, rows, ys1, ny, dy, y_min);\n+        for (i = 0; i < rows; i++, rowstart++) {\n+            if (i > 0 && *rowstart == 0) {\n+                memcpy(position, oldposition, rowsize * sizeof(agg::int8u));\n+                oldposition = position;\n+                position += rowsize;\n+            } else {\n+                oldposition = position;\n+                start += *rowstart * inrowsize;\n+                inposition = start;\n+                for (j = 0, colstart = &colstarts[0]; j < cols; j++, position += 4, colstart++) {\n+                    inposition += *colstart * 4;\n+                    memcpy(position, inposition, 4 * sizeof(agg::int8u));\n+                }\n+            }\n+        }\n+    } else if (interpolation == Image::BILINEAR) {\n+        std::vector<float> acols(cols);\n+        std::vector<float> arows(rows);\n+\n+        _bin_indices_middle_linear(&acols[0], colstart, cols, xs1, nx, dx, x_min);\n+        _bin_indices_middle_linear(&arows[0], rowstart, rows, ys1, ny, dy, y_min);\n+        double a00, a01, a10, a11, alpha, beta;\n+\n+        // Copy data to output buffer\n+        for (i = 0; i < rows; i++) {\n+            for (j = 0; j < cols; j++) {\n+                alpha = arows[i];\n+                beta = acols[j];\n+\n+                a00 = alpha * beta;\n+                a01 = alpha * (1.0 - beta);\n+                a10 = (1.0 - alpha) * beta;\n+                a11 = 1.0 - a00 - a01 - a10;\n+\n+                typename ColorArray::sub_t::sub_t start00 = d[rowstart[i]][colstart[j]];\n+                typename ColorArray::sub_t::sub_t start01 = d[rowstart[i]][colstart[j] + 1];\n+                typename ColorArray::sub_t::sub_t start10 = d[rowstart[i] + 1][colstart[j]];\n+                typename ColorArray::sub_t::sub_t start11 = d[rowstart[i] + 1][colstart[j] + 1];\n+                for (size_t k = 0; k < 4; ++k) {\n+                    position[k] =\n+                        start00(k) * a00 + start01(k) * a01 + start10(k) * a10 + start11(k) * a11;\n+                }\n+                position += 4;\n+            }\n+        }\n+    }\n+\n+    return imo;\n+}\n+\n+template <class CoordinateArray, class ColorArray, class Color>\n+Image *pcolor2(CoordinateArray &x,\n+               CoordinateArray &y,\n+               ColorArray &d,\n+               unsigned int rows,\n+               unsigned int cols,\n+               float bounds[4],\n+               Color &bg)\n+{\n+    double x_left = bounds[0];\n+    double x_right = bounds[1];\n+    double y_bot = bounds[2];\n+    double y_top = bounds[3];\n+\n+    // Check we have something to output to\n+    if (rows == 0 || cols == 0) {\n+        throw \"rows or cols is zero; there are no pixels\";\n+    }\n+\n+    if (d.dim(2) != 4) {\n+        throw \"data must be in RGBA format\";\n+    }\n+\n+    // Check dimensions match\n+    unsigned long nx = x.dim(0);\n+    unsigned long ny = y.dim(0);\n+    if (nx != d.dim(1) + 1 || ny != d.dim(0) + 1) {\n+        throw \"data and axis bin boundary dimensions are incompatible\";\n+    }\n+\n+    if (bg.dim(0) != 4) {\n+        throw \"bg must be in RGBA format\";\n+    }\n+\n+    std::vector<int> irows(rows);\n+    std::vector<int> jcols(cols);\n+\n+    // Create output\n+    Image *imo = new Image(rows, cols, true);\n+\n+    // Calculate the pointer arrays to map input x to output x\n+    size_t i, j;\n+    const double *x0 = x.data();\n+    const double *y0 = y.data();\n+    double sx = cols / (x_right - x_left);\n+    double sy = rows / (y_top - y_bot);\n+    _bin_indices(&jcols[0], cols, x0, nx, sx, x_left);\n+    _bin_indices(&irows[0], rows, y0, ny, sy, y_bot);\n+\n+    // Copy data to output buffer\n+    agg::int8u *position = imo->bufferOut;\n+\n+    for (i = 0; i < rows; i++) {\n+        for (j = 0; j < cols; j++) {\n+            if (irows[i] == -1 || jcols[j] == -1) {\n+                memcpy(position, (const agg::int8u *)bg.data(), 4 * sizeof(agg::int8u));\n+            } else {\n+                for (size_t k = 0; k < 4; ++k) {\n+                    position[k] = d(irows[i], jcols[j], k);\n+                }\n+            }\n+            position += 4;\n+        }\n+    }\n+\n+    return imo;\n+}\n+\n+#endif"}
{"patches_id": 2, "files_id": 37, "language": "cpp", "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_image_wrapper.cpp", "raw_code": "#include \"mplutils.h\"\n#include \"_image.h\"\n#include \"py_converters.h\"\n\n/**********************************************************************\n * Image\n * */\n\ntypedef struct\n{\n    PyObject_HEAD;\n    Image *x;\n    Py_ssize_t shape[3];\n    Py_ssize_t strides[3];\n    Py_ssize_t suboffsets[3];\n    PyObject *dict;\n} PyImage;\n\nstatic PyTypeObject PyImageType;\n\nstatic PyObject *PyImage_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    PyImage *self;\n    self = (PyImage *)type->tp_alloc(type, 0);\n    memset(self, 0, sizeof(PyImage));\n    self->x = NULL;\n    self->dict = PyDict_New();\n    return (PyObject *)self;\n}\n\nstatic PyObject *PyImage_cnew(Image *im)\n{\n    PyImage *self;\n    self = (PyImage *)PyImageType.tp_alloc(&PyImageType, 0);\n    self->x = im;\n    self->dict = PyDict_New();\n    return (PyObject *)self;\n}\n\nstatic int PyImage_init(PyImage *self, PyObject *args, PyObject *kwds)\n{\n    if (!PyArg_ParseTuple(args, \"\")) {\n        return -1;\n    }\n\n    CALL_CPP_INIT(\"Image\", (self->x = new Image()));\n\n    return 0;\n}\n\nstatic void PyImage_dealloc(PyImage *self)\n{\n    delete self->x;\n    Py_DECREF(self->dict);\n    Py_TYPE(self)->tp_free((PyObject *)self);\n}\n\nconst char *PyImage_apply_rotation__doc__ =\n    \"apply_rotation(angle)\\n\"\n    \"\\n\"\n    \"Apply the rotation (degrees) to image\";\n\nstatic PyObject *PyImage_apply_rotation(PyImage *self, PyObject *args, PyObject *kwds)\n{\n    double r;\n\n    if (!PyArg_ParseTuple(args, \"d:apply_rotation\", &r)) {\n        return NULL;\n    }\n\n    CALL_CPP(\"apply_rotation\", (self->x->apply_rotation(r)));\n\n    Py_RETURN_NONE;\n}\n\nconst char *PyImage_set_bg__doc__ =\n    \"set_bg(r,g,b,a)\\n\"\n    \"\\n\"\n    \"Set the background color\";\n\nstatic PyObject *PyImage_set_bg(PyImage *self, PyObject *args, PyObject *kwds)\n{\n    double r, g, b, a;\n\n    if (!PyArg_ParseTuple(args, \"dddd:set_bg\", &r, &g, &b, &a)) {\n        return NULL;\n    }\n\n    CALL_CPP(\"set_bg\", (self->x->set_bg(r, g, b, a)));\n\n    Py_RETURN_NONE;\n}\n\nconst char *PyImage_apply_scaling__doc__ =\n    \"apply_scaling(sx, sy)\\n\"\n    \"\\n\"\n    \"Apply the scale factors sx, sy to the transform matrix\";\n\nstatic PyObject *PyImage_apply_scaling(PyImage *self, PyObject *args, PyObject *kwds)\n{\n    double sx, sy;\n\n    if (!PyArg_ParseTuple(args, \"dd:apply_scaling\", &sx, &sy)) {\n        return NULL;\n    }\n\n    CALL_CPP(\"apply_scaling\", (self->x->apply_scaling(sx, sy)));\n\n    Py_RETURN_NONE;\n}\n\nconst char *PyImage_apply_translation__doc__ =\n    \"apply_translation(tx, ty)\\n\"\n    \"\\n\"\n    \"Apply the translation tx, ty to the transform matrix\";\n\nstatic PyObject *PyImage_apply_translation(PyImage *self, PyObject *args, PyObject *kwds)\n{\n    double tx, ty;\n    if (!PyArg_ParseTuple(args, \"dd:apply_translation\", &tx, &ty)) {\n        return NULL;\n    }\n\n    CALL_CPP(\"apply_translation\", self->x->apply_translation(tx, ty));\n\n    Py_RETURN_NONE;\n}\n\nconst char *PyImage_as_rgba_str__doc__ =\n    \"numrows, numcols, s = as_rgba_str()\"\n    \"\\n\"\n    \"Call this function after resize to get the data as string\\n\"\n    \"The string is a numrows by numcols x 4 (RGBA) unsigned char buffer\\n\";\n\nstatic PyObject *PyImage_as_rgba_str(PyImage *self, PyObject *args, PyObject *kwds)\n{\n    // TODO: This performs a copy.  Use buffer interface when possible\n\n    PyObject *result = PyBytes_FromStringAndSize(NULL, self->x->rowsOut * self->x->colsOut * 4);\n    if (result == NULL) {\n        return NULL;\n    }\n\n    CALL_CPP_CLEANUP(\"as_rgba_str\",\n                     (self->x->as_rgba_str((agg::int8u *)PyBytes_AsString(result))),\n                     Py_DECREF(result));\n\n    return Py_BuildValue(\"nnN\", self->x->rowsOut, self->x->colsOut, result);\n}\n\nconst char *PyImage_color_conv__doc__ =\n    \"numrows, numcols, buffer = color_conv(format)\"\n    \"\\n\"\n    \"format 0(BGRA) or 1(ARGB)\\n\"\n    \"Convert image to format and return in a writable buffer\\n\";\n\n// TODO: This function is a terrible interface.  Change/remove?  Only\n// used by Cairo backend.\n\nstatic PyObject *PyImage_color_conv(PyImage *self, PyObject *args, PyObject *kwds)\n{\n    int format;\n\n    if (!PyArg_ParseTuple(args, \"i:color_conv\", &format)) {\n        return NULL;\n    }\n\n    PyObject *result = PyBytes_FromStringAndSize(NULL, self->x->rowsOut * self->x->colsOut * 4);\n    if (result == NULL) {\n        return NULL;\n    }\n\n    CALL_CPP_CLEANUP(\"color_conv\",\n                     (self->x->color_conv(format, (agg::int8u *)PyBytes_AsString(result))),\n                     Py_DECREF(result));\n\n    return Py_BuildValue(\"nnN\", self->x->rowsOut, self->x->colsOut, result);\n}\n\nconst char *PyImage_buffer_rgba__doc__ =\n    \"buffer = buffer_rgba()\"\n    \"\\n\"\n    \"Return the image buffer as rgba32\\n\";\n\nstatic PyObject *PyImage_buffer_rgba(PyImage *self, PyObject *args, PyObject *kwds)\n{\n#if PY3K\n    return Py_BuildValue(\"nny#\",\n                         self->x->rowsOut,\n                         self->x->colsOut,\n                         self->x->rbufOut,\n                         self->x->rowsOut * self->x->colsOut * 4);\n#else\n    PyObject *buffer =\n        PyBuffer_FromReadWriteMemory(self->x->rbufOut, self->x->rowsOut * self->x->colsOut * 4);\n    if (buffer == NULL) {\n        return NULL;\n    }\n\n    return Py_BuildValue(\"nnN\", self->x->rowsOut, self->x->colsOut, buffer);\n#endif\n}\n\nconst char *PyImage_reset_matrix__doc__ =\n    \"reset_matrix()\"\n    \"\\n\"\n    \"Reset the transformation matrix\";\n\nstatic PyObject *PyImage_reset_matrix(PyImage *self, PyObject *args, PyObject *kwds)\n{\n    CALL_CPP(\"reset_matrix\", self->x->reset_matrix());\n\n    Py_RETURN_NONE;\n}\n\nconst char *PyImage_get_matrix__doc__ =\n    \"(m11,m21,m12,m22,m13,m23) = get_matrix()\\n\"\n    \"\\n\"\n    \"Get the affine transformation matrix\\n\"\n    \"  /m11,m12,m13\\\\\\n\"\n    \"  /m21,m22,m23|\\n\"\n    \"  \\\\ 0 , 0 , 1 /\";\n\nstatic PyObject *PyImage_get_matrix(PyImage *self, PyObject *args, PyObject *kwds)\n{\n    double m[6];\n    self->x->srcMatrix.store_to(m);\n\n    return Py_BuildValue(\"dddddd\", m[0], m[1], m[2], m[3], m[4], m[5]);\n}\n\nconst char *PyImage_resize__doc__ =\n    \"resize(width, height, norm=1, radius=4.0)\\n\"\n    \"\\n\"\n    \"Resize the image to width, height using interpolation\\n\"\n    \"norm and radius are optional args for some of the filters\\n\";\n\nstatic PyObject *PyImage_resize(PyImage *self, PyObject *args, PyObject *kwds)\n{\n    double width;\n    double height;\n    double norm;\n    double radius;\n    const char *names[] = { \"width\", \"height\", \"norm\", \"radius\", NULL };\n\n    if (!PyArg_ParseTupleAndKeywords(\n             args, kwds, \"dd|dd:resize\", (char **)names, &width, &height, &norm, &radius)) {\n        return NULL;\n    }\n\n    CALL_CPP(\"resize\", (self->x->resize(width, height, norm, radius)));\n\n    Py_RETURN_NONE;\n}\n\nconst char *PyImage_get_interpolation__doc__ =\n    \"get_interpolation()\\n\"\n    \"\\n\"\n    \"Get the interpolation scheme to one of the module constants, \"\n    \"one of image.NEAREST, image.BILINEAR, etc...\";\n\nstatic PyObject *PyImage_get_interpolation(PyImage *self, PyObject *args, PyObject *kwds)\n{\n    return PyLong_FromLong(self->x->interpolation);\n}\n\nconst char *PyImage_set_interpolation__doc__ =\n    \"set_interpolation(scheme)\\n\"\n    \"\\n\"\n    \"Set the interpolation scheme to one of the module constants, \"\n    \"eg, image.NEAREST, image.BILINEAR, etc...\";\n\nstatic PyObject *PyImage_set_interpolation(PyImage *self, PyObject *args, PyObject *kwds)\n{\n    int method;\n\n    if (!PyArg_ParseTuple(args, \"i:set_interpolation\", &method)) {\n        return NULL;\n    }\n\n    self->x->interpolation = method;\n\n    Py_RETURN_NONE;\n}\n\nconst char *PyImage_get_aspect__doc__ =\n    \"get_aspect()\\n\"\n    \"\\n\"\n    \"Get the aspect constraint constants\";\n\nstatic PyObject *PyImage_get_aspect(PyImage *self, PyObject *args, PyObject *kwds)\n{\n    return PyLong_FromLong(self->x->aspect);\n}\n\nconst char *PyImage_set_aspect__doc__ =\n    \"set_aspect(scheme)\\n\"\n    \"\\n\"\n    \"Set the aspect ratio to one of the image module constant.\"\n    \"eg, one of image.ASPECT_PRESERVE, image.ASPECT_FREE\";\n\nstatic PyObject *PyImage_set_aspect(PyImage *self, PyObject *args, PyObject *kwds)\n{\n    int scheme;\n    if (!PyArg_ParseTuple(args, \"i:set_aspect\", &scheme)) {\n        return NULL;\n    }\n\n    self->x->aspect = scheme;\n\n    Py_RETURN_NONE;\n}\n\nconst char *PyImage_get_size__doc__ =\n    \"numrows, numcols = get_size()\\n\"\n    \"\\n\"\n    \"Get the number or rows and columns of the input image\";\n\nstatic PyObject *PyImage_get_size(PyImage *self, PyObject *args, PyObject *kwds)\n{\n    return Py_BuildValue(\"ii\", self->x->rowsIn, self->x->colsIn);\n}\n\nconst char *PyImage_get_resample__doc__ =\n    \"get_resample()\\n\"\n    \"\\n\"\n    \"Get the resample flag.\";\n\nstatic PyObject *PyImage_get_resample(PyImage *self, PyObject *args, PyObject *kwds)\n{\n    if (self->x->resample) {\n        Py_RETURN_TRUE;\n    }\n    Py_RETURN_FALSE;\n}\n\nconst char *PyImage_set_resample__doc__ =\n    \"set_resample(boolean)\\n\"\n    \"\\n\"\n    \"Set the resample flag.\";\n\nstatic PyObject *PyImage_set_resample(PyImage *self, PyObject *args, PyObject *kwds)\n{\n    int resample;\n\n    if (!PyArg_ParseTuple(args, \"i:set_resample\", &resample)) {\n        return NULL;\n    }\n\n    self->x->resample = resample;\n\n    Py_RETURN_NONE;\n}\n\nconst char *PyImage_get_size_out__doc__ =\n    \"numrows, numcols = get_size_out()\\n\"\n    \"\\n\"\n    \"Get the number or rows and columns of the output image\";\n\nstatic PyObject *PyImage_get_size_out(PyImage *self, PyObject *args, PyObject *kwds)\n{\n    return Py_BuildValue(\"ii\", self->x->rowsOut, self->x->colsOut);\n}\n\nstatic int PyImage_get_buffer(PyImage *self, Py_buffer *buf, int flags)\n{\n    Image *im = self->x;\n\n    Py_INCREF(self);\n    buf->obj = (PyObject *)self;\n    buf->buf = im->bufferOut;\n    buf->len = im->colsOut * im->rowsOut * 4;\n    buf->readonly = 0;\n    buf->format = (char *)\"B\";\n    buf->ndim = 3;\n    self->shape[0] = im->rowsOut;\n    self->shape[1] = im->colsOut;\n    self->shape[2] = 4;\n    buf->shape = self->shape;\n    self->strides[0] = im->colsOut * 4;\n    self->strides[1] = 4;\n    self->strides[2] = 1;\n    buf->strides = self->strides;\n    buf->suboffsets = NULL;\n    buf->itemsize = 1;\n    buf->internal = NULL;\n\n    return 1;\n}\n\nstatic PyTypeObject *PyImage_init_type(PyObject *m, PyTypeObject *type)\n{\n    static PyMethodDef methods[] = {\n        {\"apply_rotation\", (PyCFunction)PyImage_apply_rotation, METH_VARARGS, PyImage_apply_rotation__doc__},\n        {\"set_bg\", (PyCFunction)PyImage_set_bg, METH_VARARGS, PyImage_set_bg__doc__},\n        {\"apply_scaling\", (PyCFunction)PyImage_apply_scaling, METH_VARARGS, PyImage_apply_scaling__doc__},\n        {\"apply_translation\", (PyCFunction)PyImage_apply_translation, METH_VARARGS, PyImage_apply_translation__doc__},\n        {\"as_rgba_str\", (PyCFunction)PyImage_as_rgba_str, METH_NOARGS, PyImage_as_rgba_str__doc__},\n        {\"color_conv\", (PyCFunction)PyImage_color_conv, METH_VARARGS, PyImage_color_conv__doc__},\n        {\"buffer_rgba\", (PyCFunction)PyImage_buffer_rgba, METH_NOARGS, PyImage_buffer_rgba__doc__},\n        {\"reset_matrix\", (PyCFunction)PyImage_reset_matrix, METH_NOARGS, PyImage_reset_matrix__doc__},\n        {\"get_matrix\", (PyCFunction)PyImage_get_matrix, METH_NOARGS, PyImage_get_matrix__doc__},\n        {\"resize\", (PyCFunction)PyImage_resize, METH_VARARGS|METH_KEYWORDS, PyImage_resize__doc__},\n        {\"get_interpolation\", (PyCFunction)PyImage_get_interpolation, METH_NOARGS, PyImage_get_interpolation__doc__},\n        {\"set_interpolation\", (PyCFunction)PyImage_set_interpolation, METH_VARARGS, PyImage_set_interpolation__doc__},\n        {\"get_aspect\", (PyCFunction)PyImage_get_aspect, METH_NOARGS, PyImage_get_aspect__doc__},\n        {\"set_aspect\", (PyCFunction)PyImage_set_aspect, METH_VARARGS, PyImage_set_aspect__doc__},\n        {\"get_size\", (PyCFunction)PyImage_get_size, METH_NOARGS, PyImage_get_size__doc__},\n        {\"get_resample\", (PyCFunction)PyImage_get_resample, METH_VARARGS, PyImage_get_resample__doc__},\n        {\"set_resample\", (PyCFunction)PyImage_set_resample, METH_VARARGS, PyImage_set_resample__doc__},\n        {\"get_size_out\", (PyCFunction)PyImage_get_size_out, METH_VARARGS, PyImage_get_size_out__doc__},\n        {NULL}\n    };\n\n    static PyBufferProcs buffer_procs;\n    memset(&buffer_procs, 0, sizeof(PyBufferProcs));\n    buffer_procs.bf_getbuffer = (getbufferproc)PyImage_get_buffer;\n\n    memset(type, 0, sizeof(PyTypeObject));\n    type->tp_name = \"matplotlib._image.Image\";\n    type->tp_basicsize = sizeof(PyImage);\n    type->tp_dealloc = (destructor)PyImage_dealloc;\n    type->tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_NEWBUFFER;\n    type->tp_methods = methods;\n    type->tp_new = PyImage_new;\n    type->tp_init = (initproc)PyImage_init;\n    type->tp_as_buffer = &buffer_procs;\n    type->tp_dictoffset = offsetof(PyImage, dict);\n\n    if (PyType_Ready(type) < 0) {\n        return NULL;\n    }\n\n    if (PyModule_AddObject(m, \"Image\", (PyObject *)type)) {\n        return NULL;\n    }\n\n    return type;\n}\n\n/**********************************************************************\n * Free functions\n * */\n\nconst char *image_from_images__doc__ =\n    \"from_images(numrows, numcols, seq)\\n\"\n    \"\\n\"\n    \"return an image instance with numrows, numcols from a seq of image\\n\"\n    \"instances using alpha blending.  seq is a list of (Image, ox, oy)\";\n\nstatic PyObject *image_from_images(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    unsigned int numrows;\n    unsigned int numcols;\n    PyObject *images;\n    size_t numimages;\n\n    if (!PyArg_ParseTuple(args, \"IIO:from_images\", &numrows, &numcols, &images)) {\n        return NULL;\n    }\n\n    if (!PySequence_Check(images)) {\n        return NULL;\n    }\n\n    Image *im = new Image(numrows, numcols, true);\n    im->clear();\n\n    numimages = PySequence_Size(images);\n\n    for (size_t i = 0; i < numimages; ++i) {\n        PyObject *entry = PySequence_GetItem(images, i);\n        if (entry == NULL) {\n            delete im;\n            return NULL;\n        }\n\n        PyObject *subimage;\n        unsigned int x;\n        unsigned int y;\n        PyObject *alphaobj = NULL;\n        double alpha = 0.0;\n\n        if (!PyArg_ParseTuple(entry, \"O!II|O\", &PyImageType, &subimage, &x, &y, &alphaobj)) {\n            Py_DECREF(entry);\n            delete im;\n            return NULL;\n        }\n\n        bool has_alpha = false;\n        if (alphaobj != NULL && alphaobj != Py_None) {\n            has_alpha = true;\n            alpha = PyFloat_AsDouble(alphaobj);\n            if (PyErr_Occurred()) {\n                Py_DECREF(entry);\n                delete im;\n                return NULL;\n            }\n        }\n\n        CALL_CPP(\"from_images\",\n                 (im->blend_image(*((PyImage *)subimage)->x, x, y, has_alpha, alpha)));\n\n        Py_DECREF(entry);\n    }\n\n    return PyImage_cnew(im);\n}\n\nconst char *image_fromarray__doc__ =\n    \"fromarray(A, isoutput)\\n\"\n    \"\\n\"\n    \"Load the image from a numpy array\\n\"\n    \"By default this function fills the input buffer, which can subsequently\\n\"\n    \"be resampled using resize.  If isoutput=1, fill the output buffer.\\n\"\n    \"This is used to support raw pixel images w/o resampling\\n\";\n\nstatic PyObject *image_fromarray(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    PyObject *array;\n    int isoutput;\n    const char *names[] = { \"array\", \"isoutput\", NULL };\n\n    if (!PyArg_ParseTupleAndKeywords(\n             args, kwds, \"O|i:fromarray\", (char **)names, &array, &isoutput)) {\n        return NULL;\n    }\n\n    numpy::array_view<const double, 3> color_array;\n    numpy::array_view<const double, 2> grey_array;\n    Image *result = NULL;\n\n    if (numpy::convert_array<const double, 3>(array, &color_array)) {\n        CALL_CPP(\"fromarray\", result = from_color_array(color_array, isoutput));\n    } else if (numpy::convert_array<const double, 2>(array, &grey_array)) {\n        CALL_CPP(\"fromarray\", result = from_grey_array(grey_array, isoutput));\n    } else {\n        PyErr_SetString(PyExc_ValueError, \"invalid array\");\n        return NULL;\n    }\n\n    return PyImage_cnew(result);\n}\n\nconst char *image_frombyte__doc__ =\n    \"frombyte(A, isoutput)\\n\"\n    \"\\n\"\n    \"Load the image from a byte array.\\n\"\n    \"By default this function fills the input buffer, which can subsequently\\n\"\n    \"be resampled using resize.  If isoutput=1, fill the output buffer.\\n\"\n    \"This is used to support raw pixel images w/o resampling.\";\n\nstatic PyObject *image_frombyte(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    numpy::array_view<const uint8_t, 3> array;\n    int isoutput;\n    const char *names[] = { \"array\", \"isoutput\", NULL };\n    Image *result;\n\n    if (!PyArg_ParseTupleAndKeywords(args,\n                                     kwds,\n                                     \"O&|i:frombyte\",\n                                     (char **)names,\n                                     &numpy::convert_array_contiguous<const uint8_t, 3>,\n                                     &array,\n                                     &isoutput)) {\n        return NULL;\n    }\n\n    CALL_CPP(\"frombyte\", (result = frombyte(array, isoutput)));\n\n    return PyImage_cnew(result);\n}\n\nconst char *image_frombuffer__doc__ =\n    \"frombuffer(buffer, width, height, isoutput)\\n\"\n    \"\\n\"\n    \"Load the image from a character buffer\\n\"\n    \"By default this function fills the input buffer, which can subsequently\\n\"\n    \"be resampled using resize.  If isoutput=1, fill the output buffer.\\n\"\n    \"This is used to support raw pixel images w/o resampling.\";\n\nstatic PyObject *image_frombuffer(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    PyObject *buffer;\n    unsigned x;\n    unsigned y;\n    int isoutput;\n    const char *names[] = { \"buffer\", \"x\", \"y\", \"isoutput\", NULL };\n\n    if (!PyArg_ParseTupleAndKeywords(\n             args, kwds, \"OII|i:frombuffer\", (char **)names, &buffer, &x, &y, &isoutput)) {\n        return NULL;\n    }\n\n    const void *rawbuf;\n    Py_ssize_t buflen;\n    if (PyObject_AsReadBuffer(buffer, &rawbuf, &buflen) != 0) {\n        return NULL;\n    }\n\n    if (buflen != (Py_ssize_t)(y * x * 4)) {\n        PyErr_SetString(PyExc_ValueError, \"Buffer is incorrect length\");\n        return NULL;\n    }\n\n    Image *im;\n    CALL_CPP(\"frombuffer\", (im = new Image(y, x, isoutput)));\n\n    agg::int8u *inbuf = (agg::int8u *)rawbuf;\n    agg::int8u *outbuf;\n    if (isoutput) {\n        outbuf = im->bufferOut;\n    } else {\n        outbuf = im->bufferIn;\n    }\n\n    for (int i = (x * 4) * (y - 1); i >= 0; i -= (x * 4)) {\n        memmove(outbuf, &inbuf[i], (x * 4));\n        outbuf += x * 4;\n    }\n\n    return PyImage_cnew(im);\n}\n\nconst char *image_pcolor__doc__ =\n    \"pcolor(x, y, data, rows, cols, bounds)\\n\"\n    \"\\n\"\n    \"Generate a pseudo-color image from data on a non-uniform grid using\\n\"\n    \"nearest neighbour or linear interpolation.\\n\"\n    \"bounds = (x_min, x_max, y_min, y_max)\\n\"\n    \"interpolation = NEAREST or BILINEAR \\n\";\n\nstatic PyObject *image_pcolor(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    numpy::array_view<const float, 1> x;\n    numpy::array_view<const float, 1> y;\n    numpy::array_view<const agg::int8u, 3> d;\n    unsigned int rows;\n    unsigned int cols;\n    float bounds[4];\n    int interpolation;\n    Image *result;\n\n    if (!PyArg_ParseTuple(args,\n                          \"O&O&O&II(ffff)i:pcolor\",\n                          &numpy::convert_array_contiguous<const float, 1>,\n                          &x,\n                          &numpy::convert_array_contiguous<const float, 1>,\n                          &y,\n                          &numpy::convert_array_contiguous<const agg::int8u, 3>,\n                          &d,\n                          &rows,\n                          &cols,\n                          &bounds[0],\n                          &bounds[1],\n                          &bounds[2],\n                          &bounds[3],\n                          &interpolation)) {\n        return NULL;\n    }\n\n    CALL_CPP(\"pcolor\", (result = pcolor(x, y, d, rows, cols, bounds, interpolation)));\n\n    return PyImage_cnew(result);\n}\n\nconst char *image_pcolor2__doc__ =\n    \"pcolor2(x, y, data, rows, cols, bounds, bg)\\n\"\n    \"\\n\"\n    \"Generate a pseudo-color image from data on a non-uniform grid\\n\"\n    \"specified by its cell boundaries.\\n\"\n    \"bounds = (x_left, x_right, y_bot, y_top)\\n\"\n    \"bg = ndarray of 4 uint8 representing background rgba\\n\";\n\nstatic PyObject *image_pcolor2(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    numpy::array_view<const double, 1> x;\n    numpy::array_view<const double, 1> y;\n    numpy::array_view<const agg::int8u, 3> d;\n    unsigned int rows;\n    unsigned int cols;\n    float bounds[4];\n    numpy::array_view<const agg::int8u, 1> bg;\n    Image *result;\n\n    if (!PyArg_ParseTuple(args,\n                          \"O&O&O&II(ffff)O&:pcolor2\",\n                          &numpy::convert_array_contiguous<const double, 1>,\n                          &x,\n                          &numpy::convert_array_contiguous<const double, 1>,\n                          &y,\n                          &numpy::convert_array<const agg::int8u, 3>,\n                          &d,\n                          &rows,\n                          &cols,\n                          &bounds[0],\n                          &bounds[1],\n                          &bounds[2],\n                          &bounds[3],\n                          &numpy::convert_array<const agg::int8u, 1>,\n                          &bg)) {\n        return NULL;\n    }\n\n    CALL_CPP(\"pcolor2\", (result = pcolor2(x, y, d, rows, cols, bounds, bg)));\n\n    return PyImage_cnew(result);\n}\n\nstatic PyMethodDef module_functions[] = {\n    {\"from_images\", (PyCFunction)image_from_images, METH_VARARGS, image_from_images__doc__},\n    {\"fromarray\", (PyCFunction)image_fromarray, METH_VARARGS|METH_KEYWORDS, image_fromarray__doc__},\n    {\"frombyte\", (PyCFunction)image_frombyte, METH_VARARGS|METH_KEYWORDS, image_frombyte__doc__},\n    {\"frombuffer\", (PyCFunction)image_frombuffer, METH_VARARGS|METH_KEYWORDS, image_frombuffer__doc__},\n    {\"pcolor\", (PyCFunction)image_pcolor, METH_VARARGS, image_pcolor__doc__},\n    {\"pcolor2\", (PyCFunction)image_pcolor2, METH_VARARGS, image_pcolor2__doc__},\n    {NULL}\n};\n\nextern \"C\" {\n\nstruct module_state\n{\n/* The Sun compiler can't handle empty structs */\n#if defined(__SUNPRO_C) || defined(_MSC_VER)\n    int _dummy;\n#endif\n};\n\n#if PY3K\nstatic struct PyModuleDef moduledef = {\n    PyModuleDef_HEAD_INIT,\n    \"_image\",\n    NULL,\n    sizeof(struct module_state),\n    module_functions,\n    NULL,\n    NULL,\n    NULL,\n    NULL\n};\n\n#define INITERROR return NULL\n\nPyMODINIT_FUNC PyInit__image(void)\n\n#else\n#define INITERROR return\n\nPyMODINIT_FUNC init_image(void)\n#endif\n\n{\n    PyObject *m;\n\n#if PY3K\n    m = PyModule_Create(&moduledef);\n#else\n    m = Py_InitModule3(\"_image\", module_functions, NULL);\n#endif\n\n    if (m == NULL) {\n        INITERROR;\n    }\n\n    import_array();\n\n    if (!PyImage_init_type(m, &PyImageType)) {\n        INITERROR;\n    }\n\n    PyObject *d = PyModule_GetDict(m);\n\n    if (add_dict_int(d, \"NEAREST\", Image::NEAREST) ||\n        add_dict_int(d, \"BILINEAR\", Image::BILINEAR) ||\n        add_dict_int(d, \"BICUBIC\", Image::BICUBIC) ||\n        add_dict_int(d, \"SPLINE16\", Image::SPLINE16) ||\n        add_dict_int(d, \"SPLINE36\", Image::SPLINE36) ||\n        add_dict_int(d, \"HANNING\", Image::HANNING) ||\n        add_dict_int(d, \"HAMMING\", Image::HAMMING) ||\n        add_dict_int(d, \"HERMITE\", Image::HERMITE) ||\n        add_dict_int(d, \"KAISER\", Image::KAISER) ||\n        add_dict_int(d, \"QUADRIC\", Image::QUADRIC) ||\n        add_dict_int(d, \"CATROM\", Image::CATROM) ||\n        add_dict_int(d, \"GAUSSIAN\", Image::GAUSSIAN) ||\n        add_dict_int(d, \"BESSEL\", Image::BESSEL) ||\n        add_dict_int(d, \"MITCHELL\", Image::MITCHELL) ||\n        add_dict_int(d, \"SINC\", Image::SINC) ||\n        add_dict_int(d, \"LANCZOS\", Image::LANCZOS) ||\n        add_dict_int(d, \"BLACKMAN\", Image::BLACKMAN) ||\n\n        add_dict_int(d, \"ASPECT_FREE\", Image::ASPECT_FREE) ||\n        add_dict_int(d, \"ASPECT_PRESERVE\", Image::ASPECT_PRESERVE)) {\n        INITERROR;\n    }\n\n    import_array();\n\n#if PY3K\n    return m;\n#endif\n}\n\n} // extern \"C\"\n", "patch": "@@ -0,0 +1,805 @@\n+#include \"mplutils.h\"\n+#include \"_image.h\"\n+#include \"py_converters.h\"\n+\n+/**********************************************************************\n+ * Image\n+ * */\n+\n+typedef struct\n+{\n+    PyObject_HEAD;\n+    Image *x;\n+    Py_ssize_t shape[3];\n+    Py_ssize_t strides[3];\n+    Py_ssize_t suboffsets[3];\n+    PyObject *dict;\n+} PyImage;\n+\n+static PyTypeObject PyImageType;\n+\n+static PyObject *PyImage_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n+{\n+    PyImage *self;\n+    self = (PyImage *)type->tp_alloc(type, 0);\n+    memset(self, 0, sizeof(PyImage));\n+    self->x = NULL;\n+    self->dict = PyDict_New();\n+    return (PyObject *)self;\n+}\n+\n+static PyObject *PyImage_cnew(Image *im)\n+{\n+    PyImage *self;\n+    self = (PyImage *)PyImageType.tp_alloc(&PyImageType, 0);\n+    self->x = im;\n+    self->dict = PyDict_New();\n+    return (PyObject *)self;\n+}\n+\n+static int PyImage_init(PyImage *self, PyObject *args, PyObject *kwds)\n+{\n+    if (!PyArg_ParseTuple(args, \"\")) {\n+        return -1;\n+    }\n+\n+    CALL_CPP_INIT(\"Image\", (self->x = new Image()));\n+\n+    return 0;\n+}\n+\n+static void PyImage_dealloc(PyImage *self)\n+{\n+    delete self->x;\n+    Py_DECREF(self->dict);\n+    Py_TYPE(self)->tp_free((PyObject *)self);\n+}\n+\n+const char *PyImage_apply_rotation__doc__ =\n+    \"apply_rotation(angle)\\n\"\n+    \"\\n\"\n+    \"Apply the rotation (degrees) to image\";\n+\n+static PyObject *PyImage_apply_rotation(PyImage *self, PyObject *args, PyObject *kwds)\n+{\n+    double r;\n+\n+    if (!PyArg_ParseTuple(args, \"d:apply_rotation\", &r)) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP(\"apply_rotation\", (self->x->apply_rotation(r)));\n+\n+    Py_RETURN_NONE;\n+}\n+\n+const char *PyImage_set_bg__doc__ =\n+    \"set_bg(r,g,b,a)\\n\"\n+    \"\\n\"\n+    \"Set the background color\";\n+\n+static PyObject *PyImage_set_bg(PyImage *self, PyObject *args, PyObject *kwds)\n+{\n+    double r, g, b, a;\n+\n+    if (!PyArg_ParseTuple(args, \"dddd:set_bg\", &r, &g, &b, &a)) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP(\"set_bg\", (self->x->set_bg(r, g, b, a)));\n+\n+    Py_RETURN_NONE;\n+}\n+\n+const char *PyImage_apply_scaling__doc__ =\n+    \"apply_scaling(sx, sy)\\n\"\n+    \"\\n\"\n+    \"Apply the scale factors sx, sy to the transform matrix\";\n+\n+static PyObject *PyImage_apply_scaling(PyImage *self, PyObject *args, PyObject *kwds)\n+{\n+    double sx, sy;\n+\n+    if (!PyArg_ParseTuple(args, \"dd:apply_scaling\", &sx, &sy)) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP(\"apply_scaling\", (self->x->apply_scaling(sx, sy)));\n+\n+    Py_RETURN_NONE;\n+}\n+\n+const char *PyImage_apply_translation__doc__ =\n+    \"apply_translation(tx, ty)\\n\"\n+    \"\\n\"\n+    \"Apply the translation tx, ty to the transform matrix\";\n+\n+static PyObject *PyImage_apply_translation(PyImage *self, PyObject *args, PyObject *kwds)\n+{\n+    double tx, ty;\n+    if (!PyArg_ParseTuple(args, \"dd:apply_translation\", &tx, &ty)) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP(\"apply_translation\", self->x->apply_translation(tx, ty));\n+\n+    Py_RETURN_NONE;\n+}\n+\n+const char *PyImage_as_rgba_str__doc__ =\n+    \"numrows, numcols, s = as_rgba_str()\"\n+    \"\\n\"\n+    \"Call this function after resize to get the data as string\\n\"\n+    \"The string is a numrows by numcols x 4 (RGBA) unsigned char buffer\\n\";\n+\n+static PyObject *PyImage_as_rgba_str(PyImage *self, PyObject *args, PyObject *kwds)\n+{\n+    // TODO: This performs a copy.  Use buffer interface when possible\n+\n+    PyObject *result = PyBytes_FromStringAndSize(NULL, self->x->rowsOut * self->x->colsOut * 4);\n+    if (result == NULL) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP_CLEANUP(\"as_rgba_str\",\n+                     (self->x->as_rgba_str((agg::int8u *)PyBytes_AsString(result))),\n+                     Py_DECREF(result));\n+\n+    return Py_BuildValue(\"nnN\", self->x->rowsOut, self->x->colsOut, result);\n+}\n+\n+const char *PyImage_color_conv__doc__ =\n+    \"numrows, numcols, buffer = color_conv(format)\"\n+    \"\\n\"\n+    \"format 0(BGRA) or 1(ARGB)\\n\"\n+    \"Convert image to format and return in a writable buffer\\n\";\n+\n+// TODO: This function is a terrible interface.  Change/remove?  Only\n+// used by Cairo backend.\n+\n+static PyObject *PyImage_color_conv(PyImage *self, PyObject *args, PyObject *kwds)\n+{\n+    int format;\n+\n+    if (!PyArg_ParseTuple(args, \"i:color_conv\", &format)) {\n+        return NULL;\n+    }\n+\n+    PyObject *result = PyBytes_FromStringAndSize(NULL, self->x->rowsOut * self->x->colsOut * 4);\n+    if (result == NULL) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP_CLEANUP(\"color_conv\",\n+                     (self->x->color_conv(format, (agg::int8u *)PyBytes_AsString(result))),\n+                     Py_DECREF(result));\n+\n+    return Py_BuildValue(\"nnN\", self->x->rowsOut, self->x->colsOut, result);\n+}\n+\n+const char *PyImage_buffer_rgba__doc__ =\n+    \"buffer = buffer_rgba()\"\n+    \"\\n\"\n+    \"Return the image buffer as rgba32\\n\";\n+\n+static PyObject *PyImage_buffer_rgba(PyImage *self, PyObject *args, PyObject *kwds)\n+{\n+#if PY3K\n+    return Py_BuildValue(\"nny#\",\n+                         self->x->rowsOut,\n+                         self->x->colsOut,\n+                         self->x->rbufOut,\n+                         self->x->rowsOut * self->x->colsOut * 4);\n+#else\n+    PyObject *buffer =\n+        PyBuffer_FromReadWriteMemory(self->x->rbufOut, self->x->rowsOut * self->x->colsOut * 4);\n+    if (buffer == NULL) {\n+        return NULL;\n+    }\n+\n+    return Py_BuildValue(\"nnN\", self->x->rowsOut, self->x->colsOut, buffer);\n+#endif\n+}\n+\n+const char *PyImage_reset_matrix__doc__ =\n+    \"reset_matrix()\"\n+    \"\\n\"\n+    \"Reset the transformation matrix\";\n+\n+static PyObject *PyImage_reset_matrix(PyImage *self, PyObject *args, PyObject *kwds)\n+{\n+    CALL_CPP(\"reset_matrix\", self->x->reset_matrix());\n+\n+    Py_RETURN_NONE;\n+}\n+\n+const char *PyImage_get_matrix__doc__ =\n+    \"(m11,m21,m12,m22,m13,m23) = get_matrix()\\n\"\n+    \"\\n\"\n+    \"Get the affine transformation matrix\\n\"\n+    \"  /m11,m12,m13\\\\\\n\"\n+    \"  /m21,m22,m23|\\n\"\n+    \"  \\\\ 0 , 0 , 1 /\";\n+\n+static PyObject *PyImage_get_matrix(PyImage *self, PyObject *args, PyObject *kwds)\n+{\n+    double m[6];\n+    self->x->srcMatrix.store_to(m);\n+\n+    return Py_BuildValue(\"dddddd\", m[0], m[1], m[2], m[3], m[4], m[5]);\n+}\n+\n+const char *PyImage_resize__doc__ =\n+    \"resize(width, height, norm=1, radius=4.0)\\n\"\n+    \"\\n\"\n+    \"Resize the image to width, height using interpolation\\n\"\n+    \"norm and radius are optional args for some of the filters\\n\";\n+\n+static PyObject *PyImage_resize(PyImage *self, PyObject *args, PyObject *kwds)\n+{\n+    double width;\n+    double height;\n+    double norm;\n+    double radius;\n+    const char *names[] = { \"width\", \"height\", \"norm\", \"radius\", NULL };\n+\n+    if (!PyArg_ParseTupleAndKeywords(\n+             args, kwds, \"dd|dd:resize\", (char **)names, &width, &height, &norm, &radius)) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP(\"resize\", (self->x->resize(width, height, norm, radius)));\n+\n+    Py_RETURN_NONE;\n+}\n+\n+const char *PyImage_get_interpolation__doc__ =\n+    \"get_interpolation()\\n\"\n+    \"\\n\"\n+    \"Get the interpolation scheme to one of the module constants, \"\n+    \"one of image.NEAREST, image.BILINEAR, etc...\";\n+\n+static PyObject *PyImage_get_interpolation(PyImage *self, PyObject *args, PyObject *kwds)\n+{\n+    return PyLong_FromLong(self->x->interpolation);\n+}\n+\n+const char *PyImage_set_interpolation__doc__ =\n+    \"set_interpolation(scheme)\\n\"\n+    \"\\n\"\n+    \"Set the interpolation scheme to one of the module constants, \"\n+    \"eg, image.NEAREST, image.BILINEAR, etc...\";\n+\n+static PyObject *PyImage_set_interpolation(PyImage *self, PyObject *args, PyObject *kwds)\n+{\n+    int method;\n+\n+    if (!PyArg_ParseTuple(args, \"i:set_interpolation\", &method)) {\n+        return NULL;\n+    }\n+\n+    self->x->interpolation = method;\n+\n+    Py_RETURN_NONE;\n+}\n+\n+const char *PyImage_get_aspect__doc__ =\n+    \"get_aspect()\\n\"\n+    \"\\n\"\n+    \"Get the aspect constraint constants\";\n+\n+static PyObject *PyImage_get_aspect(PyImage *self, PyObject *args, PyObject *kwds)\n+{\n+    return PyLong_FromLong(self->x->aspect);\n+}\n+\n+const char *PyImage_set_aspect__doc__ =\n+    \"set_aspect(scheme)\\n\"\n+    \"\\n\"\n+    \"Set the aspect ratio to one of the image module constant.\"\n+    \"eg, one of image.ASPECT_PRESERVE, image.ASPECT_FREE\";\n+\n+static PyObject *PyImage_set_aspect(PyImage *self, PyObject *args, PyObject *kwds)\n+{\n+    int scheme;\n+    if (!PyArg_ParseTuple(args, \"i:set_aspect\", &scheme)) {\n+        return NULL;\n+    }\n+\n+    self->x->aspect = scheme;\n+\n+    Py_RETURN_NONE;\n+}\n+\n+const char *PyImage_get_size__doc__ =\n+    \"numrows, numcols = get_size()\\n\"\n+    \"\\n\"\n+    \"Get the number or rows and columns of the input image\";\n+\n+static PyObject *PyImage_get_size(PyImage *self, PyObject *args, PyObject *kwds)\n+{\n+    return Py_BuildValue(\"ii\", self->x->rowsIn, self->x->colsIn);\n+}\n+\n+const char *PyImage_get_resample__doc__ =\n+    \"get_resample()\\n\"\n+    \"\\n\"\n+    \"Get the resample flag.\";\n+\n+static PyObject *PyImage_get_resample(PyImage *self, PyObject *args, PyObject *kwds)\n+{\n+    if (self->x->resample) {\n+        Py_RETURN_TRUE;\n+    }\n+    Py_RETURN_FALSE;\n+}\n+\n+const char *PyImage_set_resample__doc__ =\n+    \"set_resample(boolean)\\n\"\n+    \"\\n\"\n+    \"Set the resample flag.\";\n+\n+static PyObject *PyImage_set_resample(PyImage *self, PyObject *args, PyObject *kwds)\n+{\n+    int resample;\n+\n+    if (!PyArg_ParseTuple(args, \"i:set_resample\", &resample)) {\n+        return NULL;\n+    }\n+\n+    self->x->resample = resample;\n+\n+    Py_RETURN_NONE;\n+}\n+\n+const char *PyImage_get_size_out__doc__ =\n+    \"numrows, numcols = get_size_out()\\n\"\n+    \"\\n\"\n+    \"Get the number or rows and columns of the output image\";\n+\n+static PyObject *PyImage_get_size_out(PyImage *self, PyObject *args, PyObject *kwds)\n+{\n+    return Py_BuildValue(\"ii\", self->x->rowsOut, self->x->colsOut);\n+}\n+\n+static int PyImage_get_buffer(PyImage *self, Py_buffer *buf, int flags)\n+{\n+    Image *im = self->x;\n+\n+    Py_INCREF(self);\n+    buf->obj = (PyObject *)self;\n+    buf->buf = im->bufferOut;\n+    buf->len = im->colsOut * im->rowsOut * 4;\n+    buf->readonly = 0;\n+    buf->format = (char *)\"B\";\n+    buf->ndim = 3;\n+    self->shape[0] = im->rowsOut;\n+    self->shape[1] = im->colsOut;\n+    self->shape[2] = 4;\n+    buf->shape = self->shape;\n+    self->strides[0] = im->colsOut * 4;\n+    self->strides[1] = 4;\n+    self->strides[2] = 1;\n+    buf->strides = self->strides;\n+    buf->suboffsets = NULL;\n+    buf->itemsize = 1;\n+    buf->internal = NULL;\n+\n+    return 1;\n+}\n+\n+static PyTypeObject *PyImage_init_type(PyObject *m, PyTypeObject *type)\n+{\n+    static PyMethodDef methods[] = {\n+        {\"apply_rotation\", (PyCFunction)PyImage_apply_rotation, METH_VARARGS, PyImage_apply_rotation__doc__},\n+        {\"set_bg\", (PyCFunction)PyImage_set_bg, METH_VARARGS, PyImage_set_bg__doc__},\n+        {\"apply_scaling\", (PyCFunction)PyImage_apply_scaling, METH_VARARGS, PyImage_apply_scaling__doc__},\n+        {\"apply_translation\", (PyCFunction)PyImage_apply_translation, METH_VARARGS, PyImage_apply_translation__doc__},\n+        {\"as_rgba_str\", (PyCFunction)PyImage_as_rgba_str, METH_NOARGS, PyImage_as_rgba_str__doc__},\n+        {\"color_conv\", (PyCFunction)PyImage_color_conv, METH_VARARGS, PyImage_color_conv__doc__},\n+        {\"buffer_rgba\", (PyCFunction)PyImage_buffer_rgba, METH_NOARGS, PyImage_buffer_rgba__doc__},\n+        {\"reset_matrix\", (PyCFunction)PyImage_reset_matrix, METH_NOARGS, PyImage_reset_matrix__doc__},\n+        {\"get_matrix\", (PyCFunction)PyImage_get_matrix, METH_NOARGS, PyImage_get_matrix__doc__},\n+        {\"resize\", (PyCFunction)PyImage_resize, METH_VARARGS|METH_KEYWORDS, PyImage_resize__doc__},\n+        {\"get_interpolation\", (PyCFunction)PyImage_get_interpolation, METH_NOARGS, PyImage_get_interpolation__doc__},\n+        {\"set_interpolation\", (PyCFunction)PyImage_set_interpolation, METH_VARARGS, PyImage_set_interpolation__doc__},\n+        {\"get_aspect\", (PyCFunction)PyImage_get_aspect, METH_NOARGS, PyImage_get_aspect__doc__},\n+        {\"set_aspect\", (PyCFunction)PyImage_set_aspect, METH_VARARGS, PyImage_set_aspect__doc__},\n+        {\"get_size\", (PyCFunction)PyImage_get_size, METH_NOARGS, PyImage_get_size__doc__},\n+        {\"get_resample\", (PyCFunction)PyImage_get_resample, METH_VARARGS, PyImage_get_resample__doc__},\n+        {\"set_resample\", (PyCFunction)PyImage_set_resample, METH_VARARGS, PyImage_set_resample__doc__},\n+        {\"get_size_out\", (PyCFunction)PyImage_get_size_out, METH_VARARGS, PyImage_get_size_out__doc__},\n+        {NULL}\n+    };\n+\n+    static PyBufferProcs buffer_procs;\n+    memset(&buffer_procs, 0, sizeof(PyBufferProcs));\n+    buffer_procs.bf_getbuffer = (getbufferproc)PyImage_get_buffer;\n+\n+    memset(type, 0, sizeof(PyTypeObject));\n+    type->tp_name = \"matplotlib._image.Image\";\n+    type->tp_basicsize = sizeof(PyImage);\n+    type->tp_dealloc = (destructor)PyImage_dealloc;\n+    type->tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_NEWBUFFER;\n+    type->tp_methods = methods;\n+    type->tp_new = PyImage_new;\n+    type->tp_init = (initproc)PyImage_init;\n+    type->tp_as_buffer = &buffer_procs;\n+    type->tp_dictoffset = offsetof(PyImage, dict);\n+\n+    if (PyType_Ready(type) < 0) {\n+        return NULL;\n+    }\n+\n+    if (PyModule_AddObject(m, \"Image\", (PyObject *)type)) {\n+        return NULL;\n+    }\n+\n+    return type;\n+}\n+\n+/**********************************************************************\n+ * Free functions\n+ * */\n+\n+const char *image_from_images__doc__ =\n+    \"from_images(numrows, numcols, seq)\\n\"\n+    \"\\n\"\n+    \"return an image instance with numrows, numcols from a seq of image\\n\"\n+    \"instances using alpha blending.  seq is a list of (Image, ox, oy)\";\n+\n+static PyObject *image_from_images(PyObject *self, PyObject *args, PyObject *kwds)\n+{\n+    unsigned int numrows;\n+    unsigned int numcols;\n+    PyObject *images;\n+    size_t numimages;\n+\n+    if (!PyArg_ParseTuple(args, \"IIO:from_images\", &numrows, &numcols, &images)) {\n+        return NULL;\n+    }\n+\n+    if (!PySequence_Check(images)) {\n+        return NULL;\n+    }\n+\n+    Image *im = new Image(numrows, numcols, true);\n+    im->clear();\n+\n+    numimages = PySequence_Size(images);\n+\n+    for (size_t i = 0; i < numimages; ++i) {\n+        PyObject *entry = PySequence_GetItem(images, i);\n+        if (entry == NULL) {\n+            delete im;\n+            return NULL;\n+        }\n+\n+        PyObject *subimage;\n+        unsigned int x;\n+        unsigned int y;\n+        PyObject *alphaobj = NULL;\n+        double alpha = 0.0;\n+\n+        if (!PyArg_ParseTuple(entry, \"O!II|O\", &PyImageType, &subimage, &x, &y, &alphaobj)) {\n+            Py_DECREF(entry);\n+            delete im;\n+            return NULL;\n+        }\n+\n+        bool has_alpha = false;\n+        if (alphaobj != NULL && alphaobj != Py_None) {\n+            has_alpha = true;\n+            alpha = PyFloat_AsDouble(alphaobj);\n+            if (PyErr_Occurred()) {\n+                Py_DECREF(entry);\n+                delete im;\n+                return NULL;\n+            }\n+        }\n+\n+        CALL_CPP(\"from_images\",\n+                 (im->blend_image(*((PyImage *)subimage)->x, x, y, has_alpha, alpha)));\n+\n+        Py_DECREF(entry);\n+    }\n+\n+    return PyImage_cnew(im);\n+}\n+\n+const char *image_fromarray__doc__ =\n+    \"fromarray(A, isoutput)\\n\"\n+    \"\\n\"\n+    \"Load the image from a numpy array\\n\"\n+    \"By default this function fills the input buffer, which can subsequently\\n\"\n+    \"be resampled using resize.  If isoutput=1, fill the output buffer.\\n\"\n+    \"This is used to support raw pixel images w/o resampling\\n\";\n+\n+static PyObject *image_fromarray(PyObject *self, PyObject *args, PyObject *kwds)\n+{\n+    PyObject *array;\n+    int isoutput;\n+    const char *names[] = { \"array\", \"isoutput\", NULL };\n+\n+    if (!PyArg_ParseTupleAndKeywords(\n+             args, kwds, \"O|i:fromarray\", (char **)names, &array, &isoutput)) {\n+        return NULL;\n+    }\n+\n+    numpy::array_view<const double, 3> color_array;\n+    numpy::array_view<const double, 2> grey_array;\n+    Image *result = NULL;\n+\n+    if (numpy::convert_array<const double, 3>(array, &color_array)) {\n+        CALL_CPP(\"fromarray\", result = from_color_array(color_array, isoutput));\n+    } else if (numpy::convert_array<const double, 2>(array, &grey_array)) {\n+        CALL_CPP(\"fromarray\", result = from_grey_array(grey_array, isoutput));\n+    } else {\n+        PyErr_SetString(PyExc_ValueError, \"invalid array\");\n+        return NULL;\n+    }\n+\n+    return PyImage_cnew(result);\n+}\n+\n+const char *image_frombyte__doc__ =\n+    \"frombyte(A, isoutput)\\n\"\n+    \"\\n\"\n+    \"Load the image from a byte array.\\n\"\n+    \"By default this function fills the input buffer, which can subsequently\\n\"\n+    \"be resampled using resize.  If isoutput=1, fill the output buffer.\\n\"\n+    \"This is used to support raw pixel images w/o resampling.\";\n+\n+static PyObject *image_frombyte(PyObject *self, PyObject *args, PyObject *kwds)\n+{\n+    numpy::array_view<const uint8_t, 3> array;\n+    int isoutput;\n+    const char *names[] = { \"array\", \"isoutput\", NULL };\n+    Image *result;\n+\n+    if (!PyArg_ParseTupleAndKeywords(args,\n+                                     kwds,\n+                                     \"O&|i:frombyte\",\n+                                     (char **)names,\n+                                     &numpy::convert_array_contiguous<const uint8_t, 3>,\n+                                     &array,\n+                                     &isoutput)) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP(\"frombyte\", (result = frombyte(array, isoutput)));\n+\n+    return PyImage_cnew(result);\n+}\n+\n+const char *image_frombuffer__doc__ =\n+    \"frombuffer(buffer, width, height, isoutput)\\n\"\n+    \"\\n\"\n+    \"Load the image from a character buffer\\n\"\n+    \"By default this function fills the input buffer, which can subsequently\\n\"\n+    \"be resampled using resize.  If isoutput=1, fill the output buffer.\\n\"\n+    \"This is used to support raw pixel images w/o resampling.\";\n+\n+static PyObject *image_frombuffer(PyObject *self, PyObject *args, PyObject *kwds)\n+{\n+    PyObject *buffer;\n+    unsigned x;\n+    unsigned y;\n+    int isoutput;\n+    const char *names[] = { \"buffer\", \"x\", \"y\", \"isoutput\", NULL };\n+\n+    if (!PyArg_ParseTupleAndKeywords(\n+             args, kwds, \"OII|i:frombuffer\", (char **)names, &buffer, &x, &y, &isoutput)) {\n+        return NULL;\n+    }\n+\n+    const void *rawbuf;\n+    Py_ssize_t buflen;\n+    if (PyObject_AsReadBuffer(buffer, &rawbuf, &buflen) != 0) {\n+        return NULL;\n+    }\n+\n+    if (buflen != (Py_ssize_t)(y * x * 4)) {\n+        PyErr_SetString(PyExc_ValueError, \"Buffer is incorrect length\");\n+        return NULL;\n+    }\n+\n+    Image *im;\n+    CALL_CPP(\"frombuffer\", (im = new Image(y, x, isoutput)));\n+\n+    agg::int8u *inbuf = (agg::int8u *)rawbuf;\n+    agg::int8u *outbuf;\n+    if (isoutput) {\n+        outbuf = im->bufferOut;\n+    } else {\n+        outbuf = im->bufferIn;\n+    }\n+\n+    for (int i = (x * 4) * (y - 1); i >= 0; i -= (x * 4)) {\n+        memmove(outbuf, &inbuf[i], (x * 4));\n+        outbuf += x * 4;\n+    }\n+\n+    return PyImage_cnew(im);\n+}\n+\n+const char *image_pcolor__doc__ =\n+    \"pcolor(x, y, data, rows, cols, bounds)\\n\"\n+    \"\\n\"\n+    \"Generate a pseudo-color image from data on a non-uniform grid using\\n\"\n+    \"nearest neighbour or linear interpolation.\\n\"\n+    \"bounds = (x_min, x_max, y_min, y_max)\\n\"\n+    \"interpolation = NEAREST or BILINEAR \\n\";\n+\n+static PyObject *image_pcolor(PyObject *self, PyObject *args, PyObject *kwds)\n+{\n+    numpy::array_view<const float, 1> x;\n+    numpy::array_view<const float, 1> y;\n+    numpy::array_view<const agg::int8u, 3> d;\n+    unsigned int rows;\n+    unsigned int cols;\n+    float bounds[4];\n+    int interpolation;\n+    Image *result;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"O&O&O&II(ffff)i:pcolor\",\n+                          &numpy::convert_array_contiguous<const float, 1>,\n+                          &x,\n+                          &numpy::convert_array_contiguous<const float, 1>,\n+                          &y,\n+                          &numpy::convert_array_contiguous<const agg::int8u, 3>,\n+                          &d,\n+                          &rows,\n+                          &cols,\n+                          &bounds[0],\n+                          &bounds[1],\n+                          &bounds[2],\n+                          &bounds[3],\n+                          &interpolation)) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP(\"pcolor\", (result = pcolor(x, y, d, rows, cols, bounds, interpolation)));\n+\n+    return PyImage_cnew(result);\n+}\n+\n+const char *image_pcolor2__doc__ =\n+    \"pcolor2(x, y, data, rows, cols, bounds, bg)\\n\"\n+    \"\\n\"\n+    \"Generate a pseudo-color image from data on a non-uniform grid\\n\"\n+    \"specified by its cell boundaries.\\n\"\n+    \"bounds = (x_left, x_right, y_bot, y_top)\\n\"\n+    \"bg = ndarray of 4 uint8 representing background rgba\\n\";\n+\n+static PyObject *image_pcolor2(PyObject *self, PyObject *args, PyObject *kwds)\n+{\n+    numpy::array_view<const double, 1> x;\n+    numpy::array_view<const double, 1> y;\n+    numpy::array_view<const agg::int8u, 3> d;\n+    unsigned int rows;\n+    unsigned int cols;\n+    float bounds[4];\n+    numpy::array_view<const agg::int8u, 1> bg;\n+    Image *result;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"O&O&O&II(ffff)O&:pcolor2\",\n+                          &numpy::convert_array_contiguous<const double, 1>,\n+                          &x,\n+                          &numpy::convert_array_contiguous<const double, 1>,\n+                          &y,\n+                          &numpy::convert_array<const agg::int8u, 3>,\n+                          &d,\n+                          &rows,\n+                          &cols,\n+                          &bounds[0],\n+                          &bounds[1],\n+                          &bounds[2],\n+                          &bounds[3],\n+                          &numpy::convert_array<const agg::int8u, 1>,\n+                          &bg)) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP(\"pcolor2\", (result = pcolor2(x, y, d, rows, cols, bounds, bg)));\n+\n+    return PyImage_cnew(result);\n+}\n+\n+static PyMethodDef module_functions[] = {\n+    {\"from_images\", (PyCFunction)image_from_images, METH_VARARGS, image_from_images__doc__},\n+    {\"fromarray\", (PyCFunction)image_fromarray, METH_VARARGS|METH_KEYWORDS, image_fromarray__doc__},\n+    {\"frombyte\", (PyCFunction)image_frombyte, METH_VARARGS|METH_KEYWORDS, image_frombyte__doc__},\n+    {\"frombuffer\", (PyCFunction)image_frombuffer, METH_VARARGS|METH_KEYWORDS, image_frombuffer__doc__},\n+    {\"pcolor\", (PyCFunction)image_pcolor, METH_VARARGS, image_pcolor__doc__},\n+    {\"pcolor2\", (PyCFunction)image_pcolor2, METH_VARARGS, image_pcolor2__doc__},\n+    {NULL}\n+};\n+\n+extern \"C\" {\n+\n+struct module_state\n+{\n+/* The Sun compiler can't handle empty structs */\n+#if defined(__SUNPRO_C) || defined(_MSC_VER)\n+    int _dummy;\n+#endif\n+};\n+\n+#if PY3K\n+static struct PyModuleDef moduledef = {\n+    PyModuleDef_HEAD_INIT,\n+    \"_image\",\n+    NULL,\n+    sizeof(struct module_state),\n+    module_functions,\n+    NULL,\n+    NULL,\n+    NULL,\n+    NULL\n+};\n+\n+#define INITERROR return NULL\n+\n+PyMODINIT_FUNC PyInit__image(void)\n+\n+#else\n+#define INITERROR return\n+\n+PyMODINIT_FUNC init_image(void)\n+#endif\n+\n+{\n+    PyObject *m;\n+\n+#if PY3K\n+    m = PyModule_Create(&moduledef);\n+#else\n+    m = Py_InitModule3(\"_image\", module_functions, NULL);\n+#endif\n+\n+    if (m == NULL) {\n+        INITERROR;\n+    }\n+\n+    import_array();\n+\n+    if (!PyImage_init_type(m, &PyImageType)) {\n+        INITERROR;\n+    }\n+\n+    PyObject *d = PyModule_GetDict(m);\n+\n+    if (add_dict_int(d, \"NEAREST\", Image::NEAREST) ||\n+        add_dict_int(d, \"BILINEAR\", Image::BILINEAR) ||\n+        add_dict_int(d, \"BICUBIC\", Image::BICUBIC) ||\n+        add_dict_int(d, \"SPLINE16\", Image::SPLINE16) ||\n+        add_dict_int(d, \"SPLINE36\", Image::SPLINE36) ||\n+        add_dict_int(d, \"HANNING\", Image::HANNING) ||\n+        add_dict_int(d, \"HAMMING\", Image::HAMMING) ||\n+        add_dict_int(d, \"HERMITE\", Image::HERMITE) ||\n+        add_dict_int(d, \"KAISER\", Image::KAISER) ||\n+        add_dict_int(d, \"QUADRIC\", Image::QUADRIC) ||\n+        add_dict_int(d, \"CATROM\", Image::CATROM) ||\n+        add_dict_int(d, \"GAUSSIAN\", Image::GAUSSIAN) ||\n+        add_dict_int(d, \"BESSEL\", Image::BESSEL) ||\n+        add_dict_int(d, \"MITCHELL\", Image::MITCHELL) ||\n+        add_dict_int(d, \"SINC\", Image::SINC) ||\n+        add_dict_int(d, \"LANCZOS\", Image::LANCZOS) ||\n+        add_dict_int(d, \"BLACKMAN\", Image::BLACKMAN) ||\n+\n+        add_dict_int(d, \"ASPECT_FREE\", Image::ASPECT_FREE) ||\n+        add_dict_int(d, \"ASPECT_PRESERVE\", Image::ASPECT_PRESERVE)) {\n+        INITERROR;\n+    }\n+\n+    import_array();\n+\n+#if PY3K\n+    return m;\n+#endif\n+}\n+\n+} // extern \"C\""}
{"patches_id": 2, "files_id": 38, "language": "m", "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_macosx.m", "raw_code": "#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n#include <sys/socket.h>\n#include <Python.h>\n#include \"numpy/arrayobject.h\"\n#include \"path_cleanup.h\"\n\n#if PY_MAJOR_VERSION >= 3\n#define PY3K 1\n#else\n#define PY3K 0\n#endif\n\n#if (PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION >=3)\n#define PY33 1\n#else\n#define PY33 0\n#endif\n\n/* Must define Py_TYPE for Python 2.5 or older */\n#ifndef Py_TYPE\n# define Py_TYPE(o) ((o)->ob_type)\n#endif\n\n/* Must define PyVarObject_HEAD_INIT for Python 2.5 or older */\n#ifndef PyVarObject_HEAD_INIT\n#define PyVarObject_HEAD_INIT(type, size)       \\\n        PyObject_HEAD_INIT(type) size,\n#endif\n\n/* Proper way to check for the OS X version we are compiling for, from\n   http://developer.apple.com/documentation/DeveloperTools/Conceptual/cross_development */\n#if __MAC_OS_X_VERSION_MIN_REQUIRED >= 1050\n#define COMPILING_FOR_10_5\n#endif\n#if __MAC_OS_X_VERSION_MIN_REQUIRED >= 1060\n#define COMPILING_FOR_10_6\n#endif\n\nstatic int nwin = 0;   /* The number of open windows */\n\n/* Use Atsui for Mac OS X 10.4, CoreText for Mac OS X 10.5 */\n#ifndef COMPILING_FOR_10_5\nstatic int ngc = 0;    /* The number of graphics contexts in use */\n\n\n/* For drawing Unicode strings with ATSUI */\nstatic ATSUStyle style = NULL;\nstatic ATSUTextLayout layout = NULL;\n#endif\n\n/* CGFloat was defined in Mac OS X 10.5 */\n#ifndef CGFLOAT_DEFINED\n#define CGFloat float\n#endif\n\n\n/* Various NSApplicationDefined event subtypes */\n#define STDIN_READY 0\n#define SIGINT_CALLED 1\n#define STOP_EVENT_LOOP 2\n#define WINDOW_CLOSING 3\n\n/* Path definitions */\n#define STOP      0\n#define MOVETO    1\n#define LINETO    2\n#define CURVE3    3\n#define CURVE4    4\n#define CLOSEPOLY 0x4f\n\n/* Hatching */\n#define HATCH_SIZE 72\n\n/* -------------------------- Helper function ---------------------------- */\n\nstatic void stdin_ready(CFReadStreamRef readStream, CFStreamEventType eventType, void* context)\n{\n    NSEvent* event = [NSEvent otherEventWithType: NSApplicationDefined\n                                        location: NSZeroPoint\n                                   modifierFlags: 0\n                                       timestamp: 0.0\n                                    windowNumber: 0\n                                         context: nil\n                                         subtype: STDIN_READY\n                                           data1: 0\n                                           data2: 0];\n    [NSApp postEvent: event atStart: true];\n}\n\nstatic int sigint_fd = -1;\n\nstatic void _sigint_handler(int sig)\n{\n    const char c = 'i';\n    write(sigint_fd, &c, 1);\n}\n\nstatic void _callback(CFSocketRef s,\n                      CFSocketCallBackType type,\n                      CFDataRef address,\n                      const void * data,\n                      void *info)\n{\n    char c;\n    CFSocketNativeHandle handle = CFSocketGetNative(s);\n    read(handle, &c, 1);\n    NSEvent* event = [NSEvent otherEventWithType: NSApplicationDefined\n                                        location: NSZeroPoint\n                                   modifierFlags: 0\n                                       timestamp: 0.0\n                                    windowNumber: 0\n                                         context: nil\n                                         subtype: SIGINT_CALLED\n                                           data1: 0\n                                           data2: 0];\n    [NSApp postEvent: event atStart: true];\n}\n\nstatic int wait_for_stdin(void)\n{\n    const UInt8 buffer[] = \"/dev/fd/0\";\n    const CFIndex n = (CFIndex)strlen((char*)buffer);\n    CFRunLoopRef runloop = CFRunLoopGetCurrent();\n    CFURLRef url = CFURLCreateFromFileSystemRepresentation(kCFAllocatorDefault,\n                                                           buffer,\n                                                           n,\n                                                           false);\n    CFReadStreamRef stream = CFReadStreamCreateWithFile(kCFAllocatorDefault,\n                                                        url);\n    CFRelease(url);\n\n    CFReadStreamOpen(stream);\n    if (!CFReadStreamHasBytesAvailable(stream))\n    /* This is possible because of how PyOS_InputHook is called from Python */\n    {\n        int error;\n        int interrupted = 0;\n        int channel[2];\n        CFSocketRef sigint_socket = NULL;\n        PyOS_sighandler_t py_sigint_handler = NULL;\n        CFStreamClientContext clientContext = {0, NULL, NULL, NULL, NULL};\n        CFReadStreamSetClient(stream,\n                              kCFStreamEventHasBytesAvailable,\n                              stdin_ready,\n                              &clientContext);\n        CFReadStreamScheduleWithRunLoop(stream, runloop, kCFRunLoopCommonModes);\n        error = pipe(channel);\n        if (error==0)\n        {\n            fcntl(channel[1], F_SETFL, O_WRONLY | O_NONBLOCK);\n\n            sigint_socket = CFSocketCreateWithNative(kCFAllocatorDefault,\n                                                     channel[0],\n                                                     kCFSocketReadCallBack,\n                                                     _callback,\n                                                     NULL);\n            if (sigint_socket)\n            {\n                CFRunLoopSourceRef source;\n                source = CFSocketCreateRunLoopSource(kCFAllocatorDefault,\n                                                     sigint_socket,\n                                                     0);\n                CFRelease(sigint_socket);\n                if (source)\n                {\n                    CFRunLoopAddSource(runloop, source, kCFRunLoopDefaultMode);\n                    CFRelease(source);\n                    sigint_fd = channel[1];\n                    py_sigint_handler = PyOS_setsig(SIGINT, _sigint_handler);\n                }\n            }\n            else\n                close(channel[0]);\n        }\n\n        NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];\n        NSDate* date = [NSDate distantFuture];\n        while (true)\n        {   NSEvent* event = [NSApp nextEventMatchingMask: NSAnyEventMask\n                                                untilDate: date\n                                                   inMode: NSDefaultRunLoopMode\n                                                  dequeue: YES];\n           if (!event) break; /* No windows open */\n           if ([event type]==NSApplicationDefined)\n           {   short subtype = [event subtype];\n               if (subtype==STDIN_READY) break;\n               if (subtype==SIGINT_CALLED)\n               {   interrupted = true;\n                   break;\n               }\n           }\n           [NSApp sendEvent: event];\n        }\n        [pool release];\n\n        if (py_sigint_handler) PyOS_setsig(SIGINT, py_sigint_handler);\n        CFReadStreamUnscheduleFromRunLoop(stream,\n                                          runloop,\n                                          kCFRunLoopCommonModes);\n        if (sigint_socket) CFSocketInvalidate(sigint_socket);\n        if (error==0) close(channel[1]);\n        if (interrupted) raise(SIGINT);\n    }\n    CFReadStreamClose(stream);\n    CFRelease(stream);\n    return 1;\n}\n\n#ifndef COMPILING_FOR_10_5\nstatic int _init_atsui(void)\n{\n    OSStatus status;\n\n    status = ATSUCreateStyle(&style);\n    if (status!=noErr)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"ATSUCreateStyle failed\");\n        return 0;\n    }\n\n    status = ATSUCreateTextLayout(&layout);\n    if (status!=noErr)\n    {\n        status = ATSUDisposeStyle(style);\n        if (status!=noErr)\n            PyErr_WarnEx(PyExc_RuntimeWarning, \"ATSUDisposeStyle failed\", 1);\n        PyErr_SetString(PyExc_RuntimeError, \"ATSUCreateTextLayout failed\");\n        return 0;\n    }\n\n\n    return 1;\n}\n\nstatic void _dealloc_atsui(void)\n{\n    OSStatus status;\n\n    status = ATSUDisposeStyle(style);\n    if (status!=noErr)\n        PyErr_WarnEx(PyExc_RuntimeWarning, \"ATSUDisposeStyle failed\", 1);\n\n    status = ATSUDisposeTextLayout(layout);\n    if (status!=noErr)\n        PyErr_WarnEx(PyExc_RuntimeWarning, \"ATSUDisposeTextLayout failed\", 1);\n}\n#endif\n\nstatic int _draw_path(CGContextRef cr, void* iterator, int nmax)\n{\n    double x1, y1, x2, y2;\n    static unsigned code = STOP;\n    static double xs, ys;\n    CGPoint current;\n    int n = 0;\n\n    if (code == MOVETO) CGContextMoveToPoint(cr, xs, ys);\n\n    while (true)\n    {\n        code = get_vertex(iterator, &x1, &y1);\n        if (code == CLOSEPOLY)\n        {\n            CGContextClosePath(cr);\n            n++;\n        }\n        else if (code == STOP)\n        {\n            break;\n        }\n        else if (code == MOVETO)\n        {\n            CGContextMoveToPoint(cr, x1, y1);\n        }\n        else if (code==LINETO)\n        {\n            CGContextAddLineToPoint(cr, x1, y1);\n            n++;\n        }\n        else if (code==CURVE3)\n        {\n            get_vertex(iterator, &xs, &ys);\n            CGContextAddQuadCurveToPoint(cr, x1, y1, xs, ys);\n            n+=2;\n        }\n        else if (code==CURVE4)\n        {\n            get_vertex(iterator, &x2, &y2);\n            get_vertex(iterator, &xs, &ys);\n            CGContextAddCurveToPoint(cr, x1, y1, x2, y2, xs, ys);\n            n+=3;\n        }\n        if (n >= nmax)\n        {\n            switch (code)\n            {\n                case MOVETO:\n                case LINETO:\n                    xs = x1;\n                    ys = y1;\n                    break;\n                case CLOSEPOLY:\n                    current = CGContextGetPathCurrentPoint(cr);\n                    xs = current.x;\n                    ys = current.y;\n                    break;\n                /* nothing needed for CURVE3, CURVE4 */\n            }\n            code = MOVETO;\n            return -n;\n        }\n    }\n    return n;\n}\n\nstatic void _draw_hatch(void *info, CGContextRef cr)\n{\n    int n;\n    PyObject* hatchpath = (PyObject*)info;\n    PyObject* transform;\n    int nd = 2;\n    npy_intp dims[2] = {3, 3};\n    int typenum = NPY_DOUBLE;\n    double data[9] = {HATCH_SIZE, 0, 0, 0, HATCH_SIZE, 0, 0, 0, 1};\n    double rect[4] = { 0.0, 0.0, HATCH_SIZE, HATCH_SIZE};\n    transform = PyArray_SimpleNewFromData(nd, dims, typenum, data);\n    if (!transform)\n    {\n        PyGILState_STATE gstate = PyGILState_Ensure();\n        PyErr_Print();\n        PyGILState_Release(gstate);\n        return;\n    }\n    void* iterator  = get_path_iterator(hatchpath,\n                                        transform,\n                                        0,\n                                        0,\n                                        rect,\n                                        SNAP_FALSE,\n                                        1.0,\n                                        0);\n    Py_DECREF(transform);\n    if (!iterator)\n    {\n        PyGILState_STATE gstate = PyGILState_Ensure();\n        PyErr_SetString(PyExc_RuntimeError, \"failed to obtain path iterator for hatching\");\n        PyErr_Print();\n        PyGILState_Release(gstate);\n        return;\n    }\n    n = _draw_path(cr, iterator, INT_MAX);\n    free_path_iterator(iterator);\n    if (n==0) return;\n    CGContextSetLineWidth(cr, 1.0);\n    CGContextSetLineCap(cr, kCGLineCapSquare);\n    CGContextDrawPath(cr, kCGPathFillStroke);\n}\n\nstatic void _release_hatch(void* info)\n{\n    PyObject* hatchpath = (PyObject*)info;\n    Py_DECREF(hatchpath);\n}\n\n/* ---------------------------- Cocoa classes ---------------------------- */\n\n\n@interface Window : NSWindow\n{   PyObject* manager;\n}\n- (Window*)initWithContentRect:(NSRect)rect styleMask:(unsigned int)mask backing:(NSBackingStoreType)bufferingType defer:(BOOL)deferCreation withManager: (PyObject*)theManager;\n- (NSRect)constrainFrameRect:(NSRect)rect toScreen:(NSScreen*)screen;\n- (BOOL)closeButtonPressed;\n- (void)close;\n- (void)dealloc;\n@end\n\n@interface ToolWindow : NSWindow\n{\n}\n- (ToolWindow*)initWithContentRect:(NSRect)rect master:(NSWindow*)window;\n- (void)masterCloses:(NSNotification*)notification;\n- (void)close;\n@end\n\n#ifdef COMPILING_FOR_10_6\n@interface View : NSView <NSWindowDelegate>\n#else\n@interface View : NSView\n#endif\n{   PyObject* canvas;\n    NSRect rubberband;\n    BOOL inside;\n    NSTrackingRectTag tracking;\n}\n- (void)dealloc;\n- (void)drawRect:(NSRect)rect;\n- (void)windowDidResize:(NSNotification*)notification;\n- (View*)initWithFrame:(NSRect)rect;\n- (void)setCanvas: (PyObject*)newCanvas;\n- (void)windowWillClose:(NSNotification*)notification;\n- (BOOL)windowShouldClose:(NSNotification*)notification;\n- (BOOL)isFlipped;\n- (void)mouseEntered:(NSEvent*)event;\n- (void)mouseExited:(NSEvent*)event;\n- (void)mouseDown:(NSEvent*)event;\n- (void)mouseUp:(NSEvent*)event;\n- (void)mouseDragged:(NSEvent*)event;\n- (void)mouseMoved:(NSEvent*)event;\n- (void)rightMouseDown:(NSEvent*)event;\n- (void)rightMouseUp:(NSEvent*)event;\n- (void)rightMouseDragged:(NSEvent*)event;\n- (void)otherMouseDown:(NSEvent*)event;\n- (void)otherMouseUp:(NSEvent*)event;\n- (void)otherMouseDragged:(NSEvent*)event;\n- (void)setRubberband:(NSRect)rect;\n- (void)removeRubberband;\n- (const char*)convertKeyEvent:(NSEvent*)event;\n- (void)keyDown:(NSEvent*)event;\n- (void)keyUp:(NSEvent*)event;\n- (void)scrollWheel:(NSEvent *)event;\n- (BOOL)acceptsFirstResponder;\n//- (void)flagsChanged:(NSEvent*)event;\n@end\n\n@interface ScrollableButton : NSButton\n{\n    SEL scrollWheelUpAction;\n    SEL scrollWheelDownAction;\n}\n- (void)setScrollWheelUpAction:(SEL)action;\n- (void)setScrollWheelDownAction:(SEL)action;\n- (void)scrollWheel:(NSEvent *)event;\n@end\n\n@interface MenuItem: NSMenuItem\n{   int index;\n}\n+ (MenuItem*)menuItemWithTitle:(NSString*)title;\n+ (MenuItem*)menuItemSelectAll;\n+ (MenuItem*)menuItemInvertAll;\n+ (MenuItem*)menuItemForAxis:(int)i;\n- (void)toggle:(id)sender;\n- (void)selectAll:(id)sender;\n- (void)invertAll:(id)sender;\n- (int)index;\n@end\n\n/* ---------------------------- Python classes ---------------------------- */\n\ntypedef struct {\n    PyObject_HEAD\n    CGContextRef cr;\n    NSSize size;\n    int level;\n    BOOL forced_alpha;\n    CGFloat color[4];\n    float dpi;\n} GraphicsContext;\n\nstatic CGMutablePathRef _create_path(void* iterator)\n{\n    unsigned code;\n    CGMutablePathRef p;\n    double x1, y1, x2, y2, x3, y3;\n\n    p = CGPathCreateMutable();\n    if (!p) return NULL;\n\n    while (true)\n    {\n        code = get_vertex(iterator, &x1, &y1);\n        if (code == CLOSEPOLY)\n        {\n            CGPathCloseSubpath(p);\n        }\n        else if (code == STOP)\n        {\n            break;\n        }\n        else if (code == MOVETO)\n        {\n            CGPathMoveToPoint(p, NULL, x1, y1);\n        }\n        else if (code==LINETO)\n        {\n            CGPathAddLineToPoint(p, NULL, x1, y1);\n        }\n        else if (code==CURVE3)\n        {\n            get_vertex(iterator, &x2, &y2);\n            CGPathAddQuadCurveToPoint(p, NULL, x1, y1, x2, y2);\n        }\n        else if (code==CURVE4)\n        {\n            get_vertex(iterator, &x2, &y2);\n            get_vertex(iterator, &x3, &y3);\n            CGPathAddCurveToPoint(p, NULL, x1, y1, x2, y2, x3, y3);\n        }\n    }\n\n    return p;\n}\n\nstatic int _get_snap(GraphicsContext* self, enum e_snap_mode* mode)\n{\n    PyObject* snap = PyObject_CallMethod((PyObject*)self, \"get_snap\", \"\");\n    if(!snap) return 0;\n    if(snap==Py_None) *mode = SNAP_AUTO;\n    else if (PyBool_Check(snap)) *mode = SNAP_TRUE;\n    else *mode = SNAP_FALSE;\n    Py_DECREF(snap);\n    return 1;\n}\n\nstatic PyObject*\nGraphicsContext_new(PyTypeObject* type, PyObject *args, PyObject *kwds)\n{\n    GraphicsContext* self = (GraphicsContext*)type->tp_alloc(type, 0);\n    if (!self) return NULL;\n    self->cr = NULL;\n    self->level = 0;\n    self->forced_alpha = FALSE;\n\n#ifndef COMPILING_FOR_10_5\n    if (ngc==0)\n    {\n        int ok = _init_atsui();\n        if (!ok)\n        {\n            return NULL;\n        }\n    }\n    ngc++;\n#endif\n\n    return (PyObject*) self;\n}\n\n#ifndef COMPILING_FOR_10_5\nstatic void\nGraphicsContext_dealloc(GraphicsContext *self)\n{\n    ngc--;\n    if (ngc==0) _dealloc_atsui();\n\n    Py_TYPE(self)->tp_free((PyObject*)self);\n}\n#endif\n\nstatic PyObject*\nGraphicsContext_repr(GraphicsContext* self)\n{\n#if PY3K\n    return PyUnicode_FromFormat(\"GraphicsContext object %p wrapping the Quartz 2D graphics context %p\", (void*)self, (void*)(self->cr));\n#else\n    return PyString_FromFormat(\"GraphicsContext object %p wrapping the Quartz 2D graphics context %p\", (void*)self, (void*)(self->cr));\n#endif\n}\n\nstatic PyObject*\nGraphicsContext_save (GraphicsContext* self)\n{\n    CGContextRef cr = self->cr;\n    if (!cr)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"CGContextRef is NULL\");\n        return NULL;\n    }\n    CGContextSaveGState(cr);\n    self->level++;\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyObject*\nGraphicsContext_restore (GraphicsContext* self)\n{\n    CGContextRef cr = self->cr;\n    if (!cr)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"CGContextRef is NULL\");\n        return NULL;\n    }\n    if (self->level==0)\n    {\n        PyErr_SetString(PyExc_RuntimeError,\n            \"Attempting to execute CGContextRestoreGState on an empty stack\");\n        return NULL;\n    }\n    CGContextRestoreGState(cr);\n    self->level--;\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyObject*\nGraphicsContext_set_alpha (GraphicsContext* self, PyObject* args)\n{\n    float alpha;\n    int forced = 0;\n    if (!PyArg_ParseTuple(args, \"f|i\", &alpha, &forced)) return NULL;\n    CGContextRef cr = self->cr;\n    if (!cr)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"CGContextRef is NULL\");\n        return NULL;\n    }\n    CGContextSetAlpha(cr, alpha);\n    self->forced_alpha = (BOOL)(forced || (alpha != 1.0));\n\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic BOOL\n_set_antialiased(CGContextRef cr, PyObject* antialiased)\n{\n    const int shouldAntialias = PyObject_IsTrue(antialiased);\n    if (shouldAntialias < 0)\n    {\n        PyErr_SetString(PyExc_ValueError,\n                        \"Failed to read antialiaseds variable\");\n        return false;\n    }\n    CGContextSetShouldAntialias(cr, shouldAntialias);\n    return true;\n}\n\nstatic PyObject*\nGraphicsContext_set_antialiased (GraphicsContext* self, PyObject* args)\n{\n    CGContextRef cr = self->cr;\n    if (!cr)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"CGContextRef is NULL\");\n        return NULL;\n    }\n    if (!_set_antialiased(cr, args)) return NULL;\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyObject*\nGraphicsContext_set_capstyle (GraphicsContext* self, PyObject* args)\n{\n    char* string;\n    CGLineCap cap;\n\n    if (!PyArg_ParseTuple(args, \"s\", &string)) return NULL;\n\n    if (!strcmp(string, \"butt\")) cap = kCGLineCapButt;\n    else if (!strcmp(string, \"round\")) cap = kCGLineCapRound;\n    else if (!strcmp(string, \"projecting\")) cap = kCGLineCapSquare;\n    else\n    {\n        PyErr_SetString(PyExc_ValueError,\n                        \"capstyle should be 'butt', 'round', or 'projecting'\");\n        return NULL;\n    }\n    CGContextRef cr = self->cr;\n    if (!cr)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"CGContextRef is NULL\");\n        return NULL;\n    }\n    CGContextSetLineCap(cr, cap);\n\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyObject*\nGraphicsContext_set_clip_rectangle (GraphicsContext* self, PyObject* args)\n{\n    CGRect rect;\n    float x, y, width, height;\n    if (!PyArg_ParseTuple(args, \"(ffff)\", &x, &y, &width, &height)) return NULL;\n\n    rect.origin.x = x;\n    rect.origin.y = y;\n    rect.size.width = width;\n    rect.size.height = height;\n\n    CGContextRef cr = self->cr;\n    if (!cr)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"CGContextRef is NULL\");\n        return NULL;\n    }\n\n    CGContextClipToRect(cr, rect);\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyObject*\nGraphicsContext_set_clip_path (GraphicsContext* self, PyObject* args)\n{\n    int n;\n    CGContextRef cr = self->cr;\n\n    PyObject* path;\n    int nd = 2;\n    npy_intp dims[2] = {3, 3};\n    int typenum = NPY_DOUBLE;\n    double data[] = {1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0};\n\n    if (!cr)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"CGContextRef is NULL\");\n        return NULL;\n    }\n\n    if(!PyArg_ParseTuple(args, \"O\", &path)) return NULL;\n\n    PyObject* transform = PyArray_SimpleNewFromData(nd, dims, typenum, data);\n    if (!transform) return NULL;\n\n    double rect[4] = {0.0, 0.0, self->size.width, self->size.height};\n    void* iterator  = get_path_iterator(path,\n                                        transform,\n                                        0,\n                                        0,\n                                        rect,\n                                        SNAP_AUTO,\n                                        1.0,\n                                        0);\n    Py_DECREF(transform);\n    if (!iterator)\n    {\n        PyErr_SetString(PyExc_RuntimeError,\n            \"set_clip_path: failed to obtain path iterator for clipping\");\n        return NULL;\n    }\n    n = _draw_path(cr, iterator, INT_MAX);\n    free_path_iterator(iterator);\n\n    if (n > 0) CGContextClip(cr);\n\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic BOOL\n_set_dashes(CGContextRef cr, PyObject* linestyle)\n{\n    CGFloat phase = 0.0;\n    PyObject* offset;\n    PyObject* dashes;\n\n    if (!PyArg_ParseTuple(linestyle, \"OO\", &offset, &dashes))\n    {\n        PyErr_SetString(PyExc_TypeError,\n            \"failed to obtain the offset and dashes from the linestyle\");\n        return false;\n    }\n\n    if (offset!=Py_None)\n    {\n        if (PyFloat_Check(offset)) phase = PyFloat_AS_DOUBLE(offset);\n#if PY3K\n        else if (PyLong_Check(offset)) phase = PyLong_AS_LONG(offset);\n#else\n        else if (PyInt_Check(offset)) phase = PyInt_AS_LONG(offset);\n#endif\n        else\n        {\n            PyErr_SetString(PyExc_TypeError,\n                            \"offset should be a floating point value\");\n            return false;\n        }\n    }\n\n    if (dashes!=Py_None)\n    {\n        if (PyList_Check(dashes)) dashes = PyList_AsTuple(dashes);\n        else if (PyTuple_Check(dashes)) Py_INCREF(dashes);\n        else\n        {\n            PyErr_SetString(PyExc_TypeError,\n                            \"dashes should be a tuple or a list\");\n            return false;\n        }\n        int n = PyTuple_GET_SIZE(dashes);\n        int i;\n        CGFloat* lengths = malloc(n*sizeof(CGFloat));\n        if(!lengths)\n        {\n            PyErr_SetString(PyExc_MemoryError, \"Failed to store dashes\");\n            Py_DECREF(dashes);\n            return false;\n        }\n        for (i = 0; i < n; i++)\n        {\n            PyObject* value = PyTuple_GET_ITEM(dashes, i);\n            if (PyFloat_Check(value))\n                lengths[i] = (CGFloat) PyFloat_AS_DOUBLE(value);\n#if PY3K\n            else if (PyLong_Check(value))\n                lengths[i] = (CGFloat) PyLong_AS_LONG(value);\n#else\n            else if (PyInt_Check(value))\n                lengths[i] = (CGFloat) PyInt_AS_LONG(value);\n#endif\n            else break;\n        }\n        Py_DECREF(dashes);\n        if (i < n) /* break encountered */\n        {\n            free(lengths);\n            PyErr_SetString(PyExc_TypeError, \"Failed to read dashes\");\n            return false;\n        }\n        CGContextSetLineDash(cr, phase, lengths, n);\n        free(lengths);\n    }\n    else\n        CGContextSetLineDash(cr, phase, NULL, 0);\n\n    return true;\n}\n\nstatic PyObject*\nGraphicsContext_set_dashes (GraphicsContext* self, PyObject* args)\n{\n    CGContextRef cr = self->cr;\n    if (!cr)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"CGContextRef is NULL\");\n        return NULL;\n    }\n\n    if (!_set_dashes(cr, args))\n        return NULL;\n\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyObject*\nGraphicsContext_set_foreground(GraphicsContext* self, PyObject* args)\n{\n    float r, g, b, a;\n    if(!PyArg_ParseTuple(args, \"(ffff)\", &r, &g, &b, &a)) return NULL;\n\n    CGContextRef cr = self->cr;\n    if (!cr)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"CGContextRef is NULL\");\n        return NULL;\n    }\n\n    if (self->forced_alpha)\n    {\n        // Transparency is applied to layer\n        // Let it override (rather than multiply with) the alpha of the\n        // stroke/fill colors\n        a = 1.0;\n    }\n\n    CGContextSetRGBStrokeColor(cr, r, g, b, a);\n    CGContextSetRGBFillColor(cr, r, g, b, a);\n\n    self->color[0] = r;\n    self->color[1] = g;\n    self->color[2] = b;\n    self->color[3] = a;\n\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyObject*\nGraphicsContext_set_graylevel(GraphicsContext* self, PyObject* args)\n{   float gray;\n    if(!PyArg_ParseTuple(args, \"f\", &gray)) return NULL;\n\n    CGContextRef cr = self->cr;\n    if (!cr)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"CGContextRef is NULL\");\n        return NULL;\n    }\n\n    CGContextSetGrayStrokeColor(cr, gray, 1.0);\n    CGContextSetGrayFillColor(cr, gray, 1.0);\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyObject*\nGraphicsContext_set_dpi (GraphicsContext* self, PyObject* args)\n{\n  if (!PyArg_ParseTuple(args, \"f\", &(self->dpi))) return NULL;\n\n  Py_INCREF(Py_None);\n  return Py_None;\n}\n\nstatic PyObject*\nGraphicsContext_set_linewidth (GraphicsContext* self, PyObject* args)\n{\n    float width;\n    if (!PyArg_ParseTuple(args, \"f\", &width)) return NULL;\n\n    CGContextRef cr = self->cr;\n    if (!cr)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"CGContextRef is NULL\");\n        return NULL;\n    }\n\n    // Convert points to pixels\n    width *= self->dpi / 72.0;\n    CGContextSetLineWidth(cr, width);\n\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyObject*\nGraphicsContext_set_joinstyle(GraphicsContext* self, PyObject* args)\n{   char* string;\n    CGLineJoin join;\n\n    if (!PyArg_ParseTuple(args, \"s\", &string)) return NULL;\n\n    if (!strcmp(string, \"miter\")) join = kCGLineJoinMiter;\n    else if (!strcmp(string, \"round\")) join = kCGLineJoinRound;\n    else if (!strcmp(string, \"bevel\")) join = kCGLineJoinBevel;\n    else\n    {\n        PyErr_SetString(PyExc_ValueError,\n                        \"joinstyle should be 'miter', 'round', or 'bevel'\");\n        return NULL;\n    }\n\n    CGContextRef cr = self->cr;\n    if (!cr)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"CGContextRef is NULL\");\n        return NULL;\n    }\n    CGContextSetLineJoin(cr, join);\n\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyObject*\nGraphicsContext_draw_path (GraphicsContext* self, PyObject* args)\n{\n    PyObject* path;\n    PyObject* transform;\n    PyObject* rgbFace;\n    float linewidth;\n\n    int n;\n\n    void* iterator;\n\n    CGContextRef cr = self->cr;\n    double rect[4] = { 0.0, 0.0, self->size.width, self->size.height};\n\n    if (!cr)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"CGContextRef is NULL\");\n        return NULL;\n    }\n\n    if(!PyArg_ParseTuple(args, \"OOf|O\",\n                               &path,\n                               &transform,\n                               &linewidth,\n                               &rgbFace)) return NULL;\n\n    if(rgbFace==Py_None) rgbFace = NULL;\n\n    iterator  = get_path_iterator(path,\n                                  transform,\n                                  1,\n                                  0,\n                                  rect,\n                                  SNAP_AUTO,\n                                  linewidth,\n                                  rgbFace == NULL);\n    if (!iterator)\n    {\n        PyErr_SetString(PyExc_RuntimeError,\n                        \"draw_path: failed to obtain path iterator\");\n        return NULL;\n    }\n\n    if(rgbFace)\n    {\n        float r, g, b, a;\n        a = 1.0;\n        if (!PyArg_ParseTuple(rgbFace, \"fff|f\", &r, &g, &b, &a))\n            return NULL;\n        if (self->forced_alpha)\n            a = 1.0;\n\n        n = _draw_path(cr, iterator, INT_MAX);\n        if (n > 0)\n        {\n            CGContextSaveGState(cr);\n            CGContextSetRGBFillColor(cr, r, g, b, a);\n            CGContextDrawPath(cr, kCGPathFillStroke);\n            CGContextRestoreGState(cr);\n        }\n    }\n    else\n    {\n        const int nmax = 100;\n        while (true)\n        {\n            n = _draw_path(cr, iterator, nmax);\n            if (n != 0) CGContextStrokePath(cr);\n            if (n >= 0) break;\n        }\n    }\n    free_path_iterator(iterator);\n\n    PyObject* hatchpath;\n    hatchpath = PyObject_CallMethod((PyObject*)self, \"get_hatch_path\", \"\");\n    if (!hatchpath)\n    {\n        return NULL;\n    }\n    else if (hatchpath==Py_None)\n    {\n        Py_DECREF(hatchpath);\n    }\n    else\n    {\n        CGPatternRef pattern;\n        CGColorSpaceRef baseSpace;\n        CGColorSpaceRef patternSpace;\n        static const CGPatternCallbacks callbacks = {0,\n                                                     &_draw_hatch,\n                                                     &_release_hatch};\n        baseSpace = CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB);\n        if (!baseSpace)\n        {\n            Py_DECREF(hatchpath);\n            PyErr_SetString(PyExc_RuntimeError,\n                \"draw_path: CGColorSpaceCreateWithName failed\");\n            return NULL;\n        }\n        patternSpace = CGColorSpaceCreatePattern(baseSpace);\n        CGColorSpaceRelease(baseSpace);\n        if (!patternSpace)\n        {\n            Py_DECREF(hatchpath);\n            PyErr_SetString(PyExc_RuntimeError,\n                \"draw_path: CGColorSpaceCreatePattern failed\");\n            return NULL;\n        }\n        CGContextSetFillColorSpace(cr, patternSpace);\n        CGColorSpaceRelease(patternSpace);\n\n        pattern = CGPatternCreate((void*)hatchpath,\n                                  CGRectMake(0, 0, HATCH_SIZE, HATCH_SIZE),\n                                  CGAffineTransformIdentity,\n                                  HATCH_SIZE, HATCH_SIZE,\n                                  kCGPatternTilingNoDistortion,\n                                  false,\n                                  &callbacks);\n        CGContextSetFillPattern(cr, pattern, self->color);\n        CGPatternRelease(pattern);\n        iterator  = get_path_iterator(path,\n                                      transform,\n                                      1,\n                                      0,\n                                      rect,\n                                      SNAP_AUTO,\n                                      linewidth,\n                                      0);\n        if (!iterator)\n        {\n            Py_DECREF(hatchpath);\n            PyErr_SetString(PyExc_RuntimeError,\n                \"draw_path: failed to obtain path iterator for hatching\");\n            return NULL;\n        }\n        n = _draw_path(cr, iterator, INT_MAX);\n        free_path_iterator(iterator);\n        if (n > 0) CGContextFillPath(cr);\n    }\n\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyObject*\nGraphicsContext_draw_markers (GraphicsContext* self, PyObject* args)\n{\n    PyObject* marker_path;\n    PyObject* marker_transform;\n    PyObject* path;\n    PyObject* transform;\n    float linewidth;\n    PyObject* rgbFace;\n\n    int ok;\n    float r, g, b, a;\n\n    CGMutablePathRef marker;\n    void* iterator;\n    double rect[4] = {0.0, 0.0, self->size.width, self->size.height};\n    enum e_snap_mode mode;\n    double xc, yc;\n    unsigned code;\n\n    CGContextRef cr = self->cr;\n\n    if (!cr)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"CGContextRef is NULL\");\n        return NULL;\n    }\n\n    if(!PyArg_ParseTuple(args, \"OOOOf|O\",\n                               &marker_path,\n                               &marker_transform,\n                               &path,\n                               &transform,\n                               &linewidth,\n                               &rgbFace)) return NULL;\n\n    if(rgbFace==Py_None) rgbFace = NULL;\n\n    if (rgbFace)\n    {\n        a = 1.0;\n        ok = PyArg_ParseTuple(rgbFace, \"fff|f\", &r, &g, &b, &a);\n        if (!ok)\n        {\n            return NULL;\n        }\n        if (self->forced_alpha)\n            a = 1.0;\n        CGContextSetRGBFillColor(cr, r, g, b, a);\n    }\n\n    ok = _get_snap(self, &mode);\n    if (!ok)\n    {\n        return NULL;\n    }\n\n    iterator = get_path_iterator(marker_path,\n                                 marker_transform,\n                                 0,\n                                 0,\n                                 rect,\n                                 mode,\n                                 linewidth,\n                                 0);\n    if (!iterator)\n    {\n        PyErr_SetString(PyExc_RuntimeError,\n            \"draw_markers: failed to obtain path iterator for marker\");\n        return NULL;\n    }\n    marker = _create_path(iterator);\n    free_path_iterator(iterator);\n    if (!marker)\n    {\n        PyErr_SetString(PyExc_RuntimeError,\n            \"draw_markers: failed to draw marker path\");\n        return NULL;\n    }\n    iterator = get_path_iterator(path,\n                                 transform,\n                                 1,\n                                 1,\n                                 rect,\n                                 SNAP_TRUE,\n                                 1.0,\n                                 0);\n    if (!iterator)\n    {\n        CGPathRelease(marker);\n        PyErr_SetString(PyExc_RuntimeError,\n            \"draw_markers: failed to obtain path iterator\");\n        return NULL;\n    }\n\n    while (true)\n    {\n        code = get_vertex(iterator, &xc, &yc);\n        if (code == STOP)\n        {\n            break;\n        }\n        else if (code == MOVETO || code == LINETO || code == CURVE3 || code ==CURVE4)\n        {\n            CGContextSaveGState(cr);\n            CGContextTranslateCTM(cr, xc, yc);\n            CGContextAddPath(cr, marker);\n            CGContextRestoreGState(cr);\n        }\n        if(rgbFace) CGContextDrawPath(cr, kCGPathFillStroke);\n        else CGContextStrokePath(cr);\n    }\n    free_path_iterator(iterator);\n    CGPathRelease(marker);\n\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic int _transformation_converter(PyObject* object, void* pointer)\n{\n    CGAffineTransform* matrix = (CGAffineTransform*)pointer;\n    if (!PyArray_Check(object))\n       {\n           PyErr_SetString(PyExc_ValueError,\n                           \"transformation matrix is not a NumPy array\");\n           return 0;\n       }\n    PyArrayObject* aobject = (PyArrayObject*)object;\n\n    if (PyArray_NDIM(aobject)!=2 || PyArray_DIM(aobject, 0)!=3\n        || PyArray_DIM(aobject, 1)!=3)\n        {\n            PyErr_SetString(PyExc_ValueError,\n                \"transformation matrix is not a 3x3 NumPy array\");\n            return 0;\n        }\n    const double a =  *(double*)PyArray_GETPTR2(aobject, 0, 0);\n    const double b =  *(double*)PyArray_GETPTR2(aobject, 1, 0);\n    const double c =  *(double*)PyArray_GETPTR2(aobject, 0, 1);\n    const double d =  *(double*)PyArray_GETPTR2(aobject, 1, 1);\n    const double tx =  *(double*)PyArray_GETPTR2(aobject, 0, 2);\n    const double ty =  *(double*)PyArray_GETPTR2(aobject, 1, 2);\n    *matrix = CGAffineTransformMake(a, b, c, d, tx, ty);\n    return 1;\n}\n\nstatic PyObject*\nGraphicsContext_draw_path_collection (GraphicsContext* self, PyObject* args)\n{\n    CGAffineTransform master;\n    PyObject* path_ids;\n    PyObject* all_transforms;\n    PyObject* offsets;\n    PyArrayObject* offsets_arr = 0;\n    CGAffineTransform offset_transform;\n    PyObject* facecolors;\n    PyArrayObject* facecolors_arr = 0;\n    PyObject* edgecolors;\n    PyArrayObject* edgecolors_arr = 0;\n    PyObject* linewidths;\n    PyObject* linestyles;\n    PyObject* antialiaseds;\n\n    int offset_position = 0;\n\n    CGContextRef cr = self->cr;\n\n    if (!cr)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"CGContextRef is NULL\");\n        return NULL;\n    }\n\n    if(!PyArg_ParseTuple(args, \"O&OOOO&OOOOOi\",\n                               _transformation_converter, &master,\n                               &path_ids,\n                               &all_transforms,\n                               &offsets,\n                               _transformation_converter, &offset_transform,\n                               &facecolors,\n                               &edgecolors,\n                               &linewidths,\n                               &linestyles,\n                               &antialiaseds,\n                               &offset_position))\n        return NULL;\n\n    int ok = 1;\n    Py_ssize_t i;\n\n    CGMutablePathRef* p = NULL;\n    CGAffineTransform* transforms = NULL;\n    CGPoint *toffsets = NULL;\n    CGPatternRef pattern = NULL;\n    CGColorSpaceRef patternSpace = NULL;\n\n    PyObject* hatchpath;\n    hatchpath = PyObject_CallMethod((PyObject*)self, \"get_hatch_path\", \"\");\n    if (!hatchpath)\n    {\n        return NULL;\n    }\n    else if (hatchpath==Py_None)\n    {\n        Py_DECREF(hatchpath);\n    }\n    else\n    {\n        CGColorSpaceRef baseSpace;\n        static const CGPatternCallbacks callbacks = {0,\n                                                     &_draw_hatch,\n                                                     &_release_hatch};\n        baseSpace = CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB);\n        if (!baseSpace)\n        {\n            Py_DECREF(hatchpath);\n            PyErr_SetString(PyExc_RuntimeError,\n                \"draw_path: CGColorSpaceCreateWithName failed\");\n            return NULL;\n        }\n        patternSpace = CGColorSpaceCreatePattern(baseSpace);\n        CGColorSpaceRelease(baseSpace);\n        if (!patternSpace)\n        {\n            Py_DECREF(hatchpath);\n            PyErr_SetString(PyExc_RuntimeError,\n                \"draw_path: CGColorSpaceCreatePattern failed\");\n            return NULL;\n        }\n        pattern = CGPatternCreate((void*)hatchpath,\n                                  CGRectMake(0, 0, HATCH_SIZE, HATCH_SIZE),\n                                  CGAffineTransformIdentity,\n                                  HATCH_SIZE, HATCH_SIZE,\n                                  kCGPatternTilingNoDistortion,\n                                  false,\n                                  &callbacks);\n    }\n\n    /* --------- Prepare some variables for the path iterator ------------- */\n    void* iterator;\n    double rect[4] = {0.0, 0.0, self->size.width, self->size.height};\n    enum e_snap_mode mode;\n    ok = _get_snap(self, &mode);\n    if (!ok)\n    {\n        return NULL;\n    }\n\n    /* ------------------- Check paths ------------------------------------ */\n\n    if (!PySequence_Check(path_ids))\n    {\n        PyErr_SetString(PyExc_ValueError, \"paths must be a sequence object\");\n        return NULL;\n    }\n    const Py_ssize_t Npaths = PySequence_Size(path_ids);\n\n    /* -------------------------------------------------------------------- */\n\n    CGContextSaveGState(cr);\n\n    /* ------------------- Check facecolors array ------------------------- */\n\n    facecolors_arr = (PyArrayObject*) PyArray_FromObject(facecolors, NPY_DOUBLE, 1, 2);\n    if (!facecolors_arr ||\n        (PyArray_NDIM(facecolors_arr)==1 && PyArray_DIM(facecolors_arr, 0)!=0) ||\n        (PyArray_NDIM(facecolors_arr)==2 && PyArray_DIM(facecolors_arr, 1)!=4))\n    {\n        PyErr_SetString(PyExc_ValueError, \"Facecolors must by a Nx4 numpy array or empty\");\n        ok = 0;\n        goto exit;\n    }\n    Py_ssize_t Nfacecolors = PyArray_DIM(facecolors_arr, 0);\n\n    /* ------------------- Check edgecolors array ------------------------- */\n\n    edgecolors_arr = (PyArrayObject*) PyArray_FromObject(edgecolors, NPY_DOUBLE, 1, 2);\n    if (!edgecolors_arr ||\n        (PyArray_NDIM(edgecolors_arr)==1 && PyArray_DIM(edgecolors_arr, 0)!=0) ||\n        (PyArray_NDIM(edgecolors_arr)==2 && PyArray_DIM(edgecolors_arr, 1)!=4))\n    {\n        PyErr_SetString(PyExc_ValueError, \"Edgecolors must by a Nx4 numpy array or empty\");\n        ok = 0;\n        goto exit;\n    }\n    Py_ssize_t Nedgecolors = PyArray_DIM(edgecolors_arr, 0);\n\n    /* -------------------------------------------------------------------- */\n\n    if ((Nfacecolors==0 && Nedgecolors==0) || Npaths==0) /* Nothing to do */\n        goto exit;\n\n    /* ------------------- Check offsets array ---------------------------- */\n\n    offsets_arr = (PyArrayObject*) PyArray_FromObject(offsets, NPY_DOUBLE, 0, 2);\n\n    if (!offsets_arr ||\n        (PyArray_NDIM(offsets_arr)==2 && PyArray_DIM(offsets_arr, 1)!=2) ||\n        (PyArray_NDIM(offsets_arr)==1 && PyArray_DIM(offsets_arr, 0)!=0))\n    {\n        Py_XDECREF(offsets_arr);\n        PyErr_SetString(PyExc_ValueError, \"Offsets array must be Nx2\");\n        ok = 0;\n        goto exit;\n    }\n    const Py_ssize_t Noffsets = PyArray_DIM(offsets_arr, 0);\n    if (Noffsets > 0) {\n        toffsets = malloc(Noffsets*sizeof(CGPoint));\n        if (!toffsets)\n        {\n            Py_DECREF(offsets_arr);\n            ok = 0;\n            goto exit;\n        }\n        CGPoint point;\n        for (i = 0; i < Noffsets; i++)\n        {\n            point.x = (CGFloat) (*(double*)PyArray_GETPTR2(offsets_arr, i, 0));\n            point.y = (CGFloat) (*(double*)PyArray_GETPTR2(offsets_arr, i, 1));\n            toffsets[i] = CGPointApplyAffineTransform(point, offset_transform);\n        }\n    }\n    Py_DECREF(offsets_arr);\n\n    /* ------------------- Check transforms ------------------------------- */\n\n    if (!PySequence_Check(all_transforms))\n    {\n        PyErr_SetString(PyExc_ValueError, \"transforms must be a sequence object\");\n        return NULL;\n    }\n    const Py_ssize_t Ntransforms = PySequence_Size(all_transforms);\n    if (Ntransforms > 0)\n    {\n        transforms = malloc(Ntransforms*sizeof(CGAffineTransform));\n        if (!transforms)\n            goto exit;\n        for (i = 0; i < Ntransforms; i++)\n        {\n            PyObject* transform = PySequence_ITEM(all_transforms, i);\n            if (!transform) goto exit;\n            ok = _transformation_converter(transform, &transforms[i]);\n            Py_DECREF(transform);\n            if (!ok) goto exit;\n        }\n    }\n\n    /* -------------------------------------------------------------------- */\n\n    p = malloc(Npaths*sizeof(CGMutablePathRef));\n    if (!p)\n    {\n        ok = 0;\n        goto exit;\n    }\n    for (i = 0; i < Npaths; i++)\n    {\n        PyObject* path;\n        PyObject* transform;\n        p[i] = NULL;\n        PyObject* path_id = PySequence_ITEM(path_ids, i);\n        if (!path_id)\n        {\n            ok = 0;\n            goto exit;\n        }\n        if (!PyTuple_Check(path_id) || PyTuple_Size(path_id)!=2)\n        {\n            ok = 0;\n            PyErr_SetString(PyExc_RuntimeError,\n                            \"path_id should be a tuple of two items\");\n            goto exit;\n        }\n        path = PyTuple_GET_ITEM(path_id, 0);\n        transform = PyTuple_GET_ITEM(path_id, 1);\n        iterator = get_path_iterator(path,\n                                     transform,\n                                     1,\n                                     0,\n                                     rect,\n                                     mode,\n                                     1.0,\n                                     /* Hardcoding stroke width to 1.0\n                                        here, but for true\n                                        correctness, the paths would\n                                        need to be set up for each\n                                        different linewidth that may\n                                        be applied below.  This\n                                        difference is very minute in\n                                        practice, so this hardcoding\n                                        is probably ok for now.  --\n                                        MGD */\n                                     0);\n        if (!iterator)\n        {\n            PyErr_SetString(PyExc_RuntimeError,\n                            \"failed to obtain path iterator\");\n            ok = 0;\n            goto exit;\n        }\n        p[i] = _create_path(iterator);\n        free_path_iterator(iterator);\n        Py_DECREF(path_id);\n        if (!p[i])\n        {\n            PyErr_SetString(PyExc_RuntimeError, \"failed to create path\");\n            ok = 0;\n            goto exit;\n        }\n    }\n\n    /* ------------------- Check the other arguments ---------------------- */\n\n    if (!PySequence_Check(linewidths))\n    {\n        PyErr_SetString(PyExc_ValueError, \"linewidths must be a sequence object\");\n        ok = 0;\n        goto exit;\n    }\n    if (!PySequence_Check(linestyles))\n    {\n        PyErr_SetString(PyExc_ValueError, \"linestyles must be a sequence object\");\n        ok = 0;\n        goto exit;\n    }\n    if (!PySequence_Check(antialiaseds))\n    {\n        PyErr_SetString(PyExc_ValueError, \"antialiaseds must be a sequence object\");\n        ok = 0;\n        goto exit;\n    }\n\n    Py_ssize_t Nlinewidths = PySequence_Size(linewidths);\n    Py_ssize_t Nlinestyles = PySequence_Size(linestyles);\n    Py_ssize_t Naa         = PySequence_Size(antialiaseds);\n\n    /* Preset graphics context properties if possible */\n    if (Naa==1)\n    {\n        PyObject* antialiased = PySequence_ITEM(antialiaseds, 0);\n        if (antialiased)\n        {\n            ok = _set_antialiased(cr, antialiased);\n            Py_DECREF(antialiased);\n        }\n        else\n        {\n            PyErr_SetString(PyExc_SystemError,\n                            \"Failed to read element from antialiaseds array\");\n            ok = 0;\n        }\n        if (!ok) goto exit;\n    }\n\n    if (Nlinewidths==0 || Nedgecolors==0)\n        CGContextSetLineWidth(cr, 0.0);\n    else if (Nlinewidths==1)\n    {\n        PyObject* linewidth = PySequence_ITEM(linewidths, 0);\n        if (!linewidth)\n        {\n            PyErr_SetString(PyExc_SystemError,\n                            \"Failed to read element from linewidths array\");\n            ok = 0;\n            goto exit;\n        }\n        CGContextSetLineWidth(cr, (CGFloat)PyFloat_AsDouble(linewidth));\n        Py_DECREF(linewidth);\n    }\n\n    if (Nlinestyles==1)\n    {\n        PyObject* linestyle = PySequence_ITEM(linestyles, 0);\n        if (!linestyle)\n        {\n            PyErr_SetString(PyExc_SystemError,\n                            \"Failed to read element from linestyles array\");\n            ok = 0;\n            goto exit;\n        }\n        ok = _set_dashes(cr, linestyle);\n        Py_DECREF(linestyle);\n        if (!ok) goto exit;\n    }\n\n    if (Nedgecolors==1)\n    {\n        const double r = *(double*)PyArray_GETPTR2(edgecolors_arr, 0, 0);\n        const double g = *(double*)PyArray_GETPTR2(edgecolors_arr, 0, 1);\n        const double b = *(double*)PyArray_GETPTR2(edgecolors_arr, 0, 2);\n        const double a = *(double*)PyArray_GETPTR2(edgecolors_arr, 0, 3);\n        CGContextSetRGBStrokeColor(cr, r, g, b, a);\n        self->color[0] = r;\n        self->color[1] = g;\n        self->color[2] = b;\n        self->color[3] = a;\n    }\n    else /* We may need these for hatching */\n    {\n        self->color[0] = 0;\n        self->color[1] = 0;\n        self->color[2] = 0;\n        self->color[3] = 1;\n    }\n\n    if (Nfacecolors==1)\n    {\n        const double r = *(double*)PyArray_GETPTR2(facecolors_arr, 0, 0);\n        const double g = *(double*)PyArray_GETPTR2(facecolors_arr, 0, 1);\n        const double b = *(double*)PyArray_GETPTR2(facecolors_arr, 0, 2);\n        const double a = *(double*)PyArray_GETPTR2(facecolors_arr, 0, 3);\n        CGContextSetRGBFillColor(cr, r, g, b, a);\n    }\n\n    CGPoint translation = CGPointZero;\n\n    const Py_ssize_t N = Npaths > Noffsets ? Npaths : Noffsets;\n    for (i = 0; i < N; i++)\n    {\n        if (CGPathIsEmpty(p[i % Npaths])) continue;\n\n        if (Noffsets)\n        {\n            CGAffineTransform t;\n            CGPoint origin;\n            translation = toffsets[i % Noffsets];\n            if (offset_position)\n            {\n                t = master;\n                if (Ntransforms)\n                    t = CGAffineTransformConcat(transforms[i % Ntransforms], t);\n                translation = CGPointApplyAffineTransform(translation, t);\n                origin = CGPointApplyAffineTransform(CGPointZero, t);\n                translation.x = - (origin.x - translation.x);\n                translation.y = - (origin.y - translation.y);\n            }\n            /* in case of missing values, translation may contain NaN's */\n            if (!isfinite(translation.x) || !isfinite(translation.y)) continue;\n            CGContextTranslateCTM(cr, translation.x, translation.y);\n        }\n\n        if (Naa > 1)\n        {\n            PyObject* antialiased = PySequence_ITEM(antialiaseds, i % Naa);\n            if (antialiased)\n            {\n                ok = _set_antialiased(cr, antialiased);\n                Py_DECREF(antialiased);\n            }\n            else\n            {\n                PyErr_SetString(PyExc_SystemError,\n                    \"Failed to read element from antialiaseds array\");\n                ok = 0;\n            }\n            if (!ok) goto exit;\n        }\n\n        if (Nlinewidths > 1)\n        {\n            PyObject* linewidth = PySequence_ITEM(linewidths, i % Nlinewidths);\n            if (!linewidth)\n            {\n                PyErr_SetString(PyExc_SystemError,\n                                \"Failed to read element from linewidths array\");\n                ok = 0;\n                goto exit;\n            }\n            CGContextSetLineWidth(cr, (CGFloat)PyFloat_AsDouble(linewidth));\n            Py_DECREF(linewidth);\n        }\n\n        if (Nlinestyles > 1)\n        {\n            PyObject* linestyle = PySequence_ITEM(linestyles, i % Nlinestyles);\n            if (!linestyle)\n            {\n                PyErr_SetString(PyExc_SystemError,\n                                \"Failed to read element from linestyles array\");\n                ok = 0;\n                goto exit;\n            }\n            ok = _set_dashes(cr, linestyle);\n            Py_DECREF(linestyle);\n            if (!ok) goto exit;\n        }\n\n        if (Nedgecolors > 1)\n        {\n            npy_intp fi = i % Nedgecolors;\n            const double r = *(double*)PyArray_GETPTR2(edgecolors_arr, fi, 0);\n            const double g = *(double*)PyArray_GETPTR2(edgecolors_arr, fi, 1);\n            const double b = *(double*)PyArray_GETPTR2(edgecolors_arr, fi, 2);\n            const double a = *(double*)PyArray_GETPTR2(edgecolors_arr, fi, 3);\n            CGContextSetRGBStrokeColor(cr, r, g, b, a);\n        }\n\n        CGContextAddPath(cr, p[i % Npaths]);\n\n        if (Nfacecolors > 1)\n        {\n            npy_intp fi = i % Nfacecolors;\n            const double r = *(double*)PyArray_GETPTR2(facecolors_arr, fi, 0);\n            const double g = *(double*)PyArray_GETPTR2(facecolors_arr, fi, 1);\n            const double b = *(double*)PyArray_GETPTR2(facecolors_arr, fi, 2);\n            const double a = *(double*)PyArray_GETPTR2(facecolors_arr, fi, 3);\n            CGContextSetRGBFillColor(cr, r, g, b, a);\n            if (Nedgecolors > 0) CGContextDrawPath(cr, kCGPathFillStroke);\n            else CGContextFillPath(cr);\n        }\n        else if (Nfacecolors==1)\n        {\n            if (Nedgecolors > 0) CGContextDrawPath(cr, kCGPathFillStroke);\n            else CGContextFillPath(cr);\n        }\n        else /* We checked Nedgecolors != 0 above */\n            CGContextStrokePath(cr);\n\n        if (pattern)\n        {\n            CGContextSaveGState(cr);\n            CGContextSetFillColorSpace(cr, patternSpace);\n            CGContextSetFillPattern(cr, pattern, self->color);\n            CGContextAddPath(cr, p[i % Npaths]);\n            CGContextFillPath(cr);\n            CGContextRestoreGState(cr);\n        }\n\n        if (Noffsets)\n            CGContextTranslateCTM(cr, -translation.x, -translation.y);\n    }\n\nexit:\n    CGContextRestoreGState(cr);\n    Py_XDECREF(facecolors_arr);\n    Py_XDECREF(edgecolors_arr);\n    if (pattern) CGPatternRelease(pattern);\n    if (patternSpace) CGColorSpaceRelease(patternSpace);\n    if (transforms) free(transforms);\n    if (toffsets) free(toffsets);\n    if (p)\n    {\n        for (i = 0; i < Npaths; i++)\n        {\n            if (!p[i]) break;\n            CGPathRelease(p[i]);\n        }\n        free(p);\n    }\n    if (!ok) return NULL;\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyObject*\nGraphicsContext_draw_quad_mesh (GraphicsContext* self, PyObject* args)\n{\n    CGAffineTransform master;\n    int meshWidth;\n    int meshHeight;\n    PyObject* coordinates;\n    PyArrayObject* coordinates_arr = 0;\n    PyObject* offsets;\n    PyArrayObject* offsets_arr = 0;\n    CGAffineTransform offset_transform;\n    PyObject* facecolors;\n    PyArrayObject* facecolors_arr = 0;\n    int antialiased;\n    PyObject* edgecolors;\n    PyArrayObject* edgecolors_arr = 0;\n\n    CGPoint *toffsets = NULL;\n\n    CGContextRef cr = self->cr;\n\n    if (!cr)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"CGContextRef is NULL\");\n        return NULL;\n    }\n\n    if(!PyArg_ParseTuple(args, \"O&iiOOO&OiO\",\n                               _transformation_converter, &master,\n                               &meshWidth,\n                               &meshHeight,\n                               &coordinates,\n                               &offsets,\n                               _transformation_converter, &offset_transform,\n                               &facecolors,\n                               &antialiased,\n                               &edgecolors)) return NULL;\n\n    int ok = 1;\n    CGContextSaveGState(cr);\n\n    /* ------------------- Check coordinates array ------------------------ */\n\n    coordinates_arr = (PyArrayObject*) PyArray_FromObject(coordinates, NPY_DOUBLE, 3, 3);\n    if (!coordinates_arr ||\n        PyArray_NDIM(coordinates_arr) != 3 || PyArray_DIM(coordinates_arr, 2) != 2)\n    {\n        PyErr_SetString(PyExc_ValueError, \"Invalid coordinates array\");\n        ok = 0;\n        goto exit;\n    }\n\n    /* ------------------- Check offsets array ---------------------------- */\n\n    offsets_arr = (PyArrayObject*) PyArray_FromObject(offsets, NPY_DOUBLE, 0, 2);\n\n    if (!offsets_arr ||\n        (PyArray_NDIM(offsets_arr)==2 && PyArray_DIM(offsets_arr, 1)!=2) ||\n        (PyArray_NDIM(offsets_arr)==1 && PyArray_DIM(offsets_arr, 0)!=0))\n    {\n        Py_XDECREF(offsets_arr);\n        PyErr_SetString(PyExc_ValueError, \"Offsets array must be Nx2\");\n        ok = 0;\n        goto exit;\n    }\n    const Py_ssize_t Noffsets = PyArray_DIM(offsets_arr, 0);\n    if (Noffsets > 0) {\n        int i;\n        toffsets = malloc(Noffsets*sizeof(CGPoint));\n        if (!toffsets)\n        {\n            Py_DECREF(offsets_arr);\n            ok = 0;\n            goto exit;\n        }\n        CGPoint point;\n        for (i = 0; i < Noffsets; i++)\n        {\n            point.x = (CGFloat) (*(double*)PyArray_GETPTR2(offsets_arr, i, 0));\n            point.y = (CGFloat) (*(double*)PyArray_GETPTR2(offsets_arr, i, 1));\n            toffsets[i] = CGPointApplyAffineTransform(point, offset_transform);\n        }\n    }\n    Py_DECREF(offsets_arr);\n\n    /* ------------------- Check facecolors array ------------------------- */\n\n    facecolors_arr = (PyArrayObject*) PyArray_FromObject(facecolors, NPY_DOUBLE, 1, 2);\n    if (!facecolors_arr ||\n        (PyArray_NDIM(facecolors_arr)==1 && PyArray_DIM(facecolors_arr, 0)!=0) ||\n        (PyArray_NDIM(facecolors_arr)==2 && PyArray_DIM(facecolors_arr, 1)!=4))\n    {\n        PyErr_SetString(PyExc_ValueError, \"facecolors must by a Nx4 numpy array or empty\");\n        ok = 0;\n        goto exit;\n    }\n\n    /* ------------------- Check edgecolors array ------------------------- */\n\n    edgecolors_arr = (PyArrayObject*) PyArray_FromObject(edgecolors, NPY_DOUBLE, 1, 2);\n    if (!edgecolors_arr ||\n        (PyArray_NDIM(edgecolors_arr)==1 && PyArray_DIM(edgecolors_arr, 0)!=0) ||\n        (PyArray_NDIM(edgecolors_arr)==2 && PyArray_DIM(edgecolors_arr, 1)!=4))\n    {\n        PyErr_SetString(PyExc_ValueError, \"edgecolors must by a Nx4 numpy array or empty\");\n        ok = 0;\n        goto exit;\n    }\n\n    /* ------------------- Check the other arguments ---------------------- */\n\n    size_t Npaths      = meshWidth * meshHeight;\n    size_t Nfacecolors = (size_t) PyArray_DIM(facecolors_arr, 0);\n    size_t Nedgecolors = (size_t) PyArray_DIM(edgecolors_arr, 0);\n    if ((Nfacecolors == 0 && Nedgecolors == 0) || Npaths == 0)\n    {\n        /* Nothing to do here */\n        goto exit;\n    }\n\n    size_t i = 0;\n    size_t iw = 0;\n    size_t ih = 0;\n\n    /* Preset graphics context properties if possible */\n    CGContextSetShouldAntialias(cr, antialiased);\n\n    if (Nfacecolors==1)\n    {\n        const double r = *(double*)PyArray_GETPTR2(facecolors_arr, 0, 0);\n        const double g = *(double*)PyArray_GETPTR2(facecolors_arr, 0, 1);\n        const double b = *(double*)PyArray_GETPTR2(facecolors_arr, 0, 2);\n        const double a = *(double*)PyArray_GETPTR2(facecolors_arr, 0, 3);\n        CGContextSetRGBFillColor(cr, r, g, b, a);\n        if (antialiased && Nedgecolors==0)\n        {\n            CGContextSetRGBStrokeColor(cr, r, g, b, a);\n        }\n    }\n    if (Nedgecolors==1)\n    {\n        const double r = *(double*)PyArray_GETPTR2(edgecolors_arr, 0, 0);\n        const double g = *(double*)PyArray_GETPTR2(edgecolors_arr, 0, 1);\n        const double b = *(double*)PyArray_GETPTR2(edgecolors_arr, 0, 2);\n        const double a = *(double*)PyArray_GETPTR2(edgecolors_arr, 0, 3);\n        CGContextSetRGBStrokeColor(cr, r, g, b, a);\n    }\n\n    CGPoint translation = CGPointZero;\n    double x, y;\n    for (ih = 0; ih < meshHeight; ih++)\n    {\n        for (iw = 0; iw < meshWidth; iw++, i++)\n        {\n            CGPoint points[4];\n\n            x = *(double*)PyArray_GETPTR3(coordinates_arr, ih, iw, 0);\n            y = *(double*)PyArray_GETPTR3(coordinates_arr, ih, iw, 1);\n            if (isnan(x) || isnan(y)) continue;\n            points[0].x = (CGFloat)x;\n            points[0].y = (CGFloat)y;\n\n            x = *(double*)PyArray_GETPTR3(coordinates_arr, ih, iw+1, 0);\n            y = *(double*)PyArray_GETPTR3(coordinates_arr, ih, iw+1, 1);\n            if (isnan(x) || isnan(y)) continue;\n            points[1].x = (CGFloat)x;\n            points[1].y = (CGFloat)y;\n\n            x = *(double*)PyArray_GETPTR3(coordinates_arr, ih+1, iw+1, 0);\n            y = *(double*)PyArray_GETPTR3(coordinates_arr, ih+1, iw+1, 1);\n            if (isnan(x) || isnan(y)) continue;\n            points[2].x = (CGFloat)x;\n            points[2].y = (CGFloat)y;\n\n            x = *(double*)PyArray_GETPTR3(coordinates_arr, ih+1, iw, 0);\n            y = *(double*)PyArray_GETPTR3(coordinates_arr, ih+1, iw, 1);\n            if (isnan(x) || isnan(y)) continue;\n            points[3].x = (CGFloat)x;\n            points[3].y = (CGFloat)y;\n\n            points[0] = CGPointApplyAffineTransform(points[0], master);\n            points[1] = CGPointApplyAffineTransform(points[1], master);\n            points[2] = CGPointApplyAffineTransform(points[2], master);\n            points[3] = CGPointApplyAffineTransform(points[3], master);\n\n            if (Noffsets)\n            {\n                translation = toffsets[i % Noffsets];\n                CGContextTranslateCTM(cr, translation.x, translation.y);\n            }\n\n            CGContextMoveToPoint(cr, points[3].x, points[3].y);\n            CGContextAddLines(cr, points, 4);\n            CGContextClosePath(cr);\n\n            if (Nfacecolors > 1)\n            {\n                npy_intp fi = i % Nfacecolors;\n                const double r = *(double*)PyArray_GETPTR2(facecolors_arr, fi, 0);\n                const double g = *(double*)PyArray_GETPTR2(facecolors_arr, fi, 1);\n                const double b = *(double*)PyArray_GETPTR2(facecolors_arr, fi, 2);\n                const double a = *(double*)PyArray_GETPTR2(facecolors_arr, fi, 3);\n                CGContextSetRGBFillColor(cr, r, g, b, a);\n                if (antialiased && Nedgecolors==0)\n                {\n                    CGContextSetRGBStrokeColor(cr, r, g, b, a);\n                }\n            }\n            if (Nedgecolors > 1)\n            {\n                npy_intp fi = i % Nedgecolors;\n                const double r = *(double*)PyArray_GETPTR2(edgecolors_arr, fi, 0);\n                const double g = *(double*)PyArray_GETPTR2(edgecolors_arr, fi, 1);\n                const double b = *(double*)PyArray_GETPTR2(edgecolors_arr, fi, 2);\n                const double a = *(double*)PyArray_GETPTR2(edgecolors_arr, fi, 3);\n                CGContextSetRGBStrokeColor(cr, r, g, b, a);\n            }\n\n            if (Nfacecolors > 0)\n            {\n                if (Nedgecolors > 0 || antialiased)\n                {\n                    CGContextDrawPath(cr, kCGPathFillStroke);\n                }\n                else\n                {\n                    CGContextFillPath(cr);\n                }\n            }\n            else if (Nedgecolors > 0)\n            {\n                CGContextStrokePath(cr);\n            }\n            if (Noffsets)\n            {\n                CGContextTranslateCTM(cr, -translation.x, -translation.y);\n            }\n        }\n    }\n\nexit:\n    CGContextRestoreGState(cr);\n    if (toffsets) free(toffsets);\n    Py_XDECREF(facecolors_arr);\n    Py_XDECREF(edgecolors_arr);\n    Py_XDECREF(coordinates_arr);\n\n    if (!ok) return NULL;\n\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic int _find_minimum(CGFloat values[3])\n{\n    int i = 0;\n    CGFloat minimum = values[0];\n    if (values[1] < minimum)\n    {\n        minimum = values[1];\n        i = 1;\n    }\n    if (values[2] < minimum)\n        i = 2;\n    return i;\n}\n\nstatic int _find_maximum(CGFloat values[3])\n{\n    int i = 0;\n    CGFloat maximum = values[0];\n    if (values[1] > maximum)\n    {\n        maximum = values[1];\n        i = 1;\n    }\n    if (values[2] > maximum)\n        i = 2;\n    return i;\n}\n\nstatic void\n_rgba_color_evaluator(void* info, const CGFloat input[], CGFloat outputs[])\n{\n    const CGFloat c1 = input[0];\n    const CGFloat c0 = 1.0 - c1;\n    CGFloat(* color)[4] = info;\n    outputs[0] = c0 * color[0][0] + c1 * color[1][0];\n    outputs[1] = c0 * color[0][1] + c1 * color[1][1];\n    outputs[2] = c0 * color[0][2] + c1 * color[1][2];\n    outputs[3] = c0 * color[0][3] + c1 * color[1][3];\n}\n\nstatic void\n_gray_color_evaluator(void* info, const CGFloat input[], CGFloat outputs[])\n{\n    const CGFloat c1 = input[0];\n    const CGFloat c0 = 1.0 - c1;\n    CGFloat(* color)[2] = info;\n    outputs[0] = c0 * color[0][0] + c1 * color[1][0];\n    outputs[1] = c0 * color[0][1] + c1 * color[1][1];\n}\n\nstatic int\n_shade_one_color(CGContextRef cr, CGFloat colors[3], CGPoint points[3], int icolor)\n{\n    const int imin = _find_minimum(colors);\n    const int imax = _find_maximum(colors);\n\n    float numerator;\n    float denominator;\n    float ac;\n    float as;\n    float phi;\n    float distance;\n    CGPoint start;\n    CGPoint end;\n    static CGFunctionCallbacks callbacks = {0, &_rgba_color_evaluator, free};\n    CGFloat domain[2] = {0.0, 1.0};\n    CGFloat range[8] = {0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0};\n    CGFunctionRef function;\n\n    CGFloat(* rgba)[4] = malloc(2*sizeof(CGFloat[4]));\n    if (!rgba) return -1;\n    else {\n        rgba[0][0] = 0.0;\n        rgba[0][1] = 0.0;\n        rgba[0][2] = 0.0;\n        rgba[0][3] = 1.0;\n        rgba[1][0] = 0.0;\n        rgba[1][1] = 0.0;\n        rgba[1][2] = 0.0;\n        rgba[1][3] = 1.0;\n    }\n\n    denominator = (points[1].x-points[0].x)*(points[2].y-points[0].y)\n                - (points[2].x-points[0].x)*(points[1].y-points[0].y);\n    numerator = (colors[1]-colors[0])*(points[2].y-points[0].y)\n              - (colors[2]-colors[0])*(points[1].y-points[0].y);\n    ac = numerator / denominator;\n    numerator = (colors[2]-colors[0])*(points[1].x-points[0].x)\n              - (colors[1]-colors[0])*(points[2].x-points[0].x);\n    as = numerator / denominator;\n    phi = atan2(as, ac);\n\n    start.x = points[imin].x;\n    start.y = points[imin].y;\n\n    rgba[0][icolor] = colors[imin];\n    rgba[1][icolor] = colors[imax];\n\n    distance = (points[imax].x-points[imin].x) * cos(phi) + (points[imax].y-points[imin].y) * sin(phi);\n\n    end.x = start.x + distance * cos(phi);\n    end.y = start.y + distance * sin(phi);\n\n    function = CGFunctionCreate(rgba,\n                                1, /* one input (position) */\n                                domain,\n                                4, /* rgba output */\n                                range,\n                                &callbacks);\n    if (function)\n    {\n        CGColorSpaceRef colorspace = CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB);\n        CGShadingRef shading = CGShadingCreateAxial(colorspace,\n                                                    start,\n                                                    end,\n                                                    function,\n                                                    true,\n                                                    true);\n        CGColorSpaceRelease(colorspace);\n        CGFunctionRelease(function);\n        if (shading)\n        {\n            CGContextDrawShading(cr, shading);\n            CGShadingRelease(shading);\n            return 1;\n        }\n    }\n    free(rgba);\n    return -1;\n}\n\nstatic CGRect _find_enclosing_rect(CGPoint points[3])\n{\n    CGFloat left = points[0].x;\n    CGFloat right = points[0].x;\n    CGFloat bottom = points[0].y;\n    CGFloat top = points[0].y;\n    if (points[1].x < left) left = points[1].x;\n    if (points[1].x > right) right = points[1].x;\n    if (points[2].x < left) left = points[2].x;\n    if (points[2].x > right) right = points[2].x;\n    if (points[1].y < bottom) bottom = points[1].y;\n    if (points[1].y > top) top = points[1].y;\n    if (points[2].y < bottom) bottom = points[2].y;\n    if (points[2].y > top) top = points[2].y;\n    return CGRectMake(left,bottom,right-left,top-bottom);\n}\n\nstatic int\n_shade_alpha(CGContextRef cr, CGFloat alphas[3], CGPoint points[3])\n{\n    const int imin = _find_minimum(alphas);\n    const int imax = _find_maximum(alphas);\n\n    if (alphas[imin]==1.0) return 0;\n\n    CGRect rect = _find_enclosing_rect(points);\n    const size_t width = (size_t)rect.size.width;\n    const size_t height = (size_t)rect.size.height;\n    if (width==0 || height==0) return 0;\n\n    void* data = malloc(width*height);\n\n    CGColorSpaceRef colorspace = CGColorSpaceCreateDeviceGray();\n    CGContextRef bitmap = CGBitmapContextCreate(data,\n                                                width,\n                                                height,\n                                                8,\n                                                width,\n                                                colorspace,\n                                                0);\n    CGColorSpaceRelease(colorspace);\n\n    if (imin==imax)\n    {\n        CGRect bitmap_rect = rect;\n        bitmap_rect.origin = CGPointZero;\n        CGContextSetGrayFillColor(bitmap, alphas[0], 1.0);\n        CGContextFillRect(bitmap, bitmap_rect);\n    }\n    else\n    {\n        float numerator;\n        float denominator;\n        float ac;\n        float as;\n        float phi;\n        float distance;\n        CGPoint start;\n        CGPoint end;\n        CGFloat(*gray)[2] = malloc(2*sizeof(CGFloat[2]));\n\n        static CGFunctionCallbacks callbacks = {0, &_gray_color_evaluator, free};\n        CGFloat domain[2] = {0.0, 1.0};\n        CGFloat range[2] = {0.0, 1.0};\n        CGShadingRef shading = NULL;\n        CGFunctionRef function;\n\n        gray[0][1] = 1.0;\n        gray[1][1] = 1.0;\n\n        denominator = (points[1].x-points[0].x)*(points[2].y-points[0].y)\n                    - (points[2].x-points[0].x)*(points[1].y-points[0].y);\n        numerator = (alphas[1]-alphas[0])*(points[2].y-points[0].y)\n                  - (alphas[2]-alphas[0])*(points[1].y-points[0].y);\n        ac = numerator / denominator;\n        numerator = (alphas[2]-alphas[0])*(points[1].x-points[0].x)\n                  - (alphas[1]-alphas[0])*(points[2].x-points[0].x);\n        as = numerator / denominator;\n        phi = atan2(as, ac);\n\n        start.x = points[imin].x - rect.origin.x;\n        start.y = points[imin].y - rect.origin.y;\n\n        gray[0][0] = alphas[imin];\n        gray[1][0] = alphas[imax];\n\n        distance = (points[imax].x-points[imin].x) * cos(phi) + (points[imax].y-points[imin].y) * sin(phi);\n\n        end.x = start.x + distance * cos(phi);\n        end.y = start.y + distance * sin(phi);\n\n        function = CGFunctionCreate(gray,\n                                    1, /* one input (position) */\n                                    domain,\n                                    1, /* one output (gray level) */\n                                    range,\n                                    &callbacks);\n        if (function)\n        {\n            shading = CGShadingCreateAxial(colorspace,\n                                           start,\n                                           end,\n                                           function,\n                                           true,\n                                           true);\n            CGFunctionRelease(function);\n        }\n        if (shading)\n        {\n            CGContextDrawShading(bitmap, shading);\n            CGShadingRelease(shading);\n        }\n        else\n        {\n            free(gray);\n        }\n    }\n\n    CGImageRef mask = CGBitmapContextCreateImage(bitmap);\n    CGContextClipToMask(cr, rect, mask);\n    CGImageRelease(mask);\n    CGContextRelease(bitmap);\n    free(data);\n    return 0;\n}\n\n\nstatic CGFloat _get_device_scale(CGContextRef cr)\n{\n    CGSize pixelSize = CGContextConvertSizeToDeviceSpace(cr, CGSizeMake(1,1));\n    return pixelSize.width;\n}\n\n\nstatic PyObject*\nGraphicsContext_draw_gouraud_triangle (GraphicsContext* self, PyObject* args)\n\n{\n    PyObject* coordinates;\n    PyArrayObject* coordinates_arr = 0;\n    PyObject* colors;\n    PyArrayObject* colors_arr = 0;\n\n    CGPoint points[3];\n    CGFloat intensity[3];\n\n    int i = 0;\n\n    CGContextRef cr = self->cr;\n    if (!cr)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"CGContextRef is NULL\");\n        return NULL;\n    }\n\n    if(!PyArg_ParseTuple(args, \"OO\", &coordinates, &colors)) return NULL;\n\n    /* ------------------- Check coordinates array ------------------------ */\n\n    coordinates_arr = (PyArrayObject*) PyArray_FromObject(coordinates, NPY_DOUBLE, 2, 2);\n    if (!coordinates_arr ||\n        PyArray_DIM(coordinates_arr, 0) != 3 || PyArray_DIM(coordinates_arr, 1) != 2)\n    {\n        PyErr_SetString(PyExc_ValueError, \"Invalid coordinates array\");\n        Py_XDECREF(coordinates_arr);\n        return NULL;\n    }\n    points[0].x = *((double*)(PyArray_GETPTR2(coordinates_arr, 0, 0)));\n    points[0].y = *((double*)(PyArray_GETPTR2(coordinates_arr, 0, 1)));\n    points[1].x = *((double*)(PyArray_GETPTR2(coordinates_arr, 1, 0)));\n    points[1].y = *((double*)(PyArray_GETPTR2(coordinates_arr, 1, 1)));\n    points[2].x = *((double*)(PyArray_GETPTR2(coordinates_arr, 2, 0)));\n    points[2].y = *((double*)(PyArray_GETPTR2(coordinates_arr, 2, 1)));\n\n    /* ------------------- Check colors array ----------------------------- */\n\n    colors_arr = (PyArrayObject*) PyArray_FromObject(colors, NPY_DOUBLE, 2, 2);\n    if (!colors_arr ||\n        PyArray_DIM(colors_arr, 0) != 3 || PyArray_DIM(colors_arr, 1) != 4)\n    {\n        PyErr_SetString(PyExc_ValueError, \"colors must by a 3x4 array\");\n        Py_DECREF(coordinates_arr);\n        Py_XDECREF(colors_arr);\n        return NULL;\n    }\n\n    /* ----- Draw the gradients separately for each color component ------- */\n    CGContextSaveGState(cr);\n    CGContextMoveToPoint(cr, points[0].x, points[0].y);\n    CGContextAddLineToPoint(cr, points[1].x, points[1].y);\n    CGContextAddLineToPoint(cr, points[2].x, points[2].y);\n    CGContextClip(cr);\n    intensity[0] = *((double*)(PyArray_GETPTR2(colors_arr, 0, 3)));\n    intensity[1] = *((double*)(PyArray_GETPTR2(colors_arr, 1, 3)));\n    intensity[2] = *((double*)(PyArray_GETPTR2(colors_arr, 2, 3)));\n    if (_shade_alpha(cr, intensity, points)!=-1) {\n        CGContextBeginTransparencyLayer(cr, NULL);\n        CGContextSetBlendMode(cr, kCGBlendModeScreen);\n        for (i = 0; i < 3; i++)\n        {\n            intensity[0] = *((double*)(PyArray_GETPTR2(colors_arr, 0, i)));\n            intensity[1] = *((double*)(PyArray_GETPTR2(colors_arr, 1, i)));\n            intensity[2] = *((double*)(PyArray_GETPTR2(colors_arr, 2, i)));\n            if (!_shade_one_color(cr, intensity, points, i)) break;\n        }\n        CGContextEndTransparencyLayer(cr);\n    }\n    CGContextRestoreGState(cr);\n\n    Py_DECREF(coordinates_arr);\n    Py_DECREF(colors_arr);\n\n    if (i < 3) /* break encountered */\n    {\n        PyErr_SetString(PyExc_MemoryError, \"insufficient memory in draw_gouraud_triangle\");\n        return NULL;\n    }\n\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\n#ifdef COMPILING_FOR_10_5\nstatic CTFontRef\n#else\nstatic ATSFontRef\n#endif\nsetfont(CGContextRef cr, PyObject* family, float size, const char weight[],\n        const char italic[])\n{\n#define NMAP 40\n#define NFONT 31\n    int i, j, n;\n    const char* temp;\n    const char* name = \"Times-Roman\";\n    CFStringRef string;\n#ifdef COMPILING_FOR_10_5\n    CTFontRef font = 0;\n#else\n    ATSFontRef font = 0;\n#endif\n    PyObject* ascii = NULL;\n\n    const int k = (strcmp(italic, \"italic\") ? 0 : 2)\n                + (strcmp(weight, \"bold\") ? 0 : 1);\n\n    struct {char* name; int index;} map[NMAP] = {\n        {\"New Century Schoolbook\", 0},\n        {\"Century Schoolbook L\", 0},\n        {\"Utopia\", 1},\n        {\"ITC Bookman\", 2},\n        {\"Bookman\", 2},\n        {\"Bitstream Vera Serif\", 3},\n        {\"Nimbus Roman No9 L\", 4},\n        {\"Times New Roman\", 5},\n        {\"Times\", 6},\n        {\"Palatino\", 7},\n        {\"Charter\", 8},\n        {\"serif\", 0},\n        {\"Lucida Grande\", 9},\n        {\"Verdana\", 10},\n        {\"Geneva\", 11},\n        {\"Lucida\", 12},\n        {\"Bitstream Vera Sans\", 13},\n        {\"Arial\", 14},\n        {\"Helvetica\", 15},\n        {\"Avant Garde\", 16},\n        {\"sans-serif\", 15},\n        {\"Apple Chancery\", 17},\n        {\"Textile\", 18},\n        {\"Zapf Chancery\", 19},\n        {\"Sand\", 20},\n        {\"cursive\", 17},\n        {\"Comic Sans MS\", 21},\n        {\"Chicago\", 22},\n        {\"Charcoal\", 23},\n        {\"Impact\", 24},\n        {\"Western\", 25},\n        {\"fantasy\", 21},\n        {\"Andale Mono\", 26},\n        {\"Bitstream Vera Sans Mono\", 27},\n        {\"Nimbus Mono L\", 28},\n        {\"Courier\", 29},\n        {\"Courier New\", 30},\n        {\"Fixed\", 30},\n        {\"Terminal\", 30},\n        {\"monospace\", 30},\n    };\n\n    const char* psnames[NFONT][4] = {\n      {\"CenturySchoolbook\",                   /* 0 */\n       \"CenturySchoolbook-Bold\",\n       \"CenturySchoolbook-Italic\",\n       \"CenturySchoolbook-BoldItalic\"},\n      {\"Utopia\",                              /* 1 */\n       \"Utopia-Bold\",\n       \"Utopia-Italic\",\n       \"Utopia-BoldItalic\"},\n      {\"Bookman-Light\",                       /* 2 */\n       \"Bookman-Bold\",\n       \"Bookman-LightItalic\",\n       \"Bookman-BoldItalic\"},\n      {\"BitstreamVeraSerif-Roman\",            /* 3 */\n       \"BitstreamVeraSerif-Bold\",\n       \"\",\n       \"\"},\n      {\"NimbusRomNo9L-Reg\",                   /* 4 */\n       \"NimbusRomNo9T-Bol\",\n       \"NimbusRomNo9L-RegIta\",\n       \"NimbusRomNo9T-BolIta\"},\n      {\"TimesNewRomanPSMT\",                   /* 5 */\n       \"TimesNewRomanPS-BoldMT\",\n       \"TimesNewRomanPS-ItalicMT\",\n       \"TimesNewRomanPS-BoldItalicMT\"},\n      {\"Times-Roman\",                         /* 6 */\n       \"Times-Bold\",\n       \"Times-Italic\",\n       \"Times-BoldItalic\"},\n      {\"Palatino-Roman\",                      /* 7 */\n       \"Palatino-Bold\",\n       \"Palatino-Italic\",\n       \"Palatino-BoldItalic\"},\n      {\"CharterBT-Roman\",                     /* 8 */\n       \"CharterBT-Bold\",\n       \"CharterBT-Italic\",\n       \"CharterBT-BoldItalic\"},\n      {\"LucidaGrande\",                        /* 9 */\n       \"LucidaGrande-Bold\",\n       \"\",\n       \"\"},\n      {\"Verdana\",                            /* 10 */\n       \"Verdana-Bold\",\n       \"Verdana-Italic\",\n       \"Verdana-BoldItalic\"},\n      {\"Geneva\",                             /* 11 */\n       \"\",\n       \"\",\n       \"\"},\n      {\"LucidaSans\",                         /* 12 */\n       \"LucidaSans-Demi\",\n       \"LucidaSans-Italic\",\n       \"LucidaSans-DemiItalic\"},\n      {\"BitstreamVeraSans-Roman\",            /* 13 */\n       \"BitstreamVeraSans-Bold\",\n       \"BitstreamVeraSans-Oblique\",\n       \"BitstreamVeraSans-BoldOblique\"},\n      {\"ArialMT\",                            /* 14 */\n       \"Arial-BoldMT\",\n       \"Arial-ItalicMT\",\n       \"Arial-BoldItalicMT\"},\n      {\"Helvetica\",                          /* 15 */\n       \"Helvetica-Bold\",\n       \"Arial-ItalicMT\",\n       \"Arial-BoldItalicMT\"},\n      {\"AvantGardeITC-Book\",                 /* 16 */\n       \"AvantGardeITC-Demi\",\n       \"AvantGardeITC-BookOblique\",\n       \"AvantGardeITC-DemiOblique\"},\n      {\"Apple-Chancery\",                     /* 17 */\n       \"\",\n       \"\",\n       \"\"},\n      {\"TextileRegular\",                     /* 18 */\n       \"\",\n       \"\",\n       \"\"},\n      {\"ZapfChancery-Roman\",                 /* 19 */\n       \"ZapfChancery-Bold\",\n       \"ZapfChancery-Italic\",\n       \"ZapfChancery-MediumItalic\"},\n      {\"SandRegular\",                        /* 20 */\n       \"\",\n       \"\",\n       \"\"},\n      {\"ComicSansMS\",                        /* 21 */\n       \"ComicSansMS-Bold\",\n       \"\",\n       \"\"},\n      {\"Chicago\",                            /* 22 */\n       \"\",\n       \"\",\n       \"\"},\n      {\"Charcoal\",                           /* 23 */\n       \"\",\n       \"\",\n       \"\"},\n      {\"Impact\",                             /* 24 */\n       \"\",\n       \"\",\n       \"\"},\n      {\"Playbill\",                           /* 25 */\n       \"\",\n       \"\",\n       \"\"},\n      {\"AndaleMono\",                         /* 26 */\n       \"\",\n       \"\",\n       \"\"},\n      {\"BitstreamVeraSansMono-Roman\",        /* 27 */\n       \"BitstreamVeraSansMono-Bold\",\n       \"BitstreamVeraSansMono-Oblique\",\n       \"BitstreamVeraSansMono-BoldOb\"},\n      {\"NimbusMonL-Reg\",                     /* 28 */\n       \"NimbusMonL-Bol\",\n       \"NimbusMonL-RegObl\",\n       \"NimbusMonL-BolObl\"},\n      {\"Courier\",                            /* 29 */\n       \"Courier-Bold\",\n       \"\",\n       \"\"},\n      {\"CourierNewPS\",                       /* 30 */\n       \"CourierNewPS-BoldMT\",\n       \"CourierNewPS-ItalicMT\",\n       \"CourierNewPS-Bold-ItalicMT\"},\n    };\n\n    if(!PyList_Check(family))\n    {\n        PyErr_SetString(PyExc_ValueError, \"family should be a list\");\n        return 0;\n    }\n    n = PyList_GET_SIZE(family);\n\n    for (i = 0; i < n; i++)\n    {\n        PyObject* item = PyList_GET_ITEM(family, i);\n        ascii = PyUnicode_AsASCIIString(item);\n        if(!ascii)\n        {\n            PyErr_SetString(PyExc_ValueError,\n                            \"failed to convert font family name to ASCII\");\n            return 0;\n        }\n        temp = PyBytes_AS_STRING(ascii);\n        for (j = 0; j < NMAP; j++)\n        {    if (!strcmp(map[j].name, temp))\n             {    temp = psnames[map[j].index][k];\n                  break;\n             }\n        }\n        /* If the font name is not found in mapping, we assume */\n        /* that the user specified the Postscript name directly */\n\n        /* Check if this font can be found on the system */\n        string = CFStringCreateWithCString(kCFAllocatorDefault,\n                                           temp,\n                                           kCFStringEncodingMacRoman);\n#ifdef COMPILING_FOR_10_5\n        font = CTFontCreateWithName(string, size, NULL);\n#else\n        font = ATSFontFindFromPostScriptName(string, kATSOptionFlagsDefault);\n#endif\n\n        CFRelease(string);\n\n        if(font)\n        {\n            name = temp;\n            break;\n        }\n        Py_DECREF(ascii);\n        ascii = NULL;\n    }\n    if(!font)\n    {   string = CFStringCreateWithCString(kCFAllocatorDefault,\n                                           name,\n                                           kCFStringEncodingMacRoman);\n#ifdef COMPILING_FOR_10_5\n        font = CTFontCreateWithName(string, size, NULL);\n#else\n        font = ATSFontFindFromPostScriptName(string, kATSOptionFlagsDefault);\n#endif\n        CFRelease(string);\n    }\n    if (font == NULL)\n    {\n        PyErr_SetString(PyExc_ValueError, \"Could not load font\");\n    }\n#ifndef COMPILING_FOR_10_5\n    else {\n        CGContextSelectFont(cr, name, size, kCGEncodingMacRoman);\n    }\n#endif\n#if PY3K\n    Py_XDECREF(ascii);\n#endif\n    return font;\n}\n\n#ifdef COMPILING_FOR_10_5\nstatic PyObject*\nGraphicsContext_draw_text (GraphicsContext* self, PyObject* args)\n{\n    float x;\n    float y;\n    int n;\n    PyObject* family;\n    float size;\n    const char* weight;\n    const char* italic;\n    float angle;\n    CTFontRef font;\n    CGColorRef color;\n    CGFloat descent;\n#if PY33\n    const char* text;\n#else\n    const UniChar* text;\n#endif\n\n    CFStringRef keys[2];\n    CFTypeRef values[2];\n\n    CGContextRef cr = self->cr;\n    if (!cr)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"CGContextRef is NULL\");\n        return NULL;\n    }\n#if PY33\n    if(!PyArg_ParseTuple(args, \"ffs#Ofssf\",\n                                &x,\n                                &y,\n                                &text,\n                                &n,\n                                &family,\n                                &size,\n                                &weight,\n                                &italic,\n                                &angle)) return NULL;\n    CFStringRef s = CFStringCreateWithCString(kCFAllocatorDefault, text, kCFStringEncodingUTF8);\n#else\n    if(!PyArg_ParseTuple(args, \"ffu#Ofssf\",\n                                &x,\n                                &y,\n                                &text,\n                                &n,\n                                &family,\n                                &size,\n                                &weight,\n                                &italic,\n                                &angle)) return NULL;\n    CFStringRef s = CFStringCreateWithCharacters(kCFAllocatorDefault, text, n);\n#endif\n\n    if (!(font = setfont(cr, family, size, weight, italic)))\n    {\n        CFRelease(s);\n        return NULL;\n    }\n\n    color = CGColorCreateGenericRGB(self->color[0],\n                                    self->color[1],\n                                    self->color[2],\n                                    self->color[3]);\n\n    keys[0] = kCTFontAttributeName;\n    keys[1] = kCTForegroundColorAttributeName;\n    values[0] = font;\n    values[1] = color;\n    CFDictionaryRef attributes = CFDictionaryCreate(kCFAllocatorDefault,\n                                        (const void**)&keys,\n                                        (const void**)&values,\n                                        2,\n                                        &kCFTypeDictionaryKeyCallBacks,\n                                        &kCFTypeDictionaryValueCallBacks);\n    CGColorRelease(color);\n    CFRelease(font);\n\n    CFAttributedStringRef string = CFAttributedStringCreate(kCFAllocatorDefault,\n                                                            s,\n                                                            attributes);\n    CFRelease(s);\n    CFRelease(attributes);\n\n    CTLineRef line = CTLineCreateWithAttributedString(string);\n    CFRelease(string);\n\n    CTLineGetTypographicBounds(line, NULL, &descent, NULL);\n\n    if (!line)\n    {\n        PyErr_SetString(PyExc_RuntimeError,\n                        \"CTLineCreateWithAttributedString failed\");\n        return NULL;\n    }\n\n    CGContextSetTextMatrix(cr, CGAffineTransformIdentity);\n    if (angle)\n    {\n        CGContextSaveGState(cr);\n        CGContextTranslateCTM(cr, x, y);\n        CGContextRotateCTM(cr, angle*M_PI/180);\n        CTLineDraw(line, cr);\n        CGContextRestoreGState(cr);\n    }\n    else\n    {\n        CGContextSetTextPosition(cr, x, y);\n        CTLineDraw(line, cr);\n    }\n    CFRelease(line);\n\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyObject*\nGraphicsContext_get_text_width_height_descent(GraphicsContext* self, PyObject* args)\n{\n    int n;\n    PyObject* family;\n    float size;\n    const char* weight;\n    const char* italic;\n\n#if PY33\n    const char* text;\n#else\n    const UniChar* text;\n#endif\n\n    CGFloat ascent;\n    CGFloat descent;\n    double width;\n    CGRect rect;\n\n    CTFontRef font;\n\n    CGContextRef cr = self->cr;\n    if (!cr)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"CGContextRef is NULL\");\n        return NULL;\n    }\n\n#if PY33\n    if(!PyArg_ParseTuple(args, \"s#Ofss\",\n                                &text,\n                                &n,\n                                &family,\n                                &size,\n                                &weight,\n                                &italic)) return NULL;\n    CFStringRef s = CFStringCreateWithCString(kCFAllocatorDefault, text, kCFStringEncodingUTF8);\n#else\n    if(!PyArg_ParseTuple(args, \"u#Ofss\",\n                                &text,\n                                &n,\n                                &family,\n                                &size,\n                                &weight,\n                                &italic)) return NULL;\n    CFStringRef s = CFStringCreateWithCharacters(kCFAllocatorDefault, text, n);\n#endif\n\n    if (!(font = setfont(cr, family, size, weight, italic)))\n    {\n        CFRelease(s);\n        return NULL;\n    };\n\n    CFStringRef keys[1];\n    CFTypeRef values[1];\n\n    keys[0] = kCTFontAttributeName;\n    values[0] = font;\n    CFDictionaryRef attributes = CFDictionaryCreate(kCFAllocatorDefault,\n                                        (const void**)&keys,\n                                        (const void**)&values,\n                                        1,\n                                        &kCFTypeDictionaryKeyCallBacks,\n                                        &kCFTypeDictionaryValueCallBacks);\n    CFRelease(font);\n\n    CFAttributedStringRef string = CFAttributedStringCreate(kCFAllocatorDefault,\n                                                            s,\n                                                            attributes);\n    CFRelease(s);\n    CFRelease(attributes);\n\n    CTLineRef line = CTLineCreateWithAttributedString(string);\n    CFRelease(string);\n\n    if (!line)\n    {\n        PyErr_SetString(PyExc_RuntimeError,\n                        \"CTLineCreateWithAttributedString failed\");\n        return NULL;\n    }\n\n    width = CTLineGetTypographicBounds(line, &ascent, &descent, NULL);\n    rect = CTLineGetImageBounds(line, cr);\n\n    CFRelease(line);\n\n    return Py_BuildValue(\"fff\", width, rect.size.height, descent);\n}\n\n#else // Text drawing for OSX versions <10.5\n\nstatic PyObject*\nGraphicsContext_draw_text (GraphicsContext* self, PyObject* args)\n{\n    float x;\n    float y;\n    const UniChar* text;\n    int n;\n    PyObject* family;\n    float size;\n    const char* weight;\n    const char* italic;\n    float angle;\n    ATSFontRef atsfont;\n    CGContextRef cr = self->cr;\n    if (!cr)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"CGContextRef is NULL\");\n        return NULL;\n    }\n    if(!PyArg_ParseTuple(args, \"ffu#Ofssf\",\n                                &x,\n                                &y,\n                                &text,\n                                &n,\n                                &family,\n                                &size,\n                                &weight,\n                                &italic,\n                                &angle)) return NULL;\n\n    if (!(atsfont = setfont(cr, family, size, weight, italic)))\n    {\n        return NULL;\n    }\n\n    OSStatus status;\n\n    ATSUAttributeTag tags[] =  {kATSUFontTag, kATSUSizeTag, kATSUQDBoldfaceTag};\n    ByteCount sizes[] = {sizeof(ATSUFontID), sizeof(Fixed), sizeof(Boolean)};\n    Fixed atsuSize = Long2Fix(size);\n    Boolean isBold = FALSE; /* setfont takes care of this */\n\n    ATSUAttributeValuePtr values[] = {&atsfont, &atsuSize, &isBold};\n    status = ATSUSetAttributes(style, 3, tags, sizes, values);\n    if (status!=noErr)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"ATSUSetAttributes failed\");\n        return NULL;\n    }\n\n    status = ATSUSetTextPointerLocation(layout,\n                    text,\n                    kATSUFromTextBeginning,  /* offset from beginning */\n                    kATSUToTextEnd,          /* length of text range */\n                    n);                      /* length of text buffer */\n    if (status!=noErr)\n    {\n        PyErr_SetString(PyExc_RuntimeError,\n                        \"ATSUCreateTextLayoutWithTextPtr failed\");\n        return NULL;\n    }\n\n    status = ATSUSetRunStyle(layout,\n                             style,\n                             kATSUFromTextBeginning,\n                             kATSUToTextEnd);\n    if (status!=noErr)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"ATSUSetRunStyle failed\");\n        return NULL;\n    }\n\n    Fixed atsuAngle = X2Fix(angle);\n    ATSUAttributeTag tags2[] = {kATSUCGContextTag, kATSULineRotationTag};\n    ByteCount sizes2[] = {sizeof (CGContextRef), sizeof(Fixed)};\n    ATSUAttributeValuePtr values2[] = {&cr, &atsuAngle};\n    status = ATSUSetLayoutControls(layout, 2, tags2, sizes2, values2);\n    if (status!=noErr)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"ATSUSetLayoutControls failed\");\n        return NULL;\n    }\n\n    status = ATSUDrawText(layout,\n                          kATSUFromTextBeginning,\n                          kATSUToTextEnd,\n                          X2Fix(x),\n                          X2Fix(y));\n    if (status!=noErr)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"ATSUDrawText failed\");\n        return NULL;\n    }\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyObject*\nGraphicsContext_get_text_width_height_descent(GraphicsContext* self, PyObject* args)\n{\n    const UniChar* text;\n    int n;\n    PyObject* family;\n    float size;\n    const char* weight;\n    const char* italic;\n\n    ATSFontRef atsfont;\n\n    CGContextRef cr = self->cr;\n    if (!cr)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"CGContextRef is NULL\");\n        return NULL;\n    }\n\n    if(!PyArg_ParseTuple(args, \"u#Ofss\", &text, &n, &family, &size, &weight, &italic)) return NULL;\n\n    if (!(atsfont = setfont(cr, family, size, weight, italic)))\n    {\n        return NULL;\n    }\n\n    OSStatus status = noErr;\n    ATSUAttributeTag tags[] = {kATSUFontTag,\n                               kATSUSizeTag,\n                               kATSUQDBoldfaceTag,\n                               kATSUQDItalicTag};\n    ByteCount sizes[] = {sizeof(ATSUFontID),\n                         sizeof(Fixed),\n                         sizeof(Boolean),\n                         sizeof(Boolean)};\n    Fixed atsuSize = Long2Fix(size);\n    Boolean isBold = FALSE; /* setfont takes care of this */\n    Boolean isItalic = FALSE; /* setfont takes care of this */\n    ATSUAttributeValuePtr values[] = {&atsfont, &atsuSize, &isBold, &isItalic};\n\n    status = ATSUSetAttributes(style, 4, tags, sizes, values);\n    if (status!=noErr)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"ATSUSetAttributes failed\");\n        return NULL;\n    }\n\n    status = ATSUSetTextPointerLocation(layout,\n                    text,\n                    kATSUFromTextBeginning,  /* offset from beginning */\n                    kATSUToTextEnd,          /* length of text range */\n                    n);                      /* length of text buffer */\n    if (status!=noErr)\n    {\n        PyErr_SetString(PyExc_RuntimeError,\n                        \"ATSUCreateTextLayoutWithTextPtr failed\");\n        return NULL;\n    }\n\n    status = ATSUSetRunStyle(layout,\n                             style,\n                             kATSUFromTextBeginning,\n                             kATSUToTextEnd);\n    if (status!=noErr)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"ATSUSetRunStyle failed\");\n        return NULL;\n    }\n\n    ATSUAttributeTag tag = kATSUCGContextTag;\n    ByteCount bc = sizeof (CGContextRef);\n    ATSUAttributeValuePtr value = &cr;\n    status = ATSUSetLayoutControls(layout, 1, &tag, &bc, &value);\n    if (status!=noErr)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"ATSUSetLayoutControls failed\");\n        return NULL;\n    }\n\n    ATSUTextMeasurement before;\n    ATSUTextMeasurement after;\n    ATSUTextMeasurement ascent;\n    ATSUTextMeasurement descent;\n    status = ATSUGetUnjustifiedBounds(layout,\n                                      kATSUFromTextBeginning, kATSUToTextEnd,\n                                      &before, &after, &ascent, &descent);\n    if (status!=noErr)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"ATSUGetUnjustifiedBounds failed\");\n        return NULL;\n    }\n\n    const float width = FixedToFloat(after-before);\n    const float height = FixedToFloat(ascent-descent);\n\n    return Py_BuildValue(\"fff\", width, height, FixedToFloat(descent));\n}\n#endif\n\nstatic void _data_provider_release(void* info, const void* data, size_t size)\n{\n    PyObject* image = (PyObject*)info;\n    Py_DECREF(image);\n}\n\n\n\n\nstatic PyObject*\nGraphicsContext_draw_mathtext(GraphicsContext* self, PyObject* args)\n{\n    float x, y, angle;\n    npy_intp nrows, ncols;\n    int n;\n\n    PyObject* object;\n    PyArrayObject* image;\n\n    CGContextRef cr = self->cr;\n    if (!cr)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"CGContextRef is NULL\");\n        return NULL;\n    }\n\n    if(!PyArg_ParseTuple(args, \"fffO\", &x, &y, &angle, &object)) return NULL;\n\n    /* ------------- Check the image ---------------------------- */\n    if(!PyArray_Check (object))\n    {\n        PyErr_SetString(PyExc_TypeError, \"image should be a NumPy array.\");\n        return NULL;\n    }\n    image = (PyArrayObject*) object;\n    if(PyArray_NDIM(image) != 2)\n    {\n        PyErr_Format(PyExc_TypeError,\n                         \"image has incorrect rank (%d expected 2)\",\n                         PyArray_NDIM(image));\n        return NULL;\n    }\n    if (PyArray_TYPE(image) != NPY_UBYTE)\n    {\n        PyErr_SetString(PyExc_TypeError,\n                        \"image has incorrect type (should be uint8)\");\n        return NULL;\n    }\n    if (!PyArray_ISCONTIGUOUS(image))\n    {\n        PyErr_SetString(PyExc_TypeError, \"image array is not contiguous\");\n        return NULL;\n    }\n\n    nrows = PyArray_DIM(image, 0);\n    ncols = PyArray_DIM(image, 1);\n    if (nrows != (int) nrows || ncols != (int) ncols)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"bitmap image too large\");\n        return NULL;\n    }\n    n = nrows * ncols;\n    Py_INCREF(object);\n\n    const size_t bytesPerComponent = 1;\n    const size_t bitsPerComponent = 8 * bytesPerComponent;\n    const size_t nComponents = 1; /* gray */\n    const size_t bitsPerPixel = bitsPerComponent * nComponents;\n    const size_t bytesPerRow = nComponents * bytesPerComponent * ncols;\n    CGDataProviderRef provider = CGDataProviderCreateWithData(object,\n                                                              PyArray_DATA(image),\n                                                              n,\n                                                              _data_provider_release);\n    CGImageRef bitmap = CGImageMaskCreate ((int) ncols,\n                                           (int) nrows,\n                                           bitsPerComponent,\n                                           bitsPerPixel,\n                                           bytesPerRow,\n                                           provider,\n                                           NULL,\n                                           false);\n    CGDataProviderRelease(provider);\n\n    if(!bitmap)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"CGImageMaskCreate failed\");\n        return NULL;\n    }\n\n    CGFloat deviceScale = _get_device_scale(cr);\n\n    if (angle==0.0)\n    {\n        CGContextDrawImage(cr, CGRectMake(x, y, ncols/deviceScale, nrows/deviceScale), bitmap);\n    }\n    else\n    {\n        CGContextSaveGState(cr);\n        CGContextTranslateCTM(cr, x, y);\n        CGContextRotateCTM(cr, angle*M_PI/180);\n        CGContextDrawImage(cr, CGRectMake(0, 0, ncols/deviceScale, nrows/deviceScale), bitmap);\n        CGContextRestoreGState(cr);\n    }\n    CGImageRelease(bitmap);\n\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyObject*\nGraphicsContext_draw_image(GraphicsContext* self, PyObject* args)\n{\n    float x, y;\n    int nrows, ncols;\n    const char* data;\n    int n;\n    PyObject* image;\n\n    CGContextRef cr = self->cr;\n    if (!cr)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"CGContextRef is NULL\");\n        return NULL;\n    }\n\n    if(!PyArg_ParseTuple(args, \"ffiiO\", &x,\n                                        &y,\n                                        &nrows,\n                                        &ncols,\n                                        &image)) return NULL;\n\n    CGColorSpaceRef colorspace;\n    CGDataProviderRef provider;\n\n    if (!PyBytes_Check(image))\n    {\n#if PY3K\n        PyErr_SetString(PyExc_RuntimeError, \"image is not a bytes object\");\n#else\n        PyErr_SetString(PyExc_RuntimeError, \"image is not a str object\");\n#endif\n        return NULL;\n    }\n\n    const size_t bytesPerComponent = 1;\n    const size_t bitsPerComponent = 8 * bytesPerComponent;\n    const size_t nComponents = 4; /* red, green, blue, alpha */\n    const size_t bitsPerPixel = bitsPerComponent * nComponents;\n    const size_t bytesPerRow = nComponents * bytesPerComponent * ncols;\n\n    colorspace = CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB);\n    if (!colorspace)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"failed to create a color space\");\n        return NULL;\n    }\n\n    Py_INCREF(image);\n#ifdef PY3K\n    n = PyBytes_GET_SIZE(image);\n    data = PyBytes_AS_STRING(image);\n#else\n    n = PyString_GET_SIZE(image);\n    data = PyString_AS_STRING(image);\n#endif\n\n    provider = CGDataProviderCreateWithData(image,\n                                            data,\n                                            n,\n                                            _data_provider_release);\n    CGImageRef bitmap = CGImageCreate (ncols,\n                                       nrows,\n                                       bitsPerComponent,\n                                       bitsPerPixel,\n                                       bytesPerRow,\n                                       colorspace,\n                                       kCGImageAlphaLast,\n                                       provider,\n                                       NULL,\n                                       false,\n\t\t\t\t       kCGRenderingIntentDefault);\n    CGColorSpaceRelease(colorspace);\n    CGDataProviderRelease(provider);\n\n    if(!bitmap)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"CGImageMaskCreate failed\");\n        return NULL;\n    }\n\n    CGFloat deviceScale = _get_device_scale(cr);\n\n    CGContextDrawImage(cr, CGRectMake(x, y, ncols/deviceScale, nrows/deviceScale), bitmap);\n    CGImageRelease(bitmap);\n\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyObject*\nGraphicsContext_get_image_magnification(GraphicsContext* self)\n{\n    CGContextRef cr = self->cr;\n    if (!cr)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"CGContextRef is NULL\");\n        return NULL;\n    }\n\n    return PyFloat_FromDouble(_get_device_scale(cr));\n}\n\n\nstatic PyMethodDef GraphicsContext_methods[] = {\n    {\"save\",\n     (PyCFunction)GraphicsContext_save,\n     METH_NOARGS,\n     \"Saves the current graphics context onto the stack.\"\n    },\n    {\"restore\",\n     (PyCFunction)GraphicsContext_restore,\n     METH_NOARGS,\n     \"Restores the current graphics context from the stack.\"\n    },\n    {\"get_text_width_height_descent\",\n     (PyCFunction)GraphicsContext_get_text_width_height_descent,\n     METH_VARARGS,\n     \"Returns the width, height, and descent of the text.\"\n    },\n    {\"set_alpha\",\n     (PyCFunction)GraphicsContext_set_alpha,\n      METH_VARARGS,\n     \"Sets the opacitiy level for objects drawn in a graphics context\"\n    },\n    {\"set_antialiased\",\n     (PyCFunction)GraphicsContext_set_antialiased,\n     METH_VARARGS,\n     \"Sets anti-aliasing on or off for a graphics context.\"\n    },\n    {\"set_capstyle\",\n     (PyCFunction)GraphicsContext_set_capstyle,\n     METH_VARARGS,\n     \"Sets the style for the endpoints of lines in a graphics context.\"\n    },\n    {\"set_clip_rectangle\",\n     (PyCFunction)GraphicsContext_set_clip_rectangle,\n     METH_VARARGS,\n     \"Sets the clipping path to the area defined by the specified rectangle.\"\n    },\n    {\"set_clip_path\",\n     (PyCFunction)GraphicsContext_set_clip_path,\n     METH_VARARGS,\n     \"Sets the clipping path.\"\n    },\n    {\"set_dashes\",\n     (PyCFunction)GraphicsContext_set_dashes,\n     METH_VARARGS,\n     \"Sets the pattern for dashed lines in a graphics context.\"\n    },\n    {\"set_foreground\",\n     (PyCFunction)GraphicsContext_set_foreground,\n     METH_VARARGS,\n     \"Sets the current stroke and fill color to a value in the DeviceRGB color space.\"\n    },\n    {\"set_graylevel\",\n     (PyCFunction)GraphicsContext_set_graylevel,\n     METH_VARARGS,\n     \"Sets the current stroke and fill color to a value in the DeviceGray color space.\"\n    },\n    {\"set_dpi\",\n     (PyCFunction)GraphicsContext_set_dpi,\n     METH_VARARGS,\n     \"Sets the dpi for a graphics context.\"\n    },\n    {\"set_linewidth\",\n     (PyCFunction)GraphicsContext_set_linewidth,\n     METH_VARARGS,\n     \"Sets the line width for a graphics context.\"\n    },\n    {\"set_joinstyle\",\n     (PyCFunction)GraphicsContext_set_joinstyle,\n     METH_VARARGS,\n     \"Sets the style for the joins of connected lines in a graphics context.\"\n    },\n    {\"draw_path\",\n     (PyCFunction)GraphicsContext_draw_path,\n     METH_VARARGS,\n     \"Draw a path in the graphics context and strokes and (if rgbFace is not None) fills it.\"\n    },\n    {\"draw_markers\",\n     (PyCFunction)GraphicsContext_draw_markers,\n     METH_VARARGS,\n     \"Draws a marker in the graphics context at each of the vertices in path.\"\n    },\n    {\"draw_path_collection\",\n     (PyCFunction)GraphicsContext_draw_path_collection,\n     METH_VARARGS,\n     \"Draw a collection of paths in the graphics context.\"\n    },\n    {\"draw_quad_mesh\",\n     (PyCFunction)GraphicsContext_draw_quad_mesh,\n     METH_VARARGS,\n     \"Draws a mesh in the graphics context.\"\n    },\n    {\"draw_gouraud_triangle\",\n     (PyCFunction)GraphicsContext_draw_gouraud_triangle,\n     METH_VARARGS,\n     \"Draws a Gouraud-shaded triangle in the graphics context.\"\n    },\n    {\"draw_text\",\n     (PyCFunction)GraphicsContext_draw_text,\n     METH_VARARGS,\n     \"Draw a string at (x,y) with the given properties in the graphics context.\"\n    },\n    {\"draw_mathtext\",\n     (PyCFunction)GraphicsContext_draw_mathtext,\n     METH_VARARGS,\n     \"Draw a TeX string at (x,y) as a bitmap in the graphics context.\"\n    },\n    {\"draw_image\",\n     (PyCFunction)GraphicsContext_draw_image,\n     METH_VARARGS,\n     \"Draw an image at (x,y) in the graphics context.\"\n    },\n    {\"get_image_magnification\",\n     (PyCFunction)GraphicsContext_get_image_magnification,\n     METH_NOARGS,\n     \"Returns the scale factor between user and device coordinates.\"\n    },\n    {NULL}  /* Sentinel */\n};\n\nstatic char GraphicsContext_doc[] =\n\"A GraphicsContext object wraps a Quartz 2D graphics context\\n\"\n\"(CGContextRef). Most methods either draw into the graphics context\\n\"\n\"(moveto, lineto, etc.) or set the drawing properties (set_linewidth,\\n\"\n\"set_joinstyle, etc.).\\n\";\n\nstatic PyTypeObject GraphicsContextType = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_macosx.GraphicsContext\", /*tp_name*/\n    sizeof(GraphicsContext),   /*tp_basicsize*/\n    0,                         /*tp_itemsize*/\n#ifdef COMPILING_FOR_10_5\n    0,                         /*tp_dealloc*/\n#else\n    (destructor)GraphicsContext_dealloc,     /*tp_dealloc*/\n#endif\n    0,                         /*tp_print*/\n    0,                         /*tp_getattr*/\n    0,                         /*tp_setattr*/\n    0,                         /*tp_compare*/\n    (reprfunc)GraphicsContext_repr,     /*tp_repr*/\n    0,                         /*tp_as_number*/\n    0,                         /*tp_as_sequence*/\n    0,                         /*tp_as_mapping*/\n    0,                         /*tp_hash */\n    0,                         /*tp_call*/\n    0,                         /*tp_str*/\n    0,                         /*tp_getattro*/\n    0,                         /*tp_setattro*/\n    0,                         /*tp_as_buffer*/\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,        /*tp_flags*/\n    GraphicsContext_doc,       /* tp_doc */\n    0,                         /* tp_traverse */\n    0,                         /* tp_clear */\n    0,                         /* tp_richcompare */\n    0,                         /* tp_weaklistoffset */\n    0,                         /* tp_iter */\n    0,                         /* tp_iternext */\n    GraphicsContext_methods,   /* tp_methods */\n    0,                         /* tp_members */\n    0,                         /* tp_getset */\n    0,                         /* tp_base */\n    0,                         /* tp_dict */\n    0,                         /* tp_descr_get */\n    0,                         /* tp_descr_set */\n    0,                         /* tp_dictoffset */\n    0,                         /* tp_init */\n    0,                         /* tp_alloc */\n    GraphicsContext_new,       /* tp_new */\n};\n\ntypedef struct {\n    PyObject_HEAD\n    View* view;\n} FigureCanvas;\n\nstatic PyObject*\nFigureCanvas_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    FigureCanvas *self = (FigureCanvas*)type->tp_alloc(type, 0);\n    if (!self) return NULL;\n    self->view = [View alloc];\n    return (PyObject*)self;\n}\n\nstatic int\nFigureCanvas_init(FigureCanvas *self, PyObject *args, PyObject *kwds)\n{\n    int width;\n    int height;\n    if(!self->view)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"NSView* is NULL\");\n        return -1;\n    }\n\n    if(!PyArg_ParseTuple(args, \"ii\", &width, &height)) return -1;\n\n    NSRect rect = NSMakeRect(0.0, 0.0, width, height);\n    self->view = [self->view initWithFrame: rect];\n    [self->view setCanvas: (PyObject*)self];\n    return 0;\n}\n\nstatic void\nFigureCanvas_dealloc(FigureCanvas* self)\n{\n    if (self->view)\n    {\n        [self->view setCanvas: NULL];\n        [self->view release];\n    }\n    Py_TYPE(self)->tp_free((PyObject*)self);\n}\n\nstatic PyObject*\nFigureCanvas_repr(FigureCanvas* self)\n{\n#if PY3K\n    return PyUnicode_FromFormat(\"FigureCanvas object %p wrapping NSView %p\",\n                               (void*)self, (void*)(self->view));\n#else\n    return PyString_FromFormat(\"FigureCanvas object %p wrapping NSView %p\",\n                               (void*)self, (void*)(self->view));\n#endif\n}\n\nstatic PyObject*\nFigureCanvas_draw(FigureCanvas* self)\n{\n    View* view = self->view;\n\n    if(view) /* The figure may have been closed already */\n    {\n        /* Whereas drawRect creates its own autorelease pool, apparently\n         * [view display] also needs one. Create and release it here. */\n        NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];\n        [view display];\n        [pool release];\n    }\n\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyObject*\nFigureCanvas_invalidate(FigureCanvas* self)\n{\n    View* view = self->view;\n    if(!view)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"NSView* is NULL\");\n        return NULL;\n    }\n    [view setNeedsDisplay: YES];\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyObject*\nFigureCanvas_flush_events(FigureCanvas* self)\n{\n    View* view = self->view;\n    if(!view)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"NSView* is NULL\");\n        return NULL;\n    }\n    [view displayIfNeeded];\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyObject*\nFigureCanvas_set_rubberband(FigureCanvas* self, PyObject *args)\n{\n    View* view = self->view;\n    int x0, y0, x1, y1;\n    NSRect rubberband;\n    if(!view)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"NSView* is NULL\");\n        return NULL;\n    }\n    if(!PyArg_ParseTuple(args, \"iiii\", &x0, &y0, &x1, &y1)) return NULL;\n    if (x1 > x0)\n    {\n        rubberband.origin.x = x0;\n        rubberband.size.width = x1 - x0;\n    }\n    else\n    {\n        rubberband.origin.x = x1;\n        rubberband.size.width = x0 - x1;\n    }\n    if (y1 > y0)\n    {\n        rubberband.origin.y = y0;\n        rubberband.size.height = y1 - y0;\n    }\n    else\n    {\n        rubberband.origin.y = y1;\n        rubberband.size.height = y0 - y1;\n    }\n    [view setRubberband: rubberband];\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyObject*\nFigureCanvas_remove_rubberband(FigureCanvas* self)\n{\n    View* view = self->view;\n    if(!view)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"NSView* is NULL\");\n        return NULL;\n    }\n    [view removeRubberband];\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic NSImage* _read_ppm_image(PyObject* obj)\n{\n    int width;\n    int height;\n    const char* data;\n    int n;\n    int i;\n    NSBitmapImageRep* bitmap;\n    unsigned char* bitmapdata;\n\n    if (!obj) return NULL;\n    if (!PyTuple_Check(obj)) return NULL;\n    if (!PyArg_ParseTuple(obj, \"iit#\", &width, &height, &data, &n)) return NULL;\n    if (width*height*3 != n) return NULL; /* RGB image uses 3 colors / pixel */\n\n    bitmap = [[NSBitmapImageRep alloc]\n                  initWithBitmapDataPlanes: NULL\n                                pixelsWide: width\n                                pixelsHigh: height\n                             bitsPerSample: 8\n                           samplesPerPixel: 3\n                                  hasAlpha: NO\n                                  isPlanar: NO\n                            colorSpaceName: NSDeviceRGBColorSpace\n                              bitmapFormat: 0\n                               bytesPerRow: width*3\n                               bitsPerPixel: 24];\n    if (!bitmap) return NULL;\n    bitmapdata = [bitmap bitmapData];\n    for (i = 0; i < n; i++) bitmapdata[i] = data[i];\n\n    NSSize size = NSMakeSize(width, height);\n    NSImage* image = [[NSImage alloc] initWithSize: size];\n    if (image) [image addRepresentation: bitmap];\n\n    [bitmap release];\n\n    return image;\n}\n\nstatic PyObject*\nFigureCanvas_write_bitmap(FigureCanvas* self, PyObject* args)\n{\n    View* view = self->view;\n    int n;\n    const unichar* characters;\n    NSSize size;\n    double width, height, dpi;\n\n    if(!view)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"NSView* is NULL\");\n        return NULL;\n    }\n    /* NSSize contains CGFloat; cannot use size directly */\n    if(!PyArg_ParseTuple(args, \"u#ddd\",\n                                &characters, &n, &width, &height, &dpi)) return NULL;\n    size.width = width;\n    size.height = height;\n\n    /* This function may be called from inside the event loop, when an\n     * autorelease pool is available, or from Python, when no autorelease\n     * pool is available. To be able to handle the latter case, we need to\n     * create an autorelease pool here. */\n\n    NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];\n\n    NSRect rect = [view bounds];\n\n    NSString* filename = [NSString stringWithCharacters: characters\n                                                 length: (unsigned)n];\n    NSString* extension = [filename pathExtension];\n\n    /* Calling dataWithPDFInsideRect on the view causes its update status\n     * to be cleared. Save the status here, and invalidate the view if not\n     * up to date after calling dataWithPDFInsideRect. */\n    const BOOL invalid = [view needsDisplay];\n    NSData* data = [view dataWithPDFInsideRect: rect];\n    if (invalid) [view setNeedsDisplay: YES];\n\n    NSImage* image = [[NSImage alloc] initWithData: data];\n    NSImage *resizedImage = [[NSImage alloc] initWithSize:size];\n\n    [resizedImage lockFocus];\n    [image drawInRect:NSMakeRect(0, 0, width, height) fromRect:NSZeroRect operation:NSCompositeSourceOver fraction:1.0];\n    [resizedImage unlockFocus];\n    data = [resizedImage TIFFRepresentation];\n    [image release];\n    [resizedImage release];\n\n    NSBitmapImageRep* rep = [NSBitmapImageRep imageRepWithData:data];\n\n    NSSize pxlSize = NSMakeSize([rep pixelsWide], [rep pixelsHigh]);\n    NSSize newSize = NSMakeSize(72.0 * pxlSize.width / dpi, 72.0 * pxlSize.height / dpi);\n\n    [rep setSize:newSize];\n\n    NSBitmapImageFileType filetype;\n    if ([extension isEqualToString: @\"bmp\"])\n        filetype = NSBMPFileType;\n    else if ([extension isEqualToString: @\"gif\"])\n        filetype = NSGIFFileType;\n    else if ([extension isEqualToString: @\"jpg\"] ||\n             [extension isEqualToString: @\"jpeg\"])\n        filetype = NSJPEGFileType;\n    else if ([extension isEqualToString: @\"png\"])\n        filetype = NSPNGFileType;\n    else if ([extension isEqualToString: @\"tiff\"] ||\n             [extension isEqualToString: @\"tif\"])\n        filetype = NSTIFFFileType;\n    else\n    {   PyErr_SetString(PyExc_ValueError, \"Unknown file type\");\n        return NULL;\n    }\n\n    data = [rep representationUsingType:filetype properties:nil];\n\n    [data writeToFile: filename atomically: YES];\n    [pool release];\n\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyObject*\nFigureCanvas_start_event_loop(FigureCanvas* self, PyObject* args, PyObject* keywords)\n{\n    float timeout = 0.0;\n\n    static char* kwlist[] = {\"timeout\", NULL};\n    if(!PyArg_ParseTupleAndKeywords(args, keywords, \"f\", kwlist, &timeout))\n        return NULL;\n\n    int error;\n    int interrupted = 0;\n    int channel[2];\n    CFSocketRef sigint_socket = NULL;\n    PyOS_sighandler_t py_sigint_handler = NULL;\n\n    CFRunLoopRef runloop = CFRunLoopGetCurrent();\n\n    error = pipe(channel);\n    if (error==0)\n    {\n        CFSocketContext context = {0, NULL, NULL, NULL, NULL};\n        fcntl(channel[1], F_SETFL, O_WRONLY | O_NONBLOCK);\n\n        context.info = &interrupted;\n        sigint_socket = CFSocketCreateWithNative(kCFAllocatorDefault,\n                                                 channel[0],\n                                                 kCFSocketReadCallBack,\n                                                 _callback,\n                                                 &context);\n        if (sigint_socket)\n        {\n            CFRunLoopSourceRef source;\n            source = CFSocketCreateRunLoopSource(kCFAllocatorDefault,\n                                                 sigint_socket,\n                                                 0);\n            CFRelease(sigint_socket);\n            if (source)\n            {\n                CFRunLoopAddSource(runloop, source, kCFRunLoopDefaultMode);\n                CFRelease(source);\n                sigint_fd = channel[1];\n                py_sigint_handler = PyOS_setsig(SIGINT, _sigint_handler);\n            }\n        }\n        else\n            close(channel[0]);\n    }\n\n    NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];\n    NSDate* date =\n        (timeout > 0.0) ? [NSDate dateWithTimeIntervalSinceNow: timeout]\n                        : [NSDate distantFuture];\n    while (true)\n    {   NSEvent* event = [NSApp nextEventMatchingMask: NSAnyEventMask\n                                            untilDate: date\n                                               inMode: NSDefaultRunLoopMode\n                                              dequeue: YES];\n       if (!event || [event type]==NSApplicationDefined) break;\n       [NSApp sendEvent: event];\n    }\n    [pool release];\n\n    if (py_sigint_handler) PyOS_setsig(SIGINT, py_sigint_handler);\n\n    if (sigint_socket) CFSocketInvalidate(sigint_socket);\n    if (error==0) close(channel[1]);\n    if (interrupted) raise(SIGINT);\n\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyObject*\nFigureCanvas_stop_event_loop(FigureCanvas* self)\n{\n    NSEvent* event = [NSEvent otherEventWithType: NSApplicationDefined\n                                        location: NSZeroPoint\n                                   modifierFlags: 0\n                                       timestamp: 0.0\n                                    windowNumber: 0\n                                         context: nil\n                                         subtype: STOP_EVENT_LOOP\n                                           data1: 0\n                                           data2: 0];\n    [NSApp postEvent: event atStart: true];\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyMethodDef FigureCanvas_methods[] = {\n    {\"draw\",\n     (PyCFunction)FigureCanvas_draw,\n     METH_NOARGS,\n     \"Draws the canvas.\"\n    },\n    {\"invalidate\",\n     (PyCFunction)FigureCanvas_invalidate,\n     METH_NOARGS,\n     \"Invalidates the canvas.\"\n    },\n    {\"flush_events\",\n     (PyCFunction)FigureCanvas_flush_events,\n     METH_NOARGS,\n     \"Flush the GUI events for the figure.\"\n    },\n    {\"set_rubberband\",\n     (PyCFunction)FigureCanvas_set_rubberband,\n     METH_VARARGS,\n     \"Specifies a new rubberband rectangle and invalidates it.\"\n    },\n    {\"remove_rubberband\",\n     (PyCFunction)FigureCanvas_remove_rubberband,\n     METH_NOARGS,\n     \"Removes the current rubberband rectangle.\"\n    },\n    {\"write_bitmap\",\n     (PyCFunction)FigureCanvas_write_bitmap,\n     METH_VARARGS,\n     \"Saves the figure to the specified file as a bitmap\\n\"\n     \"(bmp, gif, jpeg, or png).\\n\"\n    },\n    {\"start_event_loop\",\n     (PyCFunction)FigureCanvas_start_event_loop,\n     METH_KEYWORDS | METH_VARARGS,\n     \"Runs the event loop until the timeout or until stop_event_loop is called.\\n\",\n    },\n    {\"stop_event_loop\",\n     (PyCFunction)FigureCanvas_stop_event_loop,\n     METH_NOARGS,\n     \"Stops the event loop that was started by start_event_loop.\\n\",\n    },\n    {NULL}  /* Sentinel */\n};\n\nstatic char FigureCanvas_doc[] =\n\"A FigureCanvas object wraps a Cocoa NSView object.\\n\";\n\nstatic PyTypeObject FigureCanvasType = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_macosx.FigureCanvas\",    /*tp_name*/\n    sizeof(FigureCanvas),      /*tp_basicsize*/\n    0,                         /*tp_itemsize*/\n    (destructor)FigureCanvas_dealloc,     /*tp_dealloc*/\n    0,                         /*tp_print*/\n    0,                         /*tp_getattr*/\n    0,                         /*tp_setattr*/\n    0,                         /*tp_compare*/\n    (reprfunc)FigureCanvas_repr,     /*tp_repr*/\n    0,                         /*tp_as_number*/\n    0,                         /*tp_as_sequence*/\n    0,                         /*tp_as_mapping*/\n    0,                         /*tp_hash */\n    0,                         /*tp_call*/\n    0,                         /*tp_str*/\n    0,                         /*tp_getattro*/\n    0,                         /*tp_setattro*/\n    0,                         /*tp_as_buffer*/\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,        /*tp_flags*/\n    FigureCanvas_doc,          /* tp_doc */\n    0,                         /* tp_traverse */\n    0,                         /* tp_clear */\n    0,                         /* tp_richcompare */\n    0,                         /* tp_weaklistoffset */\n    0,                         /* tp_iter */\n    0,                         /* tp_iternext */\n    FigureCanvas_methods,      /* tp_methods */\n    0,                         /* tp_members */\n    0,                         /* tp_getset */\n    0,                         /* tp_base */\n    0,                         /* tp_dict */\n    0,                         /* tp_descr_get */\n    0,                         /* tp_descr_set */\n    0,                         /* tp_dictoffset */\n    (initproc)FigureCanvas_init,      /* tp_init */\n    0,                         /* tp_alloc */\n    FigureCanvas_new,          /* tp_new */\n};\n\ntypedef struct {\n    PyObject_HEAD\n    Window* window;\n} FigureManager;\n\nstatic PyObject*\nFigureManager_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    Window* window = [Window alloc];\n    if (!window) return NULL;\n    FigureManager *self = (FigureManager*)type->tp_alloc(type, 0);\n    if (!self)\n    {\n        [window release];\n        return NULL;\n    }\n    self->window = window;\n    return (PyObject*)self;\n}\n\nstatic int\nFigureManager_init(FigureManager *self, PyObject *args, PyObject *kwds)\n{\n    NSRect rect;\n    Window* window;\n    View* view;\n    const char* title;\n    PyObject* size;\n    int width, height;\n    PyObject* obj;\n    FigureCanvas* canvas;\n\n    if(!self->window)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"NSWindow* is NULL\");\n        return -1;\n    }\n\n    if(!PyArg_ParseTuple(args, \"Os\", &obj, &title)) return -1;\n\n    canvas = (FigureCanvas*)obj;\n    view = canvas->view;\n    if (!view) /* Something really weird going on */\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"NSView* is NULL\");\n        return -1;\n    }\n\n    size = PyObject_CallMethod(obj, \"get_width_height\", \"\");\n    if(!size) return -1;\n    if(!PyArg_ParseTuple(size, \"ii\", &width, &height))\n    {    Py_DECREF(size);\n         return -1;\n    }\n    Py_DECREF(size);\n\n    rect.origin.x = 100;\n    rect.origin.y = 350;\n    rect.size.height = height;\n    rect.size.width = width;\n\n    NSApp = [NSApplication sharedApplication];\n    NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];\n    self->window = [self->window initWithContentRect: rect\n                                         styleMask: NSTitledWindowMask\n                                                  | NSClosableWindowMask\n                                                  | NSResizableWindowMask\n                                                  | NSMiniaturizableWindowMask\n                                           backing: NSBackingStoreBuffered\n                                             defer: YES\n                                       withManager: (PyObject*)self];\n    window = self->window;\n    [window setTitle: [NSString stringWithCString: title\n                                         encoding: NSASCIIStringEncoding]];\n\n    [window setAcceptsMouseMovedEvents: YES];\n    [window setDelegate: view];\n    [window makeFirstResponder: view];\n    [[window contentView] addSubview: view];\n\n    nwin++;\n\n    [pool release];\n    return 0;\n}\n\nstatic PyObject*\nFigureManager_repr(FigureManager* self)\n{\n#if PY3K\n    return PyUnicode_FromFormat(\"FigureManager object %p wrapping NSWindow %p\",\n                               (void*) self, (void*)(self->window));\n#else\n    return PyString_FromFormat(\"FigureManager object %p wrapping NSWindow %p\",\n                               (void*) self, (void*)(self->window));\n#endif\n}\n\nstatic void\nFigureManager_dealloc(FigureManager* self)\n{\n    Window* window = self->window;\n    if(window)\n    {\n        NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];\n        [window close];\n        [pool release];\n    }\n    Py_TYPE(self)->tp_free((PyObject*)self);\n}\n\nstatic PyObject*\nFigureManager_show(FigureManager* self)\n{\n    Window* window = self->window;\n    if(window)\n    {\n        NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];\n        [window makeKeyAndOrderFront: nil];\n        [pool release];\n    }\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyObject*\nFigureManager_destroy(FigureManager* self)\n{\n    Window* window = self->window;\n    if(window)\n    {\n        NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];\n        [window close];\n        [pool release];\n        self->window = NULL;\n    }\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyObject*\nFigureManager_set_window_title(FigureManager* self,\n                               PyObject *args, PyObject *kwds)\n{\n    char* title;\n    if(!PyArg_ParseTuple(args, \"es\", \"UTF-8\", &title))\n        return NULL;\n\n    Window* window = self->window;\n    if(window)\n    {\n        NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];\n        NSString* ns_title = [[[NSString alloc]\n                               initWithCString: title\n                               encoding: NSUTF8StringEncoding] autorelease];\n        [window setTitle: ns_title];\n        [pool release];\n    }\n    PyMem_Free(title);\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyObject*\nFigureManager_get_window_title(FigureManager* self)\n{\n    Window* window = self->window;\n    PyObject* result = NULL;\n    if(window)\n    {\n        NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];\n        NSString* title = [window title];\n        if (title) {\n            const char* cTitle = [title UTF8String];\n#if PY3K || (PY_MAJOR_VERSION == 2 && PY_MINOR_VERSION >= 6)\n            result = PyUnicode_FromString(cTitle);\n#else\n            result = PyString_FromString(cTitle);\n#endif\n        }\n        [pool release];\n    }\n    if (result) {\n        return result;\n    } else {\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n}\n\nstatic PyMethodDef FigureManager_methods[] = {\n    {\"show\",\n     (PyCFunction)FigureManager_show,\n     METH_NOARGS,\n     \"Shows the window associated with the figure manager.\"\n    },\n    {\"destroy\",\n     (PyCFunction)FigureManager_destroy,\n     METH_NOARGS,\n     \"Closes the window associated with the figure manager.\"\n    },\n    {\"set_window_title\",\n     (PyCFunction)FigureManager_set_window_title,\n     METH_VARARGS,\n     \"Sets the title of the window associated with the figure manager.\"\n    },\n    {\"get_window_title\",\n     (PyCFunction)FigureManager_get_window_title,\n     METH_NOARGS,\n     \"Returns the title of the window associated with the figure manager.\"\n    },\n    {NULL}  /* Sentinel */\n};\n\nstatic char FigureManager_doc[] =\n\"A FigureManager object wraps a Cocoa NSWindow object.\\n\";\n\nstatic PyTypeObject FigureManagerType = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_macosx.FigureManager\",   /*tp_name*/\n    sizeof(FigureManager),     /*tp_basicsize*/\n    0,                         /*tp_itemsize*/\n    (destructor)FigureManager_dealloc,     /*tp_dealloc*/\n    0,                         /*tp_print*/\n    0,                         /*tp_getattr*/\n    0,                         /*tp_setattr*/\n    0,                         /*tp_compare*/\n    (reprfunc)FigureManager_repr,     /*tp_repr*/\n    0,                         /*tp_as_number*/\n    0,                         /*tp_as_sequence*/\n    0,                         /*tp_as_mapping*/\n    0,                         /*tp_hash */\n    0,                         /*tp_call*/\n    0,                         /*tp_str*/\n    0,                         /*tp_getattro*/\n    0,                         /*tp_setattro*/\n    0,                         /*tp_as_buffer*/\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,        /*tp_flags*/\n    FigureManager_doc,         /* tp_doc */\n    0,                         /* tp_traverse */\n    0,                         /* tp_clear */\n    0,                         /* tp_richcompare */\n    0,                         /* tp_weaklistoffset */\n    0,                         /* tp_iter */\n    0,                         /* tp_iternext */\n    FigureManager_methods,     /* tp_methods */\n    0,                         /* tp_members */\n    0,                         /* tp_getset */\n    0,                         /* tp_base */\n    0,                         /* tp_dict */\n    0,                         /* tp_descr_get */\n    0,                         /* tp_descr_set */\n    0,                         /* tp_dictoffset */\n    (initproc)FigureManager_init,      /* tp_init */\n    0,                         /* tp_alloc */\n    FigureManager_new,          /* tp_new */\n};\n\n@interface NavigationToolbarHandler : NSObject\n{   PyObject* toolbar;\n}\n- (NavigationToolbarHandler*)initWithToolbar:(PyObject*)toolbar;\n-(void)left:(id)sender;\n-(void)right:(id)sender;\n-(void)up:(id)sender;\n-(void)down:(id)sender;\n-(void)zoominx:(id)sender;\n-(void)zoominy:(id)sender;\n-(void)zoomoutx:(id)sender;\n-(void)zoomouty:(id)sender;\n@end\n\ntypedef struct {\n    PyObject_HEAD\n    NSPopUpButton* menu;\n    NavigationToolbarHandler* handler;\n} NavigationToolbar;\n\n@implementation NavigationToolbarHandler\n- (NavigationToolbarHandler*)initWithToolbar:(PyObject*)theToolbar\n{   [self init];\n    toolbar = theToolbar;\n    return self;\n}\n\n-(void)left:(id)sender\n{   PyObject* result;\n    PyGILState_STATE gstate;\n    gstate = PyGILState_Ensure();\n    result = PyObject_CallMethod(toolbar, \"panx\", \"i\", -1);\n    if(result)\n        Py_DECREF(result);\n    else\n        PyErr_Print();\n    PyGILState_Release(gstate);\n}\n\n-(void)right:(id)sender\n{   PyObject* result;\n    PyGILState_STATE gstate;\n    gstate = PyGILState_Ensure();\n    result = PyObject_CallMethod(toolbar, \"panx\", \"i\", 1);\n    if(result)\n        Py_DECREF(result);\n    else\n        PyErr_Print();\n    PyGILState_Release(gstate);\n}\n\n-(void)up:(id)sender\n{   PyObject* result;\n    PyGILState_STATE gstate;\n    gstate = PyGILState_Ensure();\n    result = PyObject_CallMethod(toolbar, \"pany\", \"i\", 1);\n    if(result)\n        Py_DECREF(result);\n    else\n        PyErr_Print();\n    PyGILState_Release(gstate);\n}\n\n-(void)down:(id)sender\n{   PyObject* result;\n    PyGILState_STATE gstate;\n    gstate = PyGILState_Ensure();\n    result = PyObject_CallMethod(toolbar, \"pany\", \"i\", -1);\n    if(result)\n        Py_DECREF(result);\n    else\n        PyErr_Print();\n    PyGILState_Release(gstate);\n}\n\n-(void)zoominx:(id)sender\n{   PyObject* result;\n    PyGILState_STATE gstate;\n    gstate = PyGILState_Ensure();\n    result = PyObject_CallMethod(toolbar, \"zoomx\", \"i\", 1);\n    if(result)\n        Py_DECREF(result);\n    else\n        PyErr_Print();\n    PyGILState_Release(gstate);\n}\n\n-(void)zoomoutx:(id)sender\n{   PyObject* result;\n    PyGILState_STATE gstate;\n    gstate = PyGILState_Ensure();\n    result = PyObject_CallMethod(toolbar, \"zoomx\", \"i\", -1);\n    if(result)\n        Py_DECREF(result);\n    else\n        PyErr_Print();\n    PyGILState_Release(gstate);\n}\n\n-(void)zoominy:(id)sender\n{   PyObject* result;\n    PyGILState_STATE gstate;\n    gstate = PyGILState_Ensure();\n    result = PyObject_CallMethod(toolbar, \"zoomy\", \"i\", 1);\n    if(result)\n        Py_DECREF(result);\n    else\n        PyErr_Print();\n    PyGILState_Release(gstate);\n}\n\n-(void)zoomouty:(id)sender\n{   PyObject* result;\n    PyGILState_STATE gstate;\n    gstate = PyGILState_Ensure();\n    result = PyObject_CallMethod(toolbar, \"zoomy\", \"i\", -1);\n    if(result)\n        Py_DECREF(result);\n    else\n        PyErr_Print();\n    PyGILState_Release(gstate);\n}\n\n-(void)save_figure:(id)sender\n{   PyObject* result;\n    PyGILState_STATE gstate;\n    gstate = PyGILState_Ensure();\n    result = PyObject_CallMethod(toolbar, \"save_figure\", \"\");\n    if(result)\n        Py_DECREF(result);\n    else\n        PyErr_Print();\n    PyGILState_Release(gstate);\n}\n@end\n\nstatic PyObject*\nNavigationToolbar_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    NavigationToolbarHandler* handler = [NavigationToolbarHandler alloc];\n    if (!handler) return NULL;\n    NavigationToolbar *self = (NavigationToolbar*)type->tp_alloc(type, 0);\n    if (!self)\n    {   [handler release];\n        return NULL;\n    }\n    self->handler = handler;\n    return (PyObject*)self;\n}\n\nstatic int\nNavigationToolbar_init(NavigationToolbar *self, PyObject *args, PyObject *kwds)\n{\n    int i;\n    NSRect rect;\n\n    const float smallgap = 2;\n    const float biggap = 10;\n    const int height = 32;\n\n    PyObject* images;\n    PyObject* obj;\n\n    FigureCanvas* canvas;\n    View* view;\n\n    obj = PyObject_GetAttrString((PyObject*)self, \"canvas\");\n    if (obj==NULL)\n    {\n        PyErr_SetString(PyExc_AttributeError, \"Attempt to install toolbar for NULL canvas\");\n        return -1;\n    }\n    Py_DECREF(obj); /* Don't increase the reference count */\n    if (!PyObject_IsInstance(obj, (PyObject*) &FigureCanvasType))\n    {\n        PyErr_SetString(PyExc_TypeError, \"Attempt to install toolbar for object that is not a FigureCanvas\");\n        return -1;\n    }\n    canvas = (FigureCanvas*)obj;\n    view = canvas->view;\n    if(!view)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"NSView* is NULL\");\n        return -1;\n    }\n\n    if(!PyArg_ParseTuple(args, \"O\", &images)) return -1;\n    if(!PyDict_Check(images)) return -1;\n\n    NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];\n    NSRect bounds = [view bounds];\n    NSWindow* window = [view window];\n\n    bounds.origin.y += height;\n    [view setFrame: bounds];\n\n    bounds.size.height += height;\n    [window setContentSize: bounds.size];\n\n    char* imagenames[9] = {\"stock_left\",\n                           \"stock_right\",\n                           \"stock_zoom-in\",\n                           \"stock_zoom-out\",\n                           \"stock_up\",\n                           \"stock_down\",\n                           \"stock_zoom-in\",\n                           \"stock_zoom-out\",\n                           \"stock_save_as\"};\n\n    NSString* tooltips[9] = {\n        @\"Pan left with click or wheel mouse (bidirectional)\",\n        @\"Pan right with click or wheel mouse (bidirectional)\",\n        @\"Zoom In X (shrink the x axis limits) with click or wheel mouse (bidirectional)\",\n        @\"Zoom Out X (expand the x axis limits) with click or wheel mouse (bidirectional)\",\n        @\"Pan up with click or wheel mouse (bidirectional)\",\n        @\"Pan down with click or wheel mouse (bidirectional)\",\n        @\"Zoom in Y (shrink the y axis limits) with click or wheel mouse (bidirectional)\",\n        @\"Zoom Out Y (expand the y axis limits) with click or wheel mouse (bidirectional)\",\n        @\"Save the figure\"};\n\n    SEL actions[9] = {@selector(left:),\n                      @selector(right:),\n                      @selector(zoominx:),\n                      @selector(zoomoutx:),\n                      @selector(up:),\n                      @selector(down:),\n                      @selector(zoominy:),\n                      @selector(zoomouty:),\n                      @selector(save_figure:)};\n\n    SEL scroll_actions[9][2] = {{@selector(left:),    @selector(right:)},\n                                {@selector(left:),    @selector(right:)},\n                                {@selector(zoominx:), @selector(zoomoutx:)},\n                                {@selector(zoominx:), @selector(zoomoutx:)},\n                                {@selector(up:),      @selector(down:)},\n                                {@selector(up:),      @selector(down:)},\n                                {@selector(zoominy:), @selector(zoomouty:)},\n                                {@selector(zoominy:), @selector(zoomouty:)},\n                                {nil,nil},\n                               };\n\n\n    rect.size.width = 120;\n    rect.size.height = 24;\n    rect.origin.x = biggap;\n    rect.origin.y = 0.5*(height - rect.size.height);\n    self->menu = [[NSPopUpButton alloc] initWithFrame: rect\n                                            pullsDown: YES];\n    [self->menu setAutoenablesItems: NO];\n    [[window contentView] addSubview: self->menu];\n    [self->menu release];\n    rect.origin.x += rect.size.width + biggap;\n    rect.size.width = 24;\n\n    self->handler = [self->handler initWithToolbar: (PyObject*)self];\n    for (i = 0; i < 9; i++)\n    {\n        NSButton* button;\n        SEL scrollWheelUpAction = scroll_actions[i][0];\n        SEL scrollWheelDownAction = scroll_actions[i][1];\n        if (scrollWheelUpAction && scrollWheelDownAction)\n        {\n            ScrollableButton* scrollable_button = [ScrollableButton alloc];\n            [scrollable_button initWithFrame: rect];\n            [scrollable_button setScrollWheelUpAction: scrollWheelUpAction];\n            [scrollable_button setScrollWheelDownAction: scrollWheelDownAction];\n            button = (NSButton*)scrollable_button;\n        }\n        else\n        {\n            button = [NSButton alloc];\n            [button initWithFrame: rect];\n        }\n        PyObject* imagedata = PyDict_GetItemString(images, imagenames[i]);\n        NSImage* image = _read_ppm_image(imagedata);\n        [button setBezelStyle: NSShadowlessSquareBezelStyle];\n        [button setButtonType: NSMomentaryLightButton];\n        if(image)\n        {\n            [button setImage: image];\n            [image release];\n        }\n        [button setToolTip: tooltips[i]];\n        [button setTarget: self->handler];\n        [button setAction: actions[i]];\n        [[window contentView] addSubview: button];\n        [button release];\n        rect.origin.x += rect.size.width + smallgap;\n    }\n    [[window contentView] display];\n    [pool release];\n\n    return 0;\n}\n\nstatic void\nNavigationToolbar_dealloc(NavigationToolbar *self)\n{\n    [self->handler release];\n    Py_TYPE(self)->tp_free((PyObject*)self);\n}\n\nstatic PyObject*\nNavigationToolbar_repr(NavigationToolbar* self)\n{\n#if PY3K\n    return PyUnicode_FromFormat(\"NavigationToolbar object %p\", (void*)self);\n#else\n    return PyString_FromFormat(\"NavigationToolbar object %p\", (void*)self);\n#endif\n}\n\nstatic char NavigationToolbar_doc[] =\n\"NavigationToolbar\\n\";\n\nstatic PyObject*\nNavigationToolbar_update (NavigationToolbar* self)\n{\n    int n;\n    NSPopUpButton* button = self->menu;\n    if (!button)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"Menu button is NULL\");\n        return NULL;\n    }\n\n    PyObject* canvas = PyObject_GetAttrString((PyObject*)self, \"canvas\");\n    if (canvas==NULL)\n    {\n        PyErr_SetString(PyExc_AttributeError, \"Failed to find canvas\");\n        return NULL;\n    }\n    Py_DECREF(canvas); /* Don't keep a reference here */\n    PyObject* figure = PyObject_GetAttrString(canvas, \"figure\");\n    if (figure==NULL)\n    {\n        PyErr_SetString(PyExc_AttributeError, \"Failed to find figure\");\n        return NULL;\n    }\n    Py_DECREF(figure); /* Don't keep a reference here */\n    PyObject* axes = PyObject_GetAttrString(figure, \"axes\");\n    if (axes==NULL)\n    {\n        PyErr_SetString(PyExc_AttributeError, \"Failed to find figure axes\");\n        return NULL;\n    }\n    Py_DECREF(axes); /* Don't keep a reference here */\n    if (!PyList_Check(axes))\n    {\n        PyErr_SetString(PyExc_TypeError, \"Figure axes is not a list\");\n        return NULL;\n    }\n    n = PyList_GET_SIZE(axes);\n\n    NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];\n    [button removeAllItems];\n\n    NSMenu* menu = [button menu];\n    [menu addItem: [MenuItem menuItemWithTitle: @\"Axes\"]];\n\n    if (n==0)\n    {\n        [button setEnabled: NO];\n    }\n    else\n    {\n        int i;\n        [menu addItem: [MenuItem menuItemSelectAll]];\n        [menu addItem: [MenuItem menuItemInvertAll]];\n        [menu addItem: [NSMenuItem separatorItem]];\n        for (i = 0; i < n; i++)\n        {\n            [menu addItem: [MenuItem menuItemForAxis: i]];\n        }\n        [button setEnabled: YES];\n    }\n    [pool release];\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyObject*\nNavigationToolbar_get_active (NavigationToolbar* self)\n{\n    NSPopUpButton* button = self->menu;\n    if (!button)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"Menu button is NULL\");\n        return NULL;\n    }\n    NSMenu* menu = [button menu];\n    NSArray* items = [menu itemArray];\n    unsigned int n = [items count];\n    int* states = calloc(n, sizeof(int));\n    if (!states)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"calloc failed\");\n        return NULL;\n    }\n    int i;\n    unsigned int m = 0;\n    NSEnumerator* enumerator = [items objectEnumerator];\n    MenuItem* item;\n    while ((item = [enumerator nextObject]))\n    {\n        if ([item isSeparatorItem]) continue;\n        i = [item index];\n        if (i < 0) continue;\n        if ([item state]==NSOnState)\n        {\n            states[i] = 1;\n            m++;\n        }\n    }\n    int j = 0;\n    PyObject* list = PyList_New(m);\n    for (i = 0; i < n; i++)\n    {\n        if(states[i]==1)\n        {\n            PyList_SET_ITEM(list, j, PyLong_FromLong(i));\n            j++;\n        }\n    }\n    free(states);\n    return list;\n}\n\nstatic PyMethodDef NavigationToolbar_methods[] = {\n    {\"update\",\n     (PyCFunction)NavigationToolbar_update,\n     METH_NOARGS,\n     \"Updates the toolbar menu.\"\n    },\n    {\"get_active\",\n     (PyCFunction)NavigationToolbar_get_active,\n     METH_NOARGS,\n     \"Returns a list of integers identifying which items in the menu are selected.\"\n    },\n    {NULL}  /* Sentinel */\n};\n\nstatic PyTypeObject NavigationToolbarType = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_macosx.NavigationToolbar\", /*tp_name*/\n    sizeof(NavigationToolbar), /*tp_basicsize*/\n    0,                         /*tp_itemsize*/\n    (destructor)NavigationToolbar_dealloc,     /*tp_dealloc*/\n    0,                         /*tp_print*/\n    0,                         /*tp_getattr*/\n    0,                         /*tp_setattr*/\n    0,                         /*tp_compare*/\n    (reprfunc)NavigationToolbar_repr,     /*tp_repr*/\n    0,                         /*tp_as_number*/\n    0,                         /*tp_as_sequence*/\n    0,                         /*tp_as_mapping*/\n    0,                         /*tp_hash */\n    0,                         /*tp_call*/\n    0,                         /*tp_str*/\n    0,                         /*tp_getattro*/\n    0,                         /*tp_setattro*/\n    0,                         /*tp_as_buffer*/\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,        /*tp_flags*/\n    NavigationToolbar_doc,     /* tp_doc */\n    0,                         /* tp_traverse */\n    0,                         /* tp_clear */\n    0,                         /* tp_richcompare */\n    0,                         /* tp_weaklistoffset */\n    0,                         /* tp_iter */\n    0,                         /* tp_iternext */\n    NavigationToolbar_methods, /* tp_methods */\n    0,                         /* tp_members */\n    0,                         /* tp_getset */\n    0,                         /* tp_base */\n    0,                         /* tp_dict */\n    0,                         /* tp_descr_get */\n    0,                         /* tp_descr_set */\n    0,                         /* tp_dictoffset */\n    (initproc)NavigationToolbar_init,      /* tp_init */\n    0,                         /* tp_alloc */\n    NavigationToolbar_new,     /* tp_new */\n};\n\n@interface NavigationToolbar2Handler : NSObject\n{   PyObject* toolbar;\n    NSButton* panbutton;\n    NSButton* zoombutton;\n}\n- (NavigationToolbar2Handler*)initWithToolbar:(PyObject*)toolbar;\n- (void)installCallbacks:(SEL[7])actions forButtons: (NSButton*[7])buttons;\n- (void)home:(id)sender;\n- (void)back:(id)sender;\n- (void)forward:(id)sender;\n- (void)pan:(id)sender;\n- (void)zoom:(id)sender;\n- (void)configure_subplots:(id)sender;\n- (void)save_figure:(id)sender;\n@end\n\ntypedef struct {\n    PyObject_HEAD\n    NSPopUpButton* menu;\n    NSText* messagebox;\n    NavigationToolbar2Handler* handler;\n} NavigationToolbar2;\n\n@implementation NavigationToolbar2Handler\n- (NavigationToolbar2Handler*)initWithToolbar:(PyObject*)theToolbar\n{   [self init];\n    toolbar = theToolbar;\n    return self;\n}\n\n- (void)installCallbacks:(SEL[7])actions forButtons: (NSButton*[7])buttons\n{\n    int i;\n    for (i = 0; i < 7; i++)\n    {\n        SEL action = actions[i];\n        NSButton* button = buttons[i];\n        [button setTarget: self];\n        [button setAction: action];\n        if (action==@selector(pan:)) panbutton = button;\n        if (action==@selector(zoom:)) zoombutton = button;\n    }\n}\n\n-(void)home:(id)sender\n{   PyObject* result;\n    PyGILState_STATE gstate;\n    gstate = PyGILState_Ensure();\n    result = PyObject_CallMethod(toolbar, \"home\", \"\");\n    if(result)\n        Py_DECREF(result);\n    else\n        PyErr_Print();\n    PyGILState_Release(gstate);\n}\n\n-(void)back:(id)sender\n{   PyObject* result;\n    PyGILState_STATE gstate;\n    gstate = PyGILState_Ensure();\n    result = PyObject_CallMethod(toolbar, \"back\", \"\");\n    if(result)\n        Py_DECREF(result);\n    else\n        PyErr_Print();\n    PyGILState_Release(gstate);\n}\n\n-(void)forward:(id)sender\n{   PyObject* result;\n    PyGILState_STATE gstate;\n    gstate = PyGILState_Ensure();\n    result = PyObject_CallMethod(toolbar, \"forward\", \"\");\n    if(result)\n        Py_DECREF(result);\n    else\n        PyErr_Print();\n    PyGILState_Release(gstate);\n}\n\n-(void)pan:(id)sender\n{   PyObject* result;\n    PyGILState_STATE gstate;\n    if ([sender state])\n    {\n        if (zoombutton) [zoombutton setState: NO];\n    }\n    gstate = PyGILState_Ensure();\n    result = PyObject_CallMethod(toolbar, \"pan\", \"\");\n    if(result)\n        Py_DECREF(result);\n    else\n        PyErr_Print();\n    PyGILState_Release(gstate);\n}\n\n-(void)zoom:(id)sender\n{   PyObject* result;\n    PyGILState_STATE gstate;\n    if ([sender state])\n    {\n        if (panbutton) [panbutton setState: NO];\n    }\n    gstate = PyGILState_Ensure();\n    result = PyObject_CallMethod(toolbar, \"zoom\", \"\");\n    if(result)\n        Py_DECREF(result);\n    else\n        PyErr_Print();\n    PyGILState_Release(gstate);\n}\n\n-(void)configure_subplots:(id)sender\n{   PyObject* canvas;\n    View* view;\n    PyObject* size;\n    NSRect rect;\n    int width, height;\n\n    rect.origin.x = 100;\n    rect.origin.y = 350;\n    PyGILState_STATE gstate = PyGILState_Ensure();\n    PyObject* master = PyObject_GetAttrString(toolbar, \"canvas\");\n    if (master==nil)\n    {\n        PyErr_Print();\n        PyGILState_Release(gstate);\n        return;\n    }\n    canvas = PyObject_CallMethod(toolbar, \"prepare_configure_subplots\", \"\");\n    if(!canvas)\n    {\n        PyErr_Print();\n        Py_DECREF(master);\n        PyGILState_Release(gstate);\n        return;\n    }\n\n    view = ((FigureCanvas*)canvas)->view;\n    if (!view) /* Something really weird going on */\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"NSView* is NULL\");\n        PyErr_Print();\n        Py_DECREF(canvas);\n        Py_DECREF(master);\n        PyGILState_Release(gstate);\n        return;\n    }\n\n    size = PyObject_CallMethod(canvas, \"get_width_height\", \"\");\n    Py_DECREF(canvas);\n    if(!size)\n    {\n        PyErr_Print();\n        Py_DECREF(master);\n        PyGILState_Release(gstate);\n        return;\n    }\n\n    int ok = PyArg_ParseTuple(size, \"ii\", &width, &height);\n    Py_DECREF(size);\n    if (!ok)\n    {\n        PyErr_Print();\n        Py_DECREF(master);\n        PyGILState_Release(gstate);\n        return;\n    }\n\n    NSWindow* mw = [((FigureCanvas*)master)->view window];\n    Py_DECREF(master);\n    PyGILState_Release(gstate);\n\n    rect.size.width = width;\n    rect.size.height = height;\n\n    ToolWindow* window = [ [ToolWindow alloc] initWithContentRect: rect\n                                                           master: mw];\n    [window setContentView: view];\n    [view release];\n    [window makeKeyAndOrderFront: nil];\n}\n\n-(void)save_figure:(id)sender\n{   PyObject* result;\n    PyGILState_STATE gstate;\n    gstate = PyGILState_Ensure();\n    result = PyObject_CallMethod(toolbar, \"save_figure\", \"\");\n    if(result)\n        Py_DECREF(result);\n    else\n        PyErr_Print();\n    PyGILState_Release(gstate);\n}\n@end\n\nstatic PyObject*\nNavigationToolbar2_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    NavigationToolbar2Handler* handler = [NavigationToolbar2Handler alloc];\n    if (!handler) return NULL;\n    NavigationToolbar2 *self = (NavigationToolbar2*)type->tp_alloc(type, 0);\n    if (!self)\n    {\n        [handler release];\n        return NULL;\n    }\n    self->handler = handler;\n    return (PyObject*)self;\n}\n\nstatic int\nNavigationToolbar2_init(NavigationToolbar2 *self, PyObject *args, PyObject *kwds)\n{\n    PyObject* obj;\n    FigureCanvas* canvas;\n    View* view;\n\n    int i;\n    NSRect rect;\n\n    const float gap = 2;\n    const int height = 36;\n\n    const char* basedir;\n\n    obj = PyObject_GetAttrString((PyObject*)self, \"canvas\");\n    if (obj==NULL)\n    {\n        PyErr_SetString(PyExc_AttributeError, \"Attempt to install toolbar for NULL canvas\");\n        return -1;\n    }\n    Py_DECREF(obj); /* Don't increase the reference count */\n    if (!PyObject_IsInstance(obj, (PyObject*) &FigureCanvasType))\n    {\n        PyErr_SetString(PyExc_TypeError, \"Attempt to install toolbar for object that is not a FigureCanvas\");\n        return -1;\n    }\n    canvas = (FigureCanvas*)obj;\n    view = canvas->view;\n    if(!view)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"NSView* is NULL\");\n        return -1;\n    }\n\n    if(!PyArg_ParseTuple(args, \"s\", &basedir)) return -1;\n\n    NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];\n    NSRect bounds = [view bounds];\n    NSWindow* window = [view window];\n\n    bounds.origin.y += height;\n    [view setFrame: bounds];\n\n    bounds.size.height += height;\n    [window setContentSize: bounds.size];\n\n    NSString* dir = [NSString stringWithCString: basedir\n                                       encoding: NSASCIIStringEncoding];\n\n    NSButton* buttons[7];\n\n    NSString* images[7] = {@\"home.png\",\n                           @\"back.png\",\n                           @\"forward.png\",\n                           @\"move.png\",\n                           @\"zoom_to_rect.png\",\n                           @\"subplots.png\",\n                           @\"filesave.png\"};\n\n    NSString* tooltips[7] = {@\"Reset original view\",\n                             @\"Back to  previous view\",\n                             @\"Forward to next view\",\n                             @\"Pan axes with left mouse, zoom with right\",\n                             @\"Zoom to rectangle\",\n                             @\"Configure subplots\",\n                             @\"Save the figure\"};\n\n    SEL actions[7] = {@selector(home:),\n                      @selector(back:),\n                      @selector(forward:),\n                      @selector(pan:),\n                      @selector(zoom:),\n                      @selector(configure_subplots:),\n                      @selector(save_figure:)};\n\n    NSButtonType buttontypes[7] = {NSMomentaryLightButton,\n                                   NSMomentaryLightButton,\n                                   NSMomentaryLightButton,\n                                   NSPushOnPushOffButton,\n                                   NSPushOnPushOffButton,\n                                   NSMomentaryLightButton,\n                                   NSMomentaryLightButton};\n\n    rect.size.width = 32;\n    rect.size.height = 32;\n    rect.origin.x = gap;\n    rect.origin.y = 0.5*(height - rect.size.height);\n    for (i = 0; i < 7; i++)\n    {\n        const NSSize size = {24, 24};\n        NSString* filename = [dir stringByAppendingPathComponent: images[i]];\n        NSImage* image = [[NSImage alloc] initWithContentsOfFile: filename];\n        buttons[i] = [[NSButton alloc] initWithFrame: rect];\n        [image setSize: size];\n        [buttons[i] setBezelStyle: NSShadowlessSquareBezelStyle];\n        [buttons[i] setButtonType: buttontypes[i]];\n        [buttons[i] setImage: image];\n        [buttons[i] setImagePosition: NSImageOnly];\n        [buttons[i] setToolTip: tooltips[i]];\n        [[window contentView] addSubview: buttons[i]];\n        [buttons[i] release];\n        [image release];\n        rect.origin.x += rect.size.width + gap;\n    }\n\n    self->handler = [self->handler initWithToolbar: (PyObject*)self];\n    [self->handler installCallbacks: actions forButtons: buttons];\n\n    NSFont* font = [NSFont systemFontOfSize: 0.0];\n    rect.size.width = 300;\n    rect.size.height = 0;\n    rect.origin.x += height;\n    NSText* messagebox = [[NSText alloc] initWithFrame: rect];\n    [messagebox setFont: font];\n    [messagebox setDrawsBackground: NO];\n    [messagebox setSelectable: NO];\n    /* if selectable, the messagebox can become first responder,\n     * which is not supposed to happen */\n    rect = [messagebox frame];\n    rect.origin.y = 0.5 * (height - rect.size.height);\n    [messagebox setFrameOrigin: rect.origin];\n    [[window contentView] addSubview: messagebox];\n    [messagebox release];\n    [[window contentView] display];\n\n    [pool release];\n\n    self->messagebox = messagebox;\n    return 0;\n}\n\nstatic void\nNavigationToolbar2_dealloc(NavigationToolbar2 *self)\n{\n    [self->handler release];\n    Py_TYPE(self)->tp_free((PyObject*)self);\n}\n\nstatic PyObject*\nNavigationToolbar2_repr(NavigationToolbar2* self)\n{\n#if PY3K\n    return PyUnicode_FromFormat(\"NavigationToolbar2 object %p\", (void*)self);\n#else\n    return PyString_FromFormat(\"NavigationToolbar2 object %p\", (void*)self);\n#endif\n}\n\nstatic char NavigationToolbar2_doc[] =\n\"NavigationToolbar2\\n\";\n\nstatic PyObject*\nNavigationToolbar2_set_message(NavigationToolbar2 *self, PyObject* args)\n{\n    const char* message;\n\n#if PY3K\n    if(!PyArg_ParseTuple(args, \"y\", &message)) return NULL;\n#else\n    if(!PyArg_ParseTuple(args, \"s\", &message)) return NULL;\n#endif\n\n    NSText* messagebox = self->messagebox;\n\n    if (messagebox)\n    {   NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];\n        NSString* text = [NSString stringWithUTF8String: message];\n        [messagebox setString: text];\n        [pool release];\n    }\n\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyMethodDef NavigationToolbar2_methods[] = {\n    {\"set_message\",\n     (PyCFunction)NavigationToolbar2_set_message,\n     METH_VARARGS,\n     \"Set the message to be displayed on the toolbar.\"\n    },\n    {NULL}  /* Sentinel */\n};\n\nstatic PyTypeObject NavigationToolbar2Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_macosx.NavigationToolbar2\", /*tp_name*/\n    sizeof(NavigationToolbar2), /*tp_basicsize*/\n    0,                         /*tp_itemsize*/\n    (destructor)NavigationToolbar2_dealloc,     /*tp_dealloc*/\n    0,                         /*tp_print*/\n    0,                         /*tp_getattr*/\n    0,                         /*tp_setattr*/\n    0,                         /*tp_compare*/\n    (reprfunc)NavigationToolbar2_repr,     /*tp_repr*/\n    0,                         /*tp_as_number*/\n    0,                         /*tp_as_sequence*/\n    0,                         /*tp_as_mapping*/\n    0,                         /*tp_hash */\n    0,                         /*tp_call*/\n    0,                         /*tp_str*/\n    0,                         /*tp_getattro*/\n    0,                         /*tp_setattro*/\n    0,                         /*tp_as_buffer*/\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,        /*tp_flags*/\n    NavigationToolbar2_doc,    /* tp_doc */\n    0,                         /* tp_traverse */\n    0,                         /* tp_clear */\n    0,                         /* tp_richcompare */\n    0,                         /* tp_weaklistoffset */\n    0,                         /* tp_iter */\n    0,                         /* tp_iternext */\n    NavigationToolbar2_methods, /* tp_methods */\n    0,                         /* tp_members */\n    0,                         /* tp_getset */\n    0,                         /* tp_base */\n    0,                         /* tp_dict */\n    0,                         /* tp_descr_get */\n    0,                         /* tp_descr_set */\n    0,                         /* tp_dictoffset */\n    (initproc)NavigationToolbar2_init,      /* tp_init */\n    0,                         /* tp_alloc */\n    NavigationToolbar2_new,    /* tp_new */\n};\n\nstatic PyObject*\nchoose_save_file(PyObject* unused, PyObject* args)\n{\n    int result;\n    const char* title;\n    char* default_filename;\n    if(!PyArg_ParseTuple(args, \"ses\", &title, \"UTF-8\", &default_filename))\n        return NULL;\n\n    NSSavePanel* panel = [NSSavePanel savePanel];\n    [panel setTitle: [NSString stringWithCString: title\n                                        encoding: NSASCIIStringEncoding]];\n    NSString* ns_default_filename =\n        [[NSString alloc]\n         initWithCString: default_filename\n         encoding: NSUTF8StringEncoding];\n    PyMem_Free(default_filename);\n#ifdef COMPILING_FOR_10_6\n    [panel setNameFieldStringValue: ns_default_filename];\n    result = [panel runModal];\n#else\n    result = [panel runModalForDirectory: nil file: ns_default_filename];\n#endif\n    [ns_default_filename release];\n    if (result == NSOKButton)\n    {\n#ifdef COMPILING_FOR_10_6\n        NSURL* url = [panel URL];\n        NSString* filename = [url path];\n        if (!filename) {\n            PyErr_SetString(PyExc_RuntimeError, \"Failed to obtain filename\");\n            return 0;\n        }\n#else\n        NSString* filename = [panel filename];\n#endif\n        unsigned int n = [filename length];\n        unichar* buffer = malloc(n*sizeof(unichar));\n        [filename getCharacters: buffer];\n#if PY33\n        PyObject* string =  PyUnicode_FromKindAndData(PyUnicode_2BYTE_KIND, buffer, n);\n#else\n        PyObject* string =  PyUnicode_FromUnicode(buffer, n);\n#endif\n        free(buffer);\n        return string;\n    }\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyObject*\nset_cursor(PyObject* unused, PyObject* args)\n{\n    int i;\n    if(!PyArg_ParseTuple(args, \"i\", &i)) return NULL;\n    switch (i)\n    { case 0: [[NSCursor pointingHandCursor] set]; break;\n      case 1: [[NSCursor arrowCursor] set]; break;\n      case 2: [[NSCursor crosshairCursor] set]; break;\n      case 3: [[NSCursor openHandCursor] set]; break;\n      default: return NULL;\n    }\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\n@implementation Window\n- (Window*)initWithContentRect:(NSRect)rect styleMask:(unsigned int)mask backing:(NSBackingStoreType)bufferingType defer:(BOOL)deferCreation withManager: (PyObject*)theManager\n{\n    self = [super initWithContentRect: rect\n                            styleMask: mask\n                              backing: bufferingType\n                                defer: deferCreation];\n    manager = theManager;\n    Py_INCREF(manager);\n    return self;\n}\n\n- (NSRect)constrainFrameRect:(NSRect)rect toScreen:(NSScreen*)screen\n{\n    /* Allow window sizes larger than the screen */\n    NSRect suggested = [super constrainFrameRect: rect toScreen: screen];\n    const CGFloat difference = rect.size.height - suggested.size.height;\n    suggested.origin.y -= difference;\n    suggested.size.height += difference;\n    return suggested;\n}\n\n- (BOOL)closeButtonPressed\n{\n    PyObject* result;\n    PyGILState_STATE gstate;\n    gstate = PyGILState_Ensure();\n    result = PyObject_CallMethod(manager, \"close\", \"\");\n    if(result)\n        Py_DECREF(result);\n    else\n        PyErr_Print();\n    PyGILState_Release(gstate);\n    return YES;\n}\n\n- (void)close\n{\n    [super close];\n    nwin--;\n    if(nwin==0) [NSApp stop: self];\n}\n\n- (void)dealloc\n{\n    PyGILState_STATE gstate;\n    gstate = PyGILState_Ensure();\n    Py_DECREF(manager);\n    PyGILState_Release(gstate);\n    /* The reference count of the view that was added as a subview to the\n     * content view of this window was increased during the call to addSubview,\n     * and is decreased during the call to [super dealloc].\n     */\n    [super dealloc];\n}\n@end\n\n@implementation ToolWindow\n- (ToolWindow*)initWithContentRect:(NSRect)rect master:(NSWindow*)window\n{\n    [self initWithContentRect: rect\n                    styleMask: NSTitledWindowMask\n                             | NSClosableWindowMask\n                             | NSResizableWindowMask\n                             | NSMiniaturizableWindowMask\n                      backing: NSBackingStoreBuffered\n                        defer: YES];\n    [self setTitle: @\"Subplot Configuration Tool\"];\n    [[NSNotificationCenter defaultCenter] addObserver: self\n                                             selector: @selector(masterCloses:)\n                                                 name: NSWindowWillCloseNotification\n                                               object: window];\n    return self;\n}\n\n- (void)masterCloses:(NSNotification*)notification\n{\n    [self close];\n}\n\n- (void)close\n{\n    [[NSNotificationCenter defaultCenter] removeObserver: self];\n    [super close];\n}\n@end\n\n@implementation View\n- (BOOL)isFlipped\n{\n    return NO;\n}\n\n- (View*)initWithFrame:(NSRect)rect\n{\n    self = [super initWithFrame: rect];\n    rubberband = NSZeroRect;\n    inside = false;\n    tracking = 0;\n    return self;\n}\n\n- (void)dealloc\n{\n    FigureCanvas* fc = (FigureCanvas*)canvas;\n    if (fc) fc->view = NULL;\n    [self removeTrackingRect: tracking];\n    [super dealloc];\n}\n\n- (void)setCanvas: (PyObject*)newCanvas\n{\n    canvas = newCanvas;\n}\n\n-(void)drawRect:(NSRect)rect\n{\n    PyObject* result;\n    PyGILState_STATE gstate = PyGILState_Ensure();\n\n    PyObject* figure = PyObject_GetAttrString(canvas, \"figure\");\n    if (!figure)\n    {\n        PyErr_Print();\n        PyGILState_Release(gstate);\n        return;\n    }\n    PyObject* renderer = PyObject_GetAttrString(canvas, \"renderer\");\n    if (!renderer)\n    {\n        PyErr_Print();\n        Py_DECREF(figure);\n        PyGILState_Release(gstate);\n        return;\n    }\n    GraphicsContext* gc = (GraphicsContext*) PyObject_GetAttrString(renderer, \"gc\");\n    if (!gc)\n    {\n        PyErr_Print();\n        Py_DECREF(figure);\n        Py_DECREF(renderer);\n        PyGILState_Release(gstate);\n        return;\n    }\n\n    gc->size = [self frame].size;\n\n    CGContextRef cr = (CGContextRef) [[NSGraphicsContext currentContext] graphicsPort];\n    gc->cr = cr;\n    gc->level = 0;\n\n    result = PyObject_CallMethod(figure, \"draw\", \"O\", renderer);\n    if(result)\n        Py_DECREF(result);\n    else\n        PyErr_Print();\n\n    gc->cr = nil;\n\n    if (!NSIsEmptyRect(rubberband)) NSFrameRect(rubberband);\n\n    Py_DECREF(gc);\n    Py_DECREF(figure);\n    Py_DECREF(renderer);\n\n    PyGILState_Release(gstate);\n}\n\n- (void)windowDidResize: (NSNotification*)notification\n{\n    int width, height;\n    Window* window = [notification object];\n    NSSize size = [[window contentView] frame].size;\n    NSRect rect = [self frame];\n\n    size.height -= rect.origin.y;\n    width = size.width;\n    height = size.height;\n\n    [self setFrameSize: size];\n\n    PyGILState_STATE gstate = PyGILState_Ensure();\n    PyObject* result = PyObject_CallMethod(canvas, \"resize\", \"ii\", width, height);\n    if(result)\n        Py_DECREF(result);\n    else\n        PyErr_Print();\n    PyGILState_Release(gstate);\n    if (tracking) [self removeTrackingRect: tracking];\n    tracking = [self addTrackingRect: [self bounds]\n                               owner: self\n                            userData: nil\n                        assumeInside: NO];\n    [self setNeedsDisplay: YES];\n}\n\n- (void)windowWillClose:(NSNotification*)notification\n{\n    PyGILState_STATE gstate;\n    PyObject* result;\n\n    gstate = PyGILState_Ensure();\n    result = PyObject_CallMethod(canvas, \"close_event\", \"\");\n    if(result)\n        Py_DECREF(result);\n    else\n        PyErr_Print();\n    PyGILState_Release(gstate);\n}\n\n- (BOOL)windowShouldClose:(NSNotification*)notification\n{\n    NSWindow* window = [self window];\n    NSEvent* event = [NSEvent otherEventWithType: NSApplicationDefined\n                                        location: NSZeroPoint\n                                   modifierFlags: 0\n                                       timestamp: 0.0\n                                    windowNumber: 0\n                                         context: nil\n                                         subtype: WINDOW_CLOSING\n                                           data1: 0\n                                           data2: 0];\n    [NSApp postEvent: event atStart: true];\n    if ([window respondsToSelector: @selector(closeButtonPressed)])\n    { BOOL closed = [((Window*) window) closeButtonPressed];\n      /* If closed, the window has already been closed via the manager. */\n      if (closed) return NO;\n    }\n    return YES;\n}\n\n- (void)mouseEntered:(NSEvent *)event\n{\n    PyGILState_STATE gstate;\n    PyObject* result;\n    NSWindow* window = [self window];\n    if ([window isKeyWindow]==false) return;\n\n    gstate = PyGILState_Ensure();\n    result = PyObject_CallMethod(canvas, \"enter_notify_event\", \"\");\n    if(result)\n        Py_DECREF(result);\n    else\n        PyErr_Print();\n    PyGILState_Release(gstate);\n\n    [window setAcceptsMouseMovedEvents: YES];\n    inside = true;\n}\n\n- (void)mouseExited:(NSEvent *)event\n{\n    PyGILState_STATE gstate;\n    PyObject* result;\n    NSWindow* window = [self window];\n    if ([window isKeyWindow]==false) return;\n\n    if (inside==false) return;\n    gstate = PyGILState_Ensure();\n    result = PyObject_CallMethod(canvas, \"leave_notify_event\", \"\");\n    if(result)\n        Py_DECREF(result);\n    else\n        PyErr_Print();\n    PyGILState_Release(gstate);\n\n    [[self window] setAcceptsMouseMovedEvents: NO];\n    inside = false;\n}\n\n- (void)mouseDown:(NSEvent *)event\n{\n    int x, y;\n    int num;\n    int dblclick = 0;\n    PyObject* result;\n    PyGILState_STATE gstate;\n    NSPoint location = [event locationInWindow];\n    location = [self convertPoint: location fromView: nil];\n    x = location.x;\n    y = location.y;\n    switch ([event type])\n    {    case NSLeftMouseDown:\n         {   unsigned int modifier = [event modifierFlags];\n             if (modifier & NSControlKeyMask)\n                 /* emulate a right-button click */\n                 num = 3;\n             else if (modifier & NSAlternateKeyMask)\n                 /* emulate a middle-button click */\n                 num = 2;\n             else\n             {\n                 num = 1;\n                 if ([NSCursor currentCursor]==[NSCursor openHandCursor])\n                     [[NSCursor closedHandCursor] set];\n             }\n             break;\n         }\n         case NSOtherMouseDown: num = 2; break;\n         case NSRightMouseDown: num = 3; break;\n         default: return; /* Unknown mouse event */\n    }\n    if ([event clickCount] == 2) {\n      dblclick = 1;\n    }\n    gstate = PyGILState_Ensure();\n    result = PyObject_CallMethod(canvas, \"button_press_event\", \"iiii\", x, y, num, dblclick);\n    if(result)\n        Py_DECREF(result);\n    else\n        PyErr_Print();\n\n    PyGILState_Release(gstate);\n}\n\n- (void)mouseUp:(NSEvent *)event\n{\n    int num;\n    int x, y;\n    PyObject* result;\n    PyGILState_STATE gstate;\n    NSPoint location = [event locationInWindow];\n    location = [self convertPoint: location fromView: nil];\n    x = location.x;\n    y = location.y;\n    switch ([event type])\n    {    case NSLeftMouseUp:\n             num = 1;\n             if ([NSCursor currentCursor]==[NSCursor closedHandCursor])\n                 [[NSCursor openHandCursor] set];\n             break;\n         case NSOtherMouseUp: num = 2; break;\n         case NSRightMouseUp: num = 3; break;\n         default: return; /* Unknown mouse event */\n    }\n    gstate = PyGILState_Ensure();\n    result = PyObject_CallMethod(canvas, \"button_release_event\", \"iii\", x, y, num);\n    if(result)\n        Py_DECREF(result);\n    else\n        PyErr_Print();\n\n    PyGILState_Release(gstate);\n}\n\n- (void)mouseMoved:(NSEvent *)event\n{\n    int x, y;\n    NSPoint location = [event locationInWindow];\n    location = [self convertPoint: location fromView: nil];\n    x = location.x;\n    y = location.y;\n    PyGILState_STATE gstate = PyGILState_Ensure();\n    PyObject* result = PyObject_CallMethod(canvas, \"motion_notify_event\", \"ii\", x, y);\n    if(result)\n        Py_DECREF(result);\n    else\n        PyErr_Print();\n\n    PyGILState_Release(gstate);\n}\n\n- (void)mouseDragged:(NSEvent *)event\n{\n    int x, y;\n    NSPoint location = [event locationInWindow];\n    location = [self convertPoint: location fromView: nil];\n    x = location.x;\n    y = location.y;\n    PyGILState_STATE gstate = PyGILState_Ensure();\n    PyObject* result = PyObject_CallMethod(canvas, \"motion_notify_event\", \"ii\", x, y);\n    if(result)\n        Py_DECREF(result);\n    else\n        PyErr_Print();\n\n    PyGILState_Release(gstate);\n}\n\n- (void)rightMouseDown:(NSEvent *)event\n{\n    int x, y;\n    int num = 3;\n    int dblclick = 0;\n    PyObject* result;\n    PyGILState_STATE gstate;\n    NSPoint location = [event locationInWindow];\n    location = [self convertPoint: location fromView: nil];\n    x = location.x;\n    y = location.y;\n    gstate = PyGILState_Ensure();\n    if ([event clickCount] == 2) {\n      dblclick = 1;\n    }\n    result = PyObject_CallMethod(canvas, \"button_press_event\", \"iiii\", x, y, num, dblclick);\n    if(result)\n        Py_DECREF(result);\n    else\n        PyErr_Print();\n\n    PyGILState_Release(gstate);\n}\n\n- (void)rightMouseUp:(NSEvent *)event\n{\n    int x, y;\n    int num = 3;\n    PyObject* result;\n    PyGILState_STATE gstate;\n    NSPoint location = [event locationInWindow];\n    location = [self convertPoint: location fromView: nil];\n    x = location.x;\n    y = location.y;\n    gstate = PyGILState_Ensure();\n    result = PyObject_CallMethod(canvas, \"button_release_event\", \"iii\", x, y, num);\n    if(result)\n        Py_DECREF(result);\n    else\n        PyErr_Print();\n\n    PyGILState_Release(gstate);\n}\n\n- (void)rightMouseDragged:(NSEvent *)event\n{\n    int x, y;\n    NSPoint location = [event locationInWindow];\n    location = [self convertPoint: location fromView: nil];\n    x = location.x;\n    y = location.y;\n    PyGILState_STATE gstate = PyGILState_Ensure();\n    PyObject* result = PyObject_CallMethod(canvas, \"motion_notify_event\", \"ii\", x, y);\n    if(result)\n        Py_DECREF(result);\n    else\n        PyErr_Print();\n\n    PyGILState_Release(gstate);\n}\n\n- (void)otherMouseDown:(NSEvent *)event\n{\n    int x, y;\n    int num = 2;\n    int dblclick = 0;\n    PyObject* result;\n    PyGILState_STATE gstate;\n    NSPoint location = [event locationInWindow];\n    location = [self convertPoint: location fromView: nil];\n    x = location.x;\n    y = location.y;\n    gstate = PyGILState_Ensure();\n    if ([event clickCount] == 2) {\n      dblclick = 1;\n    }\n    result = PyObject_CallMethod(canvas, \"button_press_event\", \"iiii\", x, y, num, dblclick);\n    if(result)\n        Py_DECREF(result);\n    else\n        PyErr_Print();\n\n    PyGILState_Release(gstate);\n}\n\n- (void)otherMouseUp:(NSEvent *)event\n{\n    int x, y;\n    int num = 2;\n    PyObject* result;\n    PyGILState_STATE gstate;\n    NSPoint location = [event locationInWindow];\n    location = [self convertPoint: location fromView: nil];\n    x = location.x;\n    y = location.y;\n    gstate = PyGILState_Ensure();\n    result = PyObject_CallMethod(canvas, \"button_release_event\", \"iii\", x, y, num);\n    if(result)\n        Py_DECREF(result);\n    else\n        PyErr_Print();\n\n    PyGILState_Release(gstate);\n}\n\n- (void)otherMouseDragged:(NSEvent *)event\n{\n    int x, y;\n    NSPoint location = [event locationInWindow];\n    location = [self convertPoint: location fromView: nil];\n    x = location.x;\n    y = location.y;\n    PyGILState_STATE gstate = PyGILState_Ensure();\n    PyObject* result = PyObject_CallMethod(canvas, \"motion_notify_event\", \"ii\", x, y);\n    if(result)\n        Py_DECREF(result);\n    else\n        PyErr_Print();\n\n    PyGILState_Release(gstate);\n}\n\n- (void)setRubberband:(NSRect)rect\n{\n    if (!NSIsEmptyRect(rubberband)) [self setNeedsDisplayInRect: rubberband];\n    rubberband = rect;\n    [self setNeedsDisplayInRect: rubberband];\n}\n\n- (void)removeRubberband\n{\n    if (NSIsEmptyRect(rubberband)) return;\n    [self setNeedsDisplayInRect: rubberband];\n    rubberband = NSZeroRect;\n}\n\n\n\n- (const char*)convertKeyEvent:(NSEvent*)event\n{\n    NSDictionary* specialkeymappings = [NSDictionary dictionaryWithObjectsAndKeys:\n                                        @\"left\", [NSNumber numberWithUnsignedLong:NSLeftArrowFunctionKey],\n                                        @\"right\", [NSNumber numberWithUnsignedLong:NSRightArrowFunctionKey],\n                                        @\"up\", [NSNumber numberWithUnsignedLong:NSUpArrowFunctionKey],\n                                        @\"down\", [NSNumber numberWithUnsignedLong:NSDownArrowFunctionKey],\n                                        @\"f1\", [NSNumber numberWithUnsignedLong:NSF1FunctionKey],\n                                        @\"f2\", [NSNumber numberWithUnsignedLong:NSF2FunctionKey],\n                                        @\"f3\", [NSNumber numberWithUnsignedLong:NSF3FunctionKey],\n                                        @\"f4\", [NSNumber numberWithUnsignedLong:NSF4FunctionKey],\n                                        @\"f5\", [NSNumber numberWithUnsignedLong:NSF5FunctionKey],\n                                        @\"f6\", [NSNumber numberWithUnsignedLong:NSF6FunctionKey],\n                                        @\"f7\", [NSNumber numberWithUnsignedLong:NSF7FunctionKey],\n                                        @\"f8\", [NSNumber numberWithUnsignedLong:NSF8FunctionKey],\n                                        @\"f9\", [NSNumber numberWithUnsignedLong:NSF9FunctionKey],\n                                        @\"f10\", [NSNumber numberWithUnsignedLong:NSF10FunctionKey],\n                                        @\"f11\", [NSNumber numberWithUnsignedLong:NSF11FunctionKey],\n                                        @\"f12\", [NSNumber numberWithUnsignedLong:NSF12FunctionKey],\n                                        @\"f13\", [NSNumber numberWithUnsignedLong:NSF13FunctionKey],\n                                        @\"f14\", [NSNumber numberWithUnsignedLong:NSF14FunctionKey],\n                                        @\"f15\", [NSNumber numberWithUnsignedLong:NSF15FunctionKey],\n                                        @\"f16\", [NSNumber numberWithUnsignedLong:NSF16FunctionKey],\n                                        @\"f17\", [NSNumber numberWithUnsignedLong:NSF17FunctionKey],\n                                        @\"f18\", [NSNumber numberWithUnsignedLong:NSF18FunctionKey],\n                                        @\"f19\", [NSNumber numberWithUnsignedLong:NSF19FunctionKey],\n                                        @\"scroll_lock\", [NSNumber numberWithUnsignedLong:NSScrollLockFunctionKey],\n                                        @\"break\", [NSNumber numberWithUnsignedLong:NSBreakFunctionKey],\n                                        @\"insert\", [NSNumber numberWithUnsignedLong:NSInsertFunctionKey],\n                                        @\"delete\", [NSNumber numberWithUnsignedLong:NSDeleteFunctionKey],\n                                        @\"home\", [NSNumber numberWithUnsignedLong:NSHomeFunctionKey],\n                                        @\"end\", [NSNumber numberWithUnsignedLong:NSEndFunctionKey],\n                                        @\"pagedown\", [NSNumber numberWithUnsignedLong:NSPageDownFunctionKey],\n                                        @\"pageup\", [NSNumber numberWithUnsignedLong:NSPageUpFunctionKey],\n                                        @\"backspace\", [NSNumber numberWithUnsignedLong:NSDeleteCharacter],\n                                        @\"enter\", [NSNumber numberWithUnsignedLong:NSEnterCharacter],\n                                        @\"tab\", [NSNumber numberWithUnsignedLong:NSTabCharacter],\n                                        @\"enter\", [NSNumber numberWithUnsignedLong:NSCarriageReturnCharacter],\n                                        @\"backtab\", [NSNumber numberWithUnsignedLong:NSBackTabCharacter],\n                                        @\"escape\", [NSNumber numberWithUnsignedLong:27],\n                                        nil\n                                        ];\n\n    NSMutableString* returnkey = [NSMutableString string];\n    if ([event modifierFlags] & NSControlKeyMask)\n        [returnkey appendString:@\"ctrl+\" ];\n    if ([event modifierFlags] & NSAlternateKeyMask)\n        [returnkey appendString:@\"alt+\" ];\n    if ([event modifierFlags] & NSCommandKeyMask)\n        [returnkey appendString:@\"cmd+\" ];\n\n    unichar uc = [[event charactersIgnoringModifiers] characterAtIndex:0];\n    NSString* specialchar = [specialkeymappings objectForKey:[NSNumber numberWithUnsignedLong:uc]];\n    if (specialchar)\n        [returnkey appendString:specialchar];\n    else\n        [returnkey appendString:[event charactersIgnoringModifiers]];\n\n    return [returnkey UTF8String];\n}\n\n- (void)keyDown:(NSEvent*)event\n{\n    PyObject* result;\n    const char* s = [self convertKeyEvent: event];\n    PyGILState_STATE gstate = PyGILState_Ensure();\n    if (s==NULL)\n    {\n        result = PyObject_CallMethod(canvas, \"key_press_event\", \"O\", Py_None);\n    }\n    else\n    {\n        result = PyObject_CallMethod(canvas, \"key_press_event\", \"s\", s);\n    }\n    if(result)\n        Py_DECREF(result);\n    else\n        PyErr_Print();\n\n    PyGILState_Release(gstate);\n}\n\n- (void)keyUp:(NSEvent*)event\n{\n    PyObject* result;\n    const char* s = [self convertKeyEvent: event];\n    PyGILState_STATE gstate = PyGILState_Ensure();\n    if (s==NULL)\n    {\n        result = PyObject_CallMethod(canvas, \"key_release_event\", \"O\", Py_None);\n    }\n    else\n    {\n        result = PyObject_CallMethod(canvas, \"key_release_event\", \"s\", s);\n    }\n    if(result)\n        Py_DECREF(result);\n    else\n        PyErr_Print();\n\n    PyGILState_Release(gstate);\n}\n\n- (void)scrollWheel:(NSEvent*)event\n{\n    int step;\n    float d = [event deltaY];\n    if (d > 0) step = 1;\n    else if (d < 0) step = -1;\n    else return;\n    NSPoint location = [event locationInWindow];\n    NSPoint point = [self convertPoint: location fromView: nil];\n    int x = (int)round(point.x);\n    int y = (int)round(point.y - 1);\n\n    PyObject* result;\n    PyGILState_STATE gstate = PyGILState_Ensure();\n    result = PyObject_CallMethod(canvas, \"scroll_event\", \"iii\", x, y, step);\n    if(result)\n        Py_DECREF(result);\n    else\n        PyErr_Print();\n\n    PyGILState_Release(gstate);\n}\n\n- (BOOL)acceptsFirstResponder\n{\n    return YES;\n}\n\n/* This is all wrong. Address of pointer is being passed instead of pointer, keynames don't\n   match up with what the front-end and does the front-end even handle modifier keys by themselves?\n\n- (void)flagsChanged:(NSEvent*)event\n{\n    const char *s = NULL;\n    if (([event modifierFlags] & NSControlKeyMask) == NSControlKeyMask)\n        s = \"control\";\n    else if (([event modifierFlags] & NSShiftKeyMask) == NSShiftKeyMask)\n        s = \"shift\";\n    else if (([event modifierFlags] & NSAlternateKeyMask) == NSAlternateKeyMask)\n        s = \"alt\";\n    else return;\n    PyGILState_STATE gstate = PyGILState_Ensure();\n    PyObject* result = PyObject_CallMethod(canvas, \"key_press_event\", \"s\", &s);\n    if(result)\n        Py_DECREF(result);\n    else\n        PyErr_Print();\n\n    PyGILState_Release(gstate);\n}\n */\n@end\n\n@implementation ScrollableButton\n- (void)setScrollWheelUpAction:(SEL)action\n{\n    scrollWheelUpAction = action;\n}\n\n- (void)setScrollWheelDownAction:(SEL)action\n{\n    scrollWheelDownAction = action;\n}\n\n- (void)scrollWheel:(NSEvent*)event\n{\n    float d = [event deltaY];\n    Window* target = [self target];\n    if (d > 0)\n        [NSApp sendAction: scrollWheelUpAction to: target from: self];\n    else if (d < 0)\n        [NSApp sendAction: scrollWheelDownAction to: target from: self];\n}\n@end\n\n@implementation MenuItem\n+ (MenuItem*)menuItemWithTitle: (NSString*)title\n{\n    MenuItem* item = [[MenuItem alloc] initWithTitle: title\n                                              action: nil\n                                       keyEquivalent: @\"\"];\n    item->index = -1;\n    return [item autorelease];\n}\n\n+ (MenuItem*)menuItemForAxis: (int)i\n{\n    NSString* title = [NSString stringWithFormat: @\"Axis %d\", i+1];\n    MenuItem* item = [[MenuItem alloc] initWithTitle: title\n                                              action: @selector(toggle:)\n                                       keyEquivalent: @\"\"];\n    [item setTarget: item];\n    [item setState: NSOnState];\n    item->index = i;\n    return [item autorelease];\n}\n\n+ (MenuItem*)menuItemSelectAll\n{\n    MenuItem* item = [[MenuItem alloc] initWithTitle: @\"Select All\"\n                                              action: @selector(selectAll:)\n                                       keyEquivalent: @\"\"];\n    [item setTarget: item];\n    item->index = -1;\n    return [item autorelease];\n}\n\n+ (MenuItem*)menuItemInvertAll\n{\n    MenuItem* item = [[MenuItem alloc] initWithTitle: @\"Invert All\"\n                                              action: @selector(invertAll:)\n                                       keyEquivalent: @\"\"];\n    [item setTarget: item];\n    item->index = -1;\n    return [item autorelease];\n}\n\n- (void)toggle:(id)sender\n{\n    if ([self state]) [self setState: NSOffState];\n    else [self setState: NSOnState];\n}\n\n- (void)selectAll:(id)sender\n{\n    NSMenu* menu = [sender menu];\n    if(!menu) return; /* Weird */\n    NSArray* items = [menu itemArray];\n    NSEnumerator* enumerator = [items objectEnumerator];\n    MenuItem* item;\n    while ((item = [enumerator nextObject]))\n    {\n        if (item->index >= 0) [item setState: NSOnState];\n    }\n}\n\n- (void)invertAll:(id)sender\n{\n    NSMenu* menu = [sender menu];\n    if(!menu) return; /* Weird */\n    NSArray* items = [menu itemArray];\n    NSEnumerator* enumerator = [items objectEnumerator];\n    MenuItem* item;\n    while ((item = [enumerator nextObject]))\n    {\n        if (item->index < 0) continue;\n        if ([item state]==NSOffState) [item setState: NSOnState];\n        else [item setState: NSOffState];\n    }\n}\n\n- (int)index\n{\n    return self->index;\n}\n@end\n\n\nstatic PyObject*\nshow(PyObject* self)\n{\n    if(nwin > 0)\n    {\n        [NSApp activateIgnoringOtherApps: YES];\n        NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];\n        NSArray *windowsArray = [NSApp windows];\n        NSEnumerator *enumerator = [windowsArray objectEnumerator];\n        NSWindow *window;\n        while ((window = [enumerator nextObject])) {\n            [window orderFront:nil];\n        }\n        [pool release];\n        [NSApp run];\n    }\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\ntypedef struct {\n    PyObject_HEAD\n    CFRunLoopTimerRef timer;\n} Timer;\n\nstatic PyObject*\nTimer_new(PyTypeObject* type, PyObject *args, PyObject *kwds)\n{\n    Timer* self = (Timer*)type->tp_alloc(type, 0);\n    if (!self) return NULL;\n    self->timer = NULL;\n    return (PyObject*) self;\n}\n\nstatic PyObject*\nTimer_repr(Timer* self)\n{\n#if PY3K\n    return PyUnicode_FromFormat(\"Timer object %p wrapping CFRunLoopTimerRef %p\",\n                               (void*) self, (void*)(self->timer));\n#else\n    return PyString_FromFormat(\"Timer object %p wrapping CFRunLoopTimerRef %p\",\n                               (void*) self, (void*)(self->timer));\n#endif\n}\n\nstatic char Timer_doc[] =\n\"A Timer object wraps a CFRunLoopTimerRef and can add it to the event loop.\\n\";\n\nstatic void timer_callback(CFRunLoopTimerRef timer, void* info)\n{\n    PyObject* method = info;\n    PyGILState_STATE gstate = PyGILState_Ensure();\n    PyObject* result = PyObject_CallFunction(method, NULL);\n    if (result==NULL) PyErr_Print();\n    PyGILState_Release(gstate);\n}\n\nstatic PyObject*\nTimer__timer_start(Timer* self, PyObject* args)\n{\n    CFRunLoopRef runloop;\n    CFRunLoopTimerRef timer;\n    CFRunLoopTimerContext context;\n    double milliseconds;\n    CFTimeInterval interval;\n    PyObject* attribute;\n    PyObject* failure;\n    runloop = CFRunLoopGetCurrent();\n    if (!runloop) {\n        PyErr_SetString(PyExc_RuntimeError, \"Failed to obtain run loop\");\n        return NULL;\n    }\n    context.version = 0;\n    context.retain = 0;\n    context.release = 0;\n    context.copyDescription = 0;\n    attribute = PyObject_GetAttrString((PyObject*)self, \"_interval\");\n    if (attribute==NULL)\n    {\n        PyErr_SetString(PyExc_AttributeError, \"Timer has no attribute '_interval'\");\n        return NULL;\n    }\n    milliseconds = PyFloat_AsDouble(attribute);\n    failure = PyErr_Occurred();\n    Py_DECREF(attribute);\n    if (failure) return NULL;\n    attribute = PyObject_GetAttrString((PyObject*)self, \"_single\");\n    if (attribute==NULL)\n    {\n        PyErr_SetString(PyExc_AttributeError, \"Timer has no attribute '_single'\");\n        return NULL;\n    }\n    switch (PyObject_IsTrue(attribute)) {\n        case 1:\n            interval = 0;\n            break;\n        case 0:\n            interval = milliseconds / 1000.0;\n            break;\n        case -1:\n        default:\n            PyErr_SetString(PyExc_ValueError, \"Cannot interpret _single attribute as True of False\");\n            return NULL;\n    }\n    attribute = PyObject_GetAttrString((PyObject*)self, \"_on_timer\");\n    if (attribute==NULL)\n    {\n        PyErr_SetString(PyExc_AttributeError, \"Timer has no attribute '_on_timer'\");\n        return NULL;\n    }\n    if (!PyMethod_Check(attribute)) {\n        PyErr_SetString(PyExc_RuntimeError, \"_on_timer should be a Python method\");\n        return NULL;\n    }\n    context.info = attribute;\n    timer = CFRunLoopTimerCreate(kCFAllocatorDefault,\n                                 0,\n                                 interval,\n                                 0,\n                                 0,\n                                 timer_callback,\n                                 &context);\n    if (!timer) {\n        PyErr_SetString(PyExc_RuntimeError, \"Failed to create timer\");\n        return NULL;\n    }\n    Py_INCREF(attribute);\n    if (self->timer) {\n        CFRunLoopTimerGetContext(self->timer, &context);\n        attribute = context.info;\n        Py_DECREF(attribute);\n        CFRunLoopRemoveTimer(runloop, self->timer, kCFRunLoopCommonModes);\n        CFRelease(self->timer);\n    }\n    CFRunLoopAddTimer(runloop, timer, kCFRunLoopCommonModes);\n    /* Don't release the timer here, since the run loop may be destroyed and\n     * the timer lost before we have a chance to decrease the reference count\n     * of the attribute */\n    self->timer = timer;\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyObject*\nTimer__timer_stop(Timer* self)\n{\n    if (self->timer) {\n        PyObject* attribute;\n        CFRunLoopTimerContext context;\n        CFRunLoopTimerGetContext(self->timer, &context);\n        attribute = context.info;\n        Py_DECREF(attribute);\n        CFRunLoopRef runloop = CFRunLoopGetCurrent();\n        if (runloop) {\n            CFRunLoopRemoveTimer(runloop, self->timer, kCFRunLoopCommonModes);\n        }\n        CFRelease(self->timer);\n        self->timer = NULL;\n    }\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic void\nTimer_dealloc(Timer* self)\n{\n    Timer__timer_stop(self);\n    Py_TYPE(self)->tp_free((PyObject*)self);\n}\n\nstatic PyMethodDef Timer_methods[] = {\n    {\"_timer_start\",\n     (PyCFunction)Timer__timer_start,\n     METH_VARARGS,\n     \"Initialize and start the timer.\"\n    },\n    {\"_timer_stop\",\n     (PyCFunction)Timer__timer_stop,\n     METH_NOARGS,\n     \"Stop the timer.\"\n    },\n    {NULL}  /* Sentinel */\n};\n\nstatic PyTypeObject TimerType = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_macosx.Timer\",           /*tp_name*/\n    sizeof(Timer),             /*tp_basicsize*/\n    0,                         /*tp_itemsize*/\n    (destructor)Timer_dealloc,     /*tp_dealloc*/\n    0,                         /*tp_print*/\n    0,                         /*tp_getattr*/\n    0,                         /*tp_setattr*/\n    0,                         /*tp_compare*/\n    (reprfunc)Timer_repr,      /*tp_repr*/\n    0,                         /*tp_as_number*/\n    0,                         /*tp_as_sequence*/\n    0,                         /*tp_as_mapping*/\n    0,                         /*tp_hash */\n    0,                         /*tp_call*/\n    0,                         /*tp_str*/\n    0,                         /*tp_getattro*/\n    0,                         /*tp_setattro*/\n    0,                         /*tp_as_buffer*/\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,        /*tp_flags*/\n    Timer_doc,                 /* tp_doc */\n    0,                         /* tp_traverse */\n    0,                         /* tp_clear */\n    0,                         /* tp_richcompare */\n    0,                         /* tp_weaklistoffset */\n    0,                         /* tp_iter */\n    0,                         /* tp_iternext */\n    Timer_methods,             /* tp_methods */\n    0,                         /* tp_members */\n    0,                         /* tp_getset */\n    0,                         /* tp_base */\n    0,                         /* tp_dict */\n    0,                         /* tp_descr_get */\n    0,                         /* tp_descr_set */\n    0,                         /* tp_dictoffset */\n    0,                         /* tp_init */\n    0,                         /* tp_alloc */\n    Timer_new,                 /* tp_new */\n};\n\nstatic struct PyMethodDef methods[] = {\n   {\"show\",\n    (PyCFunction)show,\n    METH_NOARGS,\n    \"Show all the figures and enter the main loop.\\nThis function does not return until all Matplotlib windows are closed,\\nand is normally not needed in interactive sessions.\"\n   },\n   {\"choose_save_file\",\n    (PyCFunction)choose_save_file,\n    METH_VARARGS,\n    \"Closes the window.\"\n   },\n   {\"set_cursor\",\n    (PyCFunction)set_cursor,\n    METH_VARARGS,\n    \"Sets the active cursor.\"\n   },\n   {NULL,          NULL, 0, NULL}/* sentinel */\n};\n\n#if PY3K\n\nstatic struct PyModuleDef moduledef = {\n    PyModuleDef_HEAD_INIT,\n    \"_macosx\",\n    \"Mac OS X native backend\",\n    -1,\n    methods,\n    NULL,\n    NULL,\n    NULL,\n    NULL\n};\n\nPyObject* PyInit__macosx(void)\n\n#else\n\nvoid init_macosx(void)\n#endif\n{\n\n#ifdef WITH_NEXT_FRAMEWORK\n    PyObject *module;\n    import_array();\n\n    if (PyType_Ready(&GraphicsContextType) < 0\n     || PyType_Ready(&FigureCanvasType) < 0\n     || PyType_Ready(&FigureManagerType) < 0\n     || PyType_Ready(&NavigationToolbarType) < 0\n     || PyType_Ready(&NavigationToolbar2Type) < 0\n     || PyType_Ready(&TimerType) < 0)\n#if PY3K\n        return NULL;\n#else\n        return;\n#endif\n\n#if PY3K\n    module = PyModule_Create(&moduledef);\n    if (module==NULL) return NULL;\n#else\n    module = Py_InitModule4(\"_macosx\",\n                            methods,\n                            \"Mac OS X native backend\",\n                            NULL,\n                            PYTHON_API_VERSION);\n#endif\n\n    Py_INCREF(&GraphicsContextType);\n    Py_INCREF(&FigureCanvasType);\n    Py_INCREF(&FigureManagerType);\n    Py_INCREF(&NavigationToolbarType);\n    Py_INCREF(&NavigationToolbar2Type);\n    Py_INCREF(&TimerType);\n    PyModule_AddObject(module, \"GraphicsContext\", (PyObject*) &GraphicsContextType);\n    PyModule_AddObject(module, \"FigureCanvas\", (PyObject*) &FigureCanvasType);\n    PyModule_AddObject(module, \"FigureManager\", (PyObject*) &FigureManagerType);\n    PyModule_AddObject(module, \"NavigationToolbar\", (PyObject*) &NavigationToolbarType);\n    PyModule_AddObject(module, \"NavigationToolbar2\", (PyObject*) &NavigationToolbar2Type);\n    PyModule_AddObject(module, \"Timer\", (PyObject*) &TimerType);\n\n    PyOS_InputHook = wait_for_stdin;\n\n#if PY3K\n    return module;\n#endif\n#else\n    /* WITH_NEXT_FRAMEWORK is not defined. This means that Python is not\n     * installed as a framework, and therefore the Mac OS X backend will\n     * not interact properly with the window manager.\n     */\n    PyErr_SetString(PyExc_RuntimeError,\n        \"Python is not installed as a framework. The Mac OS X backend will \"\n        \"not be able to function correctly if Python is not installed as a \"\n        \"framework. See the Python documentation for more information on \"\n        \"installing Python as a framework on Mac OS X. Please either reinstall \"\n        \"Python as a framework, or try one of the other backends.\");\n#if PY3K\n    return NULL;\n#else\n    return;\n#endif\n#endif\n}\n", "patch": "@@ -4546,11 +4546,7 @@ -(void)save_figure:(id)sender\n     {\n         if(states[i]==1)\n         {\n-#if PY3K\n             PyList_SET_ITEM(list, j, PyLong_FromLong(i));\n-#else\n-            PyList_SET_ITEM(list, j, PyInt_FromLong(i));\n-#endif\n             j++;\n         }\n     }"}
{"patches_id": 2, "files_id": 39, "language": "cpp", "raw_url": "https://github.com/matplotlib/matplotlib/raw/dbeed94d578c458d31842cd13c04f665155986cb/src%2F_path.cpp", "raw_code": "/* -*- mode: c++; c-basic-offset: 4 -*- */\n\n#include \"agg_py_path_iterator.h\"\n#include \"agg_py_transforms.h\"\n#include \"path_converters.h\"\n\n#include <limits>\n#include <math.h>\n\n#include \"CXX/Extensions.hxx\"\n\n#include \"agg_conv_contour.h\"\n#include \"agg_conv_curve.h\"\n#include \"agg_conv_stroke.h\"\n#include \"agg_conv_transform.h\"\n#include \"agg_path_storage.h\"\n#include \"agg_trans_affine.h\"\n\nstruct XY\n{\n    double x;\n    double y;\n\n    XY(double x_, double y_) : x(x_), y(y_) {}\n};\n\n// the extension module\nclass _path_module : public Py::ExtensionModule<_path_module>\n{\npublic:\n    _path_module()\n            : Py::ExtensionModule<_path_module>(\"_path\")\n    {\n        add_varargs_method(\"point_in_path\", &_path_module::point_in_path,\n                           \"point_in_path(x, y, path, trans)\");\n        add_varargs_method(\"points_in_path\", &_path_module::points_in_path,\n                           \"points_in_path(points, path, trans)\");\n        add_varargs_method(\"point_on_path\", &_path_module::point_on_path,\n                           \"point_on_path(x, y, r, path, trans)\");\n        add_varargs_method(\"get_path_extents\", &_path_module::get_path_extents,\n                           \"get_path_extents(path, trans)\");\n        add_varargs_method(\"update_path_extents\", &_path_module::update_path_extents,\n                           \"update_path_extents(path, trans, bbox, minpos)\");\n        add_varargs_method(\"get_path_collection_extents\", &_path_module::get_path_collection_extents,\n                           \"get_path_collection_extents(trans, paths, transforms, offsets, offsetTrans)\");\n        add_varargs_method(\"point_in_path_collection\", &_path_module::point_in_path_collection,\n                           \"point_in_path_collection(x, y, r, trans, paths, transforms, offsets, offsetTrans, filled)\");\n        add_varargs_method(\"path_in_path\", &_path_module::path_in_path,\n                           \"path_in_path(a, atrans, b, btrans)\");\n        add_varargs_method(\"clip_path_to_rect\", &_path_module::clip_path_to_rect,\n                           \"clip_path_to_rect(path, bbox, inside)\");\n        add_varargs_method(\"affine_transform\", &_path_module::affine_transform,\n                           \"affine_transform(vertices, transform)\");\n        add_varargs_method(\"count_bboxes_overlapping_bbox\", &_path_module::count_bboxes_overlapping_bbox,\n                           \"count_bboxes_overlapping_bbox(bbox, bboxes)\");\n        add_varargs_method(\"path_intersects_path\", &_path_module::path_intersects_path,\n                           \"path_intersects_path(p1, p2)\");\n        add_varargs_method(\"convert_path_to_polygons\", &_path_module::convert_path_to_polygons,\n                           \"convert_path_to_polygons(path, trans, width, height)\");\n        add_varargs_method(\"cleanup_path\", &_path_module::cleanup_path,\n                           \"cleanup_path(path, trans, remove_nans, clip, snap, simplify, curves, sketch_params)\");\n        add_varargs_method(\"convert_to_svg\", &_path_module::convert_to_svg,\n                           \"convert_to_svg(path, trans, clip, simplify, precision)\");\n        initialize(\"Helper functions for paths\");\n    }\n\n    virtual ~_path_module() {}\n\nprivate:\n    Py::Object point_in_path(const Py::Tuple& args);\n    Py::Object points_in_path(const Py::Tuple& args);\n    Py::Object point_on_path(const Py::Tuple& args);\n    Py::Object get_path_extents(const Py::Tuple& args);\n    Py::Object update_path_extents(const Py::Tuple& args);\n    Py::Object get_path_collection_extents(const Py::Tuple& args);\n    Py::Object point_in_path_collection(const Py::Tuple& args);\n    Py::Object path_in_path(const Py::Tuple& args);\n    Py::Object clip_path_to_rect(const Py::Tuple& args);\n    Py::Object affine_transform(const Py::Tuple& args);\n    Py::Object count_bboxes_overlapping_bbox(const Py::Tuple& args);\n    Py::Object path_intersects_path(const Py::Tuple& args);\n    Py::Object convert_path_to_polygons(const Py::Tuple& args);\n    Py::Object cleanup_path(const Py::Tuple& args);\n    Py::Object convert_to_svg(const Py::Tuple& args);\n};\n\n//\n// The following function was found in the Agg 2.3 examples (interactive_polygon.cpp).\n// It has been generalized to work on (possibly curved) polylines, rather than\n// just polygons.  The original comments have been kept intact.\n//  -- Michael Droettboom 2007-10-02\n//\n//======= Crossings Multiply algorithm of InsideTest ========================\n//\n// By Eric Haines, 3D/Eye Inc, erich@eye.com\n//\n// This version is usually somewhat faster than the original published in\n// Graphics Gems IV; by turning the division for testing the X axis crossing\n// into a tricky multiplication test this part of the test became faster,\n// which had the additional effect of making the test for \"both to left or\n// both to right\" a bit slower for triangles than simply computing the\n// intersection each time.  The main increase is in triangle testing speed,\n// which was about 15% faster; all other polygon complexities were pretty much\n// the same as before.  On machines where division is very expensive (not the\n// case on the HP 9000 series on which I tested) this test should be much\n// faster overall than the old code.  Your mileage may (in fact, will) vary,\n// depending on the machine and the test data, but in general I believe this\n// code is both shorter and faster.  This test was inspired by unpublished\n// Graphics Gems submitted by Joseph Samosky and Mark Haigh-Hutchinson.\n// Related work by Samosky is in:\n//\n// Samosky, Joseph, \"SectionView: A system for interactively specifying and\n// visualizing sections through three-dimensional medical image data\",\n// M.S. Thesis, Department of Electrical Engineering and Computer Science,\n// Massachusetts Institute of Technology, 1993.\n//\n// Shoot a test ray along +X axis.  The strategy is to compare vertex Y values\n// to the testing point's Y and quickly discard edges which are entirely to one\n// side of the test ray.  Note that CONVEX and WINDING code can be added as\n// for the CrossingsTest() code; it is left out here for clarity.\n//\n// Input 2D polygon _pgon_ with _numverts_ number of vertices and test point\n// _point_, returns 1 if inside, 0 if outside.\ntemplate<class T>\nstatic void\npoint_in_path_impl(const void* const points_, const size_t s0,\n                   const size_t s1, const size_t n, T& path,\n                   npy_bool* const inside_flag)\n{\n    int *yflag0;\n    int *subpath_flag;\n    int yflag1;\n    double vtx0, vty0, vtx1, vty1;\n    double tx, ty;\n    double sx, sy;\n    double x, y;\n    size_t i;\n    int all_done;\n    const char *const points = (const char * const)points_;\n\n    yflag0 = (int *)malloc(n * sizeof(int));\n    subpath_flag = (int *)malloc(n * sizeof(int));\n\n    path.rewind(0);\n\n    for (i = 0; i < n; ++i) {\n        inside_flag[i] = 0;\n    }\n\n    unsigned code = 0;\n    do\n    {\n        if (code != agg::path_cmd_move_to)\n        {\n            code = path.vertex(&x, &y);\n            if (code == agg::path_cmd_stop ||\n                (code & agg::path_cmd_end_poly) == agg::path_cmd_end_poly) {\n                continue;\n            }\n        }\n\n        sx = vtx0 = vtx1 = x;\n        sy = vty0 = vty1 = y;\n\n        for (i = 0; i < n; ++i) {\n            ty = *(double *)(points + s0 * i + s1);\n\n            // get test bit for above/below X axis\n            yflag0[i] = (vty0 >= ty);\n\n            subpath_flag[i] = 0;\n        }\n\n        do\n        {\n            code = path.vertex(&x, &y);\n\n            // The following cases denote the beginning on a new subpath\n            if (code == agg::path_cmd_stop ||\n                (code & agg::path_cmd_end_poly) == agg::path_cmd_end_poly)\n            {\n                x = sx;\n                y = sy;\n            }\n            else if (code == agg::path_cmd_move_to)\n            {\n                break;\n            }\n\n            for (i = 0; i < n; ++i) {\n                tx = *(double *)(points + s0 * i);\n                ty = *(double *)(points + s0 * i + s1);\n\n                yflag1 = (vty1 >= ty);\n                // Check if endpoints straddle (are on opposite sides) of\n                // X axis (i.e. the Y's differ); if so, +X ray could\n                // intersect this edge.  The old test also checked whether\n                // the endpoints are both to the right or to the left of\n                // the test point.  However, given the faster intersection\n                // point computation used below, this test was found to be\n                // a break-even proposition for most polygons and a loser\n                // for triangles (where 50% or more of the edges which\n                // survive this test will cross quadrants and so have to\n                // have the X intersection computed anyway).  I credit\n                // Joseph Samosky with inspiring me to try dropping the\n                // \"both left or both right\" part of my code.\n                if (yflag0[i] != yflag1) {\n                    // Check intersection of pgon segment with +X ray.\n                    // Note if >= point's X; if so, the ray hits it.  The\n                    // division operation is avoided for the \">=\" test by\n                    // checking the sign of the first vertex wrto the test\n                    // point; idea inspired by Joseph Samosky's and Mark\n                    // Haigh-Hutchinson's different polygon inclusion\n                    // tests.\n                    if (((vty1 - ty) * (vtx0 - vtx1) >=\n                         (vtx1 - tx) * (vty0 - vty1)) == yflag1) {\n                        subpath_flag[i] ^= 1;\n                    }\n                }\n\n                // Move to the next pair of vertices, retaining info as\n                // possible.\n                yflag0[i] = yflag1;\n            }\n\n            vtx0 = vtx1;\n            vty0 = vty1;\n\n            vtx1 = x;\n            vty1 = y;\n        }\n        while (code != agg::path_cmd_stop &&\n               (code & agg::path_cmd_end_poly) != agg::path_cmd_end_poly);\n\n        all_done = 1;\n        for (i = 0; i < n; ++i) {\n            tx = *(double *)(points + s0 * i);\n            ty = *(double *)(points + s0 * i + s1);\n\n            yflag1 = (vty1 >= ty);\n            if (yflag0[i] != yflag1) {\n                if (((vty1 - ty) * (vtx0 - vtx1) >=\n                     (vtx1 - tx) * (vty0 - vty1)) == yflag1) {\n                    subpath_flag[i] ^= 1;\n                }\n            }\n            inside_flag[i] |= subpath_flag[i];\n            if (inside_flag[i] == 0) {\n                all_done = 0;\n            }\n        }\n\n        if (all_done) {\n            goto exit;\n        }\n    }\n    while (code != agg::path_cmd_stop);\n\n exit:\n\n    free(yflag0);\n    free(subpath_flag);\n}\n\ninline void\npoints_in_path(const void* const points, const size_t s0,\n               const size_t s1, const size_t n,\n               const double r, PathIterator& path,\n               const agg::trans_affine& trans,\n               npy_bool* result)\n{\n    typedef agg::conv_transform<PathIterator> transformed_path_t;\n    typedef PathNanRemover<transformed_path_t> no_nans_t;\n    typedef agg::conv_curve<no_nans_t> curve_t;\n    typedef agg::conv_contour<curve_t> contour_t;\n\n    size_t i;\n    for (i = 0; i < n; ++i) {\n        result[i] = 0;\n    }\n\n    if (path.total_vertices() < 3)\n    {\n        return;\n    }\n\n    transformed_path_t trans_path(path, trans);\n    no_nans_t no_nans_path(trans_path, true, path.has_curves());\n    curve_t curved_path(no_nans_path);\n    contour_t contoured_path(curved_path);\n    contoured_path.width(r);\n    point_in_path_impl(points, s0, s1, n, contoured_path, result);\n}\n\ninline bool\npoint_in_path(const double x, const double y, const double r,\n              PathIterator& path, const agg::trans_affine& trans)\n{\n    double points[2];\n    npy_bool result;\n\n    points[0] = x;\n    points[1] = y;\n\n    points_in_path(points, 0, sizeof(double), 1, r, path, trans, &result);\n    return result;\n}\n\ninline void\npoints_on_path(const void* const points, const size_t s0,\n               const size_t s1, const size_t n,\n               const double r, PathIterator& path,\n               const agg::trans_affine& trans,\n               npy_bool* result)\n{\n    typedef agg::conv_transform<PathIterator> transformed_path_t;\n    typedef PathNanRemover<transformed_path_t> no_nans_t;\n    typedef agg::conv_curve<no_nans_t> curve_t;\n    typedef agg::conv_stroke<curve_t> stroke_t;\n\n    transformed_path_t trans_path(path, trans);\n    no_nans_t nan_removed_path(trans_path, true, path.has_curves());\n    curve_t curved_path(nan_removed_path);\n    stroke_t stroked_path(curved_path);\n    stroked_path.width(r * 2.0);\n    point_in_path_impl(points, s0, s1, n, stroked_path, result);\n}\n\ninline bool\npoint_on_path(const double x, const double y, const double r,\n              PathIterator& path, const agg::trans_affine& trans)\n{\n    double points[2];\n    npy_bool result;\n\n    points[0] = x;\n    points[1] = y;\n\n    points_on_path(points, 0, sizeof(double), 1, r, path, trans, &result);\n    return result;\n}\n\nPy::Object\n_path_module::point_in_path(const Py::Tuple& args)\n{\n    double x = Py::Float(args[0]);\n    double y = Py::Float(args[1]);\n    double r = Py::Float(args[2]);\n    PathIterator path(args[3]);\n    agg::trans_affine trans = py_to_agg_transformation_matrix(args[4].ptr(), false);\n\n    if (::point_in_path(x, y, r, path, trans)) {\n        return Py::Int(1);\n    }\n    return Py::Int(0);\n}\n\nPy::Object\n_path_module::points_in_path(const Py::Tuple& args)\n{\n    args.verify_length(4);\n\n    npy_intp n;\n    PyArrayObject* points_array;\n    points_array = (PyArrayObject*)PyArray_FromObject(args[0].ptr(), NPY_DOUBLE, 2, 2);\n    if (points_array == NULL || PyArray_DIM(points_array, 1) != 2) {\n        throw Py::TypeError(\n            \"Argument 0 to points_in_path must be an Nx2 numpy array\");\n\n    }\n    double r = Py::Float(args[1]);\n    PathIterator path(args[2]);\n    agg::trans_affine trans = py_to_agg_transformation_matrix(args[3].ptr(), false);\n\n    n = PyArray_DIM(points_array, 0);\n    PyObject* result = PyArray_ZEROS(1, &n, NPY_BOOL, 0);\n    if (result == NULL) {\n        throw Py::MemoryError(\"Could not allocate memory for result\");\n    }\n\n    ::points_in_path(PyArray_DATA(points_array),\n                     PyArray_STRIDE(points_array, 0),\n                     PyArray_STRIDE(points_array, 1),\n                     n, r, path, trans,\n                     (npy_bool *)PyArray_DATA((PyArrayObject*)result));\n    Py_DECREF(points_array);\n\n    return Py::Object(result, true);;\n}\n\nPy::Object\n_path_module::point_on_path(const Py::Tuple& args)\n{\n    double x = Py::Float(args[0]);\n    double y = Py::Float(args[1]);\n    double r = Py::Float(args[2]);\n    PathIterator path(args[3]);\n    agg::trans_affine trans = py_to_agg_transformation_matrix(args[4].ptr());\n\n    if (::point_on_path(x, y, r, path, trans))\n    {\n        return Py::Int(1);\n    }\n    return Py::Int(0);\n}\n\nvoid\nupdate_limits(double x, double y,\n              double* x0, double* y0, double* x1, double* y1,\n              double* xm, double* ym)\n{\n    if (x < *x0) *x0 = x;\n    if (y < *y0) *y0 = y;\n    if (x > *x1) *x1 = x;\n    if (y > *y1) *y1 = y;\n    /* xm and ym are the minimum positive values in the data, used\n       by log scaling */\n    if (x > 0.0 && x < *xm) *xm = x;\n    if (y > 0.0 && y < *ym) *ym = y;\n}\n\nvoid\nget_path_extents(PathIterator& path, const agg::trans_affine& trans,\n                 double* x0, double* y0, double* x1, double* y1,\n                 double* xm, double* ym)\n{\n    typedef agg::conv_transform<PathIterator> transformed_path_t;\n    typedef PathNanRemover<transformed_path_t> nan_removed_t;\n    typedef agg::conv_curve<nan_removed_t> curve_t;\n    double x, y;\n    unsigned code;\n\n    transformed_path_t tpath(path, trans);\n    nan_removed_t nan_removed(tpath, true, path.has_curves());\n\n    nan_removed.rewind(0);\n\n    while ((code = nan_removed.vertex(&x, &y)) != agg::path_cmd_stop)\n    {\n        if ((code & agg::path_cmd_end_poly) == agg::path_cmd_end_poly)\n        {\n            continue;\n        }\n        update_limits(x, y, x0, y0, x1, y1, xm, ym);\n    }\n}\n\nPy::Object\n_path_module::get_path_extents(const Py::Tuple& args)\n{\n    args.verify_length(2);\n\n    PathIterator path(args[0]);\n    agg::trans_affine trans = py_to_agg_transformation_matrix(args[1].ptr(), false);\n\n    npy_intp extent_dims[] = { 2, 2, 0 };\n    double* extents_data = NULL;\n    double xm, ym;\n    PyArrayObject* extents = NULL;\n    try\n    {\n        extents = (PyArrayObject*)PyArray_SimpleNew\n                  (2, extent_dims, NPY_DOUBLE);\n        if (extents == NULL)\n        {\n            throw Py::MemoryError(\"Could not allocate result array\");\n        }\n        extents_data = (double*)PyArray_DATA(extents);\n\n        extents_data[0] = std::numeric_limits<double>::infinity();\n        extents_data[1] = std::numeric_limits<double>::infinity();\n        extents_data[2] = -std::numeric_limits<double>::infinity();\n        extents_data[3] = -std::numeric_limits<double>::infinity();\n        /* xm and ym are the minimum positive values in the data, used\n           by log scaling */\n        xm = std::numeric_limits<double>::infinity();\n        ym = std::numeric_limits<double>::infinity();\n\n        ::get_path_extents(path, trans, &extents_data[0], &extents_data[1],\n                           &extents_data[2], &extents_data[3], &xm, &ym);\n    }\n    catch (...)\n    {\n        Py_XDECREF(extents);\n        throw;\n    }\n\n    return Py::Object((PyObject*)extents, true);\n}\n\nPy::Object\n_path_module::update_path_extents(const Py::Tuple& args)\n{\n    args.verify_length(5);\n\n    double x0, y0, x1, y1;\n    PathIterator path(args[0]);\n    agg::trans_affine trans = py_to_agg_transformation_matrix(\n        args[1].ptr(), false);\n\n    if (!py_convert_bbox(args[2].ptr(), x0, y0, x1, y1))\n    {\n        throw Py::ValueError(\n            \"Must pass Bbox object as arg 3 of update_path_extents\");\n    }\n    Py::Object minpos_obj = args[3];\n    bool ignore = Py::Boolean(args[4]);\n\n    double xm, ym;\n    PyArrayObject* input_minpos = NULL;\n    try\n    {\n        input_minpos = (PyArrayObject*)PyArray_FromObject(\n            minpos_obj.ptr(), NPY_DOUBLE, 1, 1);\n        if (!input_minpos || PyArray_DIM(input_minpos, 0) != 2)\n        {\n            throw Py::TypeError(\n                \"Argument 4 to update_path_extents must be a length-2 numpy array.\");\n        }\n        xm = *(double*)PyArray_GETPTR1(input_minpos, 0);\n        ym = *(double*)PyArray_GETPTR1(input_minpos, 1);\n    }\n    catch (...)\n    {\n        Py_XDECREF(input_minpos);\n        throw;\n    }\n    Py_XDECREF(input_minpos);\n\n    npy_intp extent_dims[] = { 2, 2, 0 };\n    double* extents_data = NULL;\n    npy_intp minpos_dims[] = { 2, 0 };\n    double* minpos_data = NULL;\n    PyArrayObject* extents = NULL;\n    PyArrayObject* minpos = NULL;\n    bool changed = false;\n\n    try\n    {\n        extents = (PyArrayObject*)PyArray_SimpleNew\n                  (2, extent_dims, NPY_DOUBLE);\n        if (extents == NULL)\n        {\n            throw Py::MemoryError(\"Could not allocate result array\");\n        }\n        minpos = (PyArrayObject*)PyArray_SimpleNew\n                 (1, minpos_dims, NPY_DOUBLE);\n        if (minpos == NULL)\n        {\n            throw Py::MemoryError(\"Could not allocate result array\");\n        }\n\n        extents_data = (double*)PyArray_DATA(extents);\n        minpos_data = (double*)PyArray_DATA(minpos);\n\n        if (ignore)\n        {\n            extents_data[0] = std::numeric_limits<double>::infinity();\n            extents_data[1] = std::numeric_limits<double>::infinity();\n            extents_data[2] = -std::numeric_limits<double>::infinity();\n            extents_data[3] = -std::numeric_limits<double>::infinity();\n            minpos_data[0] = std::numeric_limits<double>::infinity();\n            minpos_data[1] = std::numeric_limits<double>::infinity();\n        }\n        else\n        {\n            if (x0 > x1)\n            {\n                extents_data[0] = std::numeric_limits<double>::infinity();\n                extents_data[2] = -std::numeric_limits<double>::infinity();\n            }\n            else\n            {\n                extents_data[0] = x0;\n                extents_data[2] = x1;\n            }\n            if (y0 > y1)\n            {\n                extents_data[1] = std::numeric_limits<double>::infinity();\n                extents_data[3] = -std::numeric_limits<double>::infinity();\n            }\n            else\n            {\n                extents_data[1] = y0;\n                extents_data[3] = y1;\n            }\n            minpos_data[0] = xm;\n            minpos_data[1] = ym;\n        }\n\n        ::get_path_extents(path, trans, &extents_data[0], &extents_data[1],\n                           &extents_data[2], &extents_data[3], &minpos_data[0],\n                           &minpos_data[1]);\n\n        changed = (extents_data[0] != x0 ||\n                   extents_data[1] != y0 ||\n                   extents_data[2] != x1 ||\n                   extents_data[3] != y1 ||\n                   minpos_data[0]  != xm ||\n                   minpos_data[1]  != ym);\n\n    }\n    catch (...)\n    {\n        Py_XDECREF(extents);\n        Py_XDECREF(minpos);\n        throw;\n    }\n\n    Py::Tuple result(3);\n    result[0] = Py::Object((PyObject*) extents);\n    result[1] = Py::Object((PyObject*) minpos);\n    result[2] = Py::Int(changed ? 1 : 0);\n\n    Py_XDECREF(extents);\n    Py_XDECREF(minpos);\n\n    return result;\n}\n\nPy::Object\n_path_module::get_path_collection_extents(const Py::Tuple& args)\n{\n    args.verify_length(5);\n\n    //segments, trans, clipbox, colors, linewidths, antialiaseds\n    agg::trans_affine       master_transform = py_to_agg_transformation_matrix(args[0].ptr());\n    Py::SeqBase<Py::Object> paths            = args[1];\n    Py::SeqBase<Py::Object> transforms_obj   = args[2];\n    Py::Object              offsets_obj      = args[3];\n    agg::trans_affine       offset_trans     = py_to_agg_transformation_matrix(args[4].ptr(), false);\n\n    PyArrayObject* offsets = NULL;\n    double x0, y0, x1, y1, xm, ym;\n\n    try\n    {\n        offsets = (PyArrayObject*)PyArray_FromObject(\n            offsets_obj.ptr(), NPY_DOUBLE, 0, 2);\n        if (!offsets ||\n            (PyArray_NDIM(offsets) == 2 && PyArray_DIM(offsets, 1) != 2) ||\n            (PyArray_NDIM(offsets) == 1 && PyArray_DIM(offsets, 0) != 0))\n        {\n            throw Py::ValueError(\"Offsets array must be Nx2\");\n        }\n\n        size_t Npaths      = paths.length();\n        size_t Noffsets    = PyArray_DIM(offsets, 0);\n        size_t N           = std::max(Npaths, Noffsets);\n        size_t Ntransforms = std::min(transforms_obj.length(), N);\n        size_t i;\n\n        // Convert all of the transforms up front\n        typedef std::vector<agg::trans_affine> transforms_t;\n        transforms_t transforms;\n        transforms.reserve(Ntransforms);\n        for (i = 0; i < Ntransforms; ++i)\n        {\n            agg::trans_affine trans = py_to_agg_transformation_matrix\n                (transforms_obj[i].ptr(), false);\n            trans *= master_transform;\n            transforms.push_back(trans);\n        }\n\n        // The offset each of those and collect the mins/maxs\n        x0 = std::numeric_limits<double>::infinity();\n        y0 = std::numeric_limits<double>::infinity();\n        x1 = -std::numeric_limits<double>::infinity();\n        y1 = -std::numeric_limits<double>::infinity();\n        xm = std::numeric_limits<double>::infinity();\n        ym = std::numeric_limits<double>::infinity();\n        agg::trans_affine trans;\n\n        if (transforms.size() <= 1 && paths.size() == 1)\n        {\n            PathIterator path(paths[0]);\n            if (Ntransforms)\n            {\n                trans = transforms[0];\n            }\n            else\n            {\n                trans = master_transform;\n            }\n\n            double bx0 = std::numeric_limits<double>::infinity();\n            double by0 = std::numeric_limits<double>::infinity();\n            double bx1 = -std::numeric_limits<double>::infinity();\n            double by1 = -std::numeric_limits<double>::infinity();\n            double bxm = std::numeric_limits<double>::infinity();\n            double bym = std::numeric_limits<double>::infinity();\n\n            ::get_path_extents(path, trans, &bx0, &by0, &bx1, &by1, &bxm, &bym);\n\n            for (i = 0; i < Noffsets; ++i)\n            {\n                double xo = *(double*)PyArray_GETPTR2(offsets, i % Noffsets, 0);\n                double yo = *(double*)PyArray_GETPTR2(offsets, i % Noffsets, 1);\n                offset_trans.transform(&xo, &yo);\n                update_limits(xo + bx0, yo + by0, &x0, &y0, &x1, &y1, &xm, &ym);\n                update_limits(xo + bx1, yo + by1, &x0, &y0, &x1, &y1, &xm, &ym);\n            }\n        } else {\n            for (i = 0; i < N; ++i)\n            {\n                PathIterator path(paths[i % Npaths]);\n                if (Ntransforms)\n                {\n                    trans = transforms[i % Ntransforms];\n                }\n                else\n                {\n                    trans = master_transform;\n                }\n\n                if (Noffsets)\n                {\n                    double xo = *(double*)PyArray_GETPTR2(offsets, i % Noffsets, 0);\n                    double yo = *(double*)PyArray_GETPTR2(offsets, i % Noffsets, 1);\n                    offset_trans.transform(&xo, &yo);\n                    trans *= agg::trans_affine_translation(xo, yo);\n                }\n\n                ::get_path_extents(path, trans, &x0, &y0, &x1, &y1, &xm, &ym);\n            }\n        }\n    }\n    catch (...)\n    {\n        Py_XDECREF(offsets);\n        throw;\n    }\n\n    Py_XDECREF(offsets);\n\n    Py::Tuple result(4);\n    result[0] = Py::Float(x0);\n    result[1] = Py::Float(y0);\n    result[2] = Py::Float(x1);\n    result[3] = Py::Float(y1);\n    return result;\n}\n\nPy::Object\n_path_module::point_in_path_collection(const Py::Tuple& args)\n{\n    args.verify_length(10);\n\n    //segments, trans, clipbox, colors, linewidths, antialiaseds\n    double                  x                = Py::Float(args[0]);\n    double                  y                = Py::Float(args[1]);\n    double                  radius           = Py::Float(args[2]);\n    agg::trans_affine       master_transform = py_to_agg_transformation_matrix(args[3].ptr());\n    Py::SeqBase<Py::Object> paths            = args[4];\n    Py::SeqBase<Py::Object> transforms_obj   = args[5];\n    Py::SeqBase<Py::Object> offsets_obj      = args[6];\n    agg::trans_affine       offset_trans     = py_to_agg_transformation_matrix(args[7].ptr());\n    bool                    filled           = Py::Boolean(args[8]);\n    std::string             offset_position  = Py::String(args[9]).encode(\"utf-8\");\n\n    bool data_offsets = (offset_position == \"data\");\n\n    PyArrayObject* offsets = (PyArrayObject*)PyArray_FromObject(\n        offsets_obj.ptr(), NPY_DOUBLE, 0, 2);\n    if (!offsets ||\n            (PyArray_NDIM(offsets) == 2 && PyArray_DIM(offsets, 1) != 2) ||\n            (PyArray_NDIM(offsets) == 1 && PyArray_DIM(offsets, 0) != 0))\n    {\n        Py_XDECREF(offsets);\n        throw Py::ValueError(\"Offsets array must be Nx2\");\n    }\n\n    Py::List result;\n\n    size_t Npaths      = paths.length();\n\n    if (Npaths == 0) {\n        return result;\n    }\n\n    size_t Noffsets    = PyArray_DIM(offsets, 0);\n\n    size_t N           = std::max(Npaths, Noffsets);\n    size_t Ntransforms = std::min(transforms_obj.length(), N);\n    size_t i;\n\n    // Convert all of the transforms up front\n    typedef std::vector<agg::trans_affine> transforms_t;\n    transforms_t transforms;\n    transforms.reserve(Ntransforms);\n    for (i = 0; i < Ntransforms; ++i)\n    {\n        agg::trans_affine trans = py_to_agg_transformation_matrix\n                                  (transforms_obj[i].ptr(), false);\n        trans *= master_transform;\n        transforms.push_back(trans);\n    }\n\n    agg::trans_affine trans;\n\n    for (i = 0; i < N; ++i)\n    {\n        PathIterator path(paths[i % Npaths]);\n\n        if (Ntransforms)\n        {\n            trans = transforms[i % Ntransforms];\n        }\n        else\n        {\n            trans = master_transform;\n        }\n\n        if (Noffsets)\n        {\n            double xo = *(double*)PyArray_GETPTR2(offsets, i % Noffsets, 0);\n            double yo = *(double*)PyArray_GETPTR2(offsets, i % Noffsets, 1);\n            offset_trans.transform(&xo, &yo);\n            if (data_offsets) {\n                trans = agg::trans_affine_translation(xo, yo) * trans;\n            } else {\n                trans *= agg::trans_affine_translation(xo, yo);\n            }\n        }\n\n        if (filled)\n        {\n            if (::point_in_path(x, y, radius, path, trans))\n                result.append(Py::Int((int)i));\n        }\n        else\n        {\n            if (::point_on_path(x, y, radius, path, trans))\n                result.append(Py::Int((int)i));\n        }\n    }\n\n    return result;\n}\n\nbool\npath_in_path(PathIterator& a, const agg::trans_affine& atrans,\n             PathIterator& b, const agg::trans_affine& btrans)\n{\n    typedef agg::conv_transform<PathIterator> transformed_path_t;\n    typedef PathNanRemover<transformed_path_t> no_nans_t;\n    typedef agg::conv_curve<no_nans_t> curve_t;\n\n    if (a.total_vertices() < 3)\n        return false;\n\n    transformed_path_t b_path_trans(b, btrans);\n    no_nans_t b_no_nans(b_path_trans, true, b.has_curves());\n    curve_t b_curved(b_no_nans);\n\n    double x, y;\n    b_curved.rewind(0);\n    while (b_curved.vertex(&x, &y) != agg::path_cmd_stop)\n    {\n        if (!::point_in_path(x, y, 0.0, a, atrans))\n            return false;\n    }\n\n    return true;\n}\n\nPy::Object\n_path_module::path_in_path(const Py::Tuple& args)\n{\n    args.verify_length(4);\n\n    PathIterator a(args[0]);\n    agg::trans_affine atrans = py_to_agg_transformation_matrix(\n        args[1].ptr(), false);\n    PathIterator b(args[2]);\n    agg::trans_affine btrans = py_to_agg_transformation_matrix(\n        args[3].ptr(), false);\n\n    return Py::Int(::path_in_path(a, atrans, b, btrans));\n}\n\n/** The clip_path_to_rect code here is a clean-room implementation of\n    the Sutherland-Hodgman clipping algorithm described here:\n\n  http://en.wikipedia.org/wiki/Sutherland-Hodgman_clipping_algorithm\n*/\n\ntypedef std::vector<XY> Polygon;\n\nnamespace clip_to_rect_filters\n{\n    /* There are four different passes needed to create/remove\n       vertices (one for each side of the rectangle).  The differences\n       between those passes are encapsulated in these functor classes.\n    */\n    struct bisectx\n    {\n        double m_x;\n\n        bisectx(double x) : m_x(x) {}\n\n        inline void\n        bisect(double sx, double sy, double px, double py, double* bx,\n               double* by) const\n        {\n            *bx = m_x;\n            double dx = px - sx;\n            double dy = py - sy;\n            *by = sy + dy * ((m_x - sx) / dx);\n        }\n    };\n\n    struct xlt : public bisectx\n    {\n        xlt(double x) : bisectx(x) {}\n\n        inline bool\n        is_inside(double x, double y) const\n        {\n            return x <= m_x;\n        }\n    };\n\n    struct xgt : public bisectx\n    {\n        xgt(double x) : bisectx(x) {}\n\n        inline bool\n        is_inside(double x, double y) const\n        {\n            return x >= m_x;\n        }\n    };\n\n    struct bisecty\n    {\n        double m_y;\n\n        bisecty(double y) : m_y(y) {}\n\n        inline void\n        bisect(double sx, double sy, double px, double py, double* bx,\n               double* by) const\n        {\n            *by = m_y;\n            double dx = px - sx;\n            double dy = py - sy;\n            *bx = sx + dx * ((m_y - sy) / dy);\n        }\n    };\n\n    struct ylt : public bisecty\n    {\n        ylt(double y) : bisecty(y) {}\n\n        inline bool\n        is_inside(double x, double y) const\n        {\n            return y <= m_y;\n        }\n    };\n\n    struct ygt : public bisecty\n    {\n        ygt(double y) : bisecty(y) {}\n\n        inline bool\n        is_inside(double x, double y) const\n        {\n            return y >= m_y;\n        }\n    };\n}\n\ntemplate<class Filter>\ninline void\nclip_to_rect_one_step(const Polygon& polygon, Polygon& result, const Filter& filter)\n{\n    double sx, sy, px, py, bx, by;\n    bool sinside, pinside;\n    result.clear();\n\n    if (polygon.size() == 0)\n    {\n        return;\n    }\n\n    sx = polygon.back().x;\n    sy = polygon.back().y;\n    for (Polygon::const_iterator i = polygon.begin(); i != polygon.end(); ++i)\n    {\n        px = i->x;\n        py = i->y;\n\n        sinside = filter.is_inside(sx, sy);\n        pinside = filter.is_inside(px, py);\n\n        if (sinside ^ pinside)\n        {\n            filter.bisect(sx, sy, px, py, &bx, &by);\n            result.push_back(XY(bx, by));\n        }\n\n        if (pinside)\n        {\n            result.push_back(XY(px, py));\n        }\n\n        sx = px;\n        sy = py;\n    }\n}\n\ntemplate<class Path>\nvoid\nclip_to_rect(Path& path,\n             double x0, double y0, double x1, double y1,\n             bool inside, std::vector<Polygon>& results)\n{\n    double xmin, ymin, xmax, ymax;\n    if (x0 < x1)\n    {\n        xmin = x0;\n        xmax = x1;\n    }\n    else\n    {\n        xmin = x1;\n        xmax = x0;\n    }\n\n    if (y0 < y1)\n    {\n        ymin = y0;\n        ymax = y1;\n    }\n    else\n    {\n        ymin = y1;\n        ymax = y0;\n    }\n\n    if (!inside)\n    {\n        std::swap(xmin, xmax);\n        std::swap(ymin, ymax);\n    }\n\n    Polygon polygon1, polygon2;\n    double x = 0, y = 0;\n    unsigned code = 0;\n    path.rewind(0);\n\n    do\n    {\n        // Grab the next subpath and store it in polygon1\n        polygon1.clear();\n        do\n        {\n            if (code == agg::path_cmd_move_to)\n            {\n                polygon1.push_back(XY(x, y));\n            }\n\n            code = path.vertex(&x, &y);\n\n            if (code == agg::path_cmd_stop)\n            {\n                break;\n            }\n\n            if (code != agg::path_cmd_move_to)\n            {\n                polygon1.push_back(XY(x, y));\n            }\n        }\n        while ((code & agg::path_cmd_end_poly) != agg::path_cmd_end_poly);\n\n        // The result of each step is fed into the next (note the\n        // swapping of polygon1 and polygon2 at each step).\n        clip_to_rect_one_step(polygon1, polygon2, clip_to_rect_filters::xlt(xmax));\n        clip_to_rect_one_step(polygon2, polygon1, clip_to_rect_filters::xgt(xmin));\n        clip_to_rect_one_step(polygon1, polygon2, clip_to_rect_filters::ylt(ymax));\n        clip_to_rect_one_step(polygon2, polygon1, clip_to_rect_filters::ygt(ymin));\n\n        // Empty polygons aren't very useful, so skip them\n        if (polygon1.size())\n        {\n            results.push_back(polygon1);\n        }\n    }\n    while (code != agg::path_cmd_stop);\n}\n\nPy::Object\n_path_module::clip_path_to_rect(const Py::Tuple &args)\n{\n    args.verify_length(3);\n\n    PathIterator path(args[0]);\n    Py::Object bbox_obj = args[1];\n    bool inside = Py::Boolean(args[2]);\n\n    double x0, y0, x1, y1;\n    if (!py_convert_bbox(bbox_obj.ptr(), x0, y0, x1, y1))\n    {\n        throw Py::TypeError(\"Argument 2 to clip_to_rect must be a Bbox object.\");\n    }\n\n    std::vector<Polygon> results;\n    typedef agg::conv_curve<PathIterator> curve_t;\n    curve_t curve(path);\n\n    ::clip_to_rect(curve, x0, y0, x1, y1, inside, results);\n\n    npy_intp dims[2];\n    dims[1] = 2;\n    PyObject* py_results = PyList_New(results.size());\n    if (!py_results)\n    {\n        throw Py::RuntimeError(\"Error creating results list\");\n    }\n\n    try\n    {\n        for (std::vector<Polygon>::const_iterator p = results.begin(); p != results.end(); ++p)\n        {\n            size_t size = p->size();\n            dims[0] = (npy_intp)size + 1;\n            PyArrayObject* pyarray = (PyArrayObject*)PyArray_SimpleNew(2, dims, NPY_DOUBLE);\n            if (pyarray == NULL)\n            {\n                throw Py::MemoryError(\"Could not allocate result array\");\n            }\n            double* const data = (double*)PyArray_DATA(pyarray);\n            for (size_t i = 0; i < size; ++i)\n            {\n                data[2*i]   = (*p)[i].x;\n                data[2*i+1] = (*p)[i].y;\n            }\n            data[2*size]   = (*p)[0].x;\n            data[2*size+1] = (*p)[0].y;\n\n            if (PyList_SetItem(py_results, p - results.begin(), (PyObject *)pyarray) == -1)\n            {\n                throw Py::RuntimeError(\"Error creating results list\");\n            }\n        }\n    }\n    catch (...)\n    {\n        Py_XDECREF(py_results);\n        throw;\n    }\n\n    return Py::Object(py_results, true);\n}\n\nPy::Object\n_path_module::affine_transform(const Py::Tuple& args)\n{\n    args.verify_length(2);\n\n    Py::Object vertices_obj = args[0];\n    Py::Object transform_obj = args[1];\n\n    PyArrayObject* vertices = NULL;\n    PyArrayObject* transform = NULL;\n    PyArrayObject* result = NULL;\n\n    try\n    {\n        vertices = (PyArrayObject*)PyArray_FromObject\n                   (vertices_obj.ptr(), NPY_DOUBLE, 1, 2);\n        if (!vertices ||\n            (PyArray_NDIM(vertices) == 2 && PyArray_DIM(vertices, 0) != 0 &&\n             PyArray_DIM(vertices, 1) != 2) ||\n            (PyArray_NDIM(vertices) == 1 &&\n             PyArray_DIM(vertices, 0) != 2 && PyArray_DIM(vertices, 0) != 0))\n        {\n            throw Py::ValueError(\"Invalid vertices array.\");\n        }\n\n        transform = (PyArrayObject*) PyArray_FromObject\n                    (transform_obj.ptr(), NPY_DOUBLE, 2, 2);\n        if (!transform ||\n            PyArray_DIM(transform, 0) != 3 ||\n            PyArray_DIM(transform, 1) != 3)\n        {\n            throw Py::ValueError(\"Invalid transform.\");\n        }\n\n        double a, b, c, d, e, f;\n        {\n            size_t stride0 = PyArray_STRIDE(transform, 0);\n            size_t stride1 = PyArray_STRIDE(transform, 1);\n            char* row0 = PyArray_BYTES(transform);\n            char* row1 = row0 + stride0;\n\n            a = *(double*)(row0);\n            row0 += stride1;\n            c = *(double*)(row0);\n            row0 += stride1;\n            e = *(double*)(row0);\n\n            b = *(double*)(row1);\n            row1 += stride1;\n            d = *(double*)(row1);\n            row1 += stride1;\n            f = *(double*)(row1);\n        }\n\n        result = (PyArrayObject*)PyArray_SimpleNew\n                 (PyArray_NDIM(vertices), PyArray_DIMS(vertices), NPY_DOUBLE);\n        if (result == NULL)\n        {\n            throw Py::MemoryError(\"Could not allocate memory for path\");\n        }\n        if (PyArray_NDIM(vertices) == 2)\n        {\n            size_t n = PyArray_DIM(vertices, 0);\n            char* vertex_in = PyArray_BYTES(vertices);\n            double* vertex_out = (double*)PyArray_DATA(result);\n            size_t stride0 = PyArray_STRIDE(vertices, 0);\n            size_t stride1 = PyArray_STRIDE(vertices, 1);\n            double x;\n            double y;\n            volatile double t0;\n\t    volatile double t1;\n\t    volatile double t;\n\n            for (size_t i = 0; i < n; ++i)\n            {\n                x = *(double*)(vertex_in);\n                y = *(double*)(vertex_in + stride1);\n\n\t\tt0 = a * x;\n\t\tt1 = c * y;\n                t = t0 + t1 + e;\n                *(vertex_out++) = t;\n\n\t\tt0 = b * x;\n\t\tt1 = d * y;\n                t = t0 + t1 + f;\n                *(vertex_out++) = t;\n\n                vertex_in += stride0;\n            }\n        }\n        else if (PyArray_DIM(vertices, 0) != 0)\n        {\n            char* vertex_in = PyArray_BYTES(vertices);\n            double* vertex_out = (double*)PyArray_DATA(result);\n            size_t stride0 = PyArray_STRIDE(vertices, 0);\n            double x;\n            double y;\n            x = *(double*)(vertex_in);\n            y = *(double*)(vertex_in + stride0);\n            *vertex_out++ = a * x + c * y + e;\n            *vertex_out++ = b * x + d * y + f;\n        }\n    }\n    catch (...)\n    {\n        Py_XDECREF(vertices);\n        Py_XDECREF(transform);\n        Py_XDECREF(result);\n        throw;\n    }\n\n    Py_XDECREF(vertices);\n    Py_XDECREF(transform);\n\n    return Py::Object((PyObject*)result, true);\n}\n\nPy::Object\n_path_module::count_bboxes_overlapping_bbox(const Py::Tuple& args)\n{\n    args.verify_length(2);\n\n    Py::Object              bbox   = args[0];\n    Py::SeqBase<Py::Object> bboxes = args[1];\n\n    double ax0, ay0, ax1, ay1;\n    double bx0, by0, bx1, by1;\n    long count = 0;\n\n    if (py_convert_bbox(bbox.ptr(), ax0, ay0, ax1, ay1))\n    {\n        if (ax1 < ax0)\n        {\n            std::swap(ax0, ax1);\n        }\n        if (ay1 < ay0)\n        {\n            std::swap(ay0, ay1);\n        }\n\n        size_t num_bboxes = bboxes.size();\n        for (size_t i = 0; i < num_bboxes; ++i)\n        {\n            Py::Object bbox_b = bboxes[i];\n            if (py_convert_bbox(bbox_b.ptr(), bx0, by0, bx1, by1))\n            {\n                if (bx1 < bx0)\n                {\n                    std::swap(bx0, bx1);\n                }\n                if (by1 < by0)\n                {\n                    std::swap(by0, by1);\n                }\n                if (!((bx1 <= ax0) ||\n                      (by1 <= ay0) ||\n                      (bx0 >= ax1) ||\n                      (by0 >= ay1)))\n                {\n                    ++count;\n                }\n            }\n            else\n            {\n                throw Py::ValueError(\"Non-bbox object in bboxes list\");\n            }\n        }\n    }\n    else\n    {\n        throw Py::ValueError(\"First argument to count_bboxes_overlapping_bbox must be a Bbox object.\");\n    }\n\n    return Py::Int(count);\n}\n\ninline bool\nsegments_intersect(const double& x1, const double& y1,\n                   const double& x2, const double& y2,\n                   const double& x3, const double& y3,\n                   const double& x4, const double& y4)\n{\n    double den = ((y4 - y3) * (x2 - x1)) - ((x4 - x3) * (y2 - y1));\n    if (den == 0.0)\n    {\n        return false;\n    }\n\n    double n1 = ((x4 - x3) * (y1 - y3)) - ((y4 - y3) * (x1 - x3));\n    double n2 = ((x2 - x1) * (y1 - y3)) - ((y2 - y1) * (x1 - x3));\n\n    double u1 = n1 / den;\n    double u2 = n2 / den;\n\n    return (u1 >= 0.0 && u1 <= 1.0 &&\n            u2 >= 0.0 && u2 <= 1.0);\n}\n\nbool\npath_intersects_path(PathIterator& p1, PathIterator& p2)\n{\n    typedef PathNanRemover<PathIterator> no_nans_t;\n    typedef agg::conv_curve<no_nans_t> curve_t;\n\n    if (p1.total_vertices() < 2 || p2.total_vertices() < 2)\n    {\n        return false;\n    }\n\n    no_nans_t n1(p1, true, p1.has_curves());\n    no_nans_t n2(p2, true, p2.has_curves());\n\n    curve_t c1(n1);\n    curve_t c2(n2);\n\n    double x11, y11, x12, y12;\n    double x21, y21, x22, y22;\n\n    c1.vertex(&x11, &y11);\n    while (c1.vertex(&x12, &y12) != agg::path_cmd_stop)\n    {\n        c2.rewind(0);\n        c2.vertex(&x21, &y21);\n        while (c2.vertex(&x22, &y22) != agg::path_cmd_stop)\n        {\n            if (segments_intersect(x11, y11, x12, y12, x21, y21, x22, y22))\n            {\n                return true;\n            }\n            x21 = x22;\n            y21 = y22;\n        }\n        x11 = x12;\n        y11 = y12;\n    }\n\n    return false;\n}\n\nPy::Object\n_path_module::path_intersects_path(const Py::Tuple& args)\n{\n    args.verify_length(2, 3);\n\n    PathIterator p1(args[0]);\n    PathIterator p2(args[1]);\n    bool filled = false;\n\n    if (args.size() == 3)\n    {\n        filled = args[2].isTrue();\n    }\n\n    if (!filled)\n    {\n        return Py::Int(::path_intersects_path(p1, p2));\n    }\n    else\n    {\n        return Py::Int(::path_intersects_path(p1, p2)\n                       || ::path_in_path(p1, agg::trans_affine(), p2, agg::trans_affine())\n                       || ::path_in_path(p2, agg::trans_affine(), p1, agg::trans_affine()));\n    }\n}\n\nvoid\n_add_polygon(Py::List& polygons, const std::vector<double>& polygon)\n{\n    if (polygon.size() == 0)\n    {\n        return;\n    }\n    npy_intp polygon_dims[] = { static_cast<npy_intp>(polygon.size() / 2), 2, 0 };\n    PyArrayObject* polygon_array = NULL;\n    polygon_array = (PyArrayObject*)PyArray_SimpleNew\n                    (2, polygon_dims, NPY_DOUBLE);\n    if (!polygon_array)\n    {\n        throw Py::MemoryError(\"Error creating polygon array\");\n    }\n    double* polygon_data = (double*)PyArray_DATA(polygon_array);\n    memcpy(polygon_data, &polygon[0], polygon.size() * sizeof(double));\n    polygons.append(Py::Object((PyObject*)polygon_array, true));\n}\n\nPy::Object\n_path_module::convert_path_to_polygons(const Py::Tuple& args)\n{\n    typedef agg::conv_transform<PathIterator>  transformed_path_t;\n    typedef PathNanRemover<transformed_path_t> nan_removal_t;\n    typedef PathClipper<nan_removal_t>         clipped_t;\n    typedef PathSimplifier<clipped_t>          simplify_t;\n    typedef agg::conv_curve<simplify_t>        curve_t;\n\n    typedef std::vector<double> vertices_t;\n\n    args.verify_length(4);\n\n    PathIterator path(args[0]);\n    agg::trans_affine trans = py_to_agg_transformation_matrix(args[1].ptr(), false);\n    double width = Py::Float(args[2]);\n    double height = Py::Float(args[3]);\n\n    bool do_clip = width != 0.0 && height != 0.0;\n\n    bool simplify = path.should_simplify();\n\n    transformed_path_t tpath(path, trans);\n    nan_removal_t      nan_removed(tpath, true, path.has_curves());\n    clipped_t          clipped(nan_removed, do_clip, width, height);\n    simplify_t         simplified(clipped, simplify, path.simplify_threshold());\n    curve_t            curve(simplified);\n\n    Py::List polygons;\n    vertices_t polygon;\n    double x, y;\n    unsigned code;\n\n    polygon.reserve(path.total_vertices() * 2);\n\n    while ((code = curve.vertex(&x, &y)) != agg::path_cmd_stop)\n    {\n        if ((code & agg::path_cmd_end_poly) == agg::path_cmd_end_poly)\n        {\n            if (polygon.size() >= 2)\n            {\n                polygon.push_back(polygon[0]);\n                polygon.push_back(polygon[1]);\n                _add_polygon(polygons, polygon);\n            }\n            polygon.clear();\n        }\n        else\n        {\n            if (code == agg::path_cmd_move_to)\n            {\n                _add_polygon(polygons, polygon);\n                polygon.clear();\n            }\n            polygon.push_back(x);\n            polygon.push_back(y);\n        }\n    }\n\n    _add_polygon(polygons, polygon);\n\n    return polygons;\n}\n\ntemplate<class VertexSource>\nvoid\n__cleanup_path(VertexSource& source,\n               std::vector<double>& vertices,\n               std::vector<npy_uint8>& codes)\n{\n    unsigned code;\n    double x, y;\n    do\n    {\n        code = source.vertex(&x, &y);\n        vertices.push_back(x);\n        vertices.push_back(y);\n        codes.push_back((npy_uint8)code);\n    }\n    while (code != agg::path_cmd_stop);\n}\n\nvoid\n_cleanup_path(PathIterator& path, const agg::trans_affine& trans,\n              bool remove_nans, bool do_clip,\n              const agg::rect_base<double>& rect,\n              e_snap_mode snap_mode, double stroke_width,\n              bool do_simplify, bool return_curves,\n              double sketch_scale, double sketch_length,\n              double sketch_randomness,\n              std::vector<double>& vertices,\n              std::vector<npy_uint8>& codes)\n{\n    typedef agg::conv_transform<PathIterator>  transformed_path_t;\n    typedef PathNanRemover<transformed_path_t> nan_removal_t;\n    typedef PathClipper<nan_removal_t>         clipped_t;\n    typedef PathSnapper<clipped_t>             snapped_t;\n    typedef PathSimplifier<snapped_t>          simplify_t;\n    typedef agg::conv_curve<simplify_t>        curve_t;\n    typedef Sketch<curve_t>                    sketch_t;\n\n    transformed_path_t tpath(path, trans);\n    nan_removal_t      nan_removed(tpath, remove_nans, path.has_curves());\n    clipped_t          clipped(nan_removed, do_clip, rect);\n    snapped_t          snapped(clipped, snap_mode, path.total_vertices(), stroke_width);\n    simplify_t         simplified(snapped, do_simplify, path.simplify_threshold());\n\n    vertices.reserve(path.total_vertices() * 2);\n    codes.reserve(path.total_vertices());\n\n    if (return_curves && sketch_scale == 0.0)\n    {\n        __cleanup_path(simplified, vertices, codes);\n    }\n    else\n    {\n        curve_t curve(simplified);\n        sketch_t sketch(curve, sketch_scale, sketch_length, sketch_randomness);\n        __cleanup_path(sketch, vertices, codes);\n    }\n}\n\nPy::Object\n_path_module::cleanup_path(const Py::Tuple& args)\n{\n    args.verify_length(9);\n\n    PathIterator path(args[0]);\n    agg::trans_affine trans = py_to_agg_transformation_matrix(args[1].ptr(), false);\n    bool remove_nans = args[2].isTrue();\n\n    Py::Object clip_obj = args[3];\n    bool do_clip;\n    agg::rect_base<double> clip_rect;\n    if (clip_obj.isNone())\n    {\n        do_clip = false;\n    }\n    else\n    {\n        double x1, y1, x2, y2;\n        Py::Tuple clip_tuple(clip_obj);\n        x1 = Py::Float(clip_tuple[0]);\n        y1 = Py::Float(clip_tuple[1]);\n        x2 = Py::Float(clip_tuple[2]);\n        y2 = Py::Float(clip_tuple[3]);\n        clip_rect.init(x1, y1, x2, y2);\n        do_clip = true;\n    }\n\n    Py::Object snap_obj = args[4];\n    e_snap_mode snap_mode;\n    if (snap_obj.isNone())\n    {\n        snap_mode = SNAP_AUTO;\n    }\n    else if (snap_obj.isTrue())\n    {\n        snap_mode = SNAP_TRUE;\n    }\n    else\n    {\n        snap_mode = SNAP_FALSE;\n    }\n\n    double stroke_width = Py::Float(args[5]);\n\n    bool simplify;\n    Py::Object simplify_obj = args[6];\n    if (simplify_obj.isNone())\n    {\n        simplify = path.should_simplify();\n    }\n    else\n    {\n        simplify = simplify_obj.isTrue();\n    }\n\n    bool return_curves = args[7].isTrue();\n\n    Py::Object sketch_params = args[8];\n    double sketch_scale = 0.0;\n    double sketch_length = 0.0;\n    double sketch_randomness = 0.0;\n    if (sketch_params.ptr() != Py_None) {\n        Py::Tuple sketch(sketch_params);\n        sketch_scale = Py::Float(sketch[0]);\n        sketch_length = Py::Float(sketch[1]);\n        sketch_randomness = Py::Float(sketch[2]);\n    }\n\n    std::vector<double> vertices;\n    std::vector<npy_uint8> codes;\n\n    _cleanup_path(path, trans, remove_nans, do_clip, clip_rect, snap_mode,\n                  stroke_width, simplify, return_curves, sketch_scale,\n                  sketch_length, sketch_randomness, vertices, codes);\n\n    npy_intp length = codes.size();\n    npy_intp dims[] = { length, 2, 0 };\n\n    PyArrayObject* vertices_obj = NULL;\n    PyArrayObject* codes_obj = NULL;\n    Py::Tuple result(2);\n    try\n    {\n        vertices_obj = (PyArrayObject*)PyArray_SimpleNew\n                       (2, dims, NPY_DOUBLE);\n        if (vertices_obj == NULL)\n        {\n            throw Py::MemoryError(\"Could not allocate result array\");\n        }\n\n        codes_obj = (PyArrayObject*)PyArray_SimpleNew\n                    (1, dims, NPY_UINT8);\n        if (codes_obj == NULL)\n        {\n            throw Py::MemoryError(\"Could not allocate result array\");\n        }\n\n        memcpy(PyArray_DATA(vertices_obj), &vertices[0], sizeof(double) * 2 * length);\n        memcpy(PyArray_DATA(codes_obj), &codes[0], sizeof(npy_uint8) * length);\n\n        result[0] = Py::Object((PyObject*)vertices_obj, true);\n        result[1] = Py::Object((PyObject*)codes_obj, true);\n    }\n    catch (...)\n    {\n        Py_XDECREF(vertices_obj);\n        Py_XDECREF(codes_obj);\n        throw;\n    }\n\n    return result;\n}\n\nPy::Object\n_path_module::convert_to_svg(const Py::Tuple& args)\n{\n    args.verify_length(5);\n\n    PathIterator path(args[0]);\n    agg::trans_affine trans = py_to_agg_transformation_matrix(args[1].ptr(), false);\n\n    Py::Object clip_obj = args[2];\n    bool do_clip;\n    agg::rect_base<double> clip_rect(0, 0, 0, 0);\n    if (clip_obj.isNone() || !clip_obj.isTrue())\n    {\n        do_clip = false;\n    }\n    else\n    {\n        double x1, y1, x2, y2;\n        Py::Tuple clip_tuple(clip_obj);\n        x1 = Py::Float(clip_tuple[0]);\n        y1 = Py::Float(clip_tuple[1]);\n        x2 = Py::Float(clip_tuple[2]);\n        y2 = Py::Float(clip_tuple[3]);\n        clip_rect.init(x1, y1, x2, y2);\n        do_clip = true;\n    }\n\n    bool simplify;\n    Py::Object simplify_obj = args[3];\n    if (simplify_obj.isNone())\n    {\n        simplify = path.should_simplify();\n    }\n    else\n    {\n        simplify = simplify_obj.isTrue();\n    }\n\n    int precision = Py::Int(args[4]);\n\n    #if PY_VERSION_HEX < 0x02070000\n    char format[64];\n    snprintf(format, 64, \"%s.%dg\", \"%\", precision);\n    #endif\n\n    typedef agg::conv_transform<PathIterator>  transformed_path_t;\n    typedef PathNanRemover<transformed_path_t> nan_removal_t;\n    typedef PathClipper<nan_removal_t>         clipped_t;\n    typedef PathSimplifier<clipped_t>          simplify_t;\n\n    transformed_path_t tpath(path, trans);\n    nan_removal_t      nan_removed(tpath, true, path.has_curves());\n    clipped_t          clipped(nan_removed, do_clip, clip_rect);\n    simplify_t         simplified(clipped, simplify, path.simplify_threshold());\n\n    size_t buffersize = path.total_vertices() * (precision + 5) * 4;\n    char* buffer = (char *)malloc(buffersize);\n    char* p = buffer;\n\n    const char codes[] = {'M', 'L', 'Q', 'C'};\n    const int  waits[] = {  1,   1,   2,   3};\n\n    int wait = 0;\n    unsigned code;\n    double x = 0, y = 0;\n    while ((code = simplified.vertex(&x, &y)) != agg::path_cmd_stop)\n    {\n        if (wait == 0)\n        {\n            *p++ = '\\n';\n\n            if (code == 0x4f)\n            {\n                *p++ = 'z';\n                *p++ = '\\n';\n                continue;\n            }\n\n            *p++ = codes[code-1];\n            wait = waits[code-1];\n        }\n        else\n        {\n            *p++ = ' ';\n        }\n\n        #if PY_VERSION_HEX >= 0x02070000\n        char* str;\n        str = PyOS_double_to_string(x, 'g', precision, 0, NULL);\n        p += snprintf(p, buffersize - (p - buffer), \"%s\", str);\n        PyMem_Free(str);\n        *p++ = ' ';\n        str = PyOS_double_to_string(y, 'g', precision, 0, NULL);\n        p += snprintf(p, buffersize - (p - buffer), \"%s\", str);\n        PyMem_Free(str);\n        #else\n        char str[64];\n        PyOS_ascii_formatd(str, 64, format, x);\n        p += snprintf(p, buffersize - (p - buffer), \"%s\", str);\n        *p++ = ' ';\n        PyOS_ascii_formatd(str, 64, format, y);\n        p += snprintf(p, buffersize - (p - buffer), \"%s\", str);\n        #endif\n\n        --wait;\n    }\n\n    #if PY3K\n    PyObject* result = PyUnicode_FromStringAndSize(buffer, p - buffer);\n    #else\n    PyObject* result = PyString_FromStringAndSize(buffer, p - buffer);\n    #endif\n    free(buffer);\n\n    return Py::Object(result, true);\n}\n\nPyMODINIT_FUNC\n#if PY3K\nPyInit__path(void)\n#else\ninit_path(void)\n#endif\n{\n    static _path_module* _path = NULL;\n    _path = new _path_module;\n\n    import_array();\n\n    #if PY3K\n    return _path->module().ptr();\n    #endif\n}\n", "patch": "@@ -1,1813 +0,0 @@\n-/* -*- mode: c++; c-basic-offset: 4 -*- */\n-\n-#include \"agg_py_path_iterator.h\"\n-#include \"agg_py_transforms.h\"\n-#include \"path_converters.h\"\n-\n-#include <limits>\n-#include <math.h>\n-\n-#include \"CXX/Extensions.hxx\"\n-\n-#include \"agg_conv_contour.h\"\n-#include \"agg_conv_curve.h\"\n-#include \"agg_conv_stroke.h\"\n-#include \"agg_conv_transform.h\"\n-#include \"agg_path_storage.h\"\n-#include \"agg_trans_affine.h\"\n-\n-struct XY\n-{\n-    double x;\n-    double y;\n-\n-    XY(double x_, double y_) : x(x_), y(y_) {}\n-};\n-\n-// the extension module\n-class _path_module : public Py::ExtensionModule<_path_module>\n-{\n-public:\n-    _path_module()\n-            : Py::ExtensionModule<_path_module>(\"_path\")\n-    {\n-        add_varargs_method(\"point_in_path\", &_path_module::point_in_path,\n-                           \"point_in_path(x, y, path, trans)\");\n-        add_varargs_method(\"points_in_path\", &_path_module::points_in_path,\n-                           \"points_in_path(points, path, trans)\");\n-        add_varargs_method(\"point_on_path\", &_path_module::point_on_path,\n-                           \"point_on_path(x, y, r, path, trans)\");\n-        add_varargs_method(\"get_path_extents\", &_path_module::get_path_extents,\n-                           \"get_path_extents(path, trans)\");\n-        add_varargs_method(\"update_path_extents\", &_path_module::update_path_extents,\n-                           \"update_path_extents(path, trans, bbox, minpos)\");\n-        add_varargs_method(\"get_path_collection_extents\", &_path_module::get_path_collection_extents,\n-                           \"get_path_collection_extents(trans, paths, transforms, offsets, offsetTrans)\");\n-        add_varargs_method(\"point_in_path_collection\", &_path_module::point_in_path_collection,\n-                           \"point_in_path_collection(x, y, r, trans, paths, transforms, offsets, offsetTrans, filled)\");\n-        add_varargs_method(\"path_in_path\", &_path_module::path_in_path,\n-                           \"path_in_path(a, atrans, b, btrans)\");\n-        add_varargs_method(\"clip_path_to_rect\", &_path_module::clip_path_to_rect,\n-                           \"clip_path_to_rect(path, bbox, inside)\");\n-        add_varargs_method(\"affine_transform\", &_path_module::affine_transform,\n-                           \"affine_transform(vertices, transform)\");\n-        add_varargs_method(\"count_bboxes_overlapping_bbox\", &_path_module::count_bboxes_overlapping_bbox,\n-                           \"count_bboxes_overlapping_bbox(bbox, bboxes)\");\n-        add_varargs_method(\"path_intersects_path\", &_path_module::path_intersects_path,\n-                           \"path_intersects_path(p1, p2)\");\n-        add_varargs_method(\"convert_path_to_polygons\", &_path_module::convert_path_to_polygons,\n-                           \"convert_path_to_polygons(path, trans, width, height)\");\n-        add_varargs_method(\"cleanup_path\", &_path_module::cleanup_path,\n-                           \"cleanup_path(path, trans, remove_nans, clip, snap, simplify, curves, sketch_params)\");\n-        add_varargs_method(\"convert_to_svg\", &_path_module::convert_to_svg,\n-                           \"convert_to_svg(path, trans, clip, simplify, precision)\");\n-        initialize(\"Helper functions for paths\");\n-    }\n-\n-    virtual ~_path_module() {}\n-\n-private:\n-    Py::Object point_in_path(const Py::Tuple& args);\n-    Py::Object points_in_path(const Py::Tuple& args);\n-    Py::Object point_on_path(const Py::Tuple& args);\n-    Py::Object get_path_extents(const Py::Tuple& args);\n-    Py::Object update_path_extents(const Py::Tuple& args);\n-    Py::Object get_path_collection_extents(const Py::Tuple& args);\n-    Py::Object point_in_path_collection(const Py::Tuple& args);\n-    Py::Object path_in_path(const Py::Tuple& args);\n-    Py::Object clip_path_to_rect(const Py::Tuple& args);\n-    Py::Object affine_transform(const Py::Tuple& args);\n-    Py::Object count_bboxes_overlapping_bbox(const Py::Tuple& args);\n-    Py::Object path_intersects_path(const Py::Tuple& args);\n-    Py::Object convert_path_to_polygons(const Py::Tuple& args);\n-    Py::Object cleanup_path(const Py::Tuple& args);\n-    Py::Object convert_to_svg(const Py::Tuple& args);\n-};\n-\n-//\n-// The following function was found in the Agg 2.3 examples (interactive_polygon.cpp).\n-// It has been generalized to work on (possibly curved) polylines, rather than\n-// just polygons.  The original comments have been kept intact.\n-//  -- Michael Droettboom 2007-10-02\n-//\n-//======= Crossings Multiply algorithm of InsideTest ========================\n-//\n-// By Eric Haines, 3D/Eye Inc, erich@eye.com\n-//\n-// This version is usually somewhat faster than the original published in\n-// Graphics Gems IV; by turning the division for testing the X axis crossing\n-// into a tricky multiplication test this part of the test became faster,\n-// which had the additional effect of making the test for \"both to left or\n-// both to right\" a bit slower for triangles than simply computing the\n-// intersection each time.  The main increase is in triangle testing speed,\n-// which was about 15% faster; all other polygon complexities were pretty much\n-// the same as before.  On machines where division is very expensive (not the\n-// case on the HP 9000 series on which I tested) this test should be much\n-// faster overall than the old code.  Your mileage may (in fact, will) vary,\n-// depending on the machine and the test data, but in general I believe this\n-// code is both shorter and faster.  This test was inspired by unpublished\n-// Graphics Gems submitted by Joseph Samosky and Mark Haigh-Hutchinson.\n-// Related work by Samosky is in:\n-//\n-// Samosky, Joseph, \"SectionView: A system for interactively specifying and\n-// visualizing sections through three-dimensional medical image data\",\n-// M.S. Thesis, Department of Electrical Engineering and Computer Science,\n-// Massachusetts Institute of Technology, 1993.\n-//\n-// Shoot a test ray along +X axis.  The strategy is to compare vertex Y values\n-// to the testing point's Y and quickly discard edges which are entirely to one\n-// side of the test ray.  Note that CONVEX and WINDING code can be added as\n-// for the CrossingsTest() code; it is left out here for clarity.\n-//\n-// Input 2D polygon _pgon_ with _numverts_ number of vertices and test point\n-// _point_, returns 1 if inside, 0 if outside.\n-template<class T>\n-static void\n-point_in_path_impl(const void* const points_, const size_t s0,\n-                   const size_t s1, const size_t n, T& path,\n-                   npy_bool* const inside_flag)\n-{\n-    int *yflag0;\n-    int *subpath_flag;\n-    int yflag1;\n-    double vtx0, vty0, vtx1, vty1;\n-    double tx, ty;\n-    double sx, sy;\n-    double x, y;\n-    size_t i;\n-    int all_done;\n-    const char *const points = (const char * const)points_;\n-\n-    yflag0 = (int *)malloc(n * sizeof(int));\n-    subpath_flag = (int *)malloc(n * sizeof(int));\n-\n-    path.rewind(0);\n-\n-    for (i = 0; i < n; ++i) {\n-        inside_flag[i] = 0;\n-    }\n-\n-    unsigned code = 0;\n-    do\n-    {\n-        if (code != agg::path_cmd_move_to)\n-        {\n-            code = path.vertex(&x, &y);\n-            if (code == agg::path_cmd_stop ||\n-                (code & agg::path_cmd_end_poly) == agg::path_cmd_end_poly) {\n-                continue;\n-            }\n-        }\n-\n-        sx = vtx0 = vtx1 = x;\n-        sy = vty0 = vty1 = y;\n-\n-        for (i = 0; i < n; ++i) {\n-            ty = *(double *)(points + s0 * i + s1);\n-\n-            // get test bit for above/below X axis\n-            yflag0[i] = (vty0 >= ty);\n-\n-            subpath_flag[i] = 0;\n-        }\n-\n-        do\n-        {\n-            code = path.vertex(&x, &y);\n-\n-            // The following cases denote the beginning on a new subpath\n-            if (code == agg::path_cmd_stop ||\n-                (code & agg::path_cmd_end_poly) == agg::path_cmd_end_poly)\n-            {\n-                x = sx;\n-                y = sy;\n-            }\n-            else if (code == agg::path_cmd_move_to)\n-            {\n-                break;\n-            }\n-\n-            for (i = 0; i < n; ++i) {\n-                tx = *(double *)(points + s0 * i);\n-                ty = *(double *)(points + s0 * i + s1);\n-\n-                yflag1 = (vty1 >= ty);\n-                // Check if endpoints straddle (are on opposite sides) of\n-                // X axis (i.e. the Y's differ); if so, +X ray could\n-                // intersect this edge.  The old test also checked whether\n-                // the endpoints are both to the right or to the left of\n-                // the test point.  However, given the faster intersection\n-                // point computation used below, this test was found to be\n-                // a break-even proposition for most polygons and a loser\n-                // for triangles (where 50% or more of the edges which\n-                // survive this test will cross quadrants and so have to\n-                // have the X intersection computed anyway).  I credit\n-                // Joseph Samosky with inspiring me to try dropping the\n-                // \"both left or both right\" part of my code.\n-                if (yflag0[i] != yflag1) {\n-                    // Check intersection of pgon segment with +X ray.\n-                    // Note if >= point's X; if so, the ray hits it.  The\n-                    // division operation is avoided for the \">=\" test by\n-                    // checking the sign of the first vertex wrto the test\n-                    // point; idea inspired by Joseph Samosky's and Mark\n-                    // Haigh-Hutchinson's different polygon inclusion\n-                    // tests.\n-                    if (((vty1 - ty) * (vtx0 - vtx1) >=\n-                         (vtx1 - tx) * (vty0 - vty1)) == yflag1) {\n-                        subpath_flag[i] ^= 1;\n-                    }\n-                }\n-\n-                // Move to the next pair of vertices, retaining info as\n-                // possible.\n-                yflag0[i] = yflag1;\n-            }\n-\n-            vtx0 = vtx1;\n-            vty0 = vty1;\n-\n-            vtx1 = x;\n-            vty1 = y;\n-        }\n-        while (code != agg::path_cmd_stop &&\n-               (code & agg::path_cmd_end_poly) != agg::path_cmd_end_poly);\n-\n-        all_done = 1;\n-        for (i = 0; i < n; ++i) {\n-            tx = *(double *)(points + s0 * i);\n-            ty = *(double *)(points + s0 * i + s1);\n-\n-            yflag1 = (vty1 >= ty);\n-            if (yflag0[i] != yflag1) {\n-                if (((vty1 - ty) * (vtx0 - vtx1) >=\n-                     (vtx1 - tx) * (vty0 - vty1)) == yflag1) {\n-                    subpath_flag[i] ^= 1;\n-                }\n-            }\n-            inside_flag[i] |= subpath_flag[i];\n-            if (inside_flag[i] == 0) {\n-                all_done = 0;\n-            }\n-        }\n-\n-        if (all_done) {\n-            goto exit;\n-        }\n-    }\n-    while (code != agg::path_cmd_stop);\n-\n- exit:\n-\n-    free(yflag0);\n-    free(subpath_flag);\n-}\n-\n-inline void\n-points_in_path(const void* const points, const size_t s0,\n-               const size_t s1, const size_t n,\n-               const double r, PathIterator& path,\n-               const agg::trans_affine& trans,\n-               npy_bool* result)\n-{\n-    typedef agg::conv_transform<PathIterator> transformed_path_t;\n-    typedef PathNanRemover<transformed_path_t> no_nans_t;\n-    typedef agg::conv_curve<no_nans_t> curve_t;\n-    typedef agg::conv_contour<curve_t> contour_t;\n-\n-    size_t i;\n-    for (i = 0; i < n; ++i) {\n-        result[i] = 0;\n-    }\n-\n-    if (path.total_vertices() < 3)\n-    {\n-        return;\n-    }\n-\n-    transformed_path_t trans_path(path, trans);\n-    no_nans_t no_nans_path(trans_path, true, path.has_curves());\n-    curve_t curved_path(no_nans_path);\n-    contour_t contoured_path(curved_path);\n-    contoured_path.width(r);\n-    point_in_path_impl(points, s0, s1, n, contoured_path, result);\n-}\n-\n-inline bool\n-point_in_path(const double x, const double y, const double r,\n-              PathIterator& path, const agg::trans_affine& trans)\n-{\n-    double points[2];\n-    npy_bool result;\n-\n-    points[0] = x;\n-    points[1] = y;\n-\n-    points_in_path(points, 0, sizeof(double), 1, r, path, trans, &result);\n-    return result;\n-}\n-\n-inline void\n-points_on_path(const void* const points, const size_t s0,\n-               const size_t s1, const size_t n,\n-               const double r, PathIterator& path,\n-               const agg::trans_affine& trans,\n-               npy_bool* result)\n-{\n-    typedef agg::conv_transform<PathIterator> transformed_path_t;\n-    typedef PathNanRemover<transformed_path_t> no_nans_t;\n-    typedef agg::conv_curve<no_nans_t> curve_t;\n-    typedef agg::conv_stroke<curve_t> stroke_t;\n-\n-    transformed_path_t trans_path(path, trans);\n-    no_nans_t nan_removed_path(trans_path, true, path.has_curves());\n-    curve_t curved_path(nan_removed_path);\n-    stroke_t stroked_path(curved_path);\n-    stroked_path.width(r * 2.0);\n-    point_in_path_impl(points, s0, s1, n, stroked_path, result);\n-}\n-\n-inline bool\n-point_on_path(const double x, const double y, const double r,\n-              PathIterator& path, const agg::trans_affine& trans)\n-{\n-    double points[2];\n-    npy_bool result;\n-\n-    points[0] = x;\n-    points[1] = y;\n-\n-    points_on_path(points, 0, sizeof(double), 1, r, path, trans, &result);\n-    return result;\n-}\n-\n-Py::Object\n-_path_module::point_in_path(const Py::Tuple& args)\n-{\n-    double x = Py::Float(args[0]);\n-    double y = Py::Float(args[1]);\n-    double r = Py::Float(args[2]);\n-    PathIterator path(args[3]);\n-    agg::trans_affine trans = py_to_agg_transformation_matrix(args[4].ptr(), false);\n-\n-    if (::point_in_path(x, y, r, path, trans)) {\n-        return Py::Int(1);\n-    }\n-    return Py::Int(0);\n-}\n-\n-Py::Object\n-_path_module::points_in_path(const Py::Tuple& args)\n-{\n-    args.verify_length(4);\n-\n-    npy_intp n;\n-    PyArrayObject* points_array;\n-    points_array = (PyArrayObject*)PyArray_FromObject(args[0].ptr(), NPY_DOUBLE, 2, 2);\n-    if (points_array == NULL || PyArray_DIM(points_array, 1) != 2) {\n-        throw Py::TypeError(\n-            \"Argument 0 to points_in_path must be an Nx2 numpy array\");\n-\n-    }\n-    double r = Py::Float(args[1]);\n-    PathIterator path(args[2]);\n-    agg::trans_affine trans = py_to_agg_transformation_matrix(args[3].ptr(), false);\n-\n-    n = PyArray_DIM(points_array, 0);\n-    PyObject* result = PyArray_ZEROS(1, &n, NPY_BOOL, 0);\n-    if (result == NULL) {\n-        throw Py::MemoryError(\"Could not allocate memory for result\");\n-    }\n-\n-    ::points_in_path(PyArray_DATA(points_array),\n-                     PyArray_STRIDE(points_array, 0),\n-                     PyArray_STRIDE(points_array, 1),\n-                     n, r, path, trans,\n-                     (npy_bool *)PyArray_DATA((PyArrayObject*)result));\n-    Py_DECREF(points_array);\n-\n-    return Py::Object(result, true);;\n-}\n-\n-Py::Object\n-_path_module::point_on_path(const Py::Tuple& args)\n-{\n-    double x = Py::Float(args[0]);\n-    double y = Py::Float(args[1]);\n-    double r = Py::Float(args[2]);\n-    PathIterator path(args[3]);\n-    agg::trans_affine trans = py_to_agg_transformation_matrix(args[4].ptr());\n-\n-    if (::point_on_path(x, y, r, path, trans))\n-    {\n-        return Py::Int(1);\n-    }\n-    return Py::Int(0);\n-}\n-\n-void\n-update_limits(double x, double y,\n-              double* x0, double* y0, double* x1, double* y1,\n-              double* xm, double* ym)\n-{\n-    if (x < *x0) *x0 = x;\n-    if (y < *y0) *y0 = y;\n-    if (x > *x1) *x1 = x;\n-    if (y > *y1) *y1 = y;\n-    /* xm and ym are the minimum positive values in the data, used\n-       by log scaling */\n-    if (x > 0.0 && x < *xm) *xm = x;\n-    if (y > 0.0 && y < *ym) *ym = y;\n-}\n-\n-void\n-get_path_extents(PathIterator& path, const agg::trans_affine& trans,\n-                 double* x0, double* y0, double* x1, double* y1,\n-                 double* xm, double* ym)\n-{\n-    typedef agg::conv_transform<PathIterator> transformed_path_t;\n-    typedef PathNanRemover<transformed_path_t> nan_removed_t;\n-    typedef agg::conv_curve<nan_removed_t> curve_t;\n-    double x, y;\n-    unsigned code;\n-\n-    transformed_path_t tpath(path, trans);\n-    nan_removed_t nan_removed(tpath, true, path.has_curves());\n-\n-    nan_removed.rewind(0);\n-\n-    while ((code = nan_removed.vertex(&x, &y)) != agg::path_cmd_stop)\n-    {\n-        if ((code & agg::path_cmd_end_poly) == agg::path_cmd_end_poly)\n-        {\n-            continue;\n-        }\n-        update_limits(x, y, x0, y0, x1, y1, xm, ym);\n-    }\n-}\n-\n-Py::Object\n-_path_module::get_path_extents(const Py::Tuple& args)\n-{\n-    args.verify_length(2);\n-\n-    PathIterator path(args[0]);\n-    agg::trans_affine trans = py_to_agg_transformation_matrix(args[1].ptr(), false);\n-\n-    npy_intp extent_dims[] = { 2, 2, 0 };\n-    double* extents_data = NULL;\n-    double xm, ym;\n-    PyArrayObject* extents = NULL;\n-    try\n-    {\n-        extents = (PyArrayObject*)PyArray_SimpleNew\n-                  (2, extent_dims, NPY_DOUBLE);\n-        if (extents == NULL)\n-        {\n-            throw Py::MemoryError(\"Could not allocate result array\");\n-        }\n-        extents_data = (double*)PyArray_DATA(extents);\n-\n-        extents_data[0] = std::numeric_limits<double>::infinity();\n-        extents_data[1] = std::numeric_limits<double>::infinity();\n-        extents_data[2] = -std::numeric_limits<double>::infinity();\n-        extents_data[3] = -std::numeric_limits<double>::infinity();\n-        /* xm and ym are the minimum positive values in the data, used\n-           by log scaling */\n-        xm = std::numeric_limits<double>::infinity();\n-        ym = std::numeric_limits<double>::infinity();\n-\n-        ::get_path_extents(path, trans, &extents_data[0], &extents_data[1],\n-                           &extents_data[2], &extents_data[3], &xm, &ym);\n-    }\n-    catch (...)\n-    {\n-        Py_XDECREF(extents);\n-        throw;\n-    }\n-\n-    return Py::Object((PyObject*)extents, true);\n-}\n-\n-Py::Object\n-_path_module::update_path_extents(const Py::Tuple& args)\n-{\n-    args.verify_length(5);\n-\n-    double x0, y0, x1, y1;\n-    PathIterator path(args[0]);\n-    agg::trans_affine trans = py_to_agg_transformation_matrix(\n-        args[1].ptr(), false);\n-\n-    if (!py_convert_bbox(args[2].ptr(), x0, y0, x1, y1))\n-    {\n-        throw Py::ValueError(\n-            \"Must pass Bbox object as arg 3 of update_path_extents\");\n-    }\n-    Py::Object minpos_obj = args[3];\n-    bool ignore = Py::Boolean(args[4]);\n-\n-    double xm, ym;\n-    PyArrayObject* input_minpos = NULL;\n-    try\n-    {\n-        input_minpos = (PyArrayObject*)PyArray_FromObject(\n-            minpos_obj.ptr(), NPY_DOUBLE, 1, 1);\n-        if (!input_minpos || PyArray_DIM(input_minpos, 0) != 2)\n-        {\n-            throw Py::TypeError(\n-                \"Argument 4 to update_path_extents must be a length-2 numpy array.\");\n-        }\n-        xm = *(double*)PyArray_GETPTR1(input_minpos, 0);\n-        ym = *(double*)PyArray_GETPTR1(input_minpos, 1);\n-    }\n-    catch (...)\n-    {\n-        Py_XDECREF(input_minpos);\n-        throw;\n-    }\n-    Py_XDECREF(input_minpos);\n-\n-    npy_intp extent_dims[] = { 2, 2, 0 };\n-    double* extents_data = NULL;\n-    npy_intp minpos_dims[] = { 2, 0 };\n-    double* minpos_data = NULL;\n-    PyArrayObject* extents = NULL;\n-    PyArrayObject* minpos = NULL;\n-    bool changed = false;\n-\n-    try\n-    {\n-        extents = (PyArrayObject*)PyArray_SimpleNew\n-                  (2, extent_dims, NPY_DOUBLE);\n-        if (extents == NULL)\n-        {\n-            throw Py::MemoryError(\"Could not allocate result array\");\n-        }\n-        minpos = (PyArrayObject*)PyArray_SimpleNew\n-                 (1, minpos_dims, NPY_DOUBLE);\n-        if (minpos == NULL)\n-        {\n-            throw Py::MemoryError(\"Could not allocate result array\");\n-        }\n-\n-        extents_data = (double*)PyArray_DATA(extents);\n-        minpos_data = (double*)PyArray_DATA(minpos);\n-\n-        if (ignore)\n-        {\n-            extents_data[0] = std::numeric_limits<double>::infinity();\n-            extents_data[1] = std::numeric_limits<double>::infinity();\n-            extents_data[2] = -std::numeric_limits<double>::infinity();\n-            extents_data[3] = -std::numeric_limits<double>::infinity();\n-            minpos_data[0] = std::numeric_limits<double>::infinity();\n-            minpos_data[1] = std::numeric_limits<double>::infinity();\n-        }\n-        else\n-        {\n-            if (x0 > x1)\n-            {\n-                extents_data[0] = std::numeric_limits<double>::infinity();\n-                extents_data[2] = -std::numeric_limits<double>::infinity();\n-            }\n-            else\n-            {\n-                extents_data[0] = x0;\n-                extents_data[2] = x1;\n-            }\n-            if (y0 > y1)\n-            {\n-                extents_data[1] = std::numeric_limits<double>::infinity();\n-                extents_data[3] = -std::numeric_limits<double>::infinity();\n-            }\n-            else\n-            {\n-                extents_data[1] = y0;\n-                extents_data[3] = y1;\n-            }\n-            minpos_data[0] = xm;\n-            minpos_data[1] = ym;\n-        }\n-\n-        ::get_path_extents(path, trans, &extents_data[0], &extents_data[1],\n-                           &extents_data[2], &extents_data[3], &minpos_data[0],\n-                           &minpos_data[1]);\n-\n-        changed = (extents_data[0] != x0 ||\n-                   extents_data[1] != y0 ||\n-                   extents_data[2] != x1 ||\n-                   extents_data[3] != y1 ||\n-                   minpos_data[0]  != xm ||\n-                   minpos_data[1]  != ym);\n-\n-    }\n-    catch (...)\n-    {\n-        Py_XDECREF(extents);\n-        Py_XDECREF(minpos);\n-        throw;\n-    }\n-\n-    Py::Tuple result(3);\n-    result[0] = Py::Object((PyObject*) extents);\n-    result[1] = Py::Object((PyObject*) minpos);\n-    result[2] = Py::Int(changed ? 1 : 0);\n-\n-    Py_XDECREF(extents);\n-    Py_XDECREF(minpos);\n-\n-    return result;\n-}\n-\n-Py::Object\n-_path_module::get_path_collection_extents(const Py::Tuple& args)\n-{\n-    args.verify_length(5);\n-\n-    //segments, trans, clipbox, colors, linewidths, antialiaseds\n-    agg::trans_affine       master_transform = py_to_agg_transformation_matrix(args[0].ptr());\n-    Py::SeqBase<Py::Object> paths            = args[1];\n-    Py::SeqBase<Py::Object> transforms_obj   = args[2];\n-    Py::Object              offsets_obj      = args[3];\n-    agg::trans_affine       offset_trans     = py_to_agg_transformation_matrix(args[4].ptr(), false);\n-\n-    PyArrayObject* offsets = NULL;\n-    double x0, y0, x1, y1, xm, ym;\n-\n-    try\n-    {\n-        offsets = (PyArrayObject*)PyArray_FromObject(\n-            offsets_obj.ptr(), NPY_DOUBLE, 0, 2);\n-        if (!offsets ||\n-            (PyArray_NDIM(offsets) == 2 && PyArray_DIM(offsets, 1) != 2) ||\n-            (PyArray_NDIM(offsets) == 1 && PyArray_DIM(offsets, 0) != 0))\n-        {\n-            throw Py::ValueError(\"Offsets array must be Nx2\");\n-        }\n-\n-        size_t Npaths      = paths.length();\n-        size_t Noffsets    = PyArray_DIM(offsets, 0);\n-        size_t N           = std::max(Npaths, Noffsets);\n-        size_t Ntransforms = std::min(transforms_obj.length(), N);\n-        size_t i;\n-\n-        // Convert all of the transforms up front\n-        typedef std::vector<agg::trans_affine> transforms_t;\n-        transforms_t transforms;\n-        transforms.reserve(Ntransforms);\n-        for (i = 0; i < Ntransforms; ++i)\n-        {\n-            agg::trans_affine trans = py_to_agg_transformation_matrix\n-                (transforms_obj[i].ptr(), false);\n-            trans *= master_transform;\n-            transforms.push_back(trans);\n-        }\n-\n-        // The offset each of those and collect the mins/maxs\n-        x0 = std::numeric_limits<double>::infinity();\n-        y0 = std::numeric_limits<double>::infinity();\n-        x1 = -std::numeric_limits<double>::infinity();\n-        y1 = -std::numeric_limits<double>::infinity();\n-        xm = std::numeric_limits<double>::infinity();\n-        ym = std::numeric_limits<double>::infinity();\n-        agg::trans_affine trans;\n-\n-        if (transforms.size() <= 1 && paths.size() == 1)\n-        {\n-            PathIterator path(paths[0]);\n-            if (Ntransforms)\n-            {\n-                trans = transforms[0];\n-            }\n-            else\n-            {\n-                trans = master_transform;\n-            }\n-\n-            double bx0 = std::numeric_limits<double>::infinity();\n-            double by0 = std::numeric_limits<double>::infinity();\n-            double bx1 = -std::numeric_limits<double>::infinity();\n-            double by1 = -std::numeric_limits<double>::infinity();\n-            double bxm = std::numeric_limits<double>::infinity();\n-            double bym = std::numeric_limits<double>::infinity();\n-\n-            ::get_path_extents(path, trans, &bx0, &by0, &bx1, &by1, &bxm, &bym);\n-\n-            for (i = 0; i < Noffsets; ++i)\n-            {\n-                double xo = *(double*)PyArray_GETPTR2(offsets, i % Noffsets, 0);\n-                double yo = *(double*)PyArray_GETPTR2(offsets, i % Noffsets, 1);\n-                offset_trans.transform(&xo, &yo);\n-                update_limits(xo + bx0, yo + by0, &x0, &y0, &x1, &y1, &xm, &ym);\n-                update_limits(xo + bx1, yo + by1, &x0, &y0, &x1, &y1, &xm, &ym);\n-            }\n-        } else {\n-            for (i = 0; i < N; ++i)\n-            {\n-                PathIterator path(paths[i % Npaths]);\n-                if (Ntransforms)\n-                {\n-                    trans = transforms[i % Ntransforms];\n-                }\n-                else\n-                {\n-                    trans = master_transform;\n-                }\n-\n-                if (Noffsets)\n-                {\n-                    double xo = *(double*)PyArray_GETPTR2(offsets, i % Noffsets, 0);\n-                    double yo = *(double*)PyArray_GETPTR2(offsets, i % Noffsets, 1);\n-                    offset_trans.transform(&xo, &yo);\n-                    trans *= agg::trans_affine_translation(xo, yo);\n-                }\n-\n-                ::get_path_extents(path, trans, &x0, &y0, &x1, &y1, &xm, &ym);\n-            }\n-        }\n-    }\n-    catch (...)\n-    {\n-        Py_XDECREF(offsets);\n-        throw;\n-    }\n-\n-    Py_XDECREF(offsets);\n-\n-    Py::Tuple result(4);\n-    result[0] = Py::Float(x0);\n-    result[1] = Py::Float(y0);\n-    result[2] = Py::Float(x1);\n-    result[3] = Py::Float(y1);\n-    return result;\n-}\n-\n-Py::Object\n-_path_module::point_in_path_collection(const Py::Tuple& args)\n-{\n-    args.verify_length(10);\n-\n-    //segments, trans, clipbox, colors, linewidths, antialiaseds\n-    double                  x                = Py::Float(args[0]);\n-    double                  y                = Py::Float(args[1]);\n-    double                  radius           = Py::Float(args[2]);\n-    agg::trans_affine       master_transform = py_to_agg_transformation_matrix(args[3].ptr());\n-    Py::SeqBase<Py::Object> paths            = args[4];\n-    Py::SeqBase<Py::Object> transforms_obj   = args[5];\n-    Py::SeqBase<Py::Object> offsets_obj      = args[6];\n-    agg::trans_affine       offset_trans     = py_to_agg_transformation_matrix(args[7].ptr());\n-    bool                    filled           = Py::Boolean(args[8]);\n-    std::string             offset_position  = Py::String(args[9]).encode(\"utf-8\");\n-\n-    bool data_offsets = (offset_position == \"data\");\n-\n-    PyArrayObject* offsets = (PyArrayObject*)PyArray_FromObject(\n-        offsets_obj.ptr(), NPY_DOUBLE, 0, 2);\n-    if (!offsets ||\n-            (PyArray_NDIM(offsets) == 2 && PyArray_DIM(offsets, 1) != 2) ||\n-            (PyArray_NDIM(offsets) == 1 && PyArray_DIM(offsets, 0) != 0))\n-    {\n-        Py_XDECREF(offsets);\n-        throw Py::ValueError(\"Offsets array must be Nx2\");\n-    }\n-\n-    Py::List result;\n-\n-    size_t Npaths      = paths.length();\n-\n-    if (Npaths == 0) {\n-        return result;\n-    }\n-\n-    size_t Noffsets    = PyArray_DIM(offsets, 0);\n-\n-    size_t N           = std::max(Npaths, Noffsets);\n-    size_t Ntransforms = std::min(transforms_obj.length(), N);\n-    size_t i;\n-\n-    // Convert all of the transforms up front\n-    typedef std::vector<agg::trans_affine> transforms_t;\n-    transforms_t transforms;\n-    transforms.reserve(Ntransforms);\n-    for (i = 0; i < Ntransforms; ++i)\n-    {\n-        agg::trans_affine trans = py_to_agg_transformation_matrix\n-                                  (transforms_obj[i].ptr(), false);\n-        trans *= master_transform;\n-        transforms.push_back(trans);\n-    }\n-\n-    agg::trans_affine trans;\n-\n-    for (i = 0; i < N; ++i)\n-    {\n-        PathIterator path(paths[i % Npaths]);\n-\n-        if (Ntransforms)\n-        {\n-            trans = transforms[i % Ntransforms];\n-        }\n-        else\n-        {\n-            trans = master_transform;\n-        }\n-\n-        if (Noffsets)\n-        {\n-            double xo = *(double*)PyArray_GETPTR2(offsets, i % Noffsets, 0);\n-            double yo = *(double*)PyArray_GETPTR2(offsets, i % Noffsets, 1);\n-            offset_trans.transform(&xo, &yo);\n-            if (data_offsets) {\n-                trans = agg::trans_affine_translation(xo, yo) * trans;\n-            } else {\n-                trans *= agg::trans_affine_translation(xo, yo);\n-            }\n-        }\n-\n-        if (filled)\n-        {\n-            if (::point_in_path(x, y, radius, path, trans))\n-                result.append(Py::Int((int)i));\n-        }\n-        else\n-        {\n-            if (::point_on_path(x, y, radius, path, trans))\n-                result.append(Py::Int((int)i));\n-        }\n-    }\n-\n-    return result;\n-}\n-\n-bool\n-path_in_path(PathIterator& a, const agg::trans_affine& atrans,\n-             PathIterator& b, const agg::trans_affine& btrans)\n-{\n-    typedef agg::conv_transform<PathIterator> transformed_path_t;\n-    typedef PathNanRemover<transformed_path_t> no_nans_t;\n-    typedef agg::conv_curve<no_nans_t> curve_t;\n-\n-    if (a.total_vertices() < 3)\n-        return false;\n-\n-    transformed_path_t b_path_trans(b, btrans);\n-    no_nans_t b_no_nans(b_path_trans, true, b.has_curves());\n-    curve_t b_curved(b_no_nans);\n-\n-    double x, y;\n-    b_curved.rewind(0);\n-    while (b_curved.vertex(&x, &y) != agg::path_cmd_stop)\n-    {\n-        if (!::point_in_path(x, y, 0.0, a, atrans))\n-            return false;\n-    }\n-\n-    return true;\n-}\n-\n-Py::Object\n-_path_module::path_in_path(const Py::Tuple& args)\n-{\n-    args.verify_length(4);\n-\n-    PathIterator a(args[0]);\n-    agg::trans_affine atrans = py_to_agg_transformation_matrix(\n-        args[1].ptr(), false);\n-    PathIterator b(args[2]);\n-    agg::trans_affine btrans = py_to_agg_transformation_matrix(\n-        args[3].ptr(), false);\n-\n-    return Py::Int(::path_in_path(a, atrans, b, btrans));\n-}\n-\n-/** The clip_path_to_rect code here is a clean-room implementation of\n-    the Sutherland-Hodgman clipping algorithm described here:\n-\n-  http://en.wikipedia.org/wiki/Sutherland-Hodgman_clipping_algorithm\n-*/\n-\n-typedef std::vector<XY> Polygon;\n-\n-namespace clip_to_rect_filters\n-{\n-    /* There are four different passes needed to create/remove\n-       vertices (one for each side of the rectangle).  The differences\n-       between those passes are encapsulated in these functor classes.\n-    */\n-    struct bisectx\n-    {\n-        double m_x;\n-\n-        bisectx(double x) : m_x(x) {}\n-\n-        inline void\n-        bisect(double sx, double sy, double px, double py, double* bx,\n-               double* by) const\n-        {\n-            *bx = m_x;\n-            double dx = px - sx;\n-            double dy = py - sy;\n-            *by = sy + dy * ((m_x - sx) / dx);\n-        }\n-    };\n-\n-    struct xlt : public bisectx\n-    {\n-        xlt(double x) : bisectx(x) {}\n-\n-        inline bool\n-        is_inside(double x, double y) const\n-        {\n-            return x <= m_x;\n-        }\n-    };\n-\n-    struct xgt : public bisectx\n-    {\n-        xgt(double x) : bisectx(x) {}\n-\n-        inline bool\n-        is_inside(double x, double y) const\n-        {\n-            return x >= m_x;\n-        }\n-    };\n-\n-    struct bisecty\n-    {\n-        double m_y;\n-\n-        bisecty(double y) : m_y(y) {}\n-\n-        inline void\n-        bisect(double sx, double sy, double px, double py, double* bx,\n-               double* by) const\n-        {\n-            *by = m_y;\n-            double dx = px - sx;\n-            double dy = py - sy;\n-            *bx = sx + dx * ((m_y - sy) / dy);\n-        }\n-    };\n-\n-    struct ylt : public bisecty\n-    {\n-        ylt(double y) : bisecty(y) {}\n-\n-        inline bool\n-        is_inside(double x, double y) const\n-        {\n-            return y <= m_y;\n-        }\n-    };\n-\n-    struct ygt : public bisecty\n-    {\n-        ygt(double y) : bisecty(y) {}\n-\n-        inline bool\n-        is_inside(double x, double y) const\n-        {\n-            return y >= m_y;\n-        }\n-    };\n-}\n-\n-template<class Filter>\n-inline void\n-clip_to_rect_one_step(const Polygon& polygon, Polygon& result, const Filter& filter)\n-{\n-    double sx, sy, px, py, bx, by;\n-    bool sinside, pinside;\n-    result.clear();\n-\n-    if (polygon.size() == 0)\n-    {\n-        return;\n-    }\n-\n-    sx = polygon.back().x;\n-    sy = polygon.back().y;\n-    for (Polygon::const_iterator i = polygon.begin(); i != polygon.end(); ++i)\n-    {\n-        px = i->x;\n-        py = i->y;\n-\n-        sinside = filter.is_inside(sx, sy);\n-        pinside = filter.is_inside(px, py);\n-\n-        if (sinside ^ pinside)\n-        {\n-            filter.bisect(sx, sy, px, py, &bx, &by);\n-            result.push_back(XY(bx, by));\n-        }\n-\n-        if (pinside)\n-        {\n-            result.push_back(XY(px, py));\n-        }\n-\n-        sx = px;\n-        sy = py;\n-    }\n-}\n-\n-template<class Path>\n-void\n-clip_to_rect(Path& path,\n-             double x0, double y0, double x1, double y1,\n-             bool inside, std::vector<Polygon>& results)\n-{\n-    double xmin, ymin, xmax, ymax;\n-    if (x0 < x1)\n-    {\n-        xmin = x0;\n-        xmax = x1;\n-    }\n-    else\n-    {\n-        xmin = x1;\n-        xmax = x0;\n-    }\n-\n-    if (y0 < y1)\n-    {\n-        ymin = y0;\n-        ymax = y1;\n-    }\n-    else\n-    {\n-        ymin = y1;\n-        ymax = y0;\n-    }\n-\n-    if (!inside)\n-    {\n-        std::swap(xmin, xmax);\n-        std::swap(ymin, ymax);\n-    }\n-\n-    Polygon polygon1, polygon2;\n-    double x = 0, y = 0;\n-    unsigned code = 0;\n-    path.rewind(0);\n-\n-    do\n-    {\n-        // Grab the next subpath and store it in polygon1\n-        polygon1.clear();\n-        do\n-        {\n-            if (code == agg::path_cmd_move_to)\n-            {\n-                polygon1.push_back(XY(x, y));\n-            }\n-\n-            code = path.vertex(&x, &y);\n-\n-            if (code == agg::path_cmd_stop)\n-            {\n-                break;\n-            }\n-\n-            if (code != agg::path_cmd_move_to)\n-            {\n-                polygon1.push_back(XY(x, y));\n-            }\n-        }\n-        while ((code & agg::path_cmd_end_poly) != agg::path_cmd_end_poly);\n-\n-        // The result of each step is fed into the next (note the\n-        // swapping of polygon1 and polygon2 at each step).\n-        clip_to_rect_one_step(polygon1, polygon2, clip_to_rect_filters::xlt(xmax));\n-        clip_to_rect_one_step(polygon2, polygon1, clip_to_rect_filters::xgt(xmin));\n-        clip_to_rect_one_step(polygon1, polygon2, clip_to_rect_filters::ylt(ymax));\n-        clip_to_rect_one_step(polygon2, polygon1, clip_to_rect_filters::ygt(ymin));\n-\n-        // Empty polygons aren't very useful, so skip them\n-        if (polygon1.size())\n-        {\n-            results.push_back(polygon1);\n-        }\n-    }\n-    while (code != agg::path_cmd_stop);\n-}\n-\n-Py::Object\n-_path_module::clip_path_to_rect(const Py::Tuple &args)\n-{\n-    args.verify_length(3);\n-\n-    PathIterator path(args[0]);\n-    Py::Object bbox_obj = args[1];\n-    bool inside = Py::Boolean(args[2]);\n-\n-    double x0, y0, x1, y1;\n-    if (!py_convert_bbox(bbox_obj.ptr(), x0, y0, x1, y1))\n-    {\n-        throw Py::TypeError(\"Argument 2 to clip_to_rect must be a Bbox object.\");\n-    }\n-\n-    std::vector<Polygon> results;\n-    typedef agg::conv_curve<PathIterator> curve_t;\n-    curve_t curve(path);\n-\n-    ::clip_to_rect(curve, x0, y0, x1, y1, inside, results);\n-\n-    npy_intp dims[2];\n-    dims[1] = 2;\n-    PyObject* py_results = PyList_New(results.size());\n-    if (!py_results)\n-    {\n-        throw Py::RuntimeError(\"Error creating results list\");\n-    }\n-\n-    try\n-    {\n-        for (std::vector<Polygon>::const_iterator p = results.begin(); p != results.end(); ++p)\n-        {\n-            size_t size = p->size();\n-            dims[0] = (npy_intp)size + 1;\n-            PyArrayObject* pyarray = (PyArrayObject*)PyArray_SimpleNew(2, dims, NPY_DOUBLE);\n-            if (pyarray == NULL)\n-            {\n-                throw Py::MemoryError(\"Could not allocate result array\");\n-            }\n-            double* const data = (double*)PyArray_DATA(pyarray);\n-            for (size_t i = 0; i < size; ++i)\n-            {\n-                data[2*i]   = (*p)[i].x;\n-                data[2*i+1] = (*p)[i].y;\n-            }\n-            data[2*size]   = (*p)[0].x;\n-            data[2*size+1] = (*p)[0].y;\n-\n-            if (PyList_SetItem(py_results, p - results.begin(), (PyObject *)pyarray) == -1)\n-            {\n-                throw Py::RuntimeError(\"Error creating results list\");\n-            }\n-        }\n-    }\n-    catch (...)\n-    {\n-        Py_XDECREF(py_results);\n-        throw;\n-    }\n-\n-    return Py::Object(py_results, true);\n-}\n-\n-Py::Object\n-_path_module::affine_transform(const Py::Tuple& args)\n-{\n-    args.verify_length(2);\n-\n-    Py::Object vertices_obj = args[0];\n-    Py::Object transform_obj = args[1];\n-\n-    PyArrayObject* vertices = NULL;\n-    PyArrayObject* transform = NULL;\n-    PyArrayObject* result = NULL;\n-\n-    try\n-    {\n-        vertices = (PyArrayObject*)PyArray_FromObject\n-                   (vertices_obj.ptr(), NPY_DOUBLE, 1, 2);\n-        if (!vertices ||\n-            (PyArray_NDIM(vertices) == 2 && PyArray_DIM(vertices, 0) != 0 &&\n-             PyArray_DIM(vertices, 1) != 2) ||\n-            (PyArray_NDIM(vertices) == 1 &&\n-             PyArray_DIM(vertices, 0) != 2 && PyArray_DIM(vertices, 0) != 0))\n-        {\n-            throw Py::ValueError(\"Invalid vertices array.\");\n-        }\n-\n-        transform = (PyArrayObject*) PyArray_FromObject\n-                    (transform_obj.ptr(), NPY_DOUBLE, 2, 2);\n-        if (!transform ||\n-            PyArray_DIM(transform, 0) != 3 ||\n-            PyArray_DIM(transform, 1) != 3)\n-        {\n-            throw Py::ValueError(\"Invalid transform.\");\n-        }\n-\n-        double a, b, c, d, e, f;\n-        {\n-            size_t stride0 = PyArray_STRIDE(transform, 0);\n-            size_t stride1 = PyArray_STRIDE(transform, 1);\n-            char* row0 = PyArray_BYTES(transform);\n-            char* row1 = row0 + stride0;\n-\n-            a = *(double*)(row0);\n-            row0 += stride1;\n-            c = *(double*)(row0);\n-            row0 += stride1;\n-            e = *(double*)(row0);\n-\n-            b = *(double*)(row1);\n-            row1 += stride1;\n-            d = *(double*)(row1);\n-            row1 += stride1;\n-            f = *(double*)(row1);\n-        }\n-\n-        result = (PyArrayObject*)PyArray_SimpleNew\n-                 (PyArray_NDIM(vertices), PyArray_DIMS(vertices), NPY_DOUBLE);\n-        if (result == NULL)\n-        {\n-            throw Py::MemoryError(\"Could not allocate memory for path\");\n-        }\n-        if (PyArray_NDIM(vertices) == 2)\n-        {\n-            size_t n = PyArray_DIM(vertices, 0);\n-            char* vertex_in = PyArray_BYTES(vertices);\n-            double* vertex_out = (double*)PyArray_DATA(result);\n-            size_t stride0 = PyArray_STRIDE(vertices, 0);\n-            size_t stride1 = PyArray_STRIDE(vertices, 1);\n-            double x;\n-            double y;\n-            volatile double t0;\n-\t    volatile double t1;\n-\t    volatile double t;\n-\n-            for (size_t i = 0; i < n; ++i)\n-            {\n-                x = *(double*)(vertex_in);\n-                y = *(double*)(vertex_in + stride1);\n-\n-\t\tt0 = a * x;\n-\t\tt1 = c * y;\n-                t = t0 + t1 + e;\n-                *(vertex_out++) = t;\n-\n-\t\tt0 = b * x;\n-\t\tt1 = d * y;\n-                t = t0 + t1 + f;\n-                *(vertex_out++) = t;\n-\n-                vertex_in += stride0;\n-            }\n-        }\n-        else if (PyArray_DIM(vertices, 0) != 0)\n-        {\n-            char* vertex_in = PyArray_BYTES(vertices);\n-            double* vertex_out = (double*)PyArray_DATA(result);\n-            size_t stride0 = PyArray_STRIDE(vertices, 0);\n-            double x;\n-            double y;\n-            x = *(double*)(vertex_in);\n-            y = *(double*)(vertex_in + stride0);\n-            *vertex_out++ = a * x + c * y + e;\n-            *vertex_out++ = b * x + d * y + f;\n-        }\n-    }\n-    catch (...)\n-    {\n-        Py_XDECREF(vertices);\n-        Py_XDECREF(transform);\n-        Py_XDECREF(result);\n-        throw;\n-    }\n-\n-    Py_XDECREF(vertices);\n-    Py_XDECREF(transform);\n-\n-    return Py::Object((PyObject*)result, true);\n-}\n-\n-Py::Object\n-_path_module::count_bboxes_overlapping_bbox(const Py::Tuple& args)\n-{\n-    args.verify_length(2);\n-\n-    Py::Object              bbox   = args[0];\n-    Py::SeqBase<Py::Object> bboxes = args[1];\n-\n-    double ax0, ay0, ax1, ay1;\n-    double bx0, by0, bx1, by1;\n-    long count = 0;\n-\n-    if (py_convert_bbox(bbox.ptr(), ax0, ay0, ax1, ay1))\n-    {\n-        if (ax1 < ax0)\n-        {\n-            std::swap(ax0, ax1);\n-        }\n-        if (ay1 < ay0)\n-        {\n-            std::swap(ay0, ay1);\n-        }\n-\n-        size_t num_bboxes = bboxes.size();\n-        for (size_t i = 0; i < num_bboxes; ++i)\n-        {\n-            Py::Object bbox_b = bboxes[i];\n-            if (py_convert_bbox(bbox_b.ptr(), bx0, by0, bx1, by1))\n-            {\n-                if (bx1 < bx0)\n-                {\n-                    std::swap(bx0, bx1);\n-                }\n-                if (by1 < by0)\n-                {\n-                    std::swap(by0, by1);\n-                }\n-                if (!((bx1 <= ax0) ||\n-                      (by1 <= ay0) ||\n-                      (bx0 >= ax1) ||\n-                      (by0 >= ay1)))\n-                {\n-                    ++count;\n-                }\n-            }\n-            else\n-            {\n-                throw Py::ValueError(\"Non-bbox object in bboxes list\");\n-            }\n-        }\n-    }\n-    else\n-    {\n-        throw Py::ValueError(\"First argument to count_bboxes_overlapping_bbox must be a Bbox object.\");\n-    }\n-\n-    return Py::Int(count);\n-}\n-\n-inline bool\n-segments_intersect(const double& x1, const double& y1,\n-                   const double& x2, const double& y2,\n-                   const double& x3, const double& y3,\n-                   const double& x4, const double& y4)\n-{\n-    double den = ((y4 - y3) * (x2 - x1)) - ((x4 - x3) * (y2 - y1));\n-    if (den == 0.0)\n-    {\n-        return false;\n-    }\n-\n-    double n1 = ((x4 - x3) * (y1 - y3)) - ((y4 - y3) * (x1 - x3));\n-    double n2 = ((x2 - x1) * (y1 - y3)) - ((y2 - y1) * (x1 - x3));\n-\n-    double u1 = n1 / den;\n-    double u2 = n2 / den;\n-\n-    return (u1 >= 0.0 && u1 <= 1.0 &&\n-            u2 >= 0.0 && u2 <= 1.0);\n-}\n-\n-bool\n-path_intersects_path(PathIterator& p1, PathIterator& p2)\n-{\n-    typedef PathNanRemover<PathIterator> no_nans_t;\n-    typedef agg::conv_curve<no_nans_t> curve_t;\n-\n-    if (p1.total_vertices() < 2 || p2.total_vertices() < 2)\n-    {\n-        return false;\n-    }\n-\n-    no_nans_t n1(p1, true, p1.has_curves());\n-    no_nans_t n2(p2, true, p2.has_curves());\n-\n-    curve_t c1(n1);\n-    curve_t c2(n2);\n-\n-    double x11, y11, x12, y12;\n-    double x21, y21, x22, y22;\n-\n-    c1.vertex(&x11, &y11);\n-    while (c1.vertex(&x12, &y12) != agg::path_cmd_stop)\n-    {\n-        c2.rewind(0);\n-        c2.vertex(&x21, &y21);\n-        while (c2.vertex(&x22, &y22) != agg::path_cmd_stop)\n-        {\n-            if (segments_intersect(x11, y11, x12, y12, x21, y21, x22, y22))\n-            {\n-                return true;\n-            }\n-            x21 = x22;\n-            y21 = y22;\n-        }\n-        x11 = x12;\n-        y11 = y12;\n-    }\n-\n-    return false;\n-}\n-\n-Py::Object\n-_path_module::path_intersects_path(const Py::Tuple& args)\n-{\n-    args.verify_length(2, 3);\n-\n-    PathIterator p1(args[0]);\n-    PathIterator p2(args[1]);\n-    bool filled = false;\n-\n-    if (args.size() == 3)\n-    {\n-        filled = args[2].isTrue();\n-    }\n-\n-    if (!filled)\n-    {\n-        return Py::Int(::path_intersects_path(p1, p2));\n-    }\n-    else\n-    {\n-        return Py::Int(::path_intersects_path(p1, p2)\n-                       || ::path_in_path(p1, agg::trans_affine(), p2, agg::trans_affine())\n-                       || ::path_in_path(p2, agg::trans_affine(), p1, agg::trans_affine()));\n-    }\n-}\n-\n-void\n-_add_polygon(Py::List& polygons, const std::vector<double>& polygon)\n-{\n-    if (polygon.size() == 0)\n-    {\n-        return;\n-    }\n-    npy_intp polygon_dims[] = { static_cast<npy_intp>(polygon.size() / 2), 2, 0 };\n-    PyArrayObject* polygon_array = NULL;\n-    polygon_array = (PyArrayObject*)PyArray_SimpleNew\n-                    (2, polygon_dims, NPY_DOUBLE);\n-    if (!polygon_array)\n-    {\n-        throw Py::MemoryError(\"Error creating polygon array\");\n-    }\n-    double* polygon_data = (double*)PyArray_DATA(polygon_array);\n-    memcpy(polygon_data, &polygon[0], polygon.size() * sizeof(double));\n-    polygons.append(Py::Object((PyObject*)polygon_array, true));\n-}\n-\n-Py::Object\n-_path_module::convert_path_to_polygons(const Py::Tuple& args)\n-{\n-    typedef agg::conv_transform<PathIterator>  transformed_path_t;\n-    typedef PathNanRemover<transformed_path_t> nan_removal_t;\n-    typedef PathClipper<nan_removal_t>         clipped_t;\n-    typedef PathSimplifier<clipped_t>          simplify_t;\n-    typedef agg::conv_curve<simplify_t>        curve_t;\n-\n-    typedef std::vector<double> vertices_t;\n-\n-    args.verify_length(4);\n-\n-    PathIterator path(args[0]);\n-    agg::trans_affine trans = py_to_agg_transformation_matrix(args[1].ptr(), false);\n-    double width = Py::Float(args[2]);\n-    double height = Py::Float(args[3]);\n-\n-    bool do_clip = width != 0.0 && height != 0.0;\n-\n-    bool simplify = path.should_simplify();\n-\n-    transformed_path_t tpath(path, trans);\n-    nan_removal_t      nan_removed(tpath, true, path.has_curves());\n-    clipped_t          clipped(nan_removed, do_clip, width, height);\n-    simplify_t         simplified(clipped, simplify, path.simplify_threshold());\n-    curve_t            curve(simplified);\n-\n-    Py::List polygons;\n-    vertices_t polygon;\n-    double x, y;\n-    unsigned code;\n-\n-    polygon.reserve(path.total_vertices() * 2);\n-\n-    while ((code = curve.vertex(&x, &y)) != agg::path_cmd_stop)\n-    {\n-        if ((code & agg::path_cmd_end_poly) == agg::path_cmd_end_poly)\n-        {\n-            if (polygon.size() >= 2)\n-            {\n-                polygon.push_back(polygon[0]);\n-                polygon.push_back(polygon[1]);\n-                _add_polygon(polygons, polygon);\n-            }\n-            polygon.clear();\n-        }\n-        else\n-        {\n-            if (code == agg::path_cmd_move_to)\n-            {\n-                _add_polygon(polygons, polygon);\n-                polygon.clear();\n-            }\n-            polygon.push_back(x);\n-            polygon.push_back(y);\n-        }\n-    }\n-\n-    _add_polygon(polygons, polygon);\n-\n-    return polygons;\n-}\n-\n-template<class VertexSource>\n-void\n-__cleanup_path(VertexSource& source,\n-               std::vector<double>& vertices,\n-               std::vector<npy_uint8>& codes)\n-{\n-    unsigned code;\n-    double x, y;\n-    do\n-    {\n-        code = source.vertex(&x, &y);\n-        vertices.push_back(x);\n-        vertices.push_back(y);\n-        codes.push_back((npy_uint8)code);\n-    }\n-    while (code != agg::path_cmd_stop);\n-}\n-\n-void\n-_cleanup_path(PathIterator& path, const agg::trans_affine& trans,\n-              bool remove_nans, bool do_clip,\n-              const agg::rect_base<double>& rect,\n-              e_snap_mode snap_mode, double stroke_width,\n-              bool do_simplify, bool return_curves,\n-              double sketch_scale, double sketch_length,\n-              double sketch_randomness,\n-              std::vector<double>& vertices,\n-              std::vector<npy_uint8>& codes)\n-{\n-    typedef agg::conv_transform<PathIterator>  transformed_path_t;\n-    typedef PathNanRemover<transformed_path_t> nan_removal_t;\n-    typedef PathClipper<nan_removal_t>         clipped_t;\n-    typedef PathSnapper<clipped_t>             snapped_t;\n-    typedef PathSimplifier<snapped_t>          simplify_t;\n-    typedef agg::conv_curve<simplify_t>        curve_t;\n-    typedef Sketch<curve_t>                    sketch_t;\n-\n-    transformed_path_t tpath(path, trans);\n-    nan_removal_t      nan_removed(tpath, remove_nans, path.has_curves());\n-    clipped_t          clipped(nan_removed, do_clip, rect);\n-    snapped_t          snapped(clipped, snap_mode, path.total_vertices(), stroke_width);\n-    simplify_t         simplified(snapped, do_simplify, path.simplify_threshold());\n-\n-    vertices.reserve(path.total_vertices() * 2);\n-    codes.reserve(path.total_vertices());\n-\n-    if (return_curves && sketch_scale == 0.0)\n-    {\n-        __cleanup_path(simplified, vertices, codes);\n-    }\n-    else\n-    {\n-        curve_t curve(simplified);\n-        sketch_t sketch(curve, sketch_scale, sketch_length, sketch_randomness);\n-        __cleanup_path(sketch, vertices, codes);\n-    }\n-}\n-\n-Py::Object\n-_path_module::cleanup_path(const Py::Tuple& args)\n-{\n-    args.verify_length(9);\n-\n-    PathIterator path(args[0]);\n-    agg::trans_affine trans = py_to_agg_transformation_matrix(args[1].ptr(), false);\n-    bool remove_nans = args[2].isTrue();\n-\n-    Py::Object clip_obj = args[3];\n-    bool do_clip;\n-    agg::rect_base<double> clip_rect;\n-    if (clip_obj.isNone())\n-    {\n-        do_clip = false;\n-    }\n-    else\n-    {\n-        double x1, y1, x2, y2;\n-        Py::Tuple clip_tuple(clip_obj);\n-        x1 = Py::Float(clip_tuple[0]);\n-        y1 = Py::Float(clip_tuple[1]);\n-        x2 = Py::Float(clip_tuple[2]);\n-        y2 = Py::Float(clip_tuple[3]);\n-        clip_rect.init(x1, y1, x2, y2);\n-        do_clip = true;\n-    }\n-\n-    Py::Object snap_obj = args[4];\n-    e_snap_mode snap_mode;\n-    if (snap_obj.isNone())\n-    {\n-        snap_mode = SNAP_AUTO;\n-    }\n-    else if (snap_obj.isTrue())\n-    {\n-        snap_mode = SNAP_TRUE;\n-    }\n-    else\n-    {\n-        snap_mode = SNAP_FALSE;\n-    }\n-\n-    double stroke_width = Py::Float(args[5]);\n-\n-    bool simplify;\n-    Py::Object simplify_obj = args[6];\n-    if (simplify_obj.isNone())\n-    {\n-        simplify = path.should_simplify();\n-    }\n-    else\n-    {\n-        simplify = simplify_obj.isTrue();\n-    }\n-\n-    bool return_curves = args[7].isTrue();\n-\n-    Py::Object sketch_params = args[8];\n-    double sketch_scale = 0.0;\n-    double sketch_length = 0.0;\n-    double sketch_randomness = 0.0;\n-    if (sketch_params.ptr() != Py_None) {\n-        Py::Tuple sketch(sketch_params);\n-        sketch_scale = Py::Float(sketch[0]);\n-        sketch_length = Py::Float(sketch[1]);\n-        sketch_randomness = Py::Float(sketch[2]);\n-    }\n-\n-    std::vector<double> vertices;\n-    std::vector<npy_uint8> codes;\n-\n-    _cleanup_path(path, trans, remove_nans, do_clip, clip_rect, snap_mode,\n-                  stroke_width, simplify, return_curves, sketch_scale,\n-                  sketch_length, sketch_randomness, vertices, codes);\n-\n-    npy_intp length = codes.size();\n-    npy_intp dims[] = { length, 2, 0 };\n-\n-    PyArrayObject* vertices_obj = NULL;\n-    PyArrayObject* codes_obj = NULL;\n-    Py::Tuple result(2);\n-    try\n-    {\n-        vertices_obj = (PyArrayObject*)PyArray_SimpleNew\n-                       (2, dims, NPY_DOUBLE);\n-        if (vertices_obj == NULL)\n-        {\n-            throw Py::MemoryError(\"Could not allocate result array\");\n-        }\n-\n-        codes_obj = (PyArrayObject*)PyArray_SimpleNew\n-                    (1, dims, NPY_UINT8);\n-        if (codes_obj == NULL)\n-        {\n-            throw Py::MemoryError(\"Could not allocate result array\");\n-        }\n-\n-        memcpy(PyArray_DATA(vertices_obj), &vertices[0], sizeof(double) * 2 * length);\n-        memcpy(PyArray_DATA(codes_obj), &codes[0], sizeof(npy_uint8) * length);\n-\n-        result[0] = Py::Object((PyObject*)vertices_obj, true);\n-        result[1] = Py::Object((PyObject*)codes_obj, true);\n-    }\n-    catch (...)\n-    {\n-        Py_XDECREF(vertices_obj);\n-        Py_XDECREF(codes_obj);\n-        throw;\n-    }\n-\n-    return result;\n-}\n-\n-Py::Object\n-_path_module::convert_to_svg(const Py::Tuple& args)\n-{\n-    args.verify_length(5);\n-\n-    PathIterator path(args[0]);\n-    agg::trans_affine trans = py_to_agg_transformation_matrix(args[1].ptr(), false);\n-\n-    Py::Object clip_obj = args[2];\n-    bool do_clip;\n-    agg::rect_base<double> clip_rect(0, 0, 0, 0);\n-    if (clip_obj.isNone() || !clip_obj.isTrue())\n-    {\n-        do_clip = false;\n-    }\n-    else\n-    {\n-        double x1, y1, x2, y2;\n-        Py::Tuple clip_tuple(clip_obj);\n-        x1 = Py::Float(clip_tuple[0]);\n-        y1 = Py::Float(clip_tuple[1]);\n-        x2 = Py::Float(clip_tuple[2]);\n-        y2 = Py::Float(clip_tuple[3]);\n-        clip_rect.init(x1, y1, x2, y2);\n-        do_clip = true;\n-    }\n-\n-    bool simplify;\n-    Py::Object simplify_obj = args[3];\n-    if (simplify_obj.isNone())\n-    {\n-        simplify = path.should_simplify();\n-    }\n-    else\n-    {\n-        simplify = simplify_obj.isTrue();\n-    }\n-\n-    int precision = Py::Int(args[4]);\n-\n-    #if PY_VERSION_HEX < 0x02070000\n-    char format[64];\n-    snprintf(format, 64, \"%s.%dg\", \"%\", precision);\n-    #endif\n-\n-    typedef agg::conv_transform<PathIterator>  transformed_path_t;\n-    typedef PathNanRemover<transformed_path_t> nan_removal_t;\n-    typedef PathClipper<nan_removal_t>         clipped_t;\n-    typedef PathSimplifier<clipped_t>          simplify_t;\n-\n-    transformed_path_t tpath(path, trans);\n-    nan_removal_t      nan_removed(tpath, true, path.has_curves());\n-    clipped_t          clipped(nan_removed, do_clip, clip_rect);\n-    simplify_t         simplified(clipped, simplify, path.simplify_threshold());\n-\n-    size_t buffersize = path.total_vertices() * (precision + 5) * 4;\n-    char* buffer = (char *)malloc(buffersize);\n-    char* p = buffer;\n-\n-    const char codes[] = {'M', 'L', 'Q', 'C'};\n-    const int  waits[] = {  1,   1,   2,   3};\n-\n-    int wait = 0;\n-    unsigned code;\n-    double x = 0, y = 0;\n-    while ((code = simplified.vertex(&x, &y)) != agg::path_cmd_stop)\n-    {\n-        if (wait == 0)\n-        {\n-            *p++ = '\\n';\n-\n-            if (code == 0x4f)\n-            {\n-                *p++ = 'z';\n-                *p++ = '\\n';\n-                continue;\n-            }\n-\n-            *p++ = codes[code-1];\n-            wait = waits[code-1];\n-        }\n-        else\n-        {\n-            *p++ = ' ';\n-        }\n-\n-        #if PY_VERSION_HEX >= 0x02070000\n-        char* str;\n-        str = PyOS_double_to_string(x, 'g', precision, 0, NULL);\n-        p += snprintf(p, buffersize - (p - buffer), \"%s\", str);\n-        PyMem_Free(str);\n-        *p++ = ' ';\n-        str = PyOS_double_to_string(y, 'g', precision, 0, NULL);\n-        p += snprintf(p, buffersize - (p - buffer), \"%s\", str);\n-        PyMem_Free(str);\n-        #else\n-        char str[64];\n-        PyOS_ascii_formatd(str, 64, format, x);\n-        p += snprintf(p, buffersize - (p - buffer), \"%s\", str);\n-        *p++ = ' ';\n-        PyOS_ascii_formatd(str, 64, format, y);\n-        p += snprintf(p, buffersize - (p - buffer), \"%s\", str);\n-        #endif\n-\n-        --wait;\n-    }\n-\n-    #if PY3K\n-    PyObject* result = PyUnicode_FromStringAndSize(buffer, p - buffer);\n-    #else\n-    PyObject* result = PyString_FromStringAndSize(buffer, p - buffer);\n-    #endif\n-    free(buffer);\n-\n-    return Py::Object(result, true);\n-}\n-\n-PyMODINIT_FUNC\n-#if PY3K\n-PyInit__path(void)\n-#else\n-init_path(void)\n-#endif\n-{\n-    static _path_module* _path = NULL;\n-    _path = new _path_module;\n-\n-    import_array();\n-\n-    #if PY3K\n-    return _path->module().ptr();\n-    #endif\n-}"}
{"patches_id": 2, "files_id": 40, "language": "h", "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_path.h", "raw_code": "/* -*- mode: c++; c-basic-offset: 4 -*- */\n\n#ifndef __PATH_H__\n#define __PATH_H__\n\n#include <limits>\n#include <math.h>\n#include <vector>\n\n#include \"agg_conv_contour.h\"\n#include \"agg_conv_curve.h\"\n#include \"agg_conv_stroke.h\"\n#include \"agg_conv_transform.h\"\n#include \"agg_path_storage.h\"\n#include \"agg_trans_affine.h\"\n\n#include \"path_converters.h\"\n#include \"_backend_agg_basic_types.h\"\n\nstruct XY\n{\n    double x;\n    double y;\n\n    XY(double x_, double y_) : x(x_), y(y_)\n    {\n    }\n};\n\n//\n// The following function was found in the Agg 2.3 examples (interactive_polygon.cpp).\n// It has been generalized to work on (possibly curved) polylines, rather than\n// just polygons.  The original comments have been kept intact.\n//  -- Michael Droettboom 2007-10-02\n//\n//======= Crossings Multiply algorithm of InsideTest ========================\n//\n// By Eric Haines, 3D/Eye Inc, erich@eye.com\n//\n// This version is usually somewhat faster than the original published in\n// Graphics Gems IV; by turning the division for testing the X axis crossing\n// into a tricky multiplication test this part of the test became faster,\n// which had the additional effect of making the test for \"both to left or\n// both to right\" a bit slower for triangles than simply computing the\n// intersection each time.  The main increase is in triangle testing speed,\n// which was about 15% faster; all other polygon complexities were pretty much\n// the same as before.  On machines where division is very expensive (not the\n// case on the HP 9000 series on which I tested) this test should be much\n// faster overall than the old code.  Your mileage may (in fact, will) vary,\n// depending on the machine and the test data, but in general I believe this\n// code is both shorter and faster.  This test was inspired by unpublished\n// Graphics Gems submitted by Joseph Samosky and Mark Haigh-Hutchinson.\n// Related work by Samosky is in:\n//\n// Samosky, Joseph, \"SectionView: A system for interactively specifying and\n// visualizing sections through three-dimensional medical image data\",\n// M.S. Thesis, Department of Electrical Engineering and Computer Science,\n// Massachusetts Institute of Technology, 1993.\n//\n// Shoot a test ray along +X axis.  The strategy is to compare vertex Y values\n// to the testing point's Y and quickly discard edges which are entirely to one\n// side of the test ray.  Note that CONVEX and WINDING code can be added as\n// for the CrossingsTest() code; it is left out here for clarity.\n//\n// Input 2D polygon _pgon_ with _numverts_ number of vertices and test point\n// _point_, returns 1 if inside, 0 if outside.\ntemplate <class PathIterator, class PointArray, class ResultArray>\nvoid point_in_path_impl(PointArray &points, PathIterator &path, ResultArray &inside_flag)\n{\n    int yflag1;\n    double vtx0, vty0, vtx1, vty1;\n    double tx, ty;\n    double sx, sy;\n    double x, y;\n    size_t i;\n    bool all_done;\n\n    size_t n = points.size();\n\n    std::vector<int> yflag0(n);\n    std::vector<int> subpath_flag(n);\n\n    path.rewind(0);\n\n    for (i = 0; i < n; ++i) {\n        inside_flag[i] = 0;\n    }\n\n    unsigned code = 0;\n    do {\n        if (code != agg::path_cmd_move_to) {\n            code = path.vertex(&x, &y);\n            if (code == agg::path_cmd_stop ||\n                (code & agg::path_cmd_end_poly) == agg::path_cmd_end_poly) {\n                continue;\n            }\n        }\n\n        sx = vtx0 = vtx1 = x;\n        sy = vty0 = vty1 = y;\n\n        for (i = 0; i < n; ++i) {\n            ty = points[i][1];\n\n            // get test bit for above/below X axis\n            yflag0[i] = (vty0 >= ty);\n\n            subpath_flag[i] = 0;\n        }\n\n        do {\n            code = path.vertex(&x, &y);\n\n            // The following cases denote the beginning on a new subpath\n            if (code == agg::path_cmd_stop ||\n                (code & agg::path_cmd_end_poly) == agg::path_cmd_end_poly) {\n                x = sx;\n                y = sy;\n            } else if (code == agg::path_cmd_move_to) {\n                break;\n            }\n\n            for (i = 0; i < n; ++i) {\n                tx = points[i][0];\n                ty = points[i][1];\n\n                yflag1 = (vty1 >= ty);\n                // Check if endpoints straddle (are on opposite sides) of\n                // X axis (i.e. the Y's differ); if so, +X ray could\n                // intersect this edge.  The old test also checked whether\n                // the endpoints are both to the right or to the left of\n                // the test point.  However, given the faster intersection\n                // point computation used below, this test was found to be\n                // a break-even proposition for most polygons and a loser\n                // for triangles (where 50% or more of the edges which\n                // survive this test will cross quadrants and so have to\n                // have the X intersection computed anyway).  I credit\n                // Joseph Samosky with inspiring me to try dropping the\n                // \"both left or both right\" part of my code.\n                if (yflag0[i] != yflag1) {\n                    // Check intersection of pgon segment with +X ray.\n                    // Note if >= point's X; if so, the ray hits it.  The\n                    // division operation is avoided for the \">=\" test by\n                    // checking the sign of the first vertex wrto the test\n                    // point; idea inspired by Joseph Samosky's and Mark\n                    // Haigh-Hutchinson's different polygon inclusion\n                    // tests.\n                    if (((vty1 - ty) * (vtx0 - vtx1) >= (vtx1 - tx) * (vty0 - vty1)) == yflag1) {\n                        subpath_flag[i] ^= 1;\n                    }\n                }\n\n                // Move to the next pair of vertices, retaining info as\n                // possible.\n                yflag0[i] = yflag1;\n            }\n\n            vtx0 = vtx1;\n            vty0 = vty1;\n\n            vtx1 = x;\n            vty1 = y;\n        } while (code != agg::path_cmd_stop &&\n                 (code & agg::path_cmd_end_poly) != agg::path_cmd_end_poly);\n\n        all_done = true;\n        for (i = 0; i < n; ++i) {\n            tx = points[i][0];\n            ty = points[i][1];\n\n            yflag1 = (vty1 >= ty);\n            if (yflag0[i] != yflag1) {\n                if (((vty1 - ty) * (vtx0 - vtx1) >= (vtx1 - tx) * (vty0 - vty1)) == yflag1) {\n                    subpath_flag[i] ^= 1;\n                }\n            }\n            inside_flag[i] |= subpath_flag[i];\n            if (inside_flag[i] == 0) {\n                all_done = false;\n            }\n        }\n\n        if (all_done) {\n            break;\n        }\n    } while (code != agg::path_cmd_stop);\n}\n\ntemplate <class PathIterator, class PointArray, class ResultArray>\ninline void points_in_path(PointArray &points,\n                           const double r,\n                           PathIterator &path,\n                           const agg::trans_affine &trans,\n                           ResultArray &result)\n{\n    typedef agg::conv_transform<PathIterator> transformed_path_t;\n    typedef PathNanRemover<transformed_path_t> no_nans_t;\n    typedef agg::conv_curve<no_nans_t> curve_t;\n    typedef agg::conv_contour<curve_t> contour_t;\n\n    size_t i;\n    for (i = 0; i < result.size(); ++i) {\n        result[i] = 0;\n    }\n\n    if (path.total_vertices() < 3) {\n        return;\n    }\n\n    transformed_path_t trans_path(path, trans);\n    no_nans_t no_nans_path(trans_path, true, path.has_curves());\n    curve_t curved_path(no_nans_path);\n    contour_t contoured_path(curved_path);\n    contoured_path.width(r);\n\n    point_in_path_impl(points, contoured_path, result);\n}\n\ntemplate <class PathIterator>\ninline bool point_in_path(\n    double x, double y, const double r, PathIterator &path, const agg::trans_affine &trans)\n{\n    std::vector<double> point;\n    std::vector<std::vector<double> > points;\n    point.push_back(x);\n    point.push_back(y);\n    points.push_back(point);\n\n    std::vector<uint8_t> result(1);\n    result[0] = 0;\n\n    points_in_path(points, r, path, trans, result);\n\n    return (bool)result[0];\n}\n\ntemplate <class PathIterator, class PointArray, class ResultArray>\nvoid points_on_path(PointArray &points,\n                    const double r,\n                    PathIterator &path,\n                    const agg::trans_affine &trans,\n                    ResultArray result)\n{\n    typedef agg::conv_transform<PathIterator> transformed_path_t;\n    typedef PathNanRemover<transformed_path_t> no_nans_t;\n    typedef agg::conv_curve<no_nans_t> curve_t;\n    typedef agg::conv_stroke<curve_t> stroke_t;\n\n    size_t i;\n    for (i = 0; i < result.size(); ++i) {\n        result[i] = 0;\n    }\n\n    transformed_path_t trans_path(path, trans);\n    no_nans_t nan_removed_path(trans_path, true, path.has_curves());\n    curve_t curved_path(nan_removed_path);\n    stroke_t stroked_path(curved_path);\n    stroked_path.width(r * 2.0);\n    point_in_path_impl(points, stroked_path, result);\n}\n\ntemplate <class PathIterator>\ninline bool point_on_path(\n    double x, double y, const double r, PathIterator &path, const agg::trans_affine &trans)\n{\n    std::vector<double> point;\n    std::vector<std::vector<double> > points;\n    point.push_back(x);\n    point.push_back(y);\n    points.push_back(point);\n\n    std::vector<uint8_t> result(1);\n    result[0] = 0;\n\n    points_on_path(points, r, path, trans, result);\n\n    return (bool)result[0];\n}\n\nstruct extent_limits\n{\n    double x0;\n    double y0;\n    double x1;\n    double y1;\n    double xm;\n    double ym;\n};\n\nvoid reset_limits(extent_limits &e)\n{\n    e.x0 = std::numeric_limits<double>::infinity();\n    e.y0 = std::numeric_limits<double>::infinity();\n    e.x1 = -std::numeric_limits<double>::infinity();\n    e.y1 = -std::numeric_limits<double>::infinity();\n    /* xm and ym are the minimum positive values in the data, used\n       by log scaling */\n    e.xm = std::numeric_limits<double>::infinity();\n    e.ym = std::numeric_limits<double>::infinity();\n}\n\ninline void update_limits(double x, double y, extent_limits &e)\n{\n    if (x < e.x0)\n        e.x0 = x;\n    if (y < e.y0)\n        e.y0 = y;\n    if (x > e.x1)\n        e.x1 = x;\n    if (y > e.y1)\n        e.y1 = y;\n    /* xm and ym are the minimum positive values in the data, used\n       by log scaling */\n    if (x > 0.0 && x < e.xm)\n        e.xm = x;\n    if (y > 0.0 && y < e.ym)\n        e.ym = y;\n}\n\ntemplate <class PathIterator>\nvoid update_path_extents(PathIterator &path, const agg::trans_affine &trans, extent_limits &extents)\n{\n    typedef agg::conv_transform<PathIterator> transformed_path_t;\n    typedef PathNanRemover<transformed_path_t> nan_removed_t;\n    double x, y;\n    unsigned code;\n\n    transformed_path_t tpath(path, trans);\n    nan_removed_t nan_removed(tpath, true, path.has_curves());\n\n    nan_removed.rewind(0);\n\n    while ((code = nan_removed.vertex(&x, &y)) != agg::path_cmd_stop) {\n        if ((code & agg::path_cmd_end_poly) == agg::path_cmd_end_poly) {\n            continue;\n        }\n        update_limits(x, y, extents);\n    }\n}\n\ntemplate <class PathGenerator, class TransformArray, class OffsetArray>\nvoid get_path_collection_extents(agg::trans_affine &master_transform,\n                                 PathGenerator &paths,\n                                 TransformArray &transforms,\n                                 OffsetArray &offsets,\n                                 agg::trans_affine &offset_trans,\n                                 extent_limits &extent)\n{\n    if (offsets.dim(0) != 0 && offsets.dim(1) != 2) {\n        throw \"Offsets array must be Nx2\";\n    }\n\n    size_t Npaths = paths.size();\n    size_t Noffsets = offsets.size();\n    size_t N = std::max(Npaths, Noffsets);\n    size_t Ntransforms = std::min(transforms.size(), N);\n    size_t i;\n\n    agg::trans_affine trans;\n\n    reset_limits(extent);\n\n    for (i = 0; i < N; ++i) {\n        typename PathGenerator::path_iterator path(paths(i % Npaths));\n        if (Ntransforms) {\n            typename TransformArray::sub_t subtrans = transforms[i % Ntransforms];\n            trans = agg::trans_affine(subtrans(0, 0),\n                                      subtrans(1, 0),\n                                      subtrans(0, 1),\n                                      subtrans(1, 1),\n                                      subtrans(0, 2),\n                                      subtrans(1, 2));\n        } else {\n            trans = master_transform;\n        }\n\n        if (Noffsets) {\n            double xo = offsets(i % Noffsets, 0);\n            double yo = offsets(i % Noffsets, 1);\n            offset_trans.transform(&xo, &yo);\n            trans *= agg::trans_affine_translation(xo, yo);\n        }\n\n        update_path_extents(path, trans, extent);\n    }\n}\n\ntemplate <class PathGenerator, class TransformArray, class OffsetArray>\nvoid point_in_path_collection(double x,\n                              double y,\n                              double radius,\n                              agg::trans_affine &master_transform,\n                              PathGenerator &paths,\n                              TransformArray &transforms,\n                              OffsetArray &offsets,\n                              agg::trans_affine &offset_trans,\n                              bool filled,\n                              e_offset_position offset_position,\n                              std::vector<size_t> &result)\n{\n    size_t Npaths = paths.size();\n\n    if (Npaths == 0) {\n        return;\n    }\n\n    size_t Noffsets = offsets.dim(0);\n    size_t N = std::max(Npaths, Noffsets);\n    size_t Ntransforms = std::min(transforms.size(), N);\n    size_t i;\n\n    agg::trans_affine trans;\n\n    for (i = 0; i < N; ++i) {\n        typename PathGenerator::path_iterator path = paths(i % Npaths);\n\n        if (Ntransforms) {\n            typename TransformArray::sub_t subtrans = transforms[i % Ntransforms];\n            trans = agg::trans_affine(subtrans(0, 0),\n                                      subtrans(1, 0),\n                                      subtrans(0, 1),\n                                      subtrans(1, 1),\n                                      subtrans(0, 2),\n                                      subtrans(1, 2));\n        } else {\n            trans = master_transform;\n        }\n\n        if (Noffsets) {\n            double xo = offsets(i % Noffsets, 0);\n            double yo = offsets(i % Noffsets, 1);\n            offset_trans.transform(&xo, &yo);\n            if (offset_position == OFFSET_POSITION_DATA) {\n                trans = agg::trans_affine_translation(xo, yo) * trans;\n            } else {\n                trans *= agg::trans_affine_translation(xo, yo);\n            }\n        }\n\n        if (filled) {\n            if (point_in_path(x, y, radius, path, trans)) {\n                result.push_back(i);\n            }\n        } else {\n            if (point_on_path(x, y, radius, path, trans))\n                result.push_back(i);\n        }\n    }\n}\n\ntemplate <class PathIterator1, class PathIterator2>\nbool path_in_path(PathIterator1 &a,\n                  const agg::trans_affine &atrans,\n                  PathIterator2 &b,\n                  const agg::trans_affine &btrans)\n{\n    typedef agg::conv_transform<PathIterator2> transformed_path_t;\n    typedef PathNanRemover<transformed_path_t> no_nans_t;\n    typedef agg::conv_curve<no_nans_t> curve_t;\n\n    if (a.total_vertices() < 3) {\n        return false;\n    }\n\n    transformed_path_t b_path_trans(b, btrans);\n    no_nans_t b_no_nans(b_path_trans, true, b.has_curves());\n    curve_t b_curved(b_no_nans);\n\n    double x, y;\n    b_curved.rewind(0);\n    while (b_curved.vertex(&x, &y) != agg::path_cmd_stop) {\n        if (!point_in_path(x, y, 0.0, a, atrans)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/** The clip_path_to_rect code here is a clean-room implementation of\n    the Sutherland-Hodgman clipping algorithm described here:\n\n  http://en.wikipedia.org/wiki/Sutherland-Hodgman_clipping_algorithm\n*/\n\ntypedef std::vector<XY> Polygon;\n\nnamespace clip_to_rect_filters\n{\n/* There are four different passes needed to create/remove\n   vertices (one for each side of the rectangle).  The differences\n   between those passes are encapsulated in these functor classes.\n*/\nstruct bisectx\n{\n    double m_x;\n\n    bisectx(double x) : m_x(x)\n    {\n    }\n\n    inline void bisect(double sx, double sy, double px, double py, double *bx, double *by) const\n    {\n        *bx = m_x;\n        double dx = px - sx;\n        double dy = py - sy;\n        *by = sy + dy * ((m_x - sx) / dx);\n    }\n};\n\nstruct xlt : public bisectx\n{\n    xlt(double x) : bisectx(x)\n    {\n    }\n\n    inline bool is_inside(double x, double y) const\n    {\n        return x <= m_x;\n    }\n};\n\nstruct xgt : public bisectx\n{\n    xgt(double x) : bisectx(x)\n    {\n    }\n\n    inline bool is_inside(double x, double y) const\n    {\n        return x >= m_x;\n    }\n};\n\nstruct bisecty\n{\n    double m_y;\n\n    bisecty(double y) : m_y(y)\n    {\n    }\n\n    inline void bisect(double sx, double sy, double px, double py, double *bx, double *by) const\n    {\n        *by = m_y;\n        double dx = px - sx;\n        double dy = py - sy;\n        *bx = sx + dx * ((m_y - sy) / dy);\n    }\n};\n\nstruct ylt : public bisecty\n{\n    ylt(double y) : bisecty(y)\n    {\n    }\n\n    inline bool is_inside(double x, double y) const\n    {\n        return y <= m_y;\n    }\n};\n\nstruct ygt : public bisecty\n{\n    ygt(double y) : bisecty(y)\n    {\n    }\n\n    inline bool is_inside(double x, double y) const\n    {\n        return y >= m_y;\n    }\n};\n}\n\ntemplate <class Filter>\ninline void clip_to_rect_one_step(const Polygon &polygon, Polygon &result, const Filter &filter)\n{\n    double sx, sy, px, py, bx, by;\n    bool sinside, pinside;\n    result.clear();\n\n    if (polygon.size() == 0) {\n        return;\n    }\n\n    sx = polygon.back().x;\n    sy = polygon.back().y;\n    for (Polygon::const_iterator i = polygon.begin(); i != polygon.end(); ++i) {\n        px = i->x;\n        py = i->y;\n\n        sinside = filter.is_inside(sx, sy);\n        pinside = filter.is_inside(px, py);\n\n        if (sinside ^ pinside) {\n            filter.bisect(sx, sy, px, py, &bx, &by);\n            result.push_back(XY(bx, by));\n        }\n\n        if (pinside) {\n            result.push_back(XY(px, py));\n        }\n\n        sx = px;\n        sy = py;\n    }\n}\n\ntemplate <class PathIterator>\nvoid\nclip_path_to_rect(PathIterator &path, agg::rect_d &rect, bool inside, std::vector<Polygon> &results)\n{\n    double xmin, ymin, xmax, ymax;\n    if (rect.x1 < rect.x2) {\n        xmin = rect.x1;\n        xmax = rect.x2;\n    } else {\n        xmin = rect.x2;\n        xmax = rect.x1;\n    }\n\n    if (rect.y1 < rect.y2) {\n        ymin = rect.y1;\n        ymax = rect.y2;\n    } else {\n        ymin = rect.y2;\n        ymax = rect.y1;\n    }\n\n    if (!inside) {\n        std::swap(xmin, xmax);\n        std::swap(ymin, ymax);\n    }\n\n    typedef agg::conv_curve<PathIterator> curve_t;\n    curve_t curve(path);\n\n    Polygon polygon1, polygon2;\n    double x = 0, y = 0;\n    unsigned code = 0;\n    curve.rewind(0);\n\n    do {\n        // Grab the next subpath and store it in polygon1\n        polygon1.clear();\n        do {\n            if (code == agg::path_cmd_move_to) {\n                polygon1.push_back(XY(x, y));\n            }\n\n            code = curve.vertex(&x, &y);\n\n            if (code == agg::path_cmd_stop) {\n                break;\n            }\n\n            if (code != agg::path_cmd_move_to) {\n                polygon1.push_back(XY(x, y));\n            }\n        } while ((code & agg::path_cmd_end_poly) != agg::path_cmd_end_poly);\n\n        // The result of each step is fed into the next (note the\n        // swapping of polygon1 and polygon2 at each step).\n        clip_to_rect_one_step(polygon1, polygon2, clip_to_rect_filters::xlt(xmax));\n        clip_to_rect_one_step(polygon2, polygon1, clip_to_rect_filters::xgt(xmin));\n        clip_to_rect_one_step(polygon1, polygon2, clip_to_rect_filters::ylt(ymax));\n        clip_to_rect_one_step(polygon2, polygon1, clip_to_rect_filters::ygt(ymin));\n\n        // Empty polygons aren't very useful, so skip them\n        if (polygon1.size()) {\n            results.push_back(polygon1);\n        }\n    } while (code != agg::path_cmd_stop);\n}\n\ntemplate <class VerticesArray, class ResultArray>\nvoid affine_transform(VerticesArray &vertices, agg::trans_affine &trans, ResultArray &result)\n{\n    if (vertices.dim(0) != 0 && vertices.dim(1) != 2) {\n        throw \"Invalid vertices array.\";\n    }\n\n    size_t n = vertices.dim(0);\n    double x;\n    double y;\n    double t0;\n    double t1;\n    double t;\n\n    for (size_t i = 0; i < n; ++i) {\n        x = vertices(i, 0);\n        y = vertices(i, 1);\n\n        t0 = trans.sx * x;\n        t1 = trans.shx * y;\n        t = t0 + t1 + trans.tx;\n        result(i, 0) = t;\n\n        t0 = trans.shy * x;\n        t1 = trans.sy * y;\n        t = t0 + t1 + trans.ty;\n        result(i, 1) = t;\n    }\n}\n\ntemplate <class BBoxArray>\nint count_bboxes_overlapping_bbox(agg::rect_d &a, BBoxArray &bboxes)\n{\n    agg::rect_d b;\n    int count = 0;\n\n    if (a.x2 < a.x1) {\n        std::swap(a.x1, a.x2);\n    }\n    if (a.y2 < a.y1) {\n        std::swap(a.y1, a.y2);\n    }\n\n    size_t num_bboxes = bboxes.size();\n    for (size_t i = 0; i < num_bboxes; ++i) {\n        typename BBoxArray::sub_t bbox_b = bboxes[i];\n        b = agg::rect_d(bbox_b(0, 0), bbox_b(0, 1), bbox_b(1, 0), bbox_b(1, 1));\n\n        if (b.x2 < b.x1) {\n            std::swap(b.x1, b.x2);\n        }\n        if (b.y2 < b.y1) {\n            std::swap(b.y1, b.y2);\n        }\n        if (!((b.x2 <= a.x1) || (b.y2 <= a.y1) || (b.x1 >= a.x2) || (b.y1 >= a.y2))) {\n            ++count;\n        }\n    }\n\n    return count;\n}\n\ninline bool segments_intersect(const double &x1,\n                               const double &y1,\n                               const double &x2,\n                               const double &y2,\n                               const double &x3,\n                               const double &y3,\n                               const double &x4,\n                               const double &y4)\n{\n    double den = ((y4 - y3) * (x2 - x1)) - ((x4 - x3) * (y2 - y1));\n    if (den == 0.0) {\n        return false;\n    }\n\n    double n1 = ((x4 - x3) * (y1 - y3)) - ((y4 - y3) * (x1 - x3));\n    double n2 = ((x2 - x1) * (y1 - y3)) - ((y2 - y1) * (x1 - x3));\n\n    double u1 = n1 / den;\n    double u2 = n2 / den;\n\n    return (u1 >= 0.0 && u1 <= 1.0 && u2 >= 0.0 && u2 <= 1.0);\n}\n\ntemplate <class PathIterator1, class PathIterator2>\nbool path_intersects_path(PathIterator1 &p1, PathIterator2 &p2)\n{\n    typedef PathNanRemover<py::PathIterator> no_nans_t;\n    typedef agg::conv_curve<no_nans_t> curve_t;\n\n    if (p1.total_vertices() < 2 || p2.total_vertices() < 2) {\n        return false;\n    }\n\n    no_nans_t n1(p1, true, p1.has_curves());\n    no_nans_t n2(p2, true, p2.has_curves());\n\n    curve_t c1(n1);\n    curve_t c2(n2);\n\n    double x11, y11, x12, y12;\n    double x21, y21, x22, y22;\n\n    c1.vertex(&x11, &y11);\n    while (c1.vertex(&x12, &y12) != agg::path_cmd_stop) {\n        c2.rewind(0);\n        c2.vertex(&x21, &y21);\n        while (c2.vertex(&x22, &y22) != agg::path_cmd_stop) {\n            if (segments_intersect(x11, y11, x12, y12, x21, y21, x22, y22)) {\n                return true;\n            }\n            x21 = x22;\n            y21 = y22;\n        }\n        x11 = x12;\n        y11 = y12;\n    }\n\n    return false;\n}\n\ntemplate <class PathIterator>\nvoid convert_path_to_polygons(PathIterator &path,\n                              agg::trans_affine &trans,\n                              double width,\n                              double height,\n                              std::vector<Polygon> &result)\n{\n    typedef agg::conv_transform<py::PathIterator> transformed_path_t;\n    typedef PathNanRemover<transformed_path_t> nan_removal_t;\n    typedef PathClipper<nan_removal_t> clipped_t;\n    typedef PathSimplifier<clipped_t> simplify_t;\n    typedef agg::conv_curve<simplify_t> curve_t;\n\n    bool do_clip = width != 0.0 && height != 0.0;\n    bool simplify = path.should_simplify();\n\n    transformed_path_t tpath(path, trans);\n    nan_removal_t nan_removed(tpath, true, path.has_curves());\n    clipped_t clipped(nan_removed, do_clip, width, height);\n    simplify_t simplified(clipped, simplify, path.simplify_threshold());\n    curve_t curve(simplified);\n\n    result.push_back(Polygon());\n    Polygon *polygon = &result.back();\n    double x, y;\n    unsigned code;\n\n    while ((code = curve.vertex(&x, &y)) != agg::path_cmd_stop) {\n        if ((code & agg::path_cmd_end_poly) == agg::path_cmd_end_poly) {\n            if (polygon->size() >= 1) {\n                polygon->push_back((*polygon)[0]);\n                result.push_back(Polygon());\n                polygon = &result.back();\n            }\n        } else {\n            if (code == agg::path_cmd_move_to && polygon->size() >= 1) {\n                polygon->push_back((*polygon)[0]);\n                result.push_back(Polygon());\n                polygon = &result.back();\n            }\n            polygon->push_back(XY(x, y));\n        }\n    }\n\n    if (polygon->size() == 0) {\n        result.pop_back();\n    }\n}\n\ntemplate <class VertexSource>\nvoid\n__cleanup_path(VertexSource &source, std::vector<double> &vertices, std::vector<npy_uint8> &codes)\n{\n    unsigned code;\n    double x, y;\n    do {\n        code = source.vertex(&x, &y);\n        vertices.push_back(x);\n        vertices.push_back(y);\n        codes.push_back((npy_uint8)code);\n    } while (code != agg::path_cmd_stop);\n}\n\ntemplate <class PathIterator>\nvoid cleanup_path(PathIterator &path,\n                  const agg::trans_affine &trans,\n                  bool remove_nans,\n                  bool do_clip,\n                  const agg::rect_base<double> &rect,\n                  e_snap_mode snap_mode,\n                  double stroke_width,\n                  bool do_simplify,\n                  bool return_curves,\n                  SketchParams sketch_params,\n                  std::vector<double> &vertices,\n                  std::vector<unsigned char> &codes)\n{\n    typedef agg::conv_transform<py::PathIterator> transformed_path_t;\n    typedef PathNanRemover<transformed_path_t> nan_removal_t;\n    typedef PathClipper<nan_removal_t> clipped_t;\n    typedef PathSnapper<clipped_t> snapped_t;\n    typedef PathSimplifier<snapped_t> simplify_t;\n    typedef agg::conv_curve<simplify_t> curve_t;\n    typedef Sketch<curve_t> sketch_t;\n\n    transformed_path_t tpath(path, trans);\n    nan_removal_t nan_removed(tpath, remove_nans, path.has_curves());\n    clipped_t clipped(nan_removed, do_clip, rect);\n    snapped_t snapped(clipped, snap_mode, path.total_vertices(), stroke_width);\n    simplify_t simplified(snapped, do_simplify, path.simplify_threshold());\n\n    vertices.reserve(path.total_vertices() * 2);\n    codes.reserve(path.total_vertices());\n\n    if (return_curves && sketch_params.scale == 0.0) {\n        __cleanup_path(simplified, vertices, codes);\n    } else {\n        curve_t curve(simplified);\n        sketch_t sketch(curve, sketch_params.scale, sketch_params.length, sketch_params.randomness);\n        __cleanup_path(sketch, vertices, codes);\n    }\n}\n\ntemplate <class PathIterator>\nvoid convert_to_svg(PathIterator &path,\n                    agg::trans_affine &trans,\n                    agg::rect_d &clip_rect,\n                    bool simplify,\n                    int precision,\n                    char *buffer,\n                    size_t *buffersize)\n{\n#if PY_VERSION_HEX < 0x02070000\n    char format[64];\n    snprintf(format, 64, \"%s.%dg\", \"%\", precision);\n#endif\n\n    typedef agg::conv_transform<py::PathIterator> transformed_path_t;\n    typedef PathNanRemover<transformed_path_t> nan_removal_t;\n    typedef PathClipper<nan_removal_t> clipped_t;\n    typedef PathSimplifier<clipped_t> simplify_t;\n\n    bool do_clip = (clip_rect.x1 < clip_rect.x2 && clip_rect.y1 < clip_rect.y2);\n\n    transformed_path_t tpath(path, trans);\n    nan_removal_t nan_removed(tpath, true, path.has_curves());\n    clipped_t clipped(nan_removed, do_clip, clip_rect);\n    simplify_t simplified(clipped, simplify, path.simplify_threshold());\n\n    char *p = buffer;\n\n    const char codes[] = { 'M', 'L', 'Q', 'C' };\n    const int waits[] = { 1, 1, 2, 3 };\n\n    int wait = 0;\n    unsigned code;\n    double x = 0, y = 0;\n    while ((code = simplified.vertex(&x, &y)) != agg::path_cmd_stop) {\n        if (wait == 0) {\n            *p++ = '\\n';\n\n            if (code == 0x4f) {\n                *p++ = 'z';\n                *p++ = '\\n';\n                continue;\n            }\n\n            *p++ = codes[code - 1];\n            wait = waits[code - 1];\n        } else {\n            *p++ = ' ';\n        }\n\n#if PY_VERSION_HEX >= 0x02070000\n        char *str;\n        str = PyOS_double_to_string(x, 'g', precision, 0, NULL);\n        p += snprintf(p, *buffersize - (p - buffer), \"%s\", str);\n        PyMem_Free(str);\n        *p++ = ' ';\n        str = PyOS_double_to_string(y, 'g', precision, 0, NULL);\n        p += snprintf(p, *buffersize - (p - buffer), \"%s\", str);\n        PyMem_Free(str);\n#else\n        char str[64];\n        PyOS_ascii_formatd(str, 64, format, x);\n        p += snprintf(p, *buffersize - (p - buffer), \"%s\", str);\n        *p++ = ' ';\n        PyOS_ascii_formatd(str, 64, format, y);\n        p += snprintf(p, *buffersize - (p - buffer), \"%s\", str);\n#endif\n\n        --wait;\n    }\n\n    *p = '\\0';\n    *buffersize = p - buffer;\n}\n\n#endif\n", "patch": "@@ -0,0 +1,978 @@\n+/* -*- mode: c++; c-basic-offset: 4 -*- */\n+\n+#ifndef __PATH_H__\n+#define __PATH_H__\n+\n+#include <limits>\n+#include <math.h>\n+#include <vector>\n+\n+#include \"agg_conv_contour.h\"\n+#include \"agg_conv_curve.h\"\n+#include \"agg_conv_stroke.h\"\n+#include \"agg_conv_transform.h\"\n+#include \"agg_path_storage.h\"\n+#include \"agg_trans_affine.h\"\n+\n+#include \"path_converters.h\"\n+#include \"_backend_agg_basic_types.h\"\n+\n+struct XY\n+{\n+    double x;\n+    double y;\n+\n+    XY(double x_, double y_) : x(x_), y(y_)\n+    {\n+    }\n+};\n+\n+//\n+// The following function was found in the Agg 2.3 examples (interactive_polygon.cpp).\n+// It has been generalized to work on (possibly curved) polylines, rather than\n+// just polygons.  The original comments have been kept intact.\n+//  -- Michael Droettboom 2007-10-02\n+//\n+//======= Crossings Multiply algorithm of InsideTest ========================\n+//\n+// By Eric Haines, 3D/Eye Inc, erich@eye.com\n+//\n+// This version is usually somewhat faster than the original published in\n+// Graphics Gems IV; by turning the division for testing the X axis crossing\n+// into a tricky multiplication test this part of the test became faster,\n+// which had the additional effect of making the test for \"both to left or\n+// both to right\" a bit slower for triangles than simply computing the\n+// intersection each time.  The main increase is in triangle testing speed,\n+// which was about 15% faster; all other polygon complexities were pretty much\n+// the same as before.  On machines where division is very expensive (not the\n+// case on the HP 9000 series on which I tested) this test should be much\n+// faster overall than the old code.  Your mileage may (in fact, will) vary,\n+// depending on the machine and the test data, but in general I believe this\n+// code is both shorter and faster.  This test was inspired by unpublished\n+// Graphics Gems submitted by Joseph Samosky and Mark Haigh-Hutchinson.\n+// Related work by Samosky is in:\n+//\n+// Samosky, Joseph, \"SectionView: A system for interactively specifying and\n+// visualizing sections through three-dimensional medical image data\",\n+// M.S. Thesis, Department of Electrical Engineering and Computer Science,\n+// Massachusetts Institute of Technology, 1993.\n+//\n+// Shoot a test ray along +X axis.  The strategy is to compare vertex Y values\n+// to the testing point's Y and quickly discard edges which are entirely to one\n+// side of the test ray.  Note that CONVEX and WINDING code can be added as\n+// for the CrossingsTest() code; it is left out here for clarity.\n+//\n+// Input 2D polygon _pgon_ with _numverts_ number of vertices and test point\n+// _point_, returns 1 if inside, 0 if outside.\n+template <class PathIterator, class PointArray, class ResultArray>\n+void point_in_path_impl(PointArray &points, PathIterator &path, ResultArray &inside_flag)\n+{\n+    int yflag1;\n+    double vtx0, vty0, vtx1, vty1;\n+    double tx, ty;\n+    double sx, sy;\n+    double x, y;\n+    size_t i;\n+    bool all_done;\n+\n+    size_t n = points.size();\n+\n+    std::vector<int> yflag0(n);\n+    std::vector<int> subpath_flag(n);\n+\n+    path.rewind(0);\n+\n+    for (i = 0; i < n; ++i) {\n+        inside_flag[i] = 0;\n+    }\n+\n+    unsigned code = 0;\n+    do {\n+        if (code != agg::path_cmd_move_to) {\n+            code = path.vertex(&x, &y);\n+            if (code == agg::path_cmd_stop ||\n+                (code & agg::path_cmd_end_poly) == agg::path_cmd_end_poly) {\n+                continue;\n+            }\n+        }\n+\n+        sx = vtx0 = vtx1 = x;\n+        sy = vty0 = vty1 = y;\n+\n+        for (i = 0; i < n; ++i) {\n+            ty = points[i][1];\n+\n+            // get test bit for above/below X axis\n+            yflag0[i] = (vty0 >= ty);\n+\n+            subpath_flag[i] = 0;\n+        }\n+\n+        do {\n+            code = path.vertex(&x, &y);\n+\n+            // The following cases denote the beginning on a new subpath\n+            if (code == agg::path_cmd_stop ||\n+                (code & agg::path_cmd_end_poly) == agg::path_cmd_end_poly) {\n+                x = sx;\n+                y = sy;\n+            } else if (code == agg::path_cmd_move_to) {\n+                break;\n+            }\n+\n+            for (i = 0; i < n; ++i) {\n+                tx = points[i][0];\n+                ty = points[i][1];\n+\n+                yflag1 = (vty1 >= ty);\n+                // Check if endpoints straddle (are on opposite sides) of\n+                // X axis (i.e. the Y's differ); if so, +X ray could\n+                // intersect this edge.  The old test also checked whether\n+                // the endpoints are both to the right or to the left of\n+                // the test point.  However, given the faster intersection\n+                // point computation used below, this test was found to be\n+                // a break-even proposition for most polygons and a loser\n+                // for triangles (where 50% or more of the edges which\n+                // survive this test will cross quadrants and so have to\n+                // have the X intersection computed anyway).  I credit\n+                // Joseph Samosky with inspiring me to try dropping the\n+                // \"both left or both right\" part of my code.\n+                if (yflag0[i] != yflag1) {\n+                    // Check intersection of pgon segment with +X ray.\n+                    // Note if >= point's X; if so, the ray hits it.  The\n+                    // division operation is avoided for the \">=\" test by\n+                    // checking the sign of the first vertex wrto the test\n+                    // point; idea inspired by Joseph Samosky's and Mark\n+                    // Haigh-Hutchinson's different polygon inclusion\n+                    // tests.\n+                    if (((vty1 - ty) * (vtx0 - vtx1) >= (vtx1 - tx) * (vty0 - vty1)) == yflag1) {\n+                        subpath_flag[i] ^= 1;\n+                    }\n+                }\n+\n+                // Move to the next pair of vertices, retaining info as\n+                // possible.\n+                yflag0[i] = yflag1;\n+            }\n+\n+            vtx0 = vtx1;\n+            vty0 = vty1;\n+\n+            vtx1 = x;\n+            vty1 = y;\n+        } while (code != agg::path_cmd_stop &&\n+                 (code & agg::path_cmd_end_poly) != agg::path_cmd_end_poly);\n+\n+        all_done = true;\n+        for (i = 0; i < n; ++i) {\n+            tx = points[i][0];\n+            ty = points[i][1];\n+\n+            yflag1 = (vty1 >= ty);\n+            if (yflag0[i] != yflag1) {\n+                if (((vty1 - ty) * (vtx0 - vtx1) >= (vtx1 - tx) * (vty0 - vty1)) == yflag1) {\n+                    subpath_flag[i] ^= 1;\n+                }\n+            }\n+            inside_flag[i] |= subpath_flag[i];\n+            if (inside_flag[i] == 0) {\n+                all_done = false;\n+            }\n+        }\n+\n+        if (all_done) {\n+            break;\n+        }\n+    } while (code != agg::path_cmd_stop);\n+}\n+\n+template <class PathIterator, class PointArray, class ResultArray>\n+inline void points_in_path(PointArray &points,\n+                           const double r,\n+                           PathIterator &path,\n+                           const agg::trans_affine &trans,\n+                           ResultArray &result)\n+{\n+    typedef agg::conv_transform<PathIterator> transformed_path_t;\n+    typedef PathNanRemover<transformed_path_t> no_nans_t;\n+    typedef agg::conv_curve<no_nans_t> curve_t;\n+    typedef agg::conv_contour<curve_t> contour_t;\n+\n+    size_t i;\n+    for (i = 0; i < result.size(); ++i) {\n+        result[i] = 0;\n+    }\n+\n+    if (path.total_vertices() < 3) {\n+        return;\n+    }\n+\n+    transformed_path_t trans_path(path, trans);\n+    no_nans_t no_nans_path(trans_path, true, path.has_curves());\n+    curve_t curved_path(no_nans_path);\n+    contour_t contoured_path(curved_path);\n+    contoured_path.width(r);\n+\n+    point_in_path_impl(points, contoured_path, result);\n+}\n+\n+template <class PathIterator>\n+inline bool point_in_path(\n+    double x, double y, const double r, PathIterator &path, const agg::trans_affine &trans)\n+{\n+    std::vector<double> point;\n+    std::vector<std::vector<double> > points;\n+    point.push_back(x);\n+    point.push_back(y);\n+    points.push_back(point);\n+\n+    std::vector<uint8_t> result(1);\n+    result[0] = 0;\n+\n+    points_in_path(points, r, path, trans, result);\n+\n+    return (bool)result[0];\n+}\n+\n+template <class PathIterator, class PointArray, class ResultArray>\n+void points_on_path(PointArray &points,\n+                    const double r,\n+                    PathIterator &path,\n+                    const agg::trans_affine &trans,\n+                    ResultArray result)\n+{\n+    typedef agg::conv_transform<PathIterator> transformed_path_t;\n+    typedef PathNanRemover<transformed_path_t> no_nans_t;\n+    typedef agg::conv_curve<no_nans_t> curve_t;\n+    typedef agg::conv_stroke<curve_t> stroke_t;\n+\n+    size_t i;\n+    for (i = 0; i < result.size(); ++i) {\n+        result[i] = 0;\n+    }\n+\n+    transformed_path_t trans_path(path, trans);\n+    no_nans_t nan_removed_path(trans_path, true, path.has_curves());\n+    curve_t curved_path(nan_removed_path);\n+    stroke_t stroked_path(curved_path);\n+    stroked_path.width(r * 2.0);\n+    point_in_path_impl(points, stroked_path, result);\n+}\n+\n+template <class PathIterator>\n+inline bool point_on_path(\n+    double x, double y, const double r, PathIterator &path, const agg::trans_affine &trans)\n+{\n+    std::vector<double> point;\n+    std::vector<std::vector<double> > points;\n+    point.push_back(x);\n+    point.push_back(y);\n+    points.push_back(point);\n+\n+    std::vector<uint8_t> result(1);\n+    result[0] = 0;\n+\n+    points_on_path(points, r, path, trans, result);\n+\n+    return (bool)result[0];\n+}\n+\n+struct extent_limits\n+{\n+    double x0;\n+    double y0;\n+    double x1;\n+    double y1;\n+    double xm;\n+    double ym;\n+};\n+\n+void reset_limits(extent_limits &e)\n+{\n+    e.x0 = std::numeric_limits<double>::infinity();\n+    e.y0 = std::numeric_limits<double>::infinity();\n+    e.x1 = -std::numeric_limits<double>::infinity();\n+    e.y1 = -std::numeric_limits<double>::infinity();\n+    /* xm and ym are the minimum positive values in the data, used\n+       by log scaling */\n+    e.xm = std::numeric_limits<double>::infinity();\n+    e.ym = std::numeric_limits<double>::infinity();\n+}\n+\n+inline void update_limits(double x, double y, extent_limits &e)\n+{\n+    if (x < e.x0)\n+        e.x0 = x;\n+    if (y < e.y0)\n+        e.y0 = y;\n+    if (x > e.x1)\n+        e.x1 = x;\n+    if (y > e.y1)\n+        e.y1 = y;\n+    /* xm and ym are the minimum positive values in the data, used\n+       by log scaling */\n+    if (x > 0.0 && x < e.xm)\n+        e.xm = x;\n+    if (y > 0.0 && y < e.ym)\n+        e.ym = y;\n+}\n+\n+template <class PathIterator>\n+void update_path_extents(PathIterator &path, const agg::trans_affine &trans, extent_limits &extents)\n+{\n+    typedef agg::conv_transform<PathIterator> transformed_path_t;\n+    typedef PathNanRemover<transformed_path_t> nan_removed_t;\n+    double x, y;\n+    unsigned code;\n+\n+    transformed_path_t tpath(path, trans);\n+    nan_removed_t nan_removed(tpath, true, path.has_curves());\n+\n+    nan_removed.rewind(0);\n+\n+    while ((code = nan_removed.vertex(&x, &y)) != agg::path_cmd_stop) {\n+        if ((code & agg::path_cmd_end_poly) == agg::path_cmd_end_poly) {\n+            continue;\n+        }\n+        update_limits(x, y, extents);\n+    }\n+}\n+\n+template <class PathGenerator, class TransformArray, class OffsetArray>\n+void get_path_collection_extents(agg::trans_affine &master_transform,\n+                                 PathGenerator &paths,\n+                                 TransformArray &transforms,\n+                                 OffsetArray &offsets,\n+                                 agg::trans_affine &offset_trans,\n+                                 extent_limits &extent)\n+{\n+    if (offsets.dim(0) != 0 && offsets.dim(1) != 2) {\n+        throw \"Offsets array must be Nx2\";\n+    }\n+\n+    size_t Npaths = paths.size();\n+    size_t Noffsets = offsets.size();\n+    size_t N = std::max(Npaths, Noffsets);\n+    size_t Ntransforms = std::min(transforms.size(), N);\n+    size_t i;\n+\n+    agg::trans_affine trans;\n+\n+    reset_limits(extent);\n+\n+    for (i = 0; i < N; ++i) {\n+        typename PathGenerator::path_iterator path(paths(i % Npaths));\n+        if (Ntransforms) {\n+            typename TransformArray::sub_t subtrans = transforms[i % Ntransforms];\n+            trans = agg::trans_affine(subtrans(0, 0),\n+                                      subtrans(1, 0),\n+                                      subtrans(0, 1),\n+                                      subtrans(1, 1),\n+                                      subtrans(0, 2),\n+                                      subtrans(1, 2));\n+        } else {\n+            trans = master_transform;\n+        }\n+\n+        if (Noffsets) {\n+            double xo = offsets(i % Noffsets, 0);\n+            double yo = offsets(i % Noffsets, 1);\n+            offset_trans.transform(&xo, &yo);\n+            trans *= agg::trans_affine_translation(xo, yo);\n+        }\n+\n+        update_path_extents(path, trans, extent);\n+    }\n+}\n+\n+template <class PathGenerator, class TransformArray, class OffsetArray>\n+void point_in_path_collection(double x,\n+                              double y,\n+                              double radius,\n+                              agg::trans_affine &master_transform,\n+                              PathGenerator &paths,\n+                              TransformArray &transforms,\n+                              OffsetArray &offsets,\n+                              agg::trans_affine &offset_trans,\n+                              bool filled,\n+                              e_offset_position offset_position,\n+                              std::vector<size_t> &result)\n+{\n+    size_t Npaths = paths.size();\n+\n+    if (Npaths == 0) {\n+        return;\n+    }\n+\n+    size_t Noffsets = offsets.dim(0);\n+    size_t N = std::max(Npaths, Noffsets);\n+    size_t Ntransforms = std::min(transforms.size(), N);\n+    size_t i;\n+\n+    agg::trans_affine trans;\n+\n+    for (i = 0; i < N; ++i) {\n+        typename PathGenerator::path_iterator path = paths(i % Npaths);\n+\n+        if (Ntransforms) {\n+            typename TransformArray::sub_t subtrans = transforms[i % Ntransforms];\n+            trans = agg::trans_affine(subtrans(0, 0),\n+                                      subtrans(1, 0),\n+                                      subtrans(0, 1),\n+                                      subtrans(1, 1),\n+                                      subtrans(0, 2),\n+                                      subtrans(1, 2));\n+        } else {\n+            trans = master_transform;\n+        }\n+\n+        if (Noffsets) {\n+            double xo = offsets(i % Noffsets, 0);\n+            double yo = offsets(i % Noffsets, 1);\n+            offset_trans.transform(&xo, &yo);\n+            if (offset_position == OFFSET_POSITION_DATA) {\n+                trans = agg::trans_affine_translation(xo, yo) * trans;\n+            } else {\n+                trans *= agg::trans_affine_translation(xo, yo);\n+            }\n+        }\n+\n+        if (filled) {\n+            if (point_in_path(x, y, radius, path, trans)) {\n+                result.push_back(i);\n+            }\n+        } else {\n+            if (point_on_path(x, y, radius, path, trans))\n+                result.push_back(i);\n+        }\n+    }\n+}\n+\n+template <class PathIterator1, class PathIterator2>\n+bool path_in_path(PathIterator1 &a,\n+                  const agg::trans_affine &atrans,\n+                  PathIterator2 &b,\n+                  const agg::trans_affine &btrans)\n+{\n+    typedef agg::conv_transform<PathIterator2> transformed_path_t;\n+    typedef PathNanRemover<transformed_path_t> no_nans_t;\n+    typedef agg::conv_curve<no_nans_t> curve_t;\n+\n+    if (a.total_vertices() < 3) {\n+        return false;\n+    }\n+\n+    transformed_path_t b_path_trans(b, btrans);\n+    no_nans_t b_no_nans(b_path_trans, true, b.has_curves());\n+    curve_t b_curved(b_no_nans);\n+\n+    double x, y;\n+    b_curved.rewind(0);\n+    while (b_curved.vertex(&x, &y) != agg::path_cmd_stop) {\n+        if (!point_in_path(x, y, 0.0, a, atrans)) {\n+            return false;\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+/** The clip_path_to_rect code here is a clean-room implementation of\n+    the Sutherland-Hodgman clipping algorithm described here:\n+\n+  http://en.wikipedia.org/wiki/Sutherland-Hodgman_clipping_algorithm\n+*/\n+\n+typedef std::vector<XY> Polygon;\n+\n+namespace clip_to_rect_filters\n+{\n+/* There are four different passes needed to create/remove\n+   vertices (one for each side of the rectangle).  The differences\n+   between those passes are encapsulated in these functor classes.\n+*/\n+struct bisectx\n+{\n+    double m_x;\n+\n+    bisectx(double x) : m_x(x)\n+    {\n+    }\n+\n+    inline void bisect(double sx, double sy, double px, double py, double *bx, double *by) const\n+    {\n+        *bx = m_x;\n+        double dx = px - sx;\n+        double dy = py - sy;\n+        *by = sy + dy * ((m_x - sx) / dx);\n+    }\n+};\n+\n+struct xlt : public bisectx\n+{\n+    xlt(double x) : bisectx(x)\n+    {\n+    }\n+\n+    inline bool is_inside(double x, double y) const\n+    {\n+        return x <= m_x;\n+    }\n+};\n+\n+struct xgt : public bisectx\n+{\n+    xgt(double x) : bisectx(x)\n+    {\n+    }\n+\n+    inline bool is_inside(double x, double y) const\n+    {\n+        return x >= m_x;\n+    }\n+};\n+\n+struct bisecty\n+{\n+    double m_y;\n+\n+    bisecty(double y) : m_y(y)\n+    {\n+    }\n+\n+    inline void bisect(double sx, double sy, double px, double py, double *bx, double *by) const\n+    {\n+        *by = m_y;\n+        double dx = px - sx;\n+        double dy = py - sy;\n+        *bx = sx + dx * ((m_y - sy) / dy);\n+    }\n+};\n+\n+struct ylt : public bisecty\n+{\n+    ylt(double y) : bisecty(y)\n+    {\n+    }\n+\n+    inline bool is_inside(double x, double y) const\n+    {\n+        return y <= m_y;\n+    }\n+};\n+\n+struct ygt : public bisecty\n+{\n+    ygt(double y) : bisecty(y)\n+    {\n+    }\n+\n+    inline bool is_inside(double x, double y) const\n+    {\n+        return y >= m_y;\n+    }\n+};\n+}\n+\n+template <class Filter>\n+inline void clip_to_rect_one_step(const Polygon &polygon, Polygon &result, const Filter &filter)\n+{\n+    double sx, sy, px, py, bx, by;\n+    bool sinside, pinside;\n+    result.clear();\n+\n+    if (polygon.size() == 0) {\n+        return;\n+    }\n+\n+    sx = polygon.back().x;\n+    sy = polygon.back().y;\n+    for (Polygon::const_iterator i = polygon.begin(); i != polygon.end(); ++i) {\n+        px = i->x;\n+        py = i->y;\n+\n+        sinside = filter.is_inside(sx, sy);\n+        pinside = filter.is_inside(px, py);\n+\n+        if (sinside ^ pinside) {\n+            filter.bisect(sx, sy, px, py, &bx, &by);\n+            result.push_back(XY(bx, by));\n+        }\n+\n+        if (pinside) {\n+            result.push_back(XY(px, py));\n+        }\n+\n+        sx = px;\n+        sy = py;\n+    }\n+}\n+\n+template <class PathIterator>\n+void\n+clip_path_to_rect(PathIterator &path, agg::rect_d &rect, bool inside, std::vector<Polygon> &results)\n+{\n+    double xmin, ymin, xmax, ymax;\n+    if (rect.x1 < rect.x2) {\n+        xmin = rect.x1;\n+        xmax = rect.x2;\n+    } else {\n+        xmin = rect.x2;\n+        xmax = rect.x1;\n+    }\n+\n+    if (rect.y1 < rect.y2) {\n+        ymin = rect.y1;\n+        ymax = rect.y2;\n+    } else {\n+        ymin = rect.y2;\n+        ymax = rect.y1;\n+    }\n+\n+    if (!inside) {\n+        std::swap(xmin, xmax);\n+        std::swap(ymin, ymax);\n+    }\n+\n+    typedef agg::conv_curve<PathIterator> curve_t;\n+    curve_t curve(path);\n+\n+    Polygon polygon1, polygon2;\n+    double x = 0, y = 0;\n+    unsigned code = 0;\n+    curve.rewind(0);\n+\n+    do {\n+        // Grab the next subpath and store it in polygon1\n+        polygon1.clear();\n+        do {\n+            if (code == agg::path_cmd_move_to) {\n+                polygon1.push_back(XY(x, y));\n+            }\n+\n+            code = curve.vertex(&x, &y);\n+\n+            if (code == agg::path_cmd_stop) {\n+                break;\n+            }\n+\n+            if (code != agg::path_cmd_move_to) {\n+                polygon1.push_back(XY(x, y));\n+            }\n+        } while ((code & agg::path_cmd_end_poly) != agg::path_cmd_end_poly);\n+\n+        // The result of each step is fed into the next (note the\n+        // swapping of polygon1 and polygon2 at each step).\n+        clip_to_rect_one_step(polygon1, polygon2, clip_to_rect_filters::xlt(xmax));\n+        clip_to_rect_one_step(polygon2, polygon1, clip_to_rect_filters::xgt(xmin));\n+        clip_to_rect_one_step(polygon1, polygon2, clip_to_rect_filters::ylt(ymax));\n+        clip_to_rect_one_step(polygon2, polygon1, clip_to_rect_filters::ygt(ymin));\n+\n+        // Empty polygons aren't very useful, so skip them\n+        if (polygon1.size()) {\n+            results.push_back(polygon1);\n+        }\n+    } while (code != agg::path_cmd_stop);\n+}\n+\n+template <class VerticesArray, class ResultArray>\n+void affine_transform(VerticesArray &vertices, agg::trans_affine &trans, ResultArray &result)\n+{\n+    if (vertices.dim(0) != 0 && vertices.dim(1) != 2) {\n+        throw \"Invalid vertices array.\";\n+    }\n+\n+    size_t n = vertices.dim(0);\n+    double x;\n+    double y;\n+    double t0;\n+    double t1;\n+    double t;\n+\n+    for (size_t i = 0; i < n; ++i) {\n+        x = vertices(i, 0);\n+        y = vertices(i, 1);\n+\n+        t0 = trans.sx * x;\n+        t1 = trans.shx * y;\n+        t = t0 + t1 + trans.tx;\n+        result(i, 0) = t;\n+\n+        t0 = trans.shy * x;\n+        t1 = trans.sy * y;\n+        t = t0 + t1 + trans.ty;\n+        result(i, 1) = t;\n+    }\n+}\n+\n+template <class BBoxArray>\n+int count_bboxes_overlapping_bbox(agg::rect_d &a, BBoxArray &bboxes)\n+{\n+    agg::rect_d b;\n+    int count = 0;\n+\n+    if (a.x2 < a.x1) {\n+        std::swap(a.x1, a.x2);\n+    }\n+    if (a.y2 < a.y1) {\n+        std::swap(a.y1, a.y2);\n+    }\n+\n+    size_t num_bboxes = bboxes.size();\n+    for (size_t i = 0; i < num_bboxes; ++i) {\n+        typename BBoxArray::sub_t bbox_b = bboxes[i];\n+        b = agg::rect_d(bbox_b(0, 0), bbox_b(0, 1), bbox_b(1, 0), bbox_b(1, 1));\n+\n+        if (b.x2 < b.x1) {\n+            std::swap(b.x1, b.x2);\n+        }\n+        if (b.y2 < b.y1) {\n+            std::swap(b.y1, b.y2);\n+        }\n+        if (!((b.x2 <= a.x1) || (b.y2 <= a.y1) || (b.x1 >= a.x2) || (b.y1 >= a.y2))) {\n+            ++count;\n+        }\n+    }\n+\n+    return count;\n+}\n+\n+inline bool segments_intersect(const double &x1,\n+                               const double &y1,\n+                               const double &x2,\n+                               const double &y2,\n+                               const double &x3,\n+                               const double &y3,\n+                               const double &x4,\n+                               const double &y4)\n+{\n+    double den = ((y4 - y3) * (x2 - x1)) - ((x4 - x3) * (y2 - y1));\n+    if (den == 0.0) {\n+        return false;\n+    }\n+\n+    double n1 = ((x4 - x3) * (y1 - y3)) - ((y4 - y3) * (x1 - x3));\n+    double n2 = ((x2 - x1) * (y1 - y3)) - ((y2 - y1) * (x1 - x3));\n+\n+    double u1 = n1 / den;\n+    double u2 = n2 / den;\n+\n+    return (u1 >= 0.0 && u1 <= 1.0 && u2 >= 0.0 && u2 <= 1.0);\n+}\n+\n+template <class PathIterator1, class PathIterator2>\n+bool path_intersects_path(PathIterator1 &p1, PathIterator2 &p2)\n+{\n+    typedef PathNanRemover<py::PathIterator> no_nans_t;\n+    typedef agg::conv_curve<no_nans_t> curve_t;\n+\n+    if (p1.total_vertices() < 2 || p2.total_vertices() < 2) {\n+        return false;\n+    }\n+\n+    no_nans_t n1(p1, true, p1.has_curves());\n+    no_nans_t n2(p2, true, p2.has_curves());\n+\n+    curve_t c1(n1);\n+    curve_t c2(n2);\n+\n+    double x11, y11, x12, y12;\n+    double x21, y21, x22, y22;\n+\n+    c1.vertex(&x11, &y11);\n+    while (c1.vertex(&x12, &y12) != agg::path_cmd_stop) {\n+        c2.rewind(0);\n+        c2.vertex(&x21, &y21);\n+        while (c2.vertex(&x22, &y22) != agg::path_cmd_stop) {\n+            if (segments_intersect(x11, y11, x12, y12, x21, y21, x22, y22)) {\n+                return true;\n+            }\n+            x21 = x22;\n+            y21 = y22;\n+        }\n+        x11 = x12;\n+        y11 = y12;\n+    }\n+\n+    return false;\n+}\n+\n+template <class PathIterator>\n+void convert_path_to_polygons(PathIterator &path,\n+                              agg::trans_affine &trans,\n+                              double width,\n+                              double height,\n+                              std::vector<Polygon> &result)\n+{\n+    typedef agg::conv_transform<py::PathIterator> transformed_path_t;\n+    typedef PathNanRemover<transformed_path_t> nan_removal_t;\n+    typedef PathClipper<nan_removal_t> clipped_t;\n+    typedef PathSimplifier<clipped_t> simplify_t;\n+    typedef agg::conv_curve<simplify_t> curve_t;\n+\n+    bool do_clip = width != 0.0 && height != 0.0;\n+    bool simplify = path.should_simplify();\n+\n+    transformed_path_t tpath(path, trans);\n+    nan_removal_t nan_removed(tpath, true, path.has_curves());\n+    clipped_t clipped(nan_removed, do_clip, width, height);\n+    simplify_t simplified(clipped, simplify, path.simplify_threshold());\n+    curve_t curve(simplified);\n+\n+    result.push_back(Polygon());\n+    Polygon *polygon = &result.back();\n+    double x, y;\n+    unsigned code;\n+\n+    while ((code = curve.vertex(&x, &y)) != agg::path_cmd_stop) {\n+        if ((code & agg::path_cmd_end_poly) == agg::path_cmd_end_poly) {\n+            if (polygon->size() >= 1) {\n+                polygon->push_back((*polygon)[0]);\n+                result.push_back(Polygon());\n+                polygon = &result.back();\n+            }\n+        } else {\n+            if (code == agg::path_cmd_move_to && polygon->size() >= 1) {\n+                polygon->push_back((*polygon)[0]);\n+                result.push_back(Polygon());\n+                polygon = &result.back();\n+            }\n+            polygon->push_back(XY(x, y));\n+        }\n+    }\n+\n+    if (polygon->size() == 0) {\n+        result.pop_back();\n+    }\n+}\n+\n+template <class VertexSource>\n+void\n+__cleanup_path(VertexSource &source, std::vector<double> &vertices, std::vector<npy_uint8> &codes)\n+{\n+    unsigned code;\n+    double x, y;\n+    do {\n+        code = source.vertex(&x, &y);\n+        vertices.push_back(x);\n+        vertices.push_back(y);\n+        codes.push_back((npy_uint8)code);\n+    } while (code != agg::path_cmd_stop);\n+}\n+\n+template <class PathIterator>\n+void cleanup_path(PathIterator &path,\n+                  const agg::trans_affine &trans,\n+                  bool remove_nans,\n+                  bool do_clip,\n+                  const agg::rect_base<double> &rect,\n+                  e_snap_mode snap_mode,\n+                  double stroke_width,\n+                  bool do_simplify,\n+                  bool return_curves,\n+                  SketchParams sketch_params,\n+                  std::vector<double> &vertices,\n+                  std::vector<unsigned char> &codes)\n+{\n+    typedef agg::conv_transform<py::PathIterator> transformed_path_t;\n+    typedef PathNanRemover<transformed_path_t> nan_removal_t;\n+    typedef PathClipper<nan_removal_t> clipped_t;\n+    typedef PathSnapper<clipped_t> snapped_t;\n+    typedef PathSimplifier<snapped_t> simplify_t;\n+    typedef agg::conv_curve<simplify_t> curve_t;\n+    typedef Sketch<curve_t> sketch_t;\n+\n+    transformed_path_t tpath(path, trans);\n+    nan_removal_t nan_removed(tpath, remove_nans, path.has_curves());\n+    clipped_t clipped(nan_removed, do_clip, rect);\n+    snapped_t snapped(clipped, snap_mode, path.total_vertices(), stroke_width);\n+    simplify_t simplified(snapped, do_simplify, path.simplify_threshold());\n+\n+    vertices.reserve(path.total_vertices() * 2);\n+    codes.reserve(path.total_vertices());\n+\n+    if (return_curves && sketch_params.scale == 0.0) {\n+        __cleanup_path(simplified, vertices, codes);\n+    } else {\n+        curve_t curve(simplified);\n+        sketch_t sketch(curve, sketch_params.scale, sketch_params.length, sketch_params.randomness);\n+        __cleanup_path(sketch, vertices, codes);\n+    }\n+}\n+\n+template <class PathIterator>\n+void convert_to_svg(PathIterator &path,\n+                    agg::trans_affine &trans,\n+                    agg::rect_d &clip_rect,\n+                    bool simplify,\n+                    int precision,\n+                    char *buffer,\n+                    size_t *buffersize)\n+{\n+#if PY_VERSION_HEX < 0x02070000\n+    char format[64];\n+    snprintf(format, 64, \"%s.%dg\", \"%\", precision);\n+#endif\n+\n+    typedef agg::conv_transform<py::PathIterator> transformed_path_t;\n+    typedef PathNanRemover<transformed_path_t> nan_removal_t;\n+    typedef PathClipper<nan_removal_t> clipped_t;\n+    typedef PathSimplifier<clipped_t> simplify_t;\n+\n+    bool do_clip = (clip_rect.x1 < clip_rect.x2 && clip_rect.y1 < clip_rect.y2);\n+\n+    transformed_path_t tpath(path, trans);\n+    nan_removal_t nan_removed(tpath, true, path.has_curves());\n+    clipped_t clipped(nan_removed, do_clip, clip_rect);\n+    simplify_t simplified(clipped, simplify, path.simplify_threshold());\n+\n+    char *p = buffer;\n+\n+    const char codes[] = { 'M', 'L', 'Q', 'C' };\n+    const int waits[] = { 1, 1, 2, 3 };\n+\n+    int wait = 0;\n+    unsigned code;\n+    double x = 0, y = 0;\n+    while ((code = simplified.vertex(&x, &y)) != agg::path_cmd_stop) {\n+        if (wait == 0) {\n+            *p++ = '\\n';\n+\n+            if (code == 0x4f) {\n+                *p++ = 'z';\n+                *p++ = '\\n';\n+                continue;\n+            }\n+\n+            *p++ = codes[code - 1];\n+            wait = waits[code - 1];\n+        } else {\n+            *p++ = ' ';\n+        }\n+\n+#if PY_VERSION_HEX >= 0x02070000\n+        char *str;\n+        str = PyOS_double_to_string(x, 'g', precision, 0, NULL);\n+        p += snprintf(p, *buffersize - (p - buffer), \"%s\", str);\n+        PyMem_Free(str);\n+        *p++ = ' ';\n+        str = PyOS_double_to_string(y, 'g', precision, 0, NULL);\n+        p += snprintf(p, *buffersize - (p - buffer), \"%s\", str);\n+        PyMem_Free(str);\n+#else\n+        char str[64];\n+        PyOS_ascii_formatd(str, 64, format, x);\n+        p += snprintf(p, *buffersize - (p - buffer), \"%s\", str);\n+        *p++ = ' ';\n+        PyOS_ascii_formatd(str, 64, format, y);\n+        p += snprintf(p, *buffersize - (p - buffer), \"%s\", str);\n+#endif\n+\n+        --wait;\n+    }\n+\n+    *p = '\\0';\n+    *buffersize = p - buffer;\n+}\n+\n+#endif"}
{"patches_id": 2, "files_id": 41, "language": "cpp", "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_path_wrapper.cpp", "raw_code": "#include \"_path.h\"\n\n#include \"py_converters.h\"\n#include \"py_adaptors.h\"\n\nPyObject *convert_polygon_vector(std::vector<Polygon> &polygons)\n{\n    PyObject *pyresult = PyList_New(polygons.size());\n\n    for (size_t i = 0; i < polygons.size(); ++i) {\n        Polygon poly = polygons[i];\n        npy_intp dims[] = {(npy_intp)poly.size() + 1, 2 };\n        numpy::array_view<double, 2> subresult(dims);\n\n        /* Make last point same as first. */\n        memcpy(subresult.data(), &poly[0], sizeof(double) * poly.size() * 2);\n        subresult(poly.size(), 0) = poly[0].x;\n        subresult(poly.size(), 1) = poly[0].y;\n\n        if (PyList_SetItem(pyresult, i, subresult.pyobj())) {\n            Py_DECREF(pyresult);\n            return NULL;\n        }\n    }\n\n    return pyresult;\n}\n\nconst char *Py_point_in_path__doc__ = \"point_in_path(x, y, radius, path, trans)\";\n\nstatic PyObject *Py_point_in_path(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    double x, y, r;\n    py::PathIterator path;\n    agg::trans_affine trans;\n    bool result;\n\n    if (!PyArg_ParseTuple(args,\n                          \"dddO&O&:point_in_path\",\n                          &x,\n                          &y,\n                          &r,\n                          &convert_path,\n                          &path,\n                          &convert_trans_affine,\n                          &trans)) {\n        return NULL;\n    }\n\n    CALL_CPP(\"point_in_path\", (result = point_in_path(x, y, r, path, trans)));\n\n    if (result) {\n        Py_RETURN_TRUE;\n    } else {\n        Py_RETURN_FALSE;\n    }\n}\n\nconst char *Py_points_in_path__doc__ = \"points_in_path(points, radius, path, trans)\";\n\nstatic PyObject *Py_points_in_path(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    numpy::array_view<const double, 2> points;\n    double r;\n    py::PathIterator path;\n    agg::trans_affine trans;\n\n    if (!PyArg_ParseTuple(args,\n                          \"O&dO&O&:points_in_path\",\n                          &numpy::convert_array<const double, 2>,\n                          &points,\n                          &r,\n                          &convert_path,\n                          &path,\n                          &convert_trans_affine,\n                          &trans)) {\n        return NULL;\n    }\n\n    npy_intp dims[] = { points.dim(0) };\n    numpy::array_view<uint8_t, 1> results(dims);\n\n    CALL_CPP(\"points_in_path\", (points_in_path(points, r, path, trans, results)));\n\n    return results.pyobj();\n}\n\nconst char *Py_point_on_path__doc__ = \"point_on_path(x, y, radius, path, trans)\";\n\nstatic PyObject *Py_point_on_path(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    double x, y, r;\n    py::PathIterator path;\n    agg::trans_affine trans;\n    bool result;\n\n    if (!PyArg_ParseTuple(args,\n                          \"dddO&O&:point_on_path\",\n                          &x,\n                          &y,\n                          &r,\n                          &convert_path,\n                          &path,\n                          &convert_trans_affine,\n                          &trans)) {\n        return NULL;\n    }\n\n    CALL_CPP(\"point_on_path\", (result = point_on_path(x, y, r, path, trans)));\n\n    if (result) {\n        Py_RETURN_TRUE;\n    } else {\n        Py_RETURN_FALSE;\n    }\n}\n\nconst char *Py_points_on_path__doc__ = \"points_on_path(points, radius, path, trans)\";\n\nstatic PyObject *Py_points_on_path(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    numpy::array_view<const double, 2> points;\n    double r;\n    py::PathIterator path;\n    agg::trans_affine trans;\n\n    if (!PyArg_ParseTuple(args,\n                          \"O&dO&O&:points_on_path\",\n                          &numpy::convert_array<const double, 2>,\n                          &points,\n                          &r,\n                          &convert_path,\n                          &path,\n                          &convert_trans_affine,\n                          &trans)) {\n        return NULL;\n    }\n\n    npy_intp dims[] = { points.dim(0) };\n    numpy::array_view<uint8_t, 1> results(dims);\n\n    CALL_CPP(\"points_on_path\", (points_on_path(points, r, path, trans, results)));\n\n    return results.pyobj();\n}\n\nconst char *Py_get_path_extents__doc__ = \"get_path_extents(path, trans)\";\n\nstatic PyObject *Py_get_path_extents(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    py::PathIterator path;\n    agg::trans_affine trans;\n\n    if (!PyArg_ParseTuple(\n             args, \"O&O&:get_path_extents\", &convert_path, &path, &convert_trans_affine, &trans)) {\n        return NULL;\n    }\n\n    extent_limits e;\n\n    CALL_CPP(\"get_path_extents\", (reset_limits(e)));\n    CALL_CPP(\"get_path_extents\", (update_path_extents(path, trans, e)));\n\n    npy_intp dims[] = { 2, 2 };\n    numpy::array_view<double, 2> extents(dims);\n    extents(0, 0) = e.x0;\n    extents(0, 1) = e.y0;\n    extents(1, 0) = e.x1;\n    extents(1, 1) = e.y1;\n\n    return extents.pyobj();\n}\n\nconst char *Py_update_path_extents__doc__ =\n    \"update_path_extents(path, trans, rect, minpos, ignore)\";\n\nstatic PyObject *Py_update_path_extents(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    py::PathIterator path;\n    agg::trans_affine trans;\n    agg::rect_d rect;\n    numpy::array_view<double, 1> minpos;\n    bool ignore;\n    bool changed;\n\n    if (!PyArg_ParseTuple(args,\n                          \"O&O&O&O&i:update_path_extents\",\n                          &convert_path,\n                          &path,\n                          &convert_trans_affine,\n                          &trans,\n                          &convert_rect,\n                          &rect,\n                          &numpy::convert_array<double, 1>,\n                          &minpos,\n                          &ignore)) {\n        return NULL;\n    }\n\n    if (minpos.dim(0) != 2) {\n        PyErr_SetString(PyExc_ValueError, \"minpos must be of length 2\");\n    }\n\n    extent_limits e;\n\n    if (ignore) {\n        CALL_CPP(\"update_path_extents\", reset_limits(e));\n    } else {\n        if (rect.x1 > rect.x2) {\n            e.x0 = std::numeric_limits<double>::infinity();\n            e.x1 = -std::numeric_limits<double>::infinity();\n        } else {\n            e.x0 = rect.x1;\n            e.x1 = rect.x2;\n        }\n        if (rect.y1 > rect.y2) {\n            e.y0 = std::numeric_limits<double>::infinity();\n            e.y1 = -std::numeric_limits<double>::infinity();\n        } else {\n            e.y0 = rect.y1;\n            e.y1 = rect.y2;\n        }\n        e.xm = minpos(0);\n        e.ym = minpos(1);\n    }\n\n    CALL_CPP(\"update_path_extents\", (update_path_extents(path, trans, e)));\n\n    changed = (e.x0 != rect.x1 || e.y0 != rect.y1 || e.x1 != rect.x2 || e.y1 != rect.y2 ||\n               e.xm != minpos(0) || e.ym != minpos(1));\n\n    npy_intp extentsdims[] = { 2, 2 };\n    numpy::array_view<double, 2> outextents(extentsdims);\n    outextents(0, 0) = e.x0;\n    outextents(0, 1) = e.y0;\n    outextents(1, 0) = e.x1;\n    outextents(1, 1) = e.y1;\n\n    npy_intp minposdims[] = { 2 };\n    numpy::array_view<double, 1> outminpos(minposdims);\n    outminpos(0) = e.xm;\n    outminpos(1) = e.ym;\n\n    return Py_BuildValue(\n        \"NNO\", outextents.pyobj(), outminpos.pyobj(), changed ? Py_True : Py_False);\n}\n\nconst char *Py_get_path_collection_extents__doc__ = \"get_path_collection_extents(\";\n\nstatic PyObject *Py_get_path_collection_extents(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    agg::trans_affine master_transform;\n    PyObject *pathsobj;\n    numpy::array_view<const double, 3> transforms;\n    numpy::array_view<const double, 2> offsets;\n    agg::trans_affine offset_trans;\n    extent_limits e;\n\n    if (!PyArg_ParseTuple(args,\n                          \"O&OO&O&O&:get_path_collection_extents\",\n                          &convert_trans_affine,\n                          &master_transform,\n                          &pathsobj,\n                          &numpy::convert_array<const double, 3>,\n                          &transforms,\n                          &numpy::convert_array<const double, 2>,\n                          &offsets,\n                          &convert_trans_affine,\n                          &offset_trans)) {\n        return NULL;\n    }\n\n    try\n    {\n        py::PathGenerator paths(pathsobj);\n\n        CALL_CPP(\"get_path_collection_extents\",\n                 (get_path_collection_extents(\n                     master_transform, paths, transforms, offsets, offset_trans, e)));\n    }\n    catch (py::exception &e)\n    {\n        return NULL;\n    }\n\n    npy_intp dims[] = { 2, 2 };\n    numpy::array_view<double, 2> extents(dims);\n    extents(0, 0) = e.x0;\n    extents(0, 1) = e.y0;\n    extents(1, 0) = e.x1;\n    extents(1, 1) = e.y1;\n\n    return extents.pyobj();\n}\n\nconst char *Py_point_in_path_collection__doc__ =\n    \"point_in_path_collection(x, y, radius, master_transform, paths, transforms, offsets, \"\n    \"offset_trans, filled, offset_position)\";\n\nstatic PyObject *Py_point_in_path_collection(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    double x, y, radius;\n    agg::trans_affine master_transform;\n    PyObject *pathsobj;\n    numpy::array_view<const double, 3> transforms;\n    numpy::array_view<const double, 2> offsets;\n    agg::trans_affine offset_trans;\n    int filled;\n    e_offset_position offset_position;\n    std::vector<size_t> result;\n\n    if (!PyArg_ParseTuple(args,\n                          \"dddO&OO&O&O&iO&:point_in_path_collection\",\n                          &x,\n                          &y,\n                          &radius,\n                          &convert_trans_affine,\n                          &master_transform,\n                          &pathsobj,\n                          &numpy::convert_array<const double, 3>,\n                          &transforms,\n                          &numpy::convert_array<const double, 2>,\n                          &offsets,\n                          &convert_trans_affine,\n                          &offset_trans,\n                          &filled,\n                          &convert_offset_position,\n                          &offset_position)) {\n        return NULL;\n    }\n\n    try\n    {\n        py::PathGenerator paths(pathsobj);\n\n        CALL_CPP(\"point_in_path_collection\",\n                 (point_in_path_collection(x,\n                                           y,\n                                           radius,\n                                           master_transform,\n                                           paths,\n                                           transforms,\n                                           offsets,\n                                           offset_trans,\n                                           filled,\n                                           offset_position,\n                                           result)));\n    }\n    catch (py::exception &e)\n    {\n        return NULL;\n    }\n\n    npy_intp dims[] = {(npy_intp)result.size() };\n    numpy::array_view<size_t, 1> pyresult(dims);\n    memcpy(pyresult.data(), &result[0], result.size() * sizeof(size_t));\n    return pyresult.pyobj();\n}\n\nconst char *Py_path_in_path__doc__ = \"path_in_path(path_a, trans_a, path_b, trans_b)\";\n\nstatic PyObject *Py_path_in_path(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    py::PathIterator a;\n    agg::trans_affine atrans;\n    py::PathIterator b;\n    agg::trans_affine btrans;\n    bool result;\n\n    if (!PyArg_ParseTuple(args,\n                          \"O&O&O&O&:path_in_path\",\n                          &convert_path,\n                          &a,\n                          &convert_trans_affine,\n                          &atrans,\n                          &convert_path,\n                          &b,\n                          &convert_trans_affine,\n                          &btrans)) {\n        return NULL;\n    }\n\n    CALL_CPP(\"path_in_path\", (result = path_in_path(a, atrans, b, btrans)));\n\n    if (result) {\n        Py_RETURN_TRUE;\n    } else {\n        Py_RETURN_FALSE;\n    }\n}\n\nconst char *Py_clip_path_to_rect__doc__ = \"clip_path_to_rect(path, rect, inside)\";\n\nstatic PyObject *Py_clip_path_to_rect(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    py::PathIterator path;\n    agg::rect_d rect;\n    int inside;\n    std::vector<Polygon> result;\n\n    if (!PyArg_ParseTuple(args,\n                          \"O&O&i:clip_path_to_rect\",\n                          &convert_path,\n                          &path,\n                          &convert_rect,\n                          &rect,\n                          &inside)) {\n        return NULL;\n    }\n\n    CALL_CPP(\"clip_path_to_rect\", (clip_path_to_rect(path, rect, inside, result)));\n\n    return convert_polygon_vector(result);\n}\n\nconst char *Py_affine_transform__doc__ = \"affine_transform(points, trans)\";\n\nstatic PyObject *Py_affine_transform(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    numpy::array_view<const double, 2> vertices;\n    agg::trans_affine trans;\n\n    if (!PyArg_ParseTuple(args,\n                          \"O&O&:affine_transform\",\n                          &numpy::convert_array<const double, 2>,\n                          &vertices,\n                          &convert_trans_affine,\n                          &trans)) {\n        return NULL;\n    }\n\n    npy_intp dims[] = { vertices.dim(0), 2 };\n    numpy::array_view<double, 2> result(dims);\n\n    CALL_CPP(\"affine_transform\", (affine_transform(vertices, trans, result)));\n\n    return result.pyobj();\n}\n\nconst char *Py_count_bboxes_overlapping_bbox__doc__ = \"count_bboxes_overlapping_bbox(bbox, bboxes)\";\n\nstatic PyObject *Py_count_bboxes_overlapping_bbox(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    agg::rect_d bbox;\n    numpy::array_view<const double, 3> bboxes;\n    int result;\n\n    if (!PyArg_ParseTuple(args,\n                          \"O&O&:count_bboxes_overlapping_bbox\",\n                          &convert_rect,\n                          &bbox,\n                          &numpy::convert_array<const double, 3>,\n                          &bboxes)) {\n        return NULL;\n    }\n\n    CALL_CPP(\"count_bboxes_overlapping_bbox\",\n             (result = count_bboxes_overlapping_bbox(bbox, bboxes)));\n\n    return PyLong_FromLong(result);\n}\n\nconst char *Py_path_intersects_path__doc__ = \"path_intersects_path(path1, path2, filled=False)\";\n\nstatic PyObject *Py_path_intersects_path(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    py::PathIterator p1;\n    py::PathIterator p2;\n    bool filled = false;\n    const char *names[] = { \"p1\", \"p2\", \"filled\", NULL };\n    bool result;\n\n    if (!PyArg_ParseTupleAndKeywords(args,\n                                     kwds,\n                                     \"O&O&i:path_intersects_path\",\n                                     (char **)names,\n                                     &convert_path,\n                                     &p1,\n                                     &convert_path,\n                                     &p2,\n                                     &filled)) {\n        return NULL;\n    }\n\n    CALL_CPP(\"path_intersects_path\", (result = path_intersects_path(p1, p2)));\n    if (filled) {\n        if (!result) {\n            CALL_CPP(\"path_intersects_path\",\n                     (result = path_in_path(p1, agg::trans_affine(), p2, agg::trans_affine())));\n        }\n        if (!result) {\n            CALL_CPP(\"path_intersects_path\",\n                     (result = path_in_path(p2, agg::trans_affine(), p1, agg::trans_affine())));\n        }\n    }\n\n    if (result) {\n        Py_RETURN_TRUE;\n    } else {\n        Py_RETURN_FALSE;\n    }\n}\n\nconst char *Py_convert_path_to_polygons__doc__ =\n    \"convert_path_to_polygons(path, trans, width=0, height=0)\";\n\nstatic PyObject *Py_convert_path_to_polygons(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    py::PathIterator path;\n    agg::trans_affine trans;\n    double width = 0.0, height = 0.0;\n    std::vector<Polygon> result;\n\n    if (!PyArg_ParseTuple(args,\n                          \"O&O&|dd:convert_path_to_polygons\",\n                          &convert_path,\n                          &path,\n                          &convert_trans_affine,\n                          &trans,\n                          &width,\n                          &height)) {\n        return NULL;\n    }\n\n    CALL_CPP(\"convert_path_to_polygons\",\n             (convert_path_to_polygons(path, trans, width, height, result)));\n\n    return convert_polygon_vector(result);\n}\n\nconst char *Py_cleanup_path__doc__ =\n    \"cleanup_path(path, trans, remove_nans, clip_rect, snap_mode, stroke_width, simplify, \"\n    \"return_curves, sketch)\";\n\nstatic PyObject *Py_cleanup_path(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    py::PathIterator path;\n    agg::trans_affine trans;\n    int remove_nans;\n    agg::rect_d clip_rect;\n    e_snap_mode snap_mode;\n    double stroke_width;\n    PyObject *simplifyobj;\n    bool simplify = false;\n    int return_curves;\n    SketchParams sketch;\n\n    if (!PyArg_ParseTuple(args,\n                          \"O&O&iO&O&dOiO&:cleanup_path\",\n                          &convert_path,\n                          &path,\n                          &convert_trans_affine,\n                          &trans,\n                          &remove_nans,\n                          &convert_rect,\n                          &clip_rect,\n                          &convert_snap,\n                          &snap_mode,\n                          &stroke_width,\n                          &simplifyobj,\n                          &return_curves,\n                          &convert_sketch_params,\n                          &sketch)) {\n        return NULL;\n    }\n\n    if (simplifyobj == Py_None) {\n        simplify = path.should_simplify();\n    } else if (PyObject_IsTrue(simplifyobj)) {\n        simplify = true;\n    }\n\n    bool do_clip = (clip_rect.x1 < clip_rect.x2 && clip_rect.y1 < clip_rect.y2);\n\n    std::vector<double> vertices;\n    std::vector<npy_uint8> codes;\n\n    CALL_CPP(\"cleanup_path\",\n             (cleanup_path(path,\n                           trans,\n                           remove_nans,\n                           do_clip,\n                           clip_rect,\n                           snap_mode,\n                           stroke_width,\n                           simplify,\n                           return_curves,\n                           sketch,\n                           vertices,\n                           codes)));\n\n    size_t length = codes.size();\n\n    npy_intp vertices_dims[] = {(npy_intp)length, 2 };\n    numpy::array_view<double, 2> pyvertices(vertices_dims);\n\n    npy_intp codes_dims[] = {(npy_intp)length };\n    numpy::array_view<unsigned char, 1> pycodes(codes_dims);\n\n    memcpy(pyvertices.data(), &vertices[0], sizeof(double) * 2 * length);\n    memcpy(pycodes.data(), &codes[0], sizeof(unsigned char) * length);\n\n    return Py_BuildValue(\"NN\", pyvertices.pyobj(), pycodes.pyobj());\n}\n\nconst char *Py_convert_to_svg__doc__ = \"convert_to_svg(path, trans, cliprect, simplify, precision)\";\n\nstatic PyObject *Py_convert_to_svg(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    py::PathIterator path;\n    agg::trans_affine trans;\n    agg::rect_d cliprect;\n    PyObject *simplifyobj;\n    bool simplify = false;\n    int precision;\n\n    if (!PyArg_ParseTuple(args,\n                          \"O&O&O&Oi:convert_to_svg\",\n                          &convert_path,\n                          &path,\n                          &convert_trans_affine,\n                          &trans,\n                          &convert_rect,\n                          &cliprect,\n                          &simplifyobj,\n                          &precision)) {\n        return NULL;\n    }\n\n    if (simplifyobj == Py_None) {\n        simplify = path.should_simplify();\n    } else if (PyObject_IsTrue(simplifyobj)) {\n        simplify = true;\n    }\n\n    size_t buffersize = path.total_vertices() * (precision + 5) * 4;\n    std::string buffer;\n    buffer.reserve(buffersize);\n\n    CALL_CPP(\"convert_to_svg\",\n             (convert_to_svg(path, trans, cliprect, simplify, precision, &buffer[0], &buffersize)));\n\n    return PyUnicode_DecodeASCII(&buffer[0], buffersize, \"\");\n}\n\nextern \"C\" {\n\n    static PyMethodDef module_functions[] = {\n        {\"point_in_path\", (PyCFunction)Py_point_in_path, METH_VARARGS, Py_point_in_path__doc__},\n        {\"points_in_path\", (PyCFunction)Py_points_in_path, METH_VARARGS, Py_points_in_path__doc__},\n        {\"point_on_path\", (PyCFunction)Py_point_on_path, METH_VARARGS, Py_point_on_path__doc__},\n        {\"points_on_path\", (PyCFunction)Py_points_on_path, METH_VARARGS, Py_points_on_path__doc__},\n        {\"get_path_extents\", (PyCFunction)Py_get_path_extents, METH_VARARGS, Py_get_path_extents__doc__},\n        {\"update_path_extents\", (PyCFunction)Py_update_path_extents, METH_VARARGS, Py_update_path_extents__doc__},\n        {\"get_path_collection_extents\", (PyCFunction)Py_get_path_collection_extents, METH_VARARGS, Py_get_path_collection_extents__doc__},\n        {\"point_in_path_collection\", (PyCFunction)Py_point_in_path_collection, METH_VARARGS, Py_point_in_path_collection__doc__},\n        {\"path_in_path\", (PyCFunction)Py_path_in_path, METH_VARARGS, Py_path_in_path__doc__},\n        {\"clip_path_to_rect\", (PyCFunction)Py_clip_path_to_rect, METH_VARARGS, Py_clip_path_to_rect__doc__},\n        {\"affine_transform\", (PyCFunction)Py_affine_transform, METH_VARARGS, Py_affine_transform__doc__},\n        {\"count_bboxes_overlapping_bbox\", (PyCFunction)Py_count_bboxes_overlapping_bbox, METH_VARARGS, Py_count_bboxes_overlapping_bbox__doc__},\n        {\"path_intersects_path\", (PyCFunction)Py_path_intersects_path, METH_VARARGS|METH_KEYWORDS, Py_path_intersects_path__doc__},\n        {\"convert_path_to_polygons\", (PyCFunction)Py_convert_path_to_polygons, METH_VARARGS, Py_convert_path_to_polygons__doc__},\n        {\"cleanup_path\", (PyCFunction)Py_cleanup_path, METH_VARARGS, Py_cleanup_path__doc__},\n        {\"convert_to_svg\", (PyCFunction)Py_convert_to_svg, METH_VARARGS, Py_convert_to_svg__doc__},\n        {NULL, NULL, NULL, NULL}\n    };\n\n    struct module_state\n    {\n        /* The Sun compiler can't handle empty structs */\n#if defined(__SUNPRO_C) || defined(_MSC_VER)\n        int _dummy;\n#endif\n    };\n\n#if PY3K\n    static struct PyModuleDef moduledef = {\n        PyModuleDef_HEAD_INIT,\n        \"_path\",\n        NULL,\n        sizeof(struct module_state),\n        module_functions,\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    };\n\n#define INITERROR return NULL\n    PyMODINIT_FUNC PyInit__path(void)\n#else\n#define INITERROR return\n    PyMODINIT_FUNC init_path(void)\n#endif\n    {\n        PyObject *m;\n#if PY3K\n        m = PyModule_Create(&moduledef);\n#else\n        m = Py_InitModule3(\"_path\", module_functions, NULL);\n#endif\n\n        if (m == NULL) {\n            INITERROR;\n        }\n\n        import_array();\n\n#if PY3K\n        return m;\n#endif\n    }\n}\n", "patch": "@@ -0,0 +1,713 @@\n+#include \"_path.h\"\n+\n+#include \"py_converters.h\"\n+#include \"py_adaptors.h\"\n+\n+PyObject *convert_polygon_vector(std::vector<Polygon> &polygons)\n+{\n+    PyObject *pyresult = PyList_New(polygons.size());\n+\n+    for (size_t i = 0; i < polygons.size(); ++i) {\n+        Polygon poly = polygons[i];\n+        npy_intp dims[] = {(npy_intp)poly.size() + 1, 2 };\n+        numpy::array_view<double, 2> subresult(dims);\n+\n+        /* Make last point same as first. */\n+        memcpy(subresult.data(), &poly[0], sizeof(double) * poly.size() * 2);\n+        subresult(poly.size(), 0) = poly[0].x;\n+        subresult(poly.size(), 1) = poly[0].y;\n+\n+        if (PyList_SetItem(pyresult, i, subresult.pyobj())) {\n+            Py_DECREF(pyresult);\n+            return NULL;\n+        }\n+    }\n+\n+    return pyresult;\n+}\n+\n+const char *Py_point_in_path__doc__ = \"point_in_path(x, y, radius, path, trans)\";\n+\n+static PyObject *Py_point_in_path(PyObject *self, PyObject *args, PyObject *kwds)\n+{\n+    double x, y, r;\n+    py::PathIterator path;\n+    agg::trans_affine trans;\n+    bool result;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"dddO&O&:point_in_path\",\n+                          &x,\n+                          &y,\n+                          &r,\n+                          &convert_path,\n+                          &path,\n+                          &convert_trans_affine,\n+                          &trans)) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP(\"point_in_path\", (result = point_in_path(x, y, r, path, trans)));\n+\n+    if (result) {\n+        Py_RETURN_TRUE;\n+    } else {\n+        Py_RETURN_FALSE;\n+    }\n+}\n+\n+const char *Py_points_in_path__doc__ = \"points_in_path(points, radius, path, trans)\";\n+\n+static PyObject *Py_points_in_path(PyObject *self, PyObject *args, PyObject *kwds)\n+{\n+    numpy::array_view<const double, 2> points;\n+    double r;\n+    py::PathIterator path;\n+    agg::trans_affine trans;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"O&dO&O&:points_in_path\",\n+                          &numpy::convert_array<const double, 2>,\n+                          &points,\n+                          &r,\n+                          &convert_path,\n+                          &path,\n+                          &convert_trans_affine,\n+                          &trans)) {\n+        return NULL;\n+    }\n+\n+    npy_intp dims[] = { points.dim(0) };\n+    numpy::array_view<uint8_t, 1> results(dims);\n+\n+    CALL_CPP(\"points_in_path\", (points_in_path(points, r, path, trans, results)));\n+\n+    return results.pyobj();\n+}\n+\n+const char *Py_point_on_path__doc__ = \"point_on_path(x, y, radius, path, trans)\";\n+\n+static PyObject *Py_point_on_path(PyObject *self, PyObject *args, PyObject *kwds)\n+{\n+    double x, y, r;\n+    py::PathIterator path;\n+    agg::trans_affine trans;\n+    bool result;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"dddO&O&:point_on_path\",\n+                          &x,\n+                          &y,\n+                          &r,\n+                          &convert_path,\n+                          &path,\n+                          &convert_trans_affine,\n+                          &trans)) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP(\"point_on_path\", (result = point_on_path(x, y, r, path, trans)));\n+\n+    if (result) {\n+        Py_RETURN_TRUE;\n+    } else {\n+        Py_RETURN_FALSE;\n+    }\n+}\n+\n+const char *Py_points_on_path__doc__ = \"points_on_path(points, radius, path, trans)\";\n+\n+static PyObject *Py_points_on_path(PyObject *self, PyObject *args, PyObject *kwds)\n+{\n+    numpy::array_view<const double, 2> points;\n+    double r;\n+    py::PathIterator path;\n+    agg::trans_affine trans;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"O&dO&O&:points_on_path\",\n+                          &numpy::convert_array<const double, 2>,\n+                          &points,\n+                          &r,\n+                          &convert_path,\n+                          &path,\n+                          &convert_trans_affine,\n+                          &trans)) {\n+        return NULL;\n+    }\n+\n+    npy_intp dims[] = { points.dim(0) };\n+    numpy::array_view<uint8_t, 1> results(dims);\n+\n+    CALL_CPP(\"points_on_path\", (points_on_path(points, r, path, trans, results)));\n+\n+    return results.pyobj();\n+}\n+\n+const char *Py_get_path_extents__doc__ = \"get_path_extents(path, trans)\";\n+\n+static PyObject *Py_get_path_extents(PyObject *self, PyObject *args, PyObject *kwds)\n+{\n+    py::PathIterator path;\n+    agg::trans_affine trans;\n+\n+    if (!PyArg_ParseTuple(\n+             args, \"O&O&:get_path_extents\", &convert_path, &path, &convert_trans_affine, &trans)) {\n+        return NULL;\n+    }\n+\n+    extent_limits e;\n+\n+    CALL_CPP(\"get_path_extents\", (reset_limits(e)));\n+    CALL_CPP(\"get_path_extents\", (update_path_extents(path, trans, e)));\n+\n+    npy_intp dims[] = { 2, 2 };\n+    numpy::array_view<double, 2> extents(dims);\n+    extents(0, 0) = e.x0;\n+    extents(0, 1) = e.y0;\n+    extents(1, 0) = e.x1;\n+    extents(1, 1) = e.y1;\n+\n+    return extents.pyobj();\n+}\n+\n+const char *Py_update_path_extents__doc__ =\n+    \"update_path_extents(path, trans, rect, minpos, ignore)\";\n+\n+static PyObject *Py_update_path_extents(PyObject *self, PyObject *args, PyObject *kwds)\n+{\n+    py::PathIterator path;\n+    agg::trans_affine trans;\n+    agg::rect_d rect;\n+    numpy::array_view<double, 1> minpos;\n+    bool ignore;\n+    bool changed;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"O&O&O&O&i:update_path_extents\",\n+                          &convert_path,\n+                          &path,\n+                          &convert_trans_affine,\n+                          &trans,\n+                          &convert_rect,\n+                          &rect,\n+                          &numpy::convert_array<double, 1>,\n+                          &minpos,\n+                          &ignore)) {\n+        return NULL;\n+    }\n+\n+    if (minpos.dim(0) != 2) {\n+        PyErr_SetString(PyExc_ValueError, \"minpos must be of length 2\");\n+    }\n+\n+    extent_limits e;\n+\n+    if (ignore) {\n+        CALL_CPP(\"update_path_extents\", reset_limits(e));\n+    } else {\n+        if (rect.x1 > rect.x2) {\n+            e.x0 = std::numeric_limits<double>::infinity();\n+            e.x1 = -std::numeric_limits<double>::infinity();\n+        } else {\n+            e.x0 = rect.x1;\n+            e.x1 = rect.x2;\n+        }\n+        if (rect.y1 > rect.y2) {\n+            e.y0 = std::numeric_limits<double>::infinity();\n+            e.y1 = -std::numeric_limits<double>::infinity();\n+        } else {\n+            e.y0 = rect.y1;\n+            e.y1 = rect.y2;\n+        }\n+        e.xm = minpos(0);\n+        e.ym = minpos(1);\n+    }\n+\n+    CALL_CPP(\"update_path_extents\", (update_path_extents(path, trans, e)));\n+\n+    changed = (e.x0 != rect.x1 || e.y0 != rect.y1 || e.x1 != rect.x2 || e.y1 != rect.y2 ||\n+               e.xm != minpos(0) || e.ym != minpos(1));\n+\n+    npy_intp extentsdims[] = { 2, 2 };\n+    numpy::array_view<double, 2> outextents(extentsdims);\n+    outextents(0, 0) = e.x0;\n+    outextents(0, 1) = e.y0;\n+    outextents(1, 0) = e.x1;\n+    outextents(1, 1) = e.y1;\n+\n+    npy_intp minposdims[] = { 2 };\n+    numpy::array_view<double, 1> outminpos(minposdims);\n+    outminpos(0) = e.xm;\n+    outminpos(1) = e.ym;\n+\n+    return Py_BuildValue(\n+        \"NNO\", outextents.pyobj(), outminpos.pyobj(), changed ? Py_True : Py_False);\n+}\n+\n+const char *Py_get_path_collection_extents__doc__ = \"get_path_collection_extents(\";\n+\n+static PyObject *Py_get_path_collection_extents(PyObject *self, PyObject *args, PyObject *kwds)\n+{\n+    agg::trans_affine master_transform;\n+    PyObject *pathsobj;\n+    numpy::array_view<const double, 3> transforms;\n+    numpy::array_view<const double, 2> offsets;\n+    agg::trans_affine offset_trans;\n+    extent_limits e;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"O&OO&O&O&:get_path_collection_extents\",\n+                          &convert_trans_affine,\n+                          &master_transform,\n+                          &pathsobj,\n+                          &numpy::convert_array<const double, 3>,\n+                          &transforms,\n+                          &numpy::convert_array<const double, 2>,\n+                          &offsets,\n+                          &convert_trans_affine,\n+                          &offset_trans)) {\n+        return NULL;\n+    }\n+\n+    try\n+    {\n+        py::PathGenerator paths(pathsobj);\n+\n+        CALL_CPP(\"get_path_collection_extents\",\n+                 (get_path_collection_extents(\n+                     master_transform, paths, transforms, offsets, offset_trans, e)));\n+    }\n+    catch (py::exception &e)\n+    {\n+        return NULL;\n+    }\n+\n+    npy_intp dims[] = { 2, 2 };\n+    numpy::array_view<double, 2> extents(dims);\n+    extents(0, 0) = e.x0;\n+    extents(0, 1) = e.y0;\n+    extents(1, 0) = e.x1;\n+    extents(1, 1) = e.y1;\n+\n+    return extents.pyobj();\n+}\n+\n+const char *Py_point_in_path_collection__doc__ =\n+    \"point_in_path_collection(x, y, radius, master_transform, paths, transforms, offsets, \"\n+    \"offset_trans, filled, offset_position)\";\n+\n+static PyObject *Py_point_in_path_collection(PyObject *self, PyObject *args, PyObject *kwds)\n+{\n+    double x, y, radius;\n+    agg::trans_affine master_transform;\n+    PyObject *pathsobj;\n+    numpy::array_view<const double, 3> transforms;\n+    numpy::array_view<const double, 2> offsets;\n+    agg::trans_affine offset_trans;\n+    int filled;\n+    e_offset_position offset_position;\n+    std::vector<size_t> result;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"dddO&OO&O&O&iO&:point_in_path_collection\",\n+                          &x,\n+                          &y,\n+                          &radius,\n+                          &convert_trans_affine,\n+                          &master_transform,\n+                          &pathsobj,\n+                          &numpy::convert_array<const double, 3>,\n+                          &transforms,\n+                          &numpy::convert_array<const double, 2>,\n+                          &offsets,\n+                          &convert_trans_affine,\n+                          &offset_trans,\n+                          &filled,\n+                          &convert_offset_position,\n+                          &offset_position)) {\n+        return NULL;\n+    }\n+\n+    try\n+    {\n+        py::PathGenerator paths(pathsobj);\n+\n+        CALL_CPP(\"point_in_path_collection\",\n+                 (point_in_path_collection(x,\n+                                           y,\n+                                           radius,\n+                                           master_transform,\n+                                           paths,\n+                                           transforms,\n+                                           offsets,\n+                                           offset_trans,\n+                                           filled,\n+                                           offset_position,\n+                                           result)));\n+    }\n+    catch (py::exception &e)\n+    {\n+        return NULL;\n+    }\n+\n+    npy_intp dims[] = {(npy_intp)result.size() };\n+    numpy::array_view<size_t, 1> pyresult(dims);\n+    memcpy(pyresult.data(), &result[0], result.size() * sizeof(size_t));\n+    return pyresult.pyobj();\n+}\n+\n+const char *Py_path_in_path__doc__ = \"path_in_path(path_a, trans_a, path_b, trans_b)\";\n+\n+static PyObject *Py_path_in_path(PyObject *self, PyObject *args, PyObject *kwds)\n+{\n+    py::PathIterator a;\n+    agg::trans_affine atrans;\n+    py::PathIterator b;\n+    agg::trans_affine btrans;\n+    bool result;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"O&O&O&O&:path_in_path\",\n+                          &convert_path,\n+                          &a,\n+                          &convert_trans_affine,\n+                          &atrans,\n+                          &convert_path,\n+                          &b,\n+                          &convert_trans_affine,\n+                          &btrans)) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP(\"path_in_path\", (result = path_in_path(a, atrans, b, btrans)));\n+\n+    if (result) {\n+        Py_RETURN_TRUE;\n+    } else {\n+        Py_RETURN_FALSE;\n+    }\n+}\n+\n+const char *Py_clip_path_to_rect__doc__ = \"clip_path_to_rect(path, rect, inside)\";\n+\n+static PyObject *Py_clip_path_to_rect(PyObject *self, PyObject *args, PyObject *kwds)\n+{\n+    py::PathIterator path;\n+    agg::rect_d rect;\n+    int inside;\n+    std::vector<Polygon> result;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"O&O&i:clip_path_to_rect\",\n+                          &convert_path,\n+                          &path,\n+                          &convert_rect,\n+                          &rect,\n+                          &inside)) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP(\"clip_path_to_rect\", (clip_path_to_rect(path, rect, inside, result)));\n+\n+    return convert_polygon_vector(result);\n+}\n+\n+const char *Py_affine_transform__doc__ = \"affine_transform(points, trans)\";\n+\n+static PyObject *Py_affine_transform(PyObject *self, PyObject *args, PyObject *kwds)\n+{\n+    numpy::array_view<const double, 2> vertices;\n+    agg::trans_affine trans;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"O&O&:affine_transform\",\n+                          &numpy::convert_array<const double, 2>,\n+                          &vertices,\n+                          &convert_trans_affine,\n+                          &trans)) {\n+        return NULL;\n+    }\n+\n+    npy_intp dims[] = { vertices.dim(0), 2 };\n+    numpy::array_view<double, 2> result(dims);\n+\n+    CALL_CPP(\"affine_transform\", (affine_transform(vertices, trans, result)));\n+\n+    return result.pyobj();\n+}\n+\n+const char *Py_count_bboxes_overlapping_bbox__doc__ = \"count_bboxes_overlapping_bbox(bbox, bboxes)\";\n+\n+static PyObject *Py_count_bboxes_overlapping_bbox(PyObject *self, PyObject *args, PyObject *kwds)\n+{\n+    agg::rect_d bbox;\n+    numpy::array_view<const double, 3> bboxes;\n+    int result;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"O&O&:count_bboxes_overlapping_bbox\",\n+                          &convert_rect,\n+                          &bbox,\n+                          &numpy::convert_array<const double, 3>,\n+                          &bboxes)) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP(\"count_bboxes_overlapping_bbox\",\n+             (result = count_bboxes_overlapping_bbox(bbox, bboxes)));\n+\n+    return PyLong_FromLong(result);\n+}\n+\n+const char *Py_path_intersects_path__doc__ = \"path_intersects_path(path1, path2, filled=False)\";\n+\n+static PyObject *Py_path_intersects_path(PyObject *self, PyObject *args, PyObject *kwds)\n+{\n+    py::PathIterator p1;\n+    py::PathIterator p2;\n+    bool filled = false;\n+    const char *names[] = { \"p1\", \"p2\", \"filled\", NULL };\n+    bool result;\n+\n+    if (!PyArg_ParseTupleAndKeywords(args,\n+                                     kwds,\n+                                     \"O&O&i:path_intersects_path\",\n+                                     (char **)names,\n+                                     &convert_path,\n+                                     &p1,\n+                                     &convert_path,\n+                                     &p2,\n+                                     &filled)) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP(\"path_intersects_path\", (result = path_intersects_path(p1, p2)));\n+    if (filled) {\n+        if (!result) {\n+            CALL_CPP(\"path_intersects_path\",\n+                     (result = path_in_path(p1, agg::trans_affine(), p2, agg::trans_affine())));\n+        }\n+        if (!result) {\n+            CALL_CPP(\"path_intersects_path\",\n+                     (result = path_in_path(p2, agg::trans_affine(), p1, agg::trans_affine())));\n+        }\n+    }\n+\n+    if (result) {\n+        Py_RETURN_TRUE;\n+    } else {\n+        Py_RETURN_FALSE;\n+    }\n+}\n+\n+const char *Py_convert_path_to_polygons__doc__ =\n+    \"convert_path_to_polygons(path, trans, width=0, height=0)\";\n+\n+static PyObject *Py_convert_path_to_polygons(PyObject *self, PyObject *args, PyObject *kwds)\n+{\n+    py::PathIterator path;\n+    agg::trans_affine trans;\n+    double width = 0.0, height = 0.0;\n+    std::vector<Polygon> result;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"O&O&|dd:convert_path_to_polygons\",\n+                          &convert_path,\n+                          &path,\n+                          &convert_trans_affine,\n+                          &trans,\n+                          &width,\n+                          &height)) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP(\"convert_path_to_polygons\",\n+             (convert_path_to_polygons(path, trans, width, height, result)));\n+\n+    return convert_polygon_vector(result);\n+}\n+\n+const char *Py_cleanup_path__doc__ =\n+    \"cleanup_path(path, trans, remove_nans, clip_rect, snap_mode, stroke_width, simplify, \"\n+    \"return_curves, sketch)\";\n+\n+static PyObject *Py_cleanup_path(PyObject *self, PyObject *args, PyObject *kwds)\n+{\n+    py::PathIterator path;\n+    agg::trans_affine trans;\n+    int remove_nans;\n+    agg::rect_d clip_rect;\n+    e_snap_mode snap_mode;\n+    double stroke_width;\n+    PyObject *simplifyobj;\n+    bool simplify = false;\n+    int return_curves;\n+    SketchParams sketch;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"O&O&iO&O&dOiO&:cleanup_path\",\n+                          &convert_path,\n+                          &path,\n+                          &convert_trans_affine,\n+                          &trans,\n+                          &remove_nans,\n+                          &convert_rect,\n+                          &clip_rect,\n+                          &convert_snap,\n+                          &snap_mode,\n+                          &stroke_width,\n+                          &simplifyobj,\n+                          &return_curves,\n+                          &convert_sketch_params,\n+                          &sketch)) {\n+        return NULL;\n+    }\n+\n+    if (simplifyobj == Py_None) {\n+        simplify = path.should_simplify();\n+    } else if (PyObject_IsTrue(simplifyobj)) {\n+        simplify = true;\n+    }\n+\n+    bool do_clip = (clip_rect.x1 < clip_rect.x2 && clip_rect.y1 < clip_rect.y2);\n+\n+    std::vector<double> vertices;\n+    std::vector<npy_uint8> codes;\n+\n+    CALL_CPP(\"cleanup_path\",\n+             (cleanup_path(path,\n+                           trans,\n+                           remove_nans,\n+                           do_clip,\n+                           clip_rect,\n+                           snap_mode,\n+                           stroke_width,\n+                           simplify,\n+                           return_curves,\n+                           sketch,\n+                           vertices,\n+                           codes)));\n+\n+    size_t length = codes.size();\n+\n+    npy_intp vertices_dims[] = {(npy_intp)length, 2 };\n+    numpy::array_view<double, 2> pyvertices(vertices_dims);\n+\n+    npy_intp codes_dims[] = {(npy_intp)length };\n+    numpy::array_view<unsigned char, 1> pycodes(codes_dims);\n+\n+    memcpy(pyvertices.data(), &vertices[0], sizeof(double) * 2 * length);\n+    memcpy(pycodes.data(), &codes[0], sizeof(unsigned char) * length);\n+\n+    return Py_BuildValue(\"NN\", pyvertices.pyobj(), pycodes.pyobj());\n+}\n+\n+const char *Py_convert_to_svg__doc__ = \"convert_to_svg(path, trans, cliprect, simplify, precision)\";\n+\n+static PyObject *Py_convert_to_svg(PyObject *self, PyObject *args, PyObject *kwds)\n+{\n+    py::PathIterator path;\n+    agg::trans_affine trans;\n+    agg::rect_d cliprect;\n+    PyObject *simplifyobj;\n+    bool simplify = false;\n+    int precision;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"O&O&O&Oi:convert_to_svg\",\n+                          &convert_path,\n+                          &path,\n+                          &convert_trans_affine,\n+                          &trans,\n+                          &convert_rect,\n+                          &cliprect,\n+                          &simplifyobj,\n+                          &precision)) {\n+        return NULL;\n+    }\n+\n+    if (simplifyobj == Py_None) {\n+        simplify = path.should_simplify();\n+    } else if (PyObject_IsTrue(simplifyobj)) {\n+        simplify = true;\n+    }\n+\n+    size_t buffersize = path.total_vertices() * (precision + 5) * 4;\n+    std::string buffer;\n+    buffer.reserve(buffersize);\n+\n+    CALL_CPP(\"convert_to_svg\",\n+             (convert_to_svg(path, trans, cliprect, simplify, precision, &buffer[0], &buffersize)));\n+\n+    return PyUnicode_DecodeASCII(&buffer[0], buffersize, \"\");\n+}\n+\n+extern \"C\" {\n+\n+    static PyMethodDef module_functions[] = {\n+        {\"point_in_path\", (PyCFunction)Py_point_in_path, METH_VARARGS, Py_point_in_path__doc__},\n+        {\"points_in_path\", (PyCFunction)Py_points_in_path, METH_VARARGS, Py_points_in_path__doc__},\n+        {\"point_on_path\", (PyCFunction)Py_point_on_path, METH_VARARGS, Py_point_on_path__doc__},\n+        {\"points_on_path\", (PyCFunction)Py_points_on_path, METH_VARARGS, Py_points_on_path__doc__},\n+        {\"get_path_extents\", (PyCFunction)Py_get_path_extents, METH_VARARGS, Py_get_path_extents__doc__},\n+        {\"update_path_extents\", (PyCFunction)Py_update_path_extents, METH_VARARGS, Py_update_path_extents__doc__},\n+        {\"get_path_collection_extents\", (PyCFunction)Py_get_path_collection_extents, METH_VARARGS, Py_get_path_collection_extents__doc__},\n+        {\"point_in_path_collection\", (PyCFunction)Py_point_in_path_collection, METH_VARARGS, Py_point_in_path_collection__doc__},\n+        {\"path_in_path\", (PyCFunction)Py_path_in_path, METH_VARARGS, Py_path_in_path__doc__},\n+        {\"clip_path_to_rect\", (PyCFunction)Py_clip_path_to_rect, METH_VARARGS, Py_clip_path_to_rect__doc__},\n+        {\"affine_transform\", (PyCFunction)Py_affine_transform, METH_VARARGS, Py_affine_transform__doc__},\n+        {\"count_bboxes_overlapping_bbox\", (PyCFunction)Py_count_bboxes_overlapping_bbox, METH_VARARGS, Py_count_bboxes_overlapping_bbox__doc__},\n+        {\"path_intersects_path\", (PyCFunction)Py_path_intersects_path, METH_VARARGS|METH_KEYWORDS, Py_path_intersects_path__doc__},\n+        {\"convert_path_to_polygons\", (PyCFunction)Py_convert_path_to_polygons, METH_VARARGS, Py_convert_path_to_polygons__doc__},\n+        {\"cleanup_path\", (PyCFunction)Py_cleanup_path, METH_VARARGS, Py_cleanup_path__doc__},\n+        {\"convert_to_svg\", (PyCFunction)Py_convert_to_svg, METH_VARARGS, Py_convert_to_svg__doc__},\n+        {NULL, NULL, NULL, NULL}\n+    };\n+\n+    struct module_state\n+    {\n+        /* The Sun compiler can't handle empty structs */\n+#if defined(__SUNPRO_C) || defined(_MSC_VER)\n+        int _dummy;\n+#endif\n+    };\n+\n+#if PY3K\n+    static struct PyModuleDef moduledef = {\n+        PyModuleDef_HEAD_INIT,\n+        \"_path\",\n+        NULL,\n+        sizeof(struct module_state),\n+        module_functions,\n+        NULL,\n+        NULL,\n+        NULL,\n+        NULL\n+    };\n+\n+#define INITERROR return NULL\n+    PyMODINIT_FUNC PyInit__path(void)\n+#else\n+#define INITERROR return\n+    PyMODINIT_FUNC init_path(void)\n+#endif\n+    {\n+        PyObject *m;\n+#if PY3K\n+        m = PyModule_Create(&moduledef);\n+#else\n+        m = Py_InitModule3(\"_path\", module_functions, NULL);\n+#endif\n+\n+        if (m == NULL) {\n+            INITERROR;\n+        }\n+\n+        import_array();\n+\n+#if PY3K\n+        return m;\n+#endif\n+    }\n+}"}
{"patches_id": 2, "files_id": 42, "language": "cpp", "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_png.cpp", "raw_code": "/* -*- mode: c++; c-basic-offset: 4 -*- */\n\n// this code is heavily adapted from the paint license, which is in\n// the file paint.license (BSD compatible) included in this\n// distribution.  TODO, add license file to MANIFEST.in and CVS\n\n/* For linux, png.h must be imported before Python.h because\n   png.h needs to be the one to define setjmp.\n   Undefining _POSIX_C_SOURCE and _XOPEN_SOURCE stops a couple\n   of harmless warnings.\n*/\n\n#include <vector>\n\n#ifdef __linux__\n#   include <png.h>\n#   ifdef _POSIX_C_SOURCE\n#       undef _POSIX_C_SOURCE\n#   endif\n#   ifdef _XOPEN_SOURCE\n#       undef _XOPEN_SOURCE\n#   endif\n#   include \"Python.h\"\n#else\n\n/* Python API mandates Python.h is included *first* */\n#   include \"Python.h\"\n\n#   include <png.h>\n#endif\n\n#include \"file_compat.h\"\n#include \"numpy_cpp.h\"\n#include \"mplutils.h\"\n\n// As reported in [3082058] build _png.so on aix\n#ifdef _AIX\n#undef jmpbuf\n#endif\n\nstatic void write_png_data(png_structp png_ptr, png_bytep data, png_size_t length)\n{\n    PyObject *py_file_obj = (PyObject *)png_get_io_ptr(png_ptr);\n    PyObject *write_method = PyObject_GetAttrString(py_file_obj, \"write\");\n    PyObject *result = NULL;\n    if (write_method) {\n#if PY3K\n        result = PyObject_CallFunction(write_method, (char *)\"y#\", data, length);\n#else\n        result = PyObject_CallFunction(write_method, (char *)\"s#\", data, length);\n#endif\n    }\n    Py_XDECREF(write_method);\n    Py_XDECREF(result);\n}\n\nstatic void flush_png_data(png_structp png_ptr)\n{\n    PyObject *py_file_obj = (PyObject *)png_get_io_ptr(png_ptr);\n    PyObject *flush_method = PyObject_GetAttrString(py_file_obj, \"flush\");\n    PyObject *result = NULL;\n    if (flush_method) {\n        result = PyObject_CallFunction(flush_method, (char *)\"\");\n    }\n    Py_XDECREF(flush_method);\n    Py_XDECREF(result);\n}\n\nconst char *Py_write_png__doc__ = \"write_png(buffer, file, dpi=0)\";\n\nstatic PyObject *Py_write_png(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    numpy::array_view<unsigned char, 3> buffer;\n    PyObject *filein;\n    double dpi = 0;\n    const char *names[] = { \"buffer\", \"file\", \"dpi\", NULL };\n\n    if (!PyArg_ParseTupleAndKeywords(args,\n                                     kwds,\n                                     \"O&O|d:write_png\",\n                                     (char **)names,\n                                     &numpy::convert_array<unsigned char, 3>,\n                                     &buffer,\n                                     &filein,\n                                     &dpi)) {\n        return NULL;\n    }\n\n    png_uint_32 width = (png_uint_32)buffer.dim(1);\n    png_uint_32 height = (png_uint_32)buffer.dim(0);\n    std::vector<png_bytep> row_pointers(height);\n    for (png_uint_32 row = 0; row < (png_uint_32)height; ++row) {\n        row_pointers[row] = (png_bytep)buffer[row].data();\n    }\n\n    FILE *fp = NULL;\n    mpl_off_t offset = 0;\n    bool close_file = false;\n    bool close_dup_file = false;\n    PyObject *py_file = NULL;\n\n    png_structp png_ptr = NULL;\n    png_infop info_ptr = NULL;\n    struct png_color_8_struct sig_bit;\n\n    if (buffer.dim(2) != 4) {\n        PyErr_SetString(PyExc_ValueError, \"Buffer must be RGBA NxMx4 array\");\n        goto exit;\n    }\n\n    if (PyBytes_Check(filein) || PyUnicode_Check(filein)) {\n        if ((py_file = mpl_PyFile_OpenFile(filein, (char *)\"wb\")) == NULL) {\n            goto exit;\n        }\n        close_file = true;\n    } else {\n        py_file = filein;\n    }\n\n    if ((fp = mpl_PyFile_Dup(py_file, (char *)\"wb\", &offset))) {\n        close_dup_file = true;\n    } else {\n        PyErr_Clear();\n        PyObject *write_method = PyObject_GetAttrString(py_file, \"write\");\n        if (!(write_method && PyCallable_Check(write_method))) {\n            Py_XDECREF(write_method);\n            PyErr_SetString(PyExc_TypeError,\n                            \"Object does not appear to be a 8-bit string path or \"\n                            \"a Python file-like object\");\n            goto exit;\n        }\n        Py_XDECREF(write_method);\n    }\n\n    png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);\n    if (png_ptr == NULL) {\n        PyErr_SetString(PyExc_RuntimeError, \"Could not create write struct\");\n        goto exit;\n    }\n\n    info_ptr = png_create_info_struct(png_ptr);\n    if (info_ptr == NULL) {\n        PyErr_SetString(PyExc_RuntimeError, \"Could not create info struct\");\n        goto exit;\n    }\n\n    if (setjmp(png_jmpbuf(png_ptr))) {\n        PyErr_SetString(PyExc_RuntimeError, \"Error setting jumps\");\n        goto exit;\n    }\n\n    if (fp) {\n        png_init_io(png_ptr, fp);\n    } else {\n        png_set_write_fn(png_ptr, (void *)py_file, &write_png_data, &flush_png_data);\n    }\n    png_set_IHDR(png_ptr,\n                 info_ptr,\n                 width,\n                 height,\n                 8,\n                 PNG_COLOR_TYPE_RGB_ALPHA,\n                 PNG_INTERLACE_NONE,\n                 PNG_COMPRESSION_TYPE_BASE,\n                 PNG_FILTER_TYPE_BASE);\n\n    // Save the dpi of the image in the file\n    if (dpi > 0.0) {\n        png_uint_32 dots_per_meter = (png_uint_32)(dpi / (2.54 / 100.0));\n        png_set_pHYs(png_ptr, info_ptr, dots_per_meter, dots_per_meter, PNG_RESOLUTION_METER);\n    }\n\n    // this a a color image!\n    sig_bit.gray = 0;\n    sig_bit.red = 8;\n    sig_bit.green = 8;\n    sig_bit.blue = 8;\n    /* if the image has an alpha channel then */\n    sig_bit.alpha = 8;\n    png_set_sBIT(png_ptr, info_ptr, &sig_bit);\n\n    png_write_info(png_ptr, info_ptr);\n    png_write_image(png_ptr, &row_pointers[0]);\n    png_write_end(png_ptr, info_ptr);\n\nexit:\n\n    if (png_ptr && info_ptr) {\n        png_destroy_write_struct(&png_ptr, &info_ptr);\n    }\n\n    if (close_dup_file) {\n        mpl_PyFile_DupClose(py_file, fp, offset);\n    }\n\n    if (close_file) {\n        mpl_PyFile_CloseFile(py_file);\n        Py_DECREF(py_file);\n    }\n\n    if (PyErr_Occurred()) {\n        return NULL;\n    } else {\n        Py_RETURN_NONE;\n    }\n}\n\nstatic void _read_png_data(PyObject *py_file_obj, png_bytep data, png_size_t length)\n{\n    PyObject *read_method = PyObject_GetAttrString(py_file_obj, \"read\");\n    PyObject *result = NULL;\n    char *buffer;\n    Py_ssize_t bufflen;\n    if (read_method) {\n        result = PyObject_CallFunction(read_method, (char *)\"i\", length);\n    }\n    if (PyBytes_AsStringAndSize(result, &buffer, &bufflen) == 0) {\n        if (bufflen == (Py_ssize_t)length) {\n            memcpy(data, buffer, length);\n        }\n    }\n    Py_XDECREF(read_method);\n    Py_XDECREF(result);\n}\n\nstatic void read_png_data(png_structp png_ptr, png_bytep data, png_size_t length)\n{\n    PyObject *py_file_obj = (PyObject *)png_get_io_ptr(png_ptr);\n    _read_png_data(py_file_obj, data, length);\n}\n\nstatic PyObject *_read_png(PyObject *filein, bool float_result)\n{\n    png_byte header[8]; // 8 is the maximum size that can be checked\n    FILE *fp = NULL;\n    mpl_off_t offset = 0;\n    bool close_file = false;\n    bool close_dup_file = false;\n    PyObject *py_file = NULL;\n    PyArrayObject *A = NULL;\n    png_structp png_ptr = NULL;\n    png_infop info_ptr = NULL;\n    int num_dims;\n    std::vector<png_bytep> row_pointers;\n    png_uint_32 width = 0;\n    png_uint_32 height = 0;\n    int bit_depth;\n\n    if (PyBytes_Check(filein) || PyUnicode_Check(filein)) {\n        if ((py_file = mpl_PyFile_OpenFile(filein, (char *)\"rb\")) == NULL) {\n            goto exit;\n        }\n        close_file = true;\n    } else {\n        py_file = filein;\n    }\n\n    if ((fp = mpl_PyFile_Dup(py_file, (char *)\"rb\", &offset))) {\n        close_dup_file = true;\n    } else {\n        PyErr_Clear();\n        PyObject *read_method = PyObject_GetAttrString(py_file, \"read\");\n        if (!(read_method && PyCallable_Check(read_method))) {\n            Py_XDECREF(read_method);\n            PyErr_SetString(PyExc_TypeError,\n                            \"Object does not appear to be a 8-bit string path or \"\n                            \"a Python file-like object\");\n            goto exit;\n        }\n        Py_XDECREF(read_method);\n    }\n\n    if (fp) {\n        if (fread(header, 1, 8, fp) != 8) {\n            PyErr_SetString(PyExc_IOError, \"error reading PNG header\");\n            goto exit;\n        }\n    } else {\n        _read_png_data(py_file, header, 8);\n    }\n\n    if (png_sig_cmp(header, 0, 8)) {\n        PyErr_SetString(PyExc_ValueError, \"invalid PNG header\");\n        goto exit;\n    }\n\n    /* initialize stuff */\n    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);\n\n    if (!png_ptr) {\n        PyErr_SetString(PyExc_RuntimeError, \"png_create_read_struct failed\");\n        goto exit;\n    }\n\n    info_ptr = png_create_info_struct(png_ptr);\n    if (!info_ptr) {\n        PyErr_SetString(PyExc_RuntimeError, \"png_create_info_struct failed\");\n        goto exit;\n    }\n\n    if (setjmp(png_jmpbuf(png_ptr))) {\n        PyErr_SetString(PyExc_RuntimeError, \"Error setting jump\");\n        goto exit;\n    }\n\n    if (fp) {\n        png_init_io(png_ptr, fp);\n    } else {\n        png_set_read_fn(png_ptr, (void *)py_file, &read_png_data);\n    }\n    png_set_sig_bytes(png_ptr, 8);\n    png_read_info(png_ptr, info_ptr);\n\n    width = png_get_image_width(png_ptr, info_ptr);\n    height = png_get_image_height(png_ptr, info_ptr);\n\n    bit_depth = png_get_bit_depth(png_ptr, info_ptr);\n\n    // Unpack 1, 2, and 4-bit images\n    if (bit_depth < 8) {\n        png_set_packing(png_ptr);\n    }\n\n    // If sig bits are set, shift data\n    png_color_8p sig_bit;\n    if ((png_get_color_type(png_ptr, info_ptr) != PNG_COLOR_TYPE_PALETTE) &&\n        png_get_sBIT(png_ptr, info_ptr, &sig_bit)) {\n        png_set_shift(png_ptr, sig_bit);\n    }\n\n    // Convert big endian to little\n    if (bit_depth == 16) {\n        png_set_swap(png_ptr);\n    }\n\n    // Convert palletes to full RGB\n    if (png_get_color_type(png_ptr, info_ptr) == PNG_COLOR_TYPE_PALETTE) {\n        png_set_palette_to_rgb(png_ptr);\n        bit_depth = 8;\n    }\n\n    // If there's an alpha channel convert gray to RGB\n    if (png_get_color_type(png_ptr, info_ptr) == PNG_COLOR_TYPE_GRAY_ALPHA) {\n        png_set_gray_to_rgb(png_ptr);\n    }\n\n    png_set_interlace_handling(png_ptr);\n    png_read_update_info(png_ptr, info_ptr);\n\n    row_pointers.resize(height);\n    for (png_uint_32 row = 0; row < height; row++) {\n        row_pointers[row] = new png_byte[png_get_rowbytes(png_ptr, info_ptr)];\n    }\n\n    png_read_image(png_ptr, &row_pointers[0]);\n\n    npy_intp dimensions[3];\n    dimensions[0] = height; // numrows\n    dimensions[1] = width; // numcols\n    if (png_get_color_type(png_ptr, info_ptr) & PNG_COLOR_MASK_ALPHA) {\n        dimensions[2] = 4; // RGBA images\n    } else if (png_get_color_type(png_ptr, info_ptr) & PNG_COLOR_MASK_COLOR) {\n        dimensions[2] = 3; // RGB images\n    } else {\n        dimensions[2] = 1; // Greyscale images\n    }\n    // For gray, return an x by y array, not an x by y by 1\n    num_dims = (png_get_color_type(png_ptr, info_ptr) & PNG_COLOR_MASK_COLOR) ? 3 : 2;\n\n    if (float_result) {\n        double max_value = (1 << bit_depth) - 1;\n\n        A = (PyArrayObject *)PyArray_SimpleNew(num_dims, dimensions, NPY_FLOAT);\n        if (A == NULL) {\n            goto exit;\n        }\n\n        for (png_uint_32 y = 0; y < height; y++) {\n            png_byte *row = row_pointers[y];\n            for (png_uint_32 x = 0; x < width; x++) {\n                size_t offset = y * A->strides[0] + x * A->strides[1];\n                if (bit_depth == 16) {\n                    png_uint_16 *ptr = &reinterpret_cast<png_uint_16 *>(row)[x * dimensions[2]];\n                    for (png_uint_32 p = 0; p < (png_uint_32)dimensions[2]; p++) {\n                        *(float *)(A->data + offset + p *A->strides[2]) =\n                            (float)(ptr[p]) / max_value;\n                    }\n                } else {\n                    png_byte *ptr = &(row[x * dimensions[2]]);\n                    for (png_uint_32 p = 0; p < (png_uint_32)dimensions[2]; p++) {\n                        *(float *)(A->data + offset + p *A->strides[2]) =\n                            (float)(ptr[p]) / max_value;\n                    }\n                }\n            }\n        }\n    } else {\n        if (bit_depth == 8) {\n            A = (PyArrayObject *)PyArray_SimpleNew(num_dims, dimensions, NPY_UBYTE);\n        } else if (bit_depth == 16) {\n            A = (PyArrayObject *)PyArray_SimpleNew(num_dims, dimensions, NPY_UINT16);\n        } else {\n            PyErr_SetString(PyExc_RuntimeError, \"image has unknown bit depth\");\n            goto exit;\n        }\n\n        if (A == NULL) {\n            goto exit;\n        }\n\n        for (png_uint_32 y = 0; y < height; y++) {\n            png_byte *row = row_pointers[y];\n            for (png_uint_32 x = 0; x < width; x++) {\n                size_t offset = y * A->strides[0] + x * A->strides[1];\n                if (bit_depth == 16) {\n                    png_uint_16 *ptr = &reinterpret_cast<png_uint_16 *>(row)[x * dimensions[2]];\n\n                    if (bit_depth == 16) {\n                        for (png_uint_32 p = 0; p < (png_uint_32)dimensions[2]; p++) {\n                            *(png_uint_16 *)(A->data + offset + p *A->strides[2]) = ptr[p];\n                        }\n                    } else {\n                        for (png_uint_32 p = 0; p < (png_uint_32)dimensions[2]; p++) {\n                            *(png_byte *)(A->data + offset + p *A->strides[2]) = ptr[p] >> 8;\n                        }\n                    }\n                } else {\n                    png_byte *ptr = &(row[x * dimensions[2]]);\n                    if (bit_depth == 16) {\n                        for (png_uint_32 p = 0; p < (png_uint_32)dimensions[2]; p++) {\n                            *(png_uint_16 *)(A->data + offset + p *A->strides[2]) = ptr[p];\n                        }\n                    } else {\n                        for (png_uint_32 p = 0; p < (png_uint_32)dimensions[2]; p++) {\n                            *(png_byte *)(A->data + offset + p *A->strides[2]) = ptr[p];\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // free the png memory\n    png_read_end(png_ptr, info_ptr);\n\nexit:\n    if (png_ptr && info_ptr) {\n#ifndef png_infopp_NULL\n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n#else\n        png_destroy_read_struct(&png_ptr, &info_ptr, png_infopp_NULL);\n#endif\n    }\n\n    if (close_dup_file) {\n        mpl_PyFile_DupClose(py_file, fp, offset);\n    }\n\n    if (close_file) {\n        mpl_PyFile_CloseFile(py_file);\n        Py_DECREF(py_file);\n    }\n\n    for (png_uint_32 row = 0; row < height; row++) {\n        delete[] row_pointers[row];\n    }\n\n    if (PyErr_Occurred()) {\n        Py_XDECREF((PyObject *)A);\n        return NULL;\n    } else {\n        return (PyObject *)A;\n    }\n}\n\nconst char *Py_read_png_float__doc__ = \"read_png_float(file)\";\n\nstatic PyObject *Py_read_png_float(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    return _read_png(args, true);\n}\n\nconst char *Py_read_png_int__doc__ = \"read_png_int(file)\";\n\nstatic PyObject *Py_read_png_int(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    return _read_png(args, false);\n}\n\nconst char *Py_read_png__doc__ = \"read_png(file)\";\n\nstatic PyMethodDef module_methods[] = {\n    {\"write_png\", (PyCFunction)Py_write_png, METH_VARARGS|METH_KEYWORDS, Py_write_png__doc__},\n    {\"read_png\", (PyCFunction)Py_read_png_float, METH_O, Py_read_png__doc__},\n    {\"read_png_float\", (PyCFunction)Py_read_png_float, METH_O, Py_read_png_float__doc__},\n    {\"read_png_int\", (PyCFunction)Py_read_png_int, METH_O, Py_read_png_int__doc__},\n    {NULL}\n};\n\nextern \"C\" {\n\n    struct module_state\n    {\n        /* The Sun compiler can't handle empty structs */\n#if defined(__SUNPRO_C) || defined(_MSC_VER)\n        int _dummy;\n#endif\n    };\n\n#if PY3K\n    static struct PyModuleDef moduledef = {\n        PyModuleDef_HEAD_INIT,\n        \"_png\",\n        NULL,\n        sizeof(struct module_state),\n        module_methods,\n        NULL,\n        NULL,\n        NULL,\n        NULL\n    };\n\n#define INITERROR return NULL\n\n    PyMODINIT_FUNC PyInit__png(void)\n\n#else\n#define INITERROR return\n\n    PyMODINIT_FUNC init_png(void)\n#endif\n\n    {\n        PyObject *m;\n\n#if PY3K\n        m = PyModule_Create(&moduledef);\n#else\n        m = Py_InitModule3(\"_png\", module_methods, NULL);\n#endif\n\n        if (m == NULL) {\n            INITERROR;\n        }\n\n        import_array();\n\n#if PY3K\n        return m;\n#endif\n    }\n}\n", "patch": "@@ -1,11 +1,17 @@\n /* -*- mode: c++; c-basic-offset: 4 -*- */\n \n+// this code is heavily adapted from the paint license, which is in\n+// the file paint.license (BSD compatible) included in this\n+// distribution.  TODO, add license file to MANIFEST.in and CVS\n+\n /* For linux, png.h must be imported before Python.h because\n    png.h needs to be the one to define setjmp.\n    Undefining _POSIX_C_SOURCE and _XOPEN_SOURCE stops a couple\n    of harmless warnings.\n */\n \n+#include <vector>\n+\n #ifdef __linux__\n #   include <png.h>\n #   ifdef _POSIX_C_SOURCE\n@@ -23,277 +29,193 @@\n #   include <png.h>\n #endif\n \n-// TODO: Un CXX-ify this module\n-#include \"CXX/Extensions.hxx\"\n-#include \"numpy/arrayobject.h\"\n-#include \"mplutils.h\"\n-\n #include \"file_compat.h\"\n+#include \"numpy_cpp.h\"\n+#include \"mplutils.h\"\n \n // As reported in [3082058] build _png.so on aix\n #ifdef _AIX\n #undef jmpbuf\n #endif\n \n-// the extension module\n-class _png_module : public Py::ExtensionModule<_png_module>\n-{\n-public:\n-    _png_module()\n-            : Py::ExtensionModule<_png_module>(\"_png\")\n-    {\n-        add_varargs_method(\"write_png\", &_png_module::write_png,\n-                           \"write_png(buffer, width, height, fileobj, dpi=None)\");\n-        add_varargs_method(\"read_png\", &_png_module::read_png_float,\n-                           \"read_png(fileobj)\");\n-        add_varargs_method(\"read_png_float\", &_png_module::read_png_float,\n-                           \"read_png_float(fileobj)\");\n-        add_varargs_method(\"read_png_uint8\", &_png_module::read_png_uint8,\n-                           \"read_png_uint8(fileobj)\");\n-        add_varargs_method(\"read_png_int\", &_png_module::read_png_int,\n-                           \"read_png_int(fileobj)\");\n-        initialize(\"Module to write PNG files\");\n-    }\n-\n-    virtual ~_png_module() {}\n-\n-private:\n-    Py::Object write_png(const Py::Tuple& args);\n-    Py::Object read_png_uint8(const Py::Tuple& args);\n-    Py::Object read_png_float(const Py::Tuple& args);\n-    Py::Object read_png_int(const Py::Tuple& args);\n-    PyObject* _read_png(const Py::Object& py_fileobj, const bool float_result, int result_bit_depth = -1);\n-};\n-\n static void write_png_data(png_structp png_ptr, png_bytep data, png_size_t length)\n {\n-    PyObject* py_file_obj = (PyObject*)png_get_io_ptr(png_ptr);\n-    PyObject* write_method = PyObject_GetAttrString(py_file_obj, \"write\");\n-    PyObject* result = NULL;\n-    if (write_method)\n-    {\n-        #if PY3K\n-        result = PyObject_CallFunction(write_method, (char *)\"y#\", data,\n-                                       length);\n-        #else\n-        result = PyObject_CallFunction(write_method, (char *)\"s#\", data,\n-                                       length);\n-        #endif\n+    PyObject *py_file_obj = (PyObject *)png_get_io_ptr(png_ptr);\n+    PyObject *write_method = PyObject_GetAttrString(py_file_obj, \"write\");\n+    PyObject *result = NULL;\n+    if (write_method) {\n+#if PY3K\n+        result = PyObject_CallFunction(write_method, (char *)\"y#\", data, length);\n+#else\n+        result = PyObject_CallFunction(write_method, (char *)\"s#\", data, length);\n+#endif\n     }\n     Py_XDECREF(write_method);\n     Py_XDECREF(result);\n }\n \n static void flush_png_data(png_structp png_ptr)\n {\n-    PyObject* py_file_obj = (PyObject*)png_get_io_ptr(png_ptr);\n-    PyObject* flush_method = PyObject_GetAttrString(py_file_obj, \"flush\");\n-    PyObject* result = NULL;\n-    if (flush_method)\n-    {\n+    PyObject *py_file_obj = (PyObject *)png_get_io_ptr(png_ptr);\n+    PyObject *flush_method = PyObject_GetAttrString(py_file_obj, \"flush\");\n+    PyObject *result = NULL;\n+    if (flush_method) {\n         result = PyObject_CallFunction(flush_method, (char *)\"\");\n     }\n     Py_XDECREF(flush_method);\n     Py_XDECREF(result);\n }\n \n-// this code is heavily adapted from the paint license, which is in\n-// the file paint.license (BSD compatible) included in this\n-// distribution.  TODO, add license file to MANIFEST.in and CVS\n-Py::Object _png_module::write_png(const Py::Tuple& args)\n+const char *Py_write_png__doc__ = \"write_png(buffer, file, dpi=0)\";\n+\n+static PyObject *Py_write_png(PyObject *self, PyObject *args, PyObject *kwds)\n {\n-    args.verify_length(4, 5);\n+    numpy::array_view<unsigned char, 3> buffer;\n+    PyObject *filein;\n+    double dpi = 0;\n+    const char *names[] = { \"buffer\", \"file\", \"dpi\", NULL };\n+\n+    if (!PyArg_ParseTupleAndKeywords(args,\n+                                     kwds,\n+                                     \"O&O|d:write_png\",\n+                                     (char **)names,\n+                                     &numpy::convert_array<unsigned char, 3>,\n+                                     &buffer,\n+                                     &filein,\n+                                     &dpi)) {\n+        return NULL;\n+    }\n+\n+    png_uint_32 width = (png_uint_32)buffer.dim(1);\n+    png_uint_32 height = (png_uint_32)buffer.dim(0);\n+    std::vector<png_bytep> row_pointers(height);\n+    for (png_uint_32 row = 0; row < (png_uint_32)height; ++row) {\n+        row_pointers[row] = (png_bytep)buffer[row].data();\n+    }\n \n     FILE *fp = NULL;\n-    mpl_off_t offset;\n+    mpl_off_t offset = 0;\n     bool close_file = false;\n     bool close_dup_file = false;\n-    Py::Object buffer_obj = Py::Object(args[0]);\n-    PyObject* buffer = buffer_obj.ptr();\n-    if (!PyObject_CheckReadBuffer(buffer))\n-    {\n-        throw Py::TypeError(\"First argument must be an rgba buffer.\");\n-    }\n-\n-    const void* pixBufferPtr = NULL;\n-    Py_ssize_t pixBufferLength = 0;\n-    if (PyObject_AsReadBuffer(buffer, &pixBufferPtr, &pixBufferLength))\n-    {\n-        throw Py::ValueError(\"Couldn't get data from read buffer.\");\n-    }\n+    PyObject *py_file = NULL;\n \n-    png_byte* pixBuffer = (png_byte*)pixBufferPtr;\n-    int width = (int)Py::Int(args[1]);\n-    int height = (int)Py::Int(args[2]);\n+    png_structp png_ptr = NULL;\n+    png_infop info_ptr = NULL;\n+    struct png_color_8_struct sig_bit;\n \n-    if (pixBufferLength < width * height * 4)\n-    {\n-        throw Py::ValueError(\"Buffer and width, height don't seem to match.\");\n+    if (buffer.dim(2) != 4) {\n+        PyErr_SetString(PyExc_ValueError, \"Buffer must be RGBA NxMx4 array\");\n+        goto exit;\n     }\n \n-    Py::Object py_fileobj = Py::Object(args[3]);\n-    PyObject* py_file = NULL;\n-    if (py_fileobj.isString())\n-    {\n-        if ((py_file = mpl_PyFile_OpenFile(py_fileobj.ptr(), (char *)\"wb\")) == NULL) {\n-            throw Py::Exception();\n+    if (PyBytes_Check(filein) || PyUnicode_Check(filein)) {\n+        if ((py_file = mpl_PyFile_OpenFile(filein, (char *)\"wb\")) == NULL) {\n+            goto exit;\n         }\n         close_file = true;\n-    }\n-    else\n-    {\n-        py_file = py_fileobj.ptr();\n+    } else {\n+        py_file = filein;\n     }\n \n-    if ((fp = mpl_PyFile_Dup(py_file, (char *)\"wb\", &offset)))\n-    {\n+    if ((fp = mpl_PyFile_Dup(py_file, (char *)\"wb\", &offset))) {\n         close_dup_file = true;\n-    }\n-    else\n-    {\n+    } else {\n         PyErr_Clear();\n-        PyObject* write_method = PyObject_GetAttrString(\n-                py_file, \"write\");\n-        if (!(write_method && PyCallable_Check(write_method)))\n-        {\n+        PyObject *write_method = PyObject_GetAttrString(py_file, \"write\");\n+        if (!(write_method && PyCallable_Check(write_method))) {\n             Py_XDECREF(write_method);\n-            throw Py::TypeError(\n-                    \"Object does not appear to be a 8-bit string path or \"\n-                    \"a Python file-like object\");\n+            PyErr_SetString(PyExc_TypeError,\n+                            \"Object does not appear to be a 8-bit string path or \"\n+                            \"a Python file-like object\");\n+            goto exit;\n         }\n         Py_XDECREF(write_method);\n     }\n \n-    png_bytep *row_pointers = NULL;\n-    png_structp png_ptr = NULL;\n-    png_infop info_ptr = NULL;\n-\n-    try\n-    {\n-        struct png_color_8_struct sig_bit;\n-        png_uint_32 row;\n-\n-        row_pointers = new png_bytep[height];\n-        for (row = 0; row < (png_uint_32)height; ++row)\n-        {\n-            row_pointers[row] = pixBuffer + row * width * 4;\n-        }\n+    png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);\n+    if (png_ptr == NULL) {\n+        PyErr_SetString(PyExc_RuntimeError, \"Could not create write struct\");\n+        goto exit;\n+    }\n \n-        png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);\n-        if (png_ptr == NULL)\n-        {\n-            throw Py::RuntimeError(\"Could not create write struct\");\n-        }\n+    info_ptr = png_create_info_struct(png_ptr);\n+    if (info_ptr == NULL) {\n+        PyErr_SetString(PyExc_RuntimeError, \"Could not create info struct\");\n+        goto exit;\n+    }\n \n-        info_ptr = png_create_info_struct(png_ptr);\n-        if (info_ptr == NULL)\n-        {\n-            throw Py::RuntimeError(\"Could not create info struct\");\n-        }\n+    if (setjmp(png_jmpbuf(png_ptr))) {\n+        PyErr_SetString(PyExc_RuntimeError, \"Error setting jumps\");\n+        goto exit;\n+    }\n \n-        if (setjmp(png_jmpbuf(png_ptr)))\n-        {\n-            throw Py::RuntimeError(\"Error building image\");\n-        }\n+    if (fp) {\n+        png_init_io(png_ptr, fp);\n+    } else {\n+        png_set_write_fn(png_ptr, (void *)py_file, &write_png_data, &flush_png_data);\n+    }\n+    png_set_IHDR(png_ptr,\n+                 info_ptr,\n+                 width,\n+                 height,\n+                 8,\n+                 PNG_COLOR_TYPE_RGB_ALPHA,\n+                 PNG_INTERLACE_NONE,\n+                 PNG_COMPRESSION_TYPE_BASE,\n+                 PNG_FILTER_TYPE_BASE);\n \n-        if (fp)\n-        {\n-            png_init_io(png_ptr, fp);\n-        }\n-        else\n-        {\n-            png_set_write_fn(png_ptr, (void*)py_file,\n-                             &write_png_data, &flush_png_data);\n-        }\n-        png_set_IHDR(png_ptr, info_ptr,\n-                     width, height, 8,\n-                     PNG_COLOR_TYPE_RGB_ALPHA, PNG_INTERLACE_NONE,\n-                     PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);\n-\n-        // Save the dpi of the image in the file\n-        if (args.size() == 5)\n-        {\n-            double dpi = Py::Float(args[4]);\n-            size_t dots_per_meter = (size_t)(dpi / (2.54 / 100.0));\n-            png_set_pHYs(png_ptr, info_ptr, dots_per_meter, dots_per_meter, PNG_RESOLUTION_METER);\n-        }\n+    // Save the dpi of the image in the file\n+    if (dpi > 0.0) {\n+        png_uint_32 dots_per_meter = (png_uint_32)(dpi / (2.54 / 100.0));\n+        png_set_pHYs(png_ptr, info_ptr, dots_per_meter, dots_per_meter, PNG_RESOLUTION_METER);\n+    }\n \n-        // this a a color image!\n-        sig_bit.gray = 0;\n-        sig_bit.red = 8;\n-        sig_bit.green = 8;\n-        sig_bit.blue = 8;\n-        /* if the image has an alpha channel then */\n-        sig_bit.alpha = 8;\n-        png_set_sBIT(png_ptr, info_ptr, &sig_bit);\n+    // this a a color image!\n+    sig_bit.gray = 0;\n+    sig_bit.red = 8;\n+    sig_bit.green = 8;\n+    sig_bit.blue = 8;\n+    /* if the image has an alpha channel then */\n+    sig_bit.alpha = 8;\n+    png_set_sBIT(png_ptr, info_ptr, &sig_bit);\n \n-        png_write_info(png_ptr, info_ptr);\n-        png_write_image(png_ptr, row_pointers);\n-        png_write_end(png_ptr, info_ptr);\n-    }\n-    catch (...)\n-    {\n-        if (png_ptr && info_ptr)\n-        {\n-            png_destroy_write_struct(&png_ptr, &info_ptr);\n-        }\n-        delete [] row_pointers;\n+    png_write_info(png_ptr, info_ptr);\n+    png_write_image(png_ptr, &row_pointers[0]);\n+    png_write_end(png_ptr, info_ptr);\n \n-        if (close_dup_file)\n-        {\n-            if (mpl_PyFile_DupClose(py_file, fp, offset)) {\n-              throw Py::RuntimeError(\"Error closing dupe file handle\");\n-            }\n-        }\n+exit:\n \n-        if (close_file)\n-        {\n-            mpl_PyFile_CloseFile(py_file);\n-            Py_DECREF(py_file);\n-        }\n-        /* Changed calls to png_destroy_write_struct to follow\n-           http://www.libpng.org/pub/png/libpng-manual.txt.\n-           This ensures the info_ptr memory is released.\n-        */\n-        throw;\n+    if (png_ptr && info_ptr) {\n+        png_destroy_write_struct(&png_ptr, &info_ptr);\n     }\n \n-    png_destroy_write_struct(&png_ptr, &info_ptr);\n-    delete [] row_pointers;\n-    if (close_dup_file)\n-    {\n-        if (mpl_PyFile_DupClose(py_file, fp, offset)) {\n-          throw Py::RuntimeError(\"Error closing dupe file handle\");\n-        }\n+    if (close_dup_file) {\n+        mpl_PyFile_DupClose(py_file, fp, offset);\n     }\n \n-    if (close_file)\n-    {\n+    if (close_file) {\n         mpl_PyFile_CloseFile(py_file);\n         Py_DECREF(py_file);\n     }\n \n     if (PyErr_Occurred()) {\n-        throw Py::Exception();\n+        return NULL;\n     } else {\n-        return Py::Object();\n+        Py_RETURN_NONE;\n     }\n }\n \n-static void _read_png_data(PyObject* py_file_obj, png_bytep data, png_size_t length)\n+static void _read_png_data(PyObject *py_file_obj, png_bytep data, png_size_t length)\n {\n-    PyObject* read_method = PyObject_GetAttrString(py_file_obj, \"read\");\n-    PyObject* result = NULL;\n+    PyObject *read_method = PyObject_GetAttrString(py_file_obj, \"read\");\n+    PyObject *result = NULL;\n     char *buffer;\n     Py_ssize_t bufflen;\n-    if (read_method)\n-    {\n+    if (read_method) {\n         result = PyObject_CallFunction(read_method, (char *)\"i\", length);\n     }\n-    if (PyBytes_AsStringAndSize(result, &buffer, &bufflen) == 0)\n-    {\n-        if (bufflen == (Py_ssize_t)length)\n-        {\n+    if (PyBytes_AsStringAndSize(result, &buffer, &bufflen) == 0) {\n+        if (bufflen == (Py_ssize_t)length) {\n             memcpy(data, buffer, length);\n         }\n     }\n@@ -303,345 +225,328 @@ static void _read_png_data(PyObject* py_file_obj, png_bytep data, png_size_t len\n \n static void read_png_data(png_structp png_ptr, png_bytep data, png_size_t length)\n {\n-    PyObject* py_file_obj = (PyObject*)png_get_io_ptr(png_ptr);\n+    PyObject *py_file_obj = (PyObject *)png_get_io_ptr(png_ptr);\n     _read_png_data(py_file_obj, data, length);\n }\n \n-PyObject*\n-_png_module::_read_png(const Py::Object& py_fileobj, const bool float_result,\n-                       int result_bit_depth)\n+static PyObject *_read_png(PyObject *filein, bool float_result)\n {\n-    png_byte header[8];   // 8 is the maximum size that can be checked\n-    FILE* fp = NULL;\n-    mpl_off_t offset;\n+    png_byte header[8]; // 8 is the maximum size that can be checked\n+    FILE *fp = NULL;\n+    mpl_off_t offset = 0;\n     bool close_file = false;\n     bool close_dup_file = false;\n     PyObject *py_file = NULL;\n-\n-    if (py_fileobj.isString())\n-    {\n-        if ((py_file = mpl_PyFile_OpenFile(py_fileobj.ptr(), (char *)\"rb\")) == NULL) {\n-            throw Py::Exception();\n+    PyArrayObject *A = NULL;\n+    png_structp png_ptr = NULL;\n+    png_infop info_ptr = NULL;\n+    int num_dims;\n+    std::vector<png_bytep> row_pointers;\n+    png_uint_32 width = 0;\n+    png_uint_32 height = 0;\n+    int bit_depth;\n+\n+    if (PyBytes_Check(filein) || PyUnicode_Check(filein)) {\n+        if ((py_file = mpl_PyFile_OpenFile(filein, (char *)\"rb\")) == NULL) {\n+            goto exit;\n         }\n         close_file = true;\n     } else {\n-        py_file = py_fileobj.ptr();\n+        py_file = filein;\n     }\n \n-    if ((fp = mpl_PyFile_Dup(py_file, \"rb\", &offset)))\n-    {\n+    if ((fp = mpl_PyFile_Dup(py_file, (char *)\"rb\", &offset))) {\n         close_dup_file = true;\n-    }\n-    else\n-    {\n+    } else {\n         PyErr_Clear();\n-        PyObject* read_method = PyObject_GetAttrString(py_file, \"read\");\n-        if (!(read_method && PyCallable_Check(read_method)))\n-        {\n+        PyObject *read_method = PyObject_GetAttrString(py_file, \"read\");\n+        if (!(read_method && PyCallable_Check(read_method))) {\n             Py_XDECREF(read_method);\n-            throw Py::TypeError(\n-                \"Object does not appear to be a 8-bit string path or a Python \"\n-                \"file-like object\");\n+            PyErr_SetString(PyExc_TypeError,\n+                            \"Object does not appear to be a 8-bit string path or \"\n+                            \"a Python file-like object\");\n+            goto exit;\n         }\n         Py_XDECREF(read_method);\n     }\n \n-    if (fp)\n-    {\n-        if (fread(header, 1, 8, fp) != 8)\n-        {\n-            throw Py::RuntimeError(\n-                \"_image_module::readpng: error reading PNG header\");\n+    if (fp) {\n+        if (fread(header, 1, 8, fp) != 8) {\n+            PyErr_SetString(PyExc_IOError, \"error reading PNG header\");\n+            goto exit;\n         }\n-    }\n-    else\n-    {\n+    } else {\n         _read_png_data(py_file, header, 8);\n     }\n-    if (png_sig_cmp(header, 0, 8))\n-    {\n-        throw Py::RuntimeError(\n-            \"_image_module::readpng: file not recognized as a PNG file\");\n+\n+    if (png_sig_cmp(header, 0, 8)) {\n+        PyErr_SetString(PyExc_ValueError, \"invalid PNG header\");\n+        goto exit;\n     }\n \n     /* initialize stuff */\n-    png_structp png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);\n+    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);\n \n-    if (!png_ptr)\n-    {\n-        throw Py::RuntimeError(\n-            \"_image_module::readpng:  png_create_read_struct failed\");\n+    if (!png_ptr) {\n+        PyErr_SetString(PyExc_RuntimeError, \"png_create_read_struct failed\");\n+        goto exit;\n     }\n \n-    png_infop info_ptr = png_create_info_struct(png_ptr);\n-    if (!info_ptr)\n-    {\n-        throw Py::RuntimeError(\n-            \"_image_module::readpng:  png_create_info_struct failed\");\n+    info_ptr = png_create_info_struct(png_ptr);\n+    if (!info_ptr) {\n+        PyErr_SetString(PyExc_RuntimeError, \"png_create_info_struct failed\");\n+        goto exit;\n     }\n \n-    if (setjmp(png_jmpbuf(png_ptr)))\n-    {\n-        throw Py::RuntimeError(\n-            \"_image_module::readpng:  error during init_io\");\n+    if (setjmp(png_jmpbuf(png_ptr))) {\n+        PyErr_SetString(PyExc_RuntimeError, \"Error setting jump\");\n+        goto exit;\n     }\n \n-    if (fp)\n-    {\n+    if (fp) {\n         png_init_io(png_ptr, fp);\n-    }\n-    else\n-    {\n-        png_set_read_fn(png_ptr, (void*)py_file, &read_png_data);\n+    } else {\n+        png_set_read_fn(png_ptr, (void *)py_file, &read_png_data);\n     }\n     png_set_sig_bytes(png_ptr, 8);\n     png_read_info(png_ptr, info_ptr);\n \n-    png_uint_32 width = png_get_image_width(png_ptr, info_ptr);\n-    png_uint_32 height = png_get_image_height(png_ptr, info_ptr);\n+    width = png_get_image_width(png_ptr, info_ptr);\n+    height = png_get_image_height(png_ptr, info_ptr);\n \n-    int bit_depth = png_get_bit_depth(png_ptr, info_ptr);\n+    bit_depth = png_get_bit_depth(png_ptr, info_ptr);\n \n     // Unpack 1, 2, and 4-bit images\n-    if (bit_depth < 8)\n+    if (bit_depth < 8) {\n         png_set_packing(png_ptr);\n+    }\n \n     // If sig bits are set, shift data\n     png_color_8p sig_bit;\n     if ((png_get_color_type(png_ptr, info_ptr) != PNG_COLOR_TYPE_PALETTE) &&\n-        png_get_sBIT(png_ptr, info_ptr, &sig_bit))\n-    {\n+        png_get_sBIT(png_ptr, info_ptr, &sig_bit)) {\n         png_set_shift(png_ptr, sig_bit);\n     }\n \n     // Convert big endian to little\n-    if (bit_depth == 16)\n-    {\n+    if (bit_depth == 16) {\n         png_set_swap(png_ptr);\n     }\n \n     // Convert palletes to full RGB\n-    if (png_get_color_type(png_ptr, info_ptr) == PNG_COLOR_TYPE_PALETTE)\n-    {\n+    if (png_get_color_type(png_ptr, info_ptr) == PNG_COLOR_TYPE_PALETTE) {\n         png_set_palette_to_rgb(png_ptr);\n         bit_depth = 8;\n     }\n \n     // If there's an alpha channel convert gray to RGB\n-    if (png_get_color_type(png_ptr, info_ptr) == PNG_COLOR_TYPE_GRAY_ALPHA)\n-    {\n+    if (png_get_color_type(png_ptr, info_ptr) == PNG_COLOR_TYPE_GRAY_ALPHA) {\n         png_set_gray_to_rgb(png_ptr);\n     }\n \n     png_set_interlace_handling(png_ptr);\n     png_read_update_info(png_ptr, info_ptr);\n \n-    /* read file */\n-    if (setjmp(png_jmpbuf(png_ptr)))\n-    {\n-        throw Py::RuntimeError(\n-            \"_image_module::readpng: error during read_image\");\n-    }\n-\n-    png_bytep *row_pointers = new png_bytep[height];\n-    png_uint_32 row;\n-\n-    for (row = 0; row < height; row++)\n-    {\n-        row_pointers[row] = new png_byte[png_get_rowbytes(png_ptr,info_ptr)];\n+    row_pointers.resize(height);\n+    for (png_uint_32 row = 0; row < height; row++) {\n+        row_pointers[row] = new png_byte[png_get_rowbytes(png_ptr, info_ptr)];\n     }\n \n-    png_read_image(png_ptr, row_pointers);\n+    png_read_image(png_ptr, &row_pointers[0]);\n \n     npy_intp dimensions[3];\n-    dimensions[0] = height;  //numrows\n-    dimensions[1] = width;   //numcols\n-    if (png_get_color_type(png_ptr, info_ptr) & PNG_COLOR_MASK_ALPHA)\n-    {\n-        dimensions[2] = 4;     //RGBA images\n-    }\n-    else if (png_get_color_type(png_ptr, info_ptr) & PNG_COLOR_MASK_COLOR)\n-    {\n-        dimensions[2] = 3;     //RGB images\n-    }\n-    else\n-    {\n-        dimensions[2] = 1;     //Greyscale images\n+    dimensions[0] = height; // numrows\n+    dimensions[1] = width; // numcols\n+    if (png_get_color_type(png_ptr, info_ptr) & PNG_COLOR_MASK_ALPHA) {\n+        dimensions[2] = 4; // RGBA images\n+    } else if (png_get_color_type(png_ptr, info_ptr) & PNG_COLOR_MASK_COLOR) {\n+        dimensions[2] = 3; // RGB images\n+    } else {\n+        dimensions[2] = 1; // Greyscale images\n     }\n-    //For gray, return an x by y array, not an x by y by 1\n-    int num_dims  = (png_get_color_type(png_ptr, info_ptr)\n-                                & PNG_COLOR_MASK_COLOR) ? 3 : 2;\n+    // For gray, return an x by y array, not an x by y by 1\n+    num_dims = (png_get_color_type(png_ptr, info_ptr) & PNG_COLOR_MASK_COLOR) ? 3 : 2;\n \n-    PyArrayObject *A = NULL;\n     if (float_result) {\n         double max_value = (1 << bit_depth) - 1;\n \n-        A = (PyArrayObject *) PyArray_SimpleNew(num_dims, dimensions, NPY_FLOAT);\n-\n-        if (A == NULL)\n-        {\n-            throw Py::MemoryError(\"Could not allocate image array\");\n+        A = (PyArrayObject *)PyArray_SimpleNew(num_dims, dimensions, NPY_FLOAT);\n+        if (A == NULL) {\n+            goto exit;\n         }\n \n-        const npy_intp ystride = PyArray_STRIDE(A, 0);\n-        const npy_intp xstride = PyArray_STRIDE(A, 1);\n-        const npy_intp pstride = PyArray_STRIDE(A, 2);\n-        char* target_row = PyArray_BYTES(A);\n-        for (png_uint_32 y = 0; y < height; y++, target_row += ystride)\n-        {\n-            png_byte* row = row_pointers[y];\n-            char* target_pixel = target_row;\n-            for (png_uint_32 x = 0; x < width; x++, target_pixel += xstride)\n-            {\n-                if (bit_depth == 16)\n-                {\n-                    png_uint_16* ptr = &reinterpret_cast<png_uint_16*>(row)[x * dimensions[2]];\n-                    for (png_uint_32 p = 0; p < (png_uint_32)dimensions[2]; p++)\n-                    {\n-                        *(float*)(target_pixel + p * pstride) = (float)(ptr[p]) / max_value;\n+        for (png_uint_32 y = 0; y < height; y++) {\n+            png_byte *row = row_pointers[y];\n+            for (png_uint_32 x = 0; x < width; x++) {\n+                size_t offset = y * A->strides[0] + x * A->strides[1];\n+                if (bit_depth == 16) {\n+                    png_uint_16 *ptr = &reinterpret_cast<png_uint_16 *>(row)[x * dimensions[2]];\n+                    for (png_uint_32 p = 0; p < (png_uint_32)dimensions[2]; p++) {\n+                        *(float *)(A->data + offset + p *A->strides[2]) =\n+                            (float)(ptr[p]) / max_value;\n                     }\n-                }\n-                else\n-                {\n-                    png_byte* ptr = &(row[x * dimensions[2]]);\n-                    for (png_uint_32 p = 0; p < (png_uint_32)dimensions[2]; p++)\n-                    {\n-                        *(float*)(target_pixel + p * pstride) = (float)(ptr[p]) / max_value;\n+                } else {\n+                    png_byte *ptr = &(row[x * dimensions[2]]);\n+                    for (png_uint_32 p = 0; p < (png_uint_32)dimensions[2]; p++) {\n+                        *(float *)(A->data + offset + p *A->strides[2]) =\n+                            (float)(ptr[p]) / max_value;\n                     }\n                 }\n             }\n         }\n     } else {\n-        if (result_bit_depth < 0) {\n-            result_bit_depth = bit_depth;\n-        }\n-\n-        if (result_bit_depth == 8) {\n-            A = (PyArrayObject *) PyArray_SimpleNew(num_dims, dimensions, NPY_UBYTE);\n-        } else if (result_bit_depth == 16) {\n-            A = (PyArrayObject *) PyArray_SimpleNew(num_dims, dimensions, NPY_UINT16);\n+        if (bit_depth == 8) {\n+            A = (PyArrayObject *)PyArray_SimpleNew(num_dims, dimensions, NPY_UBYTE);\n+        } else if (bit_depth == 16) {\n+            A = (PyArrayObject *)PyArray_SimpleNew(num_dims, dimensions, NPY_UINT16);\n         } else {\n-            throw Py::RuntimeError(\n-                \"_image_module::readpng: image has unknown bit depth\");\n+            PyErr_SetString(PyExc_RuntimeError, \"image has unknown bit depth\");\n+            goto exit;\n         }\n \n-        if (A == NULL)\n-        {\n-            throw Py::MemoryError(\"Could not allocate image array\");\n+        if (A == NULL) {\n+            goto exit;\n         }\n \n-        const npy_intp ystride = PyArray_STRIDE(A, 0);\n-        const npy_intp xstride = PyArray_STRIDE(A, 1);\n-        const npy_intp pstride = PyArray_STRIDE(A, 2);\n-        char* target_row = PyArray_BYTES(A);\n-        for (png_uint_32 y = 0; y < height; y++, target_row += ystride)\n-        {\n-            png_byte* row = row_pointers[y];\n-            char* target_pixel = target_row;\n-            for (png_uint_32 x = 0; x < width; x++, target_pixel += xstride)\n-            {\n-                if (bit_depth == 16)\n-                {\n-                    png_uint_16* ptr = &reinterpret_cast<png_uint_16*>(row)[x * dimensions[2]];\n-\n-                    if (result_bit_depth == 16) {\n-                        for (png_uint_32 p = 0; p < (png_uint_32)dimensions[2]; p++)\n-                        {\n-                            *(png_uint_16*)(target_pixel + p*pstride) = ptr[p];\n+        for (png_uint_32 y = 0; y < height; y++) {\n+            png_byte *row = row_pointers[y];\n+            for (png_uint_32 x = 0; x < width; x++) {\n+                size_t offset = y * A->strides[0] + x * A->strides[1];\n+                if (bit_depth == 16) {\n+                    png_uint_16 *ptr = &reinterpret_cast<png_uint_16 *>(row)[x * dimensions[2]];\n+\n+                    if (bit_depth == 16) {\n+                        for (png_uint_32 p = 0; p < (png_uint_32)dimensions[2]; p++) {\n+                            *(png_uint_16 *)(A->data + offset + p *A->strides[2]) = ptr[p];\n                         }\n                     } else {\n-                        for (png_uint_32 p = 0; p < (png_uint_32)dimensions[2]; p++)\n-                        {\n-                            *(png_byte*)(target_pixel + p*pstride) = ptr[p] >> 8;\n+                        for (png_uint_32 p = 0; p < (png_uint_32)dimensions[2]; p++) {\n+                            *(png_byte *)(A->data + offset + p *A->strides[2]) = ptr[p] >> 8;\n                         }\n                     }\n-                }\n-                else\n-                {\n-                    png_byte* ptr = &(row[x * dimensions[2]]);\n-                    if (result_bit_depth == 16) {\n-                        for (png_uint_32 p = 0; p < (png_uint_32)dimensions[2]; p++)\n-                        {\n-                            *(png_uint_16*)(target_pixel + p*pstride) = ptr[p];\n+                } else {\n+                    png_byte *ptr = &(row[x * dimensions[2]]);\n+                    if (bit_depth == 16) {\n+                        for (png_uint_32 p = 0; p < (png_uint_32)dimensions[2]; p++) {\n+                            *(png_uint_16 *)(A->data + offset + p *A->strides[2]) = ptr[p];\n                         }\n                     } else {\n-                        for (png_uint_32 p = 0; p < (png_uint_32)dimensions[2]; p++)\n-                        {\n-                            *(png_byte*)(target_pixel + p*pstride) = ptr[p];\n+                        for (png_uint_32 p = 0; p < (png_uint_32)dimensions[2]; p++) {\n+                            *(png_byte *)(A->data + offset + p *A->strides[2]) = ptr[p];\n                         }\n                     }\n                 }\n             }\n         }\n     }\n \n-    //free the png memory\n+    // free the png memory\n     png_read_end(png_ptr, info_ptr);\n+\n+exit:\n+    if (png_ptr && info_ptr) {\n #ifndef png_infopp_NULL\n-    png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n+        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n #else\n-    png_destroy_read_struct(&png_ptr, &info_ptr, png_infopp_NULL);\n+        png_destroy_read_struct(&png_ptr, &info_ptr, png_infopp_NULL);\n #endif\n-    if (close_dup_file)\n-    {\n-        if (mpl_PyFile_DupClose(py_file, fp, offset)) {\n-          throw Py::RuntimeError(\"Error closing dupe file handle\");\n-        }\n     }\n \n-    if (close_file)\n-    {\n+    if (close_dup_file) {\n+        mpl_PyFile_DupClose(py_file, fp, offset);\n+    }\n+\n+    if (close_file) {\n         mpl_PyFile_CloseFile(py_file);\n         Py_DECREF(py_file);\n     }\n \n-    for (row = 0; row < height; row++)\n-    {\n-        delete [] row_pointers[row];\n+    for (png_uint_32 row = 0; row < height; row++) {\n+        delete[] row_pointers[row];\n     }\n-    delete [] row_pointers;\n \n     if (PyErr_Occurred()) {\n-        Py_DECREF((PyObject *)A);\n+        Py_XDECREF((PyObject *)A);\n         return NULL;\n     } else {\n         return (PyObject *)A;\n     }\n }\n \n-Py::Object\n-_png_module::read_png_float(const Py::Tuple& args)\n-{\n-    args.verify_length(1);\n-    return Py::asObject(_read_png(args[0], true));\n-}\n+const char *Py_read_png_float__doc__ = \"read_png_float(file)\";\n \n-Py::Object\n-_png_module::read_png_uint8(const Py::Tuple& args)\n+static PyObject *Py_read_png_float(PyObject *self, PyObject *args, PyObject *kwds)\n {\n-    throw Py::RuntimeError(\"read_png_uint8 is deprecated.  Use read_png_int instead.\");\n+    return _read_png(args, true);\n }\n \n-Py::Object\n-_png_module::read_png_int(const Py::Tuple& args)\n+const char *Py_read_png_int__doc__ = \"read_png_int(file)\";\n+\n+static PyObject *Py_read_png_int(PyObject *self, PyObject *args, PyObject *kwds)\n {\n-    args.verify_length(1);\n-    return Py::asObject(_read_png(args[0], false));\n+    return _read_png(args, false);\n }\n \n-PyMODINIT_FUNC\n+const char *Py_read_png__doc__ = \"read_png(file)\";\n+\n+static PyMethodDef module_methods[] = {\n+    {\"write_png\", (PyCFunction)Py_write_png, METH_VARARGS|METH_KEYWORDS, Py_write_png__doc__},\n+    {\"read_png\", (PyCFunction)Py_read_png_float, METH_O, Py_read_png__doc__},\n+    {\"read_png_float\", (PyCFunction)Py_read_png_float, METH_O, Py_read_png_float__doc__},\n+    {\"read_png_int\", (PyCFunction)Py_read_png_int, METH_O, Py_read_png_int__doc__},\n+    {NULL}\n+};\n+\n+extern \"C\" {\n+\n+    struct module_state\n+    {\n+        /* The Sun compiler can't handle empty structs */\n+#if defined(__SUNPRO_C) || defined(_MSC_VER)\n+        int _dummy;\n+#endif\n+    };\n+\n #if PY3K\n-PyInit__png(void)\n+    static struct PyModuleDef moduledef = {\n+        PyModuleDef_HEAD_INIT,\n+        \"_png\",\n+        NULL,\n+        sizeof(struct module_state),\n+        module_methods,\n+        NULL,\n+        NULL,\n+        NULL,\n+        NULL\n+    };\n+\n+#define INITERROR return NULL\n+\n+    PyMODINIT_FUNC PyInit__png(void)\n+\n #else\n-init_png(void)\n+#define INITERROR return\n+\n+    PyMODINIT_FUNC init_png(void)\n #endif\n-{\n-    import_array();\n \n-    static _png_module* _png = NULL;\n-    _png = new _png_module;\n+    {\n+        PyObject *m;\n \n #if PY3K\n-    return _png->module().ptr();\n+        m = PyModule_Create(&moduledef);\n+#else\n+        m = Py_InitModule3(\"_png\", module_methods, NULL);\n #endif\n+\n+        if (m == NULL) {\n+            INITERROR;\n+        }\n+\n+        import_array();\n+\n+#if PY3K\n+        return m;\n+#endif\n+    }\n }"}
{"patches_id": 2, "files_id": 43, "language": "cpp", "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_tkagg.cpp", "raw_code": "/* -*- mode: c++; c-basic-offset: 4 -*- */\n\n/*\n * The Python Imaging Library.\n * $Id$\n *\n */\n\n/* This is needed for (at least) Tk 8.4.1, otherwise the signature of\n** Tk_PhotoPutBlock changes.\n*/\n#define USE_COMPOSITELESS_PHOTO_PUT_BLOCK\n\n#include <Python.h>\n#include <cstdlib>\n#include <cstdio>\n#include <sstream>\n\n#include \"agg_basics.h\"\n#include \"_backend_agg_wrapper.h\"\n#include \"py_converters.h\"\n\nextern \"C\"\n{\n#ifdef __APPLE__\n#  ifdef TK_FRAMEWORK\n#     include <Tcl/tcl.h>\n#     include <Tk/tk.h>\n#  else\n#     include <tk.h>\n#  endif\n#else\n#  include <tk.h>\n#endif\n}\n\n#if defined(_MSC_VER)\n#  define SIZE_T_FORMAT \"%Iu\"\n#else\n#  define SIZE_T_FORMAT \"%zu\"\n#endif\n\ntypedef struct\n{\n    PyObject_HEAD;\n    Tcl_Interp *interp;\n} TkappObject;\n\nstatic int PyAggImagePhoto(ClientData clientdata, Tcl_Interp *interp, int argc, char **argv)\n{\n    Tk_PhotoHandle photo;\n    Tk_PhotoImageBlock block;\n    PyObject *aggo;\n\n    // vars for blitting\n    PyObject *bboxo;\n\n    size_t aggl, bboxl;\n    bool has_bbox;\n    agg::int8u *destbuffer;\n    int destx, desty, destwidth, destheight, deststride;\n    //unsigned long tmp_ptr;\n\n    long mode;\n    long nval;\n    if (Tk_MainWindow(interp) == NULL) {\n        // Will throw a _tkinter.TclError with \"this isn't a Tk application\"\n        return TCL_ERROR;\n    }\n\n    if (argc != 5) {\n        Tcl_AppendResult(interp, \"usage: \", argv[0], \" destPhoto srcImage\", (char *)NULL);\n        return TCL_ERROR;\n    }\n\n    /* get Tcl PhotoImage handle */\n    photo = Tk_FindPhoto(interp, argv[1]);\n    if (photo == NULL) {\n        Tcl_AppendResult(interp, \"destination photo must exist\", (char *)NULL);\n        return TCL_ERROR;\n    }\n    /* get array (or object that can be converted to array) pointer */\n    if (sscanf(argv[2], SIZE_T_FORMAT, &aggl) != 1) {\n        Tcl_AppendResult(interp, \"error casting pointer\", (char *)NULL);\n        return TCL_ERROR;\n    }\n    aggo = (PyObject *)aggl;\n\n    // TODO: This is really brittle and will break when RendererAgg\n    // comes in multiple flavors\n    RendererAgg *aggRenderer = ((PyRendererAgg *)(aggo))->x;\n    int srcheight = (int)aggRenderer->get_height();\n\n    /* XXX insert aggRenderer type check */\n\n    /* get array mode (0=mono, 1=rgb, 2=rgba) */\n    mode = atol(argv[3]);\n    if ((mode != 0) && (mode != 1) && (mode != 2)) {\n        Tcl_AppendResult(interp, \"illegal image mode\", (char *)NULL);\n        return TCL_ERROR;\n    }\n\n    /* check for bbox/blitting */\n    if (sscanf(argv[4], SIZE_T_FORMAT, &bboxl) != 1) {\n        Tcl_AppendResult(interp, \"error casting pointer\", (char *)NULL);\n        return TCL_ERROR;\n    }\n    bboxo = (PyObject *)bboxl;\n\n    if (bboxo != NULL && bboxo != Py_None) {\n        agg::rect_d rect;\n        if (!convert_rect(bboxo, &rect)) {\n            return TCL_ERROR;\n        }\n\n        has_bbox = true;\n\n        destx = (int)rect.x1;\n        desty = srcheight - (int)rect.y2;\n        destwidth = (int)(rect.x2 - rect.x1);\n        destheight = (int)(rect.y2 - rect.y1);\n        deststride = 4 * destwidth;\n\n        destbuffer = new agg::int8u[deststride * destheight];\n        if (destbuffer == NULL) {\n            Tcl_AppendResult(interp, \"could not allocate memory\", (char *)NULL);\n            return TCL_ERROR;\n        }\n\n        agg::rendering_buffer destrbuf;\n        destrbuf.attach(destbuffer, destwidth, destheight, deststride);\n        pixfmt destpf(destrbuf);\n        renderer_base destrb(destpf);\n\n        agg::rect_base<int> region(destx, desty, (int)rect.x2, srcheight - (int)rect.y1);\n        destrb.copy_from(aggRenderer->renderingBuffer, &region, -destx, -desty);\n    } else {\n        has_bbox = false;\n        destbuffer = NULL;\n        destx = desty = destwidth = destheight = deststride = 0;\n    }\n\n    /* setup tkblock */\n    block.pixelSize = 1;\n    if (mode == 0) {\n        block.offset[0] = block.offset[1] = block.offset[2] = 0;\n        nval = 1;\n    } else {\n        block.offset[0] = 0;\n        block.offset[1] = 1;\n        block.offset[2] = 2;\n        if (mode == 1) {\n            block.offset[3] = 0;\n            block.pixelSize = 3;\n            nval = 3;\n        } else {\n            block.offset[3] = 3;\n            block.pixelSize = 4;\n            nval = 4;\n        }\n    }\n\n    if (has_bbox) {\n        block.width = destwidth;\n        block.height = destheight;\n        block.pitch = deststride;\n        block.pixelPtr = destbuffer;\n\n        Tk_PhotoPutBlock(photo, &block, destx, desty, destwidth, destheight);\n        delete[] destbuffer;\n\n    } else {\n        block.width = aggRenderer->get_width();\n        block.height = aggRenderer->get_height();\n        block.pitch = (int)block.width * nval;\n        block.pixelPtr = aggRenderer->pixBuffer;\n\n        /* Clear current contents */\n        Tk_PhotoBlank(photo);\n        /* Copy opaque block to photo image, and leave the rest to TK */\n        Tk_PhotoPutBlock(photo, &block, 0, 0, block.width, block.height);\n    }\n\n    return TCL_OK;\n}\n\nstatic PyObject *_pyobj_addr(PyObject *self, PyObject *args)\n{\n    PyObject *pyobj;\n    if (!PyArg_ParseTuple(args, \"O\", &pyobj)) {\n        return NULL;\n    }\n    return Py_BuildValue(\"n\", (Py_ssize_t)pyobj);\n}\n\nstatic PyObject *_tkinit(PyObject *self, PyObject *args)\n{\n    Tcl_Interp *interp;\n    TkappObject *app;\n\n    Py_ssize_t arg;\n    int is_interp;\n    if (!PyArg_ParseTuple(args, \"ni\", &arg, &is_interp)) {\n        return NULL;\n    }\n\n    if (is_interp) {\n        interp = (Tcl_Interp *)arg;\n    } else {\n        /* Do it the hard way.  This will break if the TkappObject\n           layout changes */\n        app = (TkappObject *)arg;\n        interp = app->interp;\n    }\n\n    /* This will bomb if interp is invalid... */\n\n    Tcl_CreateCommand(interp,\n                      \"PyAggImagePhoto\",\n                      (Tcl_CmdProc *)PyAggImagePhoto,\n                      (ClientData)0,\n                      (Tcl_CmdDeleteProc *)NULL);\n\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyMethodDef functions[] = {\n    /* Tkinter interface stuff */\n    { \"_pyobj_addr\", (PyCFunction)_pyobj_addr, 1 }, { \"tkinit\", (PyCFunction)_tkinit, 1 },\n    { NULL, NULL } /* sentinel */\n};\n\n#if PY3K\nstatic PyModuleDef _tkagg_module = { PyModuleDef_HEAD_INIT, \"_tkagg\", \"\",   -1,  functions,\n                                     NULL,                  NULL,     NULL, NULL };\n\nPyMODINIT_FUNC PyInit__tkagg(void)\n{\n    PyObject *m;\n\n    m = PyModule_Create(&_tkagg_module);\n\n    import_array();\n\n    return m;\n}\n#else\nPyMODINIT_FUNC init_tkagg(void)\n{\n    import_array();\n\n    Py_InitModule(\"_tkagg\", functions);\n}\n#endif\n", "patch": "@@ -17,8 +17,8 @@\n #include <sstream>\n \n #include \"agg_basics.h\"\n-#include \"_backend_agg.h\"\n-#include \"agg_py_transforms.h\"\n+#include \"_backend_agg_wrapper.h\"\n+#include \"py_converters.h\"\n \n extern \"C\"\n {\n@@ -42,164 +42,138 @@ extern \"C\"\n \n typedef struct\n {\n-    PyObject_HEAD\n-    Tcl_Interp* interp;\n+    PyObject_HEAD;\n+    Tcl_Interp *interp;\n } TkappObject;\n \n-static int\n-PyAggImagePhoto(ClientData clientdata, Tcl_Interp* interp,\n-                int argc, char **argv)\n+static int PyAggImagePhoto(ClientData clientdata, Tcl_Interp *interp, int argc, char **argv)\n {\n     Tk_PhotoHandle photo;\n     Tk_PhotoImageBlock block;\n-    PyObject* aggo;\n+    PyObject *aggo;\n \n     // vars for blitting\n-    PyObject* bboxo;\n+    PyObject *bboxo;\n \n     size_t aggl, bboxl;\n     bool has_bbox;\n     agg::int8u *destbuffer;\n-    double l, b, r, t;\n     int destx, desty, destwidth, destheight, deststride;\n     //unsigned long tmp_ptr;\n \n     long mode;\n     long nval;\n-    if (Tk_MainWindow(interp) == NULL)\n-    {\n+    if (Tk_MainWindow(interp) == NULL) {\n         // Will throw a _tkinter.TclError with \"this isn't a Tk application\"\n         return TCL_ERROR;\n     }\n \n-    if (argc != 5)\n-    {\n-        Tcl_AppendResult(interp, \"usage: \", argv[0],\n-                         \" destPhoto srcImage\", (char *) NULL);\n+    if (argc != 5) {\n+        Tcl_AppendResult(interp, \"usage: \", argv[0], \" destPhoto srcImage\", (char *)NULL);\n         return TCL_ERROR;\n     }\n \n     /* get Tcl PhotoImage handle */\n     photo = Tk_FindPhoto(interp, argv[1]);\n-    if (photo == NULL)\n-    {\n-        Tcl_AppendResult(interp, \"destination photo must exist\", (char *) NULL);\n+    if (photo == NULL) {\n+        Tcl_AppendResult(interp, \"destination photo must exist\", (char *)NULL);\n         return TCL_ERROR;\n     }\n     /* get array (or object that can be converted to array) pointer */\n-    if (sscanf(argv[2], SIZE_T_FORMAT, &aggl) != 1)\n-    {\n-        Tcl_AppendResult(interp, \"error casting pointer\", (char *) NULL);\n+    if (sscanf(argv[2], SIZE_T_FORMAT, &aggl) != 1) {\n+        Tcl_AppendResult(interp, \"error casting pointer\", (char *)NULL);\n         return TCL_ERROR;\n     }\n-    aggo = (PyObject*)aggl;\n-    //aggo = (PyObject*)atol(argv[2]);\n-\n-    //std::stringstream agg_ptr_ss;\n-    //agg_ptr_ss.str(argv[2]);\n-    //agg_ptr_ss >> tmp_ptr;\n-    //aggo = (PyObject*)tmp_ptr;\n-    RendererAgg *aggRenderer = (RendererAgg *)aggo;\n+    aggo = (PyObject *)aggl;\n+\n+    // TODO: This is really brittle and will break when RendererAgg\n+    // comes in multiple flavors\n+    RendererAgg *aggRenderer = ((PyRendererAgg *)(aggo))->x;\n     int srcheight = (int)aggRenderer->get_height();\n \n     /* XXX insert aggRenderer type check */\n \n     /* get array mode (0=mono, 1=rgb, 2=rgba) */\n     mode = atol(argv[3]);\n-    if ((mode != 0) && (mode != 1) && (mode != 2))\n-    {\n-        Tcl_AppendResult(interp, \"illegal image mode\", (char *) NULL);\n+    if ((mode != 0) && (mode != 1) && (mode != 2)) {\n+        Tcl_AppendResult(interp, \"illegal image mode\", (char *)NULL);\n         return TCL_ERROR;\n     }\n \n     /* check for bbox/blitting */\n-    if (sscanf(argv[4], SIZE_T_FORMAT, &bboxl) != 1)\n-    {\n-        Tcl_AppendResult(interp, \"error casting pointer\", (char *) NULL);\n+    if (sscanf(argv[4], SIZE_T_FORMAT, &bboxl) != 1) {\n+        Tcl_AppendResult(interp, \"error casting pointer\", (char *)NULL);\n         return TCL_ERROR;\n     }\n-    bboxo = (PyObject*)bboxl;\n-\n-    //bboxo = (PyObject*)atol(argv[4]);\n-    //std::stringstream bbox_ptr_ss;\n-    //bbox_ptr_ss.str(argv[4]);\n-    //bbox_ptr_ss >> tmp_ptr;\n-    //bboxo = (PyObject*)tmp_ptr;\n-    if (py_convert_bbox(bboxo, l, b, r, t))\n-    {\n+    bboxo = (PyObject *)bboxl;\n+\n+    if (bboxo != NULL && bboxo != Py_None) {\n+        agg::rect_d rect;\n+        if (!convert_rect(bboxo, &rect)) {\n+            return TCL_ERROR;\n+        }\n+\n         has_bbox = true;\n \n-        destx = (int)l;\n-        desty = srcheight - (int)t;\n-        destwidth = (int)(r - l);\n-        destheight = (int)(t - b);\n+        destx = (int)rect.x1;\n+        desty = srcheight - (int)rect.y2;\n+        destwidth = (int)(rect.x2 - rect.x1);\n+        destheight = (int)(rect.y2 - rect.y1);\n         deststride = 4 * destwidth;\n \n-        destbuffer = new agg::int8u[deststride*destheight];\n-        if (destbuffer == NULL)\n-        {\n-            throw Py::MemoryError(\"_tkagg could not allocate memory for destbuffer\");\n+        destbuffer = new agg::int8u[deststride * destheight];\n+        if (destbuffer == NULL) {\n+            Tcl_AppendResult(interp, \"could not allocate memory\", (char *)NULL);\n+            return TCL_ERROR;\n         }\n \n         agg::rendering_buffer destrbuf;\n         destrbuf.attach(destbuffer, destwidth, destheight, deststride);\n         pixfmt destpf(destrbuf);\n         renderer_base destrb(destpf);\n \n-        agg::rect_base<int> region(destx, desty, (int)r, srcheight - (int)b);\n-        destrb.copy_from(aggRenderer->renderingBuffer, &region,\n-                         -destx, -desty);\n-    }\n-    else\n-    {\n+        agg::rect_base<int> region(destx, desty, (int)rect.x2, srcheight - (int)rect.y1);\n+        destrb.copy_from(aggRenderer->renderingBuffer, &region, -destx, -desty);\n+    } else {\n         has_bbox = false;\n         destbuffer = NULL;\n         destx = desty = destwidth = destheight = deststride = 0;\n     }\n \n     /* setup tkblock */\n     block.pixelSize = 1;\n-    if (mode == 0)\n-    {\n+    if (mode == 0) {\n         block.offset[0] = block.offset[1] = block.offset[2] = 0;\n         nval = 1;\n-    }\n-    else\n-    {\n+    } else {\n         block.offset[0] = 0;\n         block.offset[1] = 1;\n         block.offset[2] = 2;\n-        if (mode == 1)\n-        {\n+        if (mode == 1) {\n             block.offset[3] = 0;\n             block.pixelSize = 3;\n             nval = 3;\n-        }\n-        else\n-        {\n+        } else {\n             block.offset[3] = 3;\n             block.pixelSize = 4;\n             nval = 4;\n         }\n     }\n \n-    if (has_bbox)\n-    {\n-        block.width  = destwidth;\n+    if (has_bbox) {\n+        block.width = destwidth;\n         block.height = destheight;\n         block.pitch = deststride;\n         block.pixelPtr = destbuffer;\n \n         Tk_PhotoPutBlock(photo, &block, destx, desty, destwidth, destheight);\n-        delete [] destbuffer;\n+        delete[] destbuffer;\n \n-    }\n-    else\n-    {\n-        block.width  = aggRenderer->get_width();\n+    } else {\n+        block.width = aggRenderer->get_width();\n         block.height = aggRenderer->get_height();\n-        block.pitch = block.width * nval;\n-        block.pixelPtr =  aggRenderer->pixBuffer;\n+        block.pitch = (int)block.width * nval;\n+        block.pixelPtr = aggRenderer->pixBuffer;\n \n         /* Clear current contents */\n         Tk_PhotoBlank(photo);\n@@ -210,75 +184,60 @@ PyAggImagePhoto(ClientData clientdata, Tcl_Interp* interp,\n     return TCL_OK;\n }\n \n-\n-static PyObject *\n-_pyobj_addr(PyObject* self, PyObject* args)\n+static PyObject *_pyobj_addr(PyObject *self, PyObject *args)\n {\n     PyObject *pyobj;\n-    if (!PyArg_ParseTuple(args, \"O\", &pyobj))\n-    {\n+    if (!PyArg_ParseTuple(args, \"O\", &pyobj)) {\n         return NULL;\n     }\n-    return Py_BuildValue(\"n\", (Py_ssize_t) pyobj);\n+    return Py_BuildValue(\"n\", (Py_ssize_t)pyobj);\n }\n \n-static PyObject*\n-_tkinit(PyObject* self, PyObject* args)\n+static PyObject *_tkinit(PyObject *self, PyObject *args)\n {\n-    Tcl_Interp* interp;\n-    TkappObject* app;\n+    Tcl_Interp *interp;\n+    TkappObject *app;\n \n     Py_ssize_t arg;\n     int is_interp;\n-    if (!PyArg_ParseTuple(args, \"ni\", &arg, &is_interp))\n-    {\n+    if (!PyArg_ParseTuple(args, \"ni\", &arg, &is_interp)) {\n         return NULL;\n     }\n \n-    if (is_interp)\n-    {\n-        interp = (Tcl_Interp*) arg;\n-    }\n-    else\n-    {\n+    if (is_interp) {\n+        interp = (Tcl_Interp *)arg;\n+    } else {\n         /* Do it the hard way.  This will break if the TkappObject\n            layout changes */\n-        app = (TkappObject*) arg;\n+        app = (TkappObject *)arg;\n         interp = app->interp;\n     }\n \n     /* This will bomb if interp is invalid... */\n \n-    Tcl_CreateCommand(interp, \"PyAggImagePhoto\",\n-                      (Tcl_CmdProc *) PyAggImagePhoto,\n-                      (ClientData) 0, (Tcl_CmdDeleteProc*) NULL);\n+    Tcl_CreateCommand(interp,\n+                      \"PyAggImagePhoto\",\n+                      (Tcl_CmdProc *)PyAggImagePhoto,\n+                      (ClientData)0,\n+                      (Tcl_CmdDeleteProc *)NULL);\n \n     Py_INCREF(Py_None);\n     return Py_None;\n }\n \n-static PyMethodDef functions[] =\n-{\n+static PyMethodDef functions[] = {\n     /* Tkinter interface stuff */\n-    {\"_pyobj_addr\", (PyCFunction)_pyobj_addr, 1},\n-    {\"tkinit\", (PyCFunction)_tkinit, 1},\n-    {NULL, NULL} /* sentinel */\n+    { \"_pyobj_addr\", (PyCFunction)_pyobj_addr, 1 }, { \"tkinit\", (PyCFunction)_tkinit, 1 },\n+    { NULL, NULL } /* sentinel */\n };\n \n #if PY3K\n-static PyModuleDef _tkagg_module = {\n-    PyModuleDef_HEAD_INIT,\n-    \"_tkagg\",\n-    \"\",\n-    -1,\n-    functions,\n-    NULL, NULL, NULL, NULL\n-};\n+static PyModuleDef _tkagg_module = { PyModuleDef_HEAD_INIT, \"_tkagg\", \"\",   -1,  functions,\n+                                     NULL,                  NULL,     NULL, NULL };\n \n-PyMODINIT_FUNC\n-PyInit__tkagg(void)\n+PyMODINIT_FUNC PyInit__tkagg(void)\n {\n-    PyObject* m;\n+    PyObject *m;\n \n     m = PyModule_Create(&_tkagg_module);\n \n@@ -287,12 +246,10 @@ PyInit__tkagg(void)\n     return m;\n }\n #else\n-PyMODINIT_FUNC\n-init_tkagg(void)\n+PyMODINIT_FUNC init_tkagg(void)\n {\n     import_array();\n \n     Py_InitModule(\"_tkagg\", functions);\n }\n #endif\n-"}
{"patches_id": 2, "files_id": 44, "language": "cpp", "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_ttconv.cpp", "raw_code": "/* -*- mode: c++; c-basic-offset: 4 -*- */\n\n/*\n  _ttconv.c\n\n  Python wrapper for TrueType conversion library in ../ttconv.\n */\n\n#include \"mplutils.h\"\n\n#include <Python.h>\n#include \"ttconv/pprdrv.h\"\n#include \"py_exceptions.h\"\n#include <vector>\n#include <cassert>\n\n/**\n * An implementation of TTStreamWriter that writes to a Python\n * file-like object.\n */\nclass PythonFileWriter : public TTStreamWriter\n{\n    PyObject *_write_method;\n\n  public:\n    PythonFileWriter()\n    {\n        _write_method = NULL;\n    }\n\n    ~PythonFileWriter()\n    {\n        Py_XDECREF(_write_method);\n    }\n\n    void set(PyObject *write_method)\n    {\n        Py_XDECREF(_write_method);\n        _write_method = write_method;\n        Py_XINCREF(_write_method);\n    }\n\n    virtual void write(const char *a)\n    {\n        PyObject *result = NULL;\n        if (_write_method) {\n            PyObject *decoded = NULL;\n            decoded = PyUnicode_DecodeLatin1(a, strlen(a), \"\");\n            if (decoded == NULL) {\n                throw py::exception();\n            }\n            result = PyObject_CallFunction(_write_method, (char *)\"O\", decoded);\n            Py_DECREF(decoded);\n            if (!result) {\n                throw py::exception();\n            }\n            Py_DECREF(result);\n        }\n    }\n};\n\nint fileobject_to_PythonFileWriter(PyObject *object, void *address)\n{\n    PythonFileWriter *file_writer = (PythonFileWriter *)address;\n\n    PyObject *write_method = PyObject_GetAttrString(object, \"write\");\n    if (write_method == NULL || !PyCallable_Check(write_method)) {\n        PyErr_SetString(PyExc_TypeError, \"Expected a file-like object with a write method.\");\n        return 0;\n    }\n\n    file_writer->set(write_method);\n    Py_DECREF(write_method);\n\n    return 1;\n}\n\nint pyiterable_to_vector_int(PyObject *object, void *address)\n{\n    std::vector<int> *result = (std::vector<int> *)address;\n\n    PyObject *iterator = PyObject_GetIter(object);\n    if (!iterator) {\n        return 0;\n    }\n\n    PyObject *item;\n    while ((item = PyIter_Next(iterator))) {\n#if PY3K\n        long value = PyLong_AsLong(item);\n#else\n        long value = PyInt_AsLong(item);\n#endif\n        Py_DECREF(item);\n        if (value == -1 && PyErr_Occurred()) {\n            return 0;\n        }\n        result->push_back((int)value);\n    }\n\n    Py_DECREF(iterator);\n\n    return 1;\n}\n\nstatic PyObject *convert_ttf_to_ps(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    const char *filename;\n    PythonFileWriter output;\n    int fonttype;\n    std::vector<int> glyph_ids;\n\n    static const char *kwlist[] = { \"filename\", \"output\", \"fonttype\", \"glyph_ids\", NULL };\n    if (!PyArg_ParseTupleAndKeywords(args,\n                                     kwds,\n#if PY_MAJOR_VERSION == 3\n                                     \"yO&i|O&:convert_ttf_to_ps\",\n#else\n                                     \"sO&i|O&:convert_ttf_to_ps\",\n#endif\n                                     (char **)kwlist,\n                                     &filename,\n                                     fileobject_to_PythonFileWriter,\n                                     &output,\n                                     &fonttype,\n                                     pyiterable_to_vector_int,\n                                     &glyph_ids)) {\n        return NULL;\n    }\n\n    if (fonttype != 3 && fonttype != 42) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"fonttype must be either 3 (raw Postscript) or 42 \"\n                        \"(embedded Truetype)\");\n        return NULL;\n    }\n\n    try\n    {\n        insert_ttfont(filename, output, (font_type_enum)fonttype, glyph_ids);\n    }\n    catch (TTException &e)\n    {\n        PyErr_SetString(PyExc_RuntimeError, e.getMessage());\n        return NULL;\n    }\n    catch (const py::exception &)\n    {\n        return NULL;\n    }\n    catch (...)\n    {\n        PyErr_SetString(PyExc_RuntimeError, \"Unknown C++ exception\");\n        return NULL;\n    }\n\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nclass PythonDictionaryCallback : public TTDictionaryCallback\n{\n    PyObject *_dict;\n\n  public:\n    PythonDictionaryCallback(PyObject *dict)\n    {\n        _dict = dict;\n    }\n\n    virtual void add_pair(const char *a, const char *b)\n    {\n        assert(a != NULL);\n        assert(b != NULL);\n        PyObject *value = PyBytes_FromString(b);\n        if (!value) {\n            throw py::exception();\n        }\n        if (PyDict_SetItemString(_dict, a, value)) {\n            Py_DECREF(value);\n            throw py::exception();\n        }\n        Py_DECREF(value);\n    }\n};\n\nstatic PyObject *py_get_pdf_charprocs(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    const char *filename;\n    std::vector<int> glyph_ids;\n    PyObject *result;\n\n    static const char *kwlist[] = { \"filename\", \"glyph_ids\", NULL };\n    if (!PyArg_ParseTupleAndKeywords(args,\n                                     kwds,\n#if PY_MAJOR_VERSION == 3\n                                     \"y|O&:get_pdf_charprocs\",\n#else\n                                     \"s|O&:get_pdf_charprocs\",\n#endif\n                                     (char **)kwlist,\n                                     &filename,\n                                     pyiterable_to_vector_int,\n                                     &glyph_ids)) {\n        return NULL;\n    }\n\n    result = PyDict_New();\n    if (!result) {\n        return NULL;\n    }\n\n    PythonDictionaryCallback dict(result);\n\n    try\n    {\n        ::get_pdf_charprocs(filename, glyph_ids, dict);\n    }\n    catch (TTException &e)\n    {\n        Py_DECREF(result);\n        PyErr_SetString(PyExc_RuntimeError, e.getMessage());\n        return NULL;\n    }\n    catch (const py::exception &)\n    {\n        Py_DECREF(result);\n        return NULL;\n    }\n    catch (...)\n    {\n        Py_DECREF(result);\n        PyErr_SetString(PyExc_RuntimeError, \"Unknown C++ exception\");\n        return NULL;\n    }\n\n    return result;\n}\n\nstatic PyMethodDef ttconv_methods[] =\n{\n    {\n        \"convert_ttf_to_ps\", (PyCFunction)convert_ttf_to_ps, METH_VARARGS | METH_KEYWORDS,\n        \"convert_ttf_to_ps(filename, output, fonttype, glyph_ids)\\n\"\n        \"\\n\"\n        \"Converts the Truetype font into a Type 3 or Type 42 Postscript font, \"\n        \"optionally subsetting the font to only the desired set of characters.\\n\"\n        \"\\n\"\n        \"filename is the path to a TTF font file.\\n\"\n        \"output is a Python file-like object with a write method that the Postscript \"\n        \"font data will be written to.\\n\"\n        \"fonttype may be either 3 or 42.  Type 3 is a \\\"raw Postscript\\\" font. \"\n        \"Type 42 is an embedded Truetype font.  Glyph subsetting is not supported \"\n        \"for Type 42 fonts.\\n\"\n        \"glyph_ids (optional) is a list of glyph ids (integers) to keep when \"\n        \"subsetting to a Type 3 font.  If glyph_ids is not provided or is None, \"\n        \"then all glyphs will be included.  If any of the glyphs specified are \"\n        \"composite glyphs, then the component glyphs will also be included.\"\n    },\n    {\n        \"get_pdf_charprocs\", (PyCFunction)py_get_pdf_charprocs, METH_VARARGS | METH_KEYWORDS,\n        \"get_pdf_charprocs(filename, glyph_ids)\\n\"\n        \"\\n\"\n        \"Given a Truetype font file, returns a dictionary containing the PDF Type 3\\n\"\n        \"representation of its paths.  Useful for subsetting a Truetype font inside\\n\"\n        \"of a PDF file.\\n\"\n        \"\\n\"\n        \"filename is the path to a TTF font file.\\n\"\n        \"glyph_ids is a list of the numeric glyph ids to include.\\n\"\n        \"The return value is a dictionary where the keys are glyph names and\\n\"\n        \"the values are the stream content needed to render that glyph.  This\\n\"\n        \"is useful to generate the CharProcs dictionary in a PDF Type 3 font.\\n\"\n    },\n    {0, 0, 0, 0}  /* Sentinel */\n};\n\nstatic const char *module_docstring =\n    \"Module to handle converting and subsetting TrueType \"\n    \"fonts to Postscript Type 3, Postscript Type 42 and \"\n    \"Pdf Type 3 fonts.\";\n\n#if PY3K\nstatic PyModuleDef ttconv_module = {\n    PyModuleDef_HEAD_INIT,\n    \"ttconv\",\n    module_docstring,\n    -1,\n    ttconv_methods,\n    NULL, NULL, NULL, NULL\n};\n\nPyMODINIT_FUNC\nPyInit_ttconv(void)\n{\n    PyObject* m;\n\n    m = PyModule_Create(&ttconv_module);\n\n    return m;\n}\n#else\nPyMODINIT_FUNC\ninitttconv(void)\n{\n    Py_InitModule3(\"ttconv\", ttconv_methods, module_docstring);\n}\n#endif\n", "patch": "@@ -10,23 +10,19 @@\n \n #include <Python.h>\n #include \"ttconv/pprdrv.h\"\n+#include \"py_exceptions.h\"\n #include <vector>\n #include <cassert>\n \n-class PythonExceptionOccurred\n-{\n-\n-};\n-\n /**\n  * An implementation of TTStreamWriter that writes to a Python\n  * file-like object.\n  */\n class PythonFileWriter : public TTStreamWriter\n {\n-    PyObject* _write_method;\n+    PyObject *_write_method;\n \n-public:\n+  public:\n     PythonFileWriter()\n     {\n         _write_method = NULL;\n@@ -37,41 +33,38 @@ class PythonFileWriter : public TTStreamWriter\n         Py_XDECREF(_write_method);\n     }\n \n-    void set(PyObject* write_method)\n+    void set(PyObject *write_method)\n     {\n         Py_XDECREF(_write_method);\n         _write_method = write_method;\n         Py_XINCREF(_write_method);\n     }\n \n-    virtual void write(const char* a)\n+    virtual void write(const char *a)\n     {\n-        PyObject* result = NULL;\n-        if (_write_method)\n-        {\n-            PyObject* decoded = NULL;\n+        PyObject *result = NULL;\n+        if (_write_method) {\n+            PyObject *decoded = NULL;\n             decoded = PyUnicode_DecodeLatin1(a, strlen(a), \"\");\n             if (decoded == NULL) {\n-                throw PythonExceptionOccurred();\n+                throw py::exception();\n             }\n-            result = PyObject_CallFunction(_write_method, \"O\", decoded);\n+            result = PyObject_CallFunction(_write_method, (char *)\"O\", decoded);\n             Py_DECREF(decoded);\n-            if (! result)\n-            {\n-                throw PythonExceptionOccurred();\n+            if (!result) {\n+                throw py::exception();\n             }\n             Py_DECREF(result);\n         }\n     }\n };\n \n-int fileobject_to_PythonFileWriter(PyObject* object, void* address)\n+int fileobject_to_PythonFileWriter(PyObject *object, void *address)\n {\n-    PythonFileWriter* file_writer = (PythonFileWriter*)address;\n+    PythonFileWriter *file_writer = (PythonFileWriter *)address;\n \n-    PyObject* write_method = PyObject_GetAttrString(object, \"write\");\n-    if (write_method == NULL || ! PyCallable_Check(write_method))\n-    {\n+    PyObject *write_method = PyObject_GetAttrString(object, \"write\");\n+    if (write_method == NULL || !PyCallable_Check(write_method)) {\n         PyErr_SetString(PyExc_TypeError, \"Expected a file-like object with a write method.\");\n         return 0;\n     }\n@@ -82,69 +75,60 @@ int fileobject_to_PythonFileWriter(PyObject* object, void* address)\n     return 1;\n }\n \n-int pyiterable_to_vector_int(PyObject* object, void* address)\n+int pyiterable_to_vector_int(PyObject *object, void *address)\n {\n-    std::vector<int>* result = (std::vector<int>*)address;\n+    std::vector<int> *result = (std::vector<int> *)address;\n \n-    PyObject* iterator = PyObject_GetIter(object);\n-    if (! iterator)\n-    {\n+    PyObject *iterator = PyObject_GetIter(object);\n+    if (!iterator) {\n         return 0;\n     }\n \n-    PyObject* item;\n-    while ((item = PyIter_Next(iterator)))\n-    {\n-        #if PY3K\n+    PyObject *item;\n+    while ((item = PyIter_Next(iterator))) {\n+#if PY3K\n         long value = PyLong_AsLong(item);\n-        #else\n+#else\n         long value = PyInt_AsLong(item);\n-        #endif\n+#endif\n         Py_DECREF(item);\n-        if (value == -1 && PyErr_Occurred())\n-        {\n+        if (value == -1 && PyErr_Occurred()) {\n             return 0;\n         }\n-        result->push_back(value);\n+        result->push_back((int)value);\n     }\n \n     Py_DECREF(iterator);\n \n     return 1;\n }\n \n-static PyObject*\n-convert_ttf_to_ps(PyObject* self, PyObject* args, PyObject* kwds)\n+static PyObject *convert_ttf_to_ps(PyObject *self, PyObject *args, PyObject *kwds)\n {\n-    const char*         filename;\n-    PythonFileWriter    output;\n-    int                 fonttype;\n-    std::vector<int>    glyph_ids;\n-\n-    static const char *kwlist[] =\n-    {\n-        \"filename\", \"output\", \"fonttype\", \"glyph_ids\", NULL\n-    };\n-    if (! PyArg_ParseTupleAndKeywords\n-        (args, kwds,\n-         #if PY_MAJOR_VERSION == 3\n-         \"yO&i|O&:convert_ttf_to_ps\",\n-         #else\n-         \"sO&i|O&:convert_ttf_to_ps\",\n-         #endif\n-         (char**)kwlist,\n-         &filename,\n-         fileobject_to_PythonFileWriter,\n-         &output,\n-         &fonttype,\n-         pyiterable_to_vector_int,\n-         &glyph_ids))\n-    {\n+    const char *filename;\n+    PythonFileWriter output;\n+    int fonttype;\n+    std::vector<int> glyph_ids;\n+\n+    static const char *kwlist[] = { \"filename\", \"output\", \"fonttype\", \"glyph_ids\", NULL };\n+    if (!PyArg_ParseTupleAndKeywords(args,\n+                                     kwds,\n+#if PY_MAJOR_VERSION == 3\n+                                     \"yO&i|O&:convert_ttf_to_ps\",\n+#else\n+                                     \"sO&i|O&:convert_ttf_to_ps\",\n+#endif\n+                                     (char **)kwlist,\n+                                     &filename,\n+                                     fileobject_to_PythonFileWriter,\n+                                     &output,\n+                                     &fonttype,\n+                                     pyiterable_to_vector_int,\n+                                     &glyph_ids)) {\n         return NULL;\n     }\n \n-    if (fonttype != 3 && fonttype != 42)\n-    {\n+    if (fonttype != 3 && fonttype != 42) {\n         PyErr_SetString(PyExc_ValueError,\n                         \"fonttype must be either 3 (raw Postscript) or 42 \"\n                         \"(embedded Truetype)\");\n@@ -155,12 +139,12 @@ convert_ttf_to_ps(PyObject* self, PyObject* args, PyObject* kwds)\n     {\n         insert_ttfont(filename, output, (font_type_enum)fonttype, glyph_ids);\n     }\n-    catch (TTException& e)\n+    catch (TTException &e)\n     {\n         PyErr_SetString(PyExc_RuntimeError, e.getMessage());\n         return NULL;\n     }\n-    catch (PythonExceptionOccurred&)\n+    catch (const py::exception &)\n     {\n         return NULL;\n     }\n@@ -176,58 +160,53 @@ convert_ttf_to_ps(PyObject* self, PyObject* args, PyObject* kwds)\n \n class PythonDictionaryCallback : public TTDictionaryCallback\n {\n-    PyObject* _dict;\n+    PyObject *_dict;\n \n-public:\n-    PythonDictionaryCallback(PyObject* dict)\n+  public:\n+    PythonDictionaryCallback(PyObject *dict)\n     {\n         _dict = dict;\n     }\n \n-    virtual void add_pair(const char* a, const char* b)\n+    virtual void add_pair(const char *a, const char *b)\n     {\n         assert(a != NULL);\n         assert(b != NULL);\n-        PyObject* value = PyBytes_FromString(b);\n-        if (!value)\n-        {\n-            throw PythonExceptionOccurred();\n+        PyObject *value = PyBytes_FromString(b);\n+        if (!value) {\n+            throw py::exception();\n         }\n-        if (PyDict_SetItemString(_dict, a, value))\n-        {\n+        if (PyDict_SetItemString(_dict, a, value)) {\n             Py_DECREF(value);\n-            throw PythonExceptionOccurred();\n+            throw py::exception();\n         }\n         Py_DECREF(value);\n     }\n };\n \n-static PyObject*\n-py_get_pdf_charprocs(PyObject* self, PyObject* args, PyObject* kwds)\n+static PyObject *py_get_pdf_charprocs(PyObject *self, PyObject *args, PyObject *kwds)\n {\n-    const char*         filename;\n-    std::vector<int>    glyph_ids;\n-    PyObject*             result;\n+    const char *filename;\n+    std::vector<int> glyph_ids;\n+    PyObject *result;\n \n     static const char *kwlist[] = { \"filename\", \"glyph_ids\", NULL };\n-    if (! PyArg_ParseTupleAndKeywords\n-            (args, kwds,\n-             #if PY_MAJOR_VERSION == 3\n-             \"y|O&:get_pdf_charprocs\",\n-             #else\n-             \"s|O&:get_pdf_charprocs\",\n-             #endif\n-             (char **)kwlist,\n-             &filename,\n-             pyiterable_to_vector_int,\n-             &glyph_ids))\n-    {\n+    if (!PyArg_ParseTupleAndKeywords(args,\n+                                     kwds,\n+#if PY_MAJOR_VERSION == 3\n+                                     \"y|O&:get_pdf_charprocs\",\n+#else\n+                                     \"s|O&:get_pdf_charprocs\",\n+#endif\n+                                     (char **)kwlist,\n+                                     &filename,\n+                                     pyiterable_to_vector_int,\n+                                     &glyph_ids)) {\n         return NULL;\n     }\n \n     result = PyDict_New();\n-    if (!result)\n-    {\n+    if (!result) {\n         return NULL;\n     }\n \n@@ -237,13 +216,13 @@ py_get_pdf_charprocs(PyObject* self, PyObject* args, PyObject* kwds)\n     {\n         ::get_pdf_charprocs(filename, glyph_ids, dict);\n     }\n-    catch (TTException& e)\n+    catch (TTException &e)\n     {\n         Py_DECREF(result);\n         PyErr_SetString(PyExc_RuntimeError, e.getMessage());\n         return NULL;\n     }\n-    catch (PythonExceptionOccurred&)\n+    catch (const py::exception &)\n     {\n         Py_DECREF(result);\n         return NULL;\n@@ -295,7 +274,7 @@ static PyMethodDef ttconv_methods[] =\n     {0, 0, 0, 0}  /* Sentinel */\n };\n \n-static const char* module_docstring =\n+static const char *module_docstring =\n     \"Module to handle converting and subsetting TrueType \"\n     \"fonts to Postscript Type 3, Postscript Type 42 and \"\n     \"Pdf Type 3 fonts.\";"}
{"patches_id": 2, "files_id": 45, "language": "h", "raw_url": "https://github.com/matplotlib/matplotlib/raw/dbeed94d578c458d31842cd13c04f665155986cb/src%2Fagg_py_path_iterator.h", "raw_code": "/* -*- mode: c++; c-basic-offset: 4 -*- */\n\n#ifndef __AGG_PY_PATH_ITERATOR_H__\n#define __AGG_PY_PATH_ITERATOR_H__\n\n#include \"CXX/Objects.hxx\"\n#include \"numpy/arrayobject.h\"\n#include \"agg_path_storage.h\"\n\n/*\n This file contains a vertex source to adapt Python Numpy arrays to\n Agg paths.  It works as an iterator, and converts on-the-fly without\n the need for a full copy of the data.\n */\n\n/************************************************************\n PathIterator acts as a bridge between Numpy and Agg.  Given a pair of\n Numpy arrays, vertices and codes, it iterates over those vertices and\n codes, using the standard Agg vertex source interface:\n\n    unsigned vertex(double* x, double* y)\n */\nclass PathIterator\n{\n    /* We hold references to the Python objects, not just the\n       underlying data arrays, so that Python reference counting can\n       work.\n    */\n    Py::Object m_vertices;\n    Py::Object m_codes;\n\n    size_t m_iterator;\n    size_t m_total_vertices;\n\n    /* This class doesn't actually do any simplification, but we\n       store the value here, since it is obtained from the Python object.\n    */\n    bool m_should_simplify;\n    double m_simplify_threshold;\n\npublic:\n    /* path_obj is an instance of the class Path as defined in path.py */\n    inline PathIterator(const Py::Object& path_obj) :\n            m_vertices(), m_codes(), m_iterator(0), m_should_simplify(false),\n            m_simplify_threshold(1.0 / 9.0)\n    {\n        Py::Object vertices_obj           = path_obj.getAttr(\"vertices\");\n        Py::Object codes_obj              = path_obj.getAttr(\"codes\");\n        Py::Object should_simplify_obj    = path_obj.getAttr(\"should_simplify\");\n        Py::Object simplify_threshold_obj = path_obj.getAttr(\"simplify_threshold\");\n\n        PyObject* vertices_arr = PyArray_FromObject(vertices_obj.ptr(), NPY_DOUBLE, 2, 2);\n        if (!vertices_arr)\n        {\n            throw Py::ValueError(\"Invalid vertices array.\");\n        }\n\n        m_vertices = Py::Object(vertices_arr, true);\n        if (PyArray_DIM((PyArrayObject*)m_vertices.ptr(), 1) != 2)\n        {\n            throw Py::ValueError(\"Invalid vertices array.\");\n        }\n\n        if (codes_obj.ptr() != Py_None)\n        {\n            PyObject* codes_arr = PyArray_FromObject(codes_obj.ptr(), NPY_UINT8, 1, 1);\n\n            if (!codes_arr)\n            {\n                throw Py::ValueError(\"Invalid codes array.\");\n            }\n\n            m_codes = Py::Object(codes_arr, true);\n            if (PyArray_DIM((PyArrayObject*)m_codes.ptr(), 0) !=\n                PyArray_DIM((PyArrayObject*)m_vertices.ptr(), 0))\n            {\n                throw Py::ValueError(\"Codes array is wrong length\");\n            }\n        }\n\n        m_should_simplify    = should_simplify_obj.isTrue();\n        m_total_vertices     = PyArray_DIM((PyArrayObject*)m_vertices.ptr(), 0);\n        m_simplify_threshold = Py::Float(simplify_threshold_obj);\n    }\n\n    ~PathIterator()\n    {\n\n    }\n\n    inline unsigned vertex(double* x, double* y)\n    {\n        if (m_iterator >= m_total_vertices) return agg::path_cmd_stop;\n\n        const size_t idx = m_iterator++;\n\n        char* pair = (char*)PyArray_GETPTR2((PyArrayObject*)m_vertices.ptr(), idx, 0);\n        *x = *(double*)pair;\n        *y = *(double*)(pair + PyArray_STRIDE((PyArrayObject*)m_vertices.ptr(), 1));\n\n        if (!m_codes.isNone())\n        {\n            return (unsigned)(*(char *)PyArray_GETPTR1((PyArrayObject*)m_codes.ptr(), idx));\n        }\n        else\n        {\n            return idx == 0 ? agg::path_cmd_move_to : agg::path_cmd_line_to;\n        }\n    }\n\n    inline void rewind(unsigned path_id)\n    {\n        m_iterator = path_id;\n    }\n\n    inline unsigned total_vertices()\n    {\n        return m_total_vertices;\n    }\n\n    inline bool should_simplify()\n    {\n        return m_should_simplify;\n    }\n\n    inline double simplify_threshold()\n    {\n        return m_simplify_threshold;\n    }\n\n    inline bool has_curves()\n    {\n        return !m_codes.isNone();\n    }\n};\n\n#endif // __AGG_PY_PATH_ITERATOR_H__\n", "patch": "@@ -1,137 +0,0 @@\n-/* -*- mode: c++; c-basic-offset: 4 -*- */\n-\n-#ifndef __AGG_PY_PATH_ITERATOR_H__\n-#define __AGG_PY_PATH_ITERATOR_H__\n-\n-#include \"CXX/Objects.hxx\"\n-#include \"numpy/arrayobject.h\"\n-#include \"agg_path_storage.h\"\n-\n-/*\n- This file contains a vertex source to adapt Python Numpy arrays to\n- Agg paths.  It works as an iterator, and converts on-the-fly without\n- the need for a full copy of the data.\n- */\n-\n-/************************************************************\n- PathIterator acts as a bridge between Numpy and Agg.  Given a pair of\n- Numpy arrays, vertices and codes, it iterates over those vertices and\n- codes, using the standard Agg vertex source interface:\n-\n-    unsigned vertex(double* x, double* y)\n- */\n-class PathIterator\n-{\n-    /* We hold references to the Python objects, not just the\n-       underlying data arrays, so that Python reference counting can\n-       work.\n-    */\n-    Py::Object m_vertices;\n-    Py::Object m_codes;\n-\n-    size_t m_iterator;\n-    size_t m_total_vertices;\n-\n-    /* This class doesn't actually do any simplification, but we\n-       store the value here, since it is obtained from the Python object.\n-    */\n-    bool m_should_simplify;\n-    double m_simplify_threshold;\n-\n-public:\n-    /* path_obj is an instance of the class Path as defined in path.py */\n-    inline PathIterator(const Py::Object& path_obj) :\n-            m_vertices(), m_codes(), m_iterator(0), m_should_simplify(false),\n-            m_simplify_threshold(1.0 / 9.0)\n-    {\n-        Py::Object vertices_obj           = path_obj.getAttr(\"vertices\");\n-        Py::Object codes_obj              = path_obj.getAttr(\"codes\");\n-        Py::Object should_simplify_obj    = path_obj.getAttr(\"should_simplify\");\n-        Py::Object simplify_threshold_obj = path_obj.getAttr(\"simplify_threshold\");\n-\n-        PyObject* vertices_arr = PyArray_FromObject(vertices_obj.ptr(), NPY_DOUBLE, 2, 2);\n-        if (!vertices_arr)\n-        {\n-            throw Py::ValueError(\"Invalid vertices array.\");\n-        }\n-\n-        m_vertices = Py::Object(vertices_arr, true);\n-        if (PyArray_DIM((PyArrayObject*)m_vertices.ptr(), 1) != 2)\n-        {\n-            throw Py::ValueError(\"Invalid vertices array.\");\n-        }\n-\n-        if (codes_obj.ptr() != Py_None)\n-        {\n-            PyObject* codes_arr = PyArray_FromObject(codes_obj.ptr(), NPY_UINT8, 1, 1);\n-\n-            if (!codes_arr)\n-            {\n-                throw Py::ValueError(\"Invalid codes array.\");\n-            }\n-\n-            m_codes = Py::Object(codes_arr, true);\n-            if (PyArray_DIM((PyArrayObject*)m_codes.ptr(), 0) !=\n-                PyArray_DIM((PyArrayObject*)m_vertices.ptr(), 0))\n-            {\n-                throw Py::ValueError(\"Codes array is wrong length\");\n-            }\n-        }\n-\n-        m_should_simplify    = should_simplify_obj.isTrue();\n-        m_total_vertices     = PyArray_DIM((PyArrayObject*)m_vertices.ptr(), 0);\n-        m_simplify_threshold = Py::Float(simplify_threshold_obj);\n-    }\n-\n-    ~PathIterator()\n-    {\n-\n-    }\n-\n-    inline unsigned vertex(double* x, double* y)\n-    {\n-        if (m_iterator >= m_total_vertices) return agg::path_cmd_stop;\n-\n-        const size_t idx = m_iterator++;\n-\n-        char* pair = (char*)PyArray_GETPTR2((PyArrayObject*)m_vertices.ptr(), idx, 0);\n-        *x = *(double*)pair;\n-        *y = *(double*)(pair + PyArray_STRIDE((PyArrayObject*)m_vertices.ptr(), 1));\n-\n-        if (!m_codes.isNone())\n-        {\n-            return (unsigned)(*(char *)PyArray_GETPTR1((PyArrayObject*)m_codes.ptr(), idx));\n-        }\n-        else\n-        {\n-            return idx == 0 ? agg::path_cmd_move_to : agg::path_cmd_line_to;\n-        }\n-    }\n-\n-    inline void rewind(unsigned path_id)\n-    {\n-        m_iterator = path_id;\n-    }\n-\n-    inline unsigned total_vertices()\n-    {\n-        return m_total_vertices;\n-    }\n-\n-    inline bool should_simplify()\n-    {\n-        return m_should_simplify;\n-    }\n-\n-    inline double simplify_threshold()\n-    {\n-        return m_simplify_threshold;\n-    }\n-\n-    inline bool has_curves()\n-    {\n-        return !m_codes.isNone();\n-    }\n-};\n-\n-#endif // __AGG_PY_PATH_ITERATOR_H__"}
{"patches_id": 2, "files_id": 46, "language": "cpp", "raw_url": "https://github.com/matplotlib/matplotlib/raw/dbeed94d578c458d31842cd13c04f665155986cb/src%2Fagg_py_transforms.cpp", "raw_code": "/* -*- mode: c++; c-basic-offset: 4 -*- */\n\n#include <Python.h>\n\n#define NO_IMPORT_ARRAY\n#include \"numpy/arrayobject.h\"\n\n#include \"CXX/Objects.hxx\"\n#include \"agg_trans_affine.h\"\n\n/** A helper function to convert from a Numpy affine transformation matrix\n *  to an agg::trans_affine. If errors = false then an Identity transform is returned.\n */\nagg::trans_affine\npy_to_agg_transformation_matrix(PyObject* obj, bool errors = true)\n{\n    PyArrayObject* matrix = NULL;\n\n    /** If None either raise a TypeError or return an agg identity transform. */\n    if (obj == Py_None)\n    {\n        if (errors)\n        {\n            throw Py::TypeError(\"Cannot convert None to an affine transform.\");\n        }\n\n        return agg::trans_affine();\n    }\n\n    /** Try turning the object into an affine transform matrix. */\n    try\n    {\n        matrix = (PyArrayObject*) PyArray_FromObject(obj, NPY_DOUBLE, 2, 2);\n        if (!matrix) {\n            PyErr_Clear();\n            throw std::exception();\n        }\n    }\n    catch (...)\n    {\n        Py_XDECREF(matrix);\n        if (errors)\n        {\n            throw Py::TypeError(\"Unable to get an affine transform matrix from the given object.\");\n        }\n\n        return agg::trans_affine();\n    }\n\n    /** Try turning the matrix into an agg transform. */\n    try\n    {\n        if (PyArray_NDIM(matrix) == 2 || PyArray_DIM(matrix, 0) == 3 || PyArray_DIM(matrix, 1) == 3)\n        {\n            size_t stride0 = PyArray_STRIDE(matrix, 0);\n            size_t stride1 = PyArray_STRIDE(matrix, 1);\n            char* row0 = PyArray_BYTES(matrix);\n            char* row1 = row0 + stride0;\n\n            double a = *(double*)(row0);\n            row0 += stride1;\n            double c = *(double*)(row0);\n            row0 += stride1;\n            double e = *(double*)(row0);\n\n            double b = *(double*)(row1);\n            row1 += stride1;\n            double d = *(double*)(row1);\n            row1 += stride1;\n            double f = *(double*)(row1);\n\n            Py_XDECREF(matrix);\n\n            return agg::trans_affine(a, b, c, d, e, f);\n        }\n\n        throw std::exception();\n    }\n    catch (...)\n    {\n        if (errors)\n        {\n            Py_XDECREF(matrix);\n            throw Py::TypeError(\"Invalid affine transformation matrix.\");\n        }\n    }\n\n    Py_XDECREF(matrix);\n    return agg::trans_affine();\n}\n\nbool\npy_convert_bbox(PyObject* bbox_obj, double& l, double& b, double& r, double& t)\n{\n    PyArrayObject* bbox = NULL;\n\n    if (bbox_obj == Py_None)\n        return false;\n\n    try\n    {\n        bbox = (PyArrayObject*) PyArray_FromObject(bbox_obj, NPY_DOUBLE, 2, 2);\n\n        if (!bbox || PyArray_NDIM(bbox) != 2 || PyArray_DIM(bbox, 0) != 2 || PyArray_DIM(bbox, 1) != 2)\n        {\n            throw Py::TypeError\n            (\"Expected a bbox array\");\n        }\n\n        l = *(double*)PyArray_GETPTR2(bbox, 0, 0);\n        b = *(double*)PyArray_GETPTR2(bbox, 0, 1);\n        r = *(double*)PyArray_GETPTR2(bbox, 1, 0);\n        t = *(double*)PyArray_GETPTR2(bbox, 1, 1);\n\n        Py_XDECREF(bbox);\n        bbox = NULL;\n        return true;\n    }\n    catch (...)\n    {\n        Py_XDECREF(bbox);\n        bbox = NULL;\n        throw;\n    }\n\n    return false;\n}\n", "patch": "@@ -1,127 +0,0 @@\n-/* -*- mode: c++; c-basic-offset: 4 -*- */\n-\n-#include <Python.h>\n-\n-#define NO_IMPORT_ARRAY\n-#include \"numpy/arrayobject.h\"\n-\n-#include \"CXX/Objects.hxx\"\n-#include \"agg_trans_affine.h\"\n-\n-/** A helper function to convert from a Numpy affine transformation matrix\n- *  to an agg::trans_affine. If errors = false then an Identity transform is returned.\n- */\n-agg::trans_affine\n-py_to_agg_transformation_matrix(PyObject* obj, bool errors = true)\n-{\n-    PyArrayObject* matrix = NULL;\n-\n-    /** If None either raise a TypeError or return an agg identity transform. */\n-    if (obj == Py_None)\n-    {\n-        if (errors)\n-        {\n-            throw Py::TypeError(\"Cannot convert None to an affine transform.\");\n-        }\n-\n-        return agg::trans_affine();\n-    }\n-\n-    /** Try turning the object into an affine transform matrix. */\n-    try\n-    {\n-        matrix = (PyArrayObject*) PyArray_FromObject(obj, NPY_DOUBLE, 2, 2);\n-        if (!matrix) {\n-            PyErr_Clear();\n-            throw std::exception();\n-        }\n-    }\n-    catch (...)\n-    {\n-        Py_XDECREF(matrix);\n-        if (errors)\n-        {\n-            throw Py::TypeError(\"Unable to get an affine transform matrix from the given object.\");\n-        }\n-\n-        return agg::trans_affine();\n-    }\n-\n-    /** Try turning the matrix into an agg transform. */\n-    try\n-    {\n-        if (PyArray_NDIM(matrix) == 2 || PyArray_DIM(matrix, 0) == 3 || PyArray_DIM(matrix, 1) == 3)\n-        {\n-            size_t stride0 = PyArray_STRIDE(matrix, 0);\n-            size_t stride1 = PyArray_STRIDE(matrix, 1);\n-            char* row0 = PyArray_BYTES(matrix);\n-            char* row1 = row0 + stride0;\n-\n-            double a = *(double*)(row0);\n-            row0 += stride1;\n-            double c = *(double*)(row0);\n-            row0 += stride1;\n-            double e = *(double*)(row0);\n-\n-            double b = *(double*)(row1);\n-            row1 += stride1;\n-            double d = *(double*)(row1);\n-            row1 += stride1;\n-            double f = *(double*)(row1);\n-\n-            Py_XDECREF(matrix);\n-\n-            return agg::trans_affine(a, b, c, d, e, f);\n-        }\n-\n-        throw std::exception();\n-    }\n-    catch (...)\n-    {\n-        if (errors)\n-        {\n-            Py_XDECREF(matrix);\n-            throw Py::TypeError(\"Invalid affine transformation matrix.\");\n-        }\n-    }\n-\n-    Py_XDECREF(matrix);\n-    return agg::trans_affine();\n-}\n-\n-bool\n-py_convert_bbox(PyObject* bbox_obj, double& l, double& b, double& r, double& t)\n-{\n-    PyArrayObject* bbox = NULL;\n-\n-    if (bbox_obj == Py_None)\n-        return false;\n-\n-    try\n-    {\n-        bbox = (PyArrayObject*) PyArray_FromObject(bbox_obj, NPY_DOUBLE, 2, 2);\n-\n-        if (!bbox || PyArray_NDIM(bbox) != 2 || PyArray_DIM(bbox, 0) != 2 || PyArray_DIM(bbox, 1) != 2)\n-        {\n-            throw Py::TypeError\n-            (\"Expected a bbox array\");\n-        }\n-\n-        l = *(double*)PyArray_GETPTR2(bbox, 0, 0);\n-        b = *(double*)PyArray_GETPTR2(bbox, 0, 1);\n-        r = *(double*)PyArray_GETPTR2(bbox, 1, 0);\n-        t = *(double*)PyArray_GETPTR2(bbox, 1, 1);\n-\n-        Py_XDECREF(bbox);\n-        bbox = NULL;\n-        return true;\n-    }\n-    catch (...)\n-    {\n-        Py_XDECREF(bbox);\n-        bbox = NULL;\n-        throw;\n-    }\n-\n-    return false;\n-}"}
{"patches_id": 2, "files_id": 47, "language": "h", "raw_url": "https://github.com/matplotlib/matplotlib/raw/dbeed94d578c458d31842cd13c04f665155986cb/src%2Fagg_py_transforms.h", "raw_code": "/* -*- mode: c++; c-basic-offset: 4 -*- */\n\n#ifndef __AGG_PY_TRANSFORMS_H__\n#define __AGG_PY_TRANSFORMS_H__\n\n#include \"agg_trans_affine.h\"\n\n/** A helper function to convert from a Numpy affine transformation matrix\n *  to an agg::trans_affine.\n */\nagg::trans_affine\npy_to_agg_transformation_matrix(PyObject* obj, bool errors = true);\n\nbool\npy_convert_bbox(PyObject* bbox_obj, double& l, double& b, double& r, double& t);\n\n#endif // __AGG_PY_TRANSFORMS_H__\n", "patch": "@@ -1,17 +0,0 @@\n-/* -*- mode: c++; c-basic-offset: 4 -*- */\n-\n-#ifndef __AGG_PY_TRANSFORMS_H__\n-#define __AGG_PY_TRANSFORMS_H__\n-\n-#include \"agg_trans_affine.h\"\n-\n-/** A helper function to convert from a Numpy affine transformation matrix\n- *  to an agg::trans_affine.\n- */\n-agg::trans_affine\n-py_to_agg_transformation_matrix(PyObject* obj, bool errors = true);\n-\n-bool\n-py_convert_bbox(PyObject* bbox_obj, double& l, double& b, double& r, double& t);\n-\n-#endif // __AGG_PY_TRANSFORMS_H__"}
{"patches_id": 2, "files_id": 48, "language": "h", "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2Farray.h", "raw_code": "/* -*- mode: c++; c-basic-offset: 4 -*- */\n\n/* Utilities to create scalars and empty arrays that behave like the\n   Numpy array wrappers in numpy_cpp.h */\n\n#ifndef _SCALAR_H_\n#define _SCALAR_H_\n\nnamespace array\n{\n\ntemplate <typename T, int ND>\nclass scalar\n{\n  public:\n    T m_value;\n\n    scalar(const T value) : m_value(value)\n    {\n    }\n\n    T &operator()(int i, int j = 0, int k = 0)\n    {\n        return m_value;\n    }\n\n    const T &operator()(int i, int j = 0, int k = 0) const\n    {\n        return m_value;\n    }\n\n    int dim(size_t i)\n    {\n        return 1;\n    }\n\n    size_t size()\n    {\n        return 1;\n    }\n};\n\ntemplate <typename T>\nclass empty\n{\n  public:\n    typedef empty<T> sub_t;\n\n    empty()\n    {\n    }\n\n    T &operator()(int i, int j = 0, int k = 0)\n    {\n        throw \"Accessed empty array\";\n    }\n\n    const T &operator()(int i, int j = 0, int k = 0) const\n    {\n        throw \"Accessed empty array\";\n    }\n\n    sub_t operator[](int i) const\n    {\n        return empty<T>();\n    }\n\n    int dim(size_t i) const\n    {\n        return 0;\n    }\n\n    size_t size() const\n    {\n        return 0;\n    }\n};\n}\n\n#endif\n", "patch": "@@ -0,0 +1,80 @@\n+/* -*- mode: c++; c-basic-offset: 4 -*- */\n+\n+/* Utilities to create scalars and empty arrays that behave like the\n+   Numpy array wrappers in numpy_cpp.h */\n+\n+#ifndef _SCALAR_H_\n+#define _SCALAR_H_\n+\n+namespace array\n+{\n+\n+template <typename T, int ND>\n+class scalar\n+{\n+  public:\n+    T m_value;\n+\n+    scalar(const T value) : m_value(value)\n+    {\n+    }\n+\n+    T &operator()(int i, int j = 0, int k = 0)\n+    {\n+        return m_value;\n+    }\n+\n+    const T &operator()(int i, int j = 0, int k = 0) const\n+    {\n+        return m_value;\n+    }\n+\n+    int dim(size_t i)\n+    {\n+        return 1;\n+    }\n+\n+    size_t size()\n+    {\n+        return 1;\n+    }\n+};\n+\n+template <typename T>\n+class empty\n+{\n+  public:\n+    typedef empty<T> sub_t;\n+\n+    empty()\n+    {\n+    }\n+\n+    T &operator()(int i, int j = 0, int k = 0)\n+    {\n+        throw \"Accessed empty array\";\n+    }\n+\n+    const T &operator()(int i, int j = 0, int k = 0) const\n+    {\n+        throw \"Accessed empty array\";\n+    }\n+\n+    sub_t operator[](int i) const\n+    {\n+        return empty<T>();\n+    }\n+\n+    int dim(size_t i) const\n+    {\n+        return 0;\n+    }\n+\n+    size_t size() const\n+    {\n+        return 0;\n+    }\n+};\n+}\n+\n+#endif"}
{"patches_id": 2, "files_id": 49, "language": "h", "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2Ffile_compat.h", "raw_code": "#ifndef __FILE_COMPAT_H__\n#define __FILE_COMPAT_H__\n\n#include <Python.h>\n#include <stdio.h>\n#include \"numpy/npy_common.h\"\n#include \"numpy/ndarrayobject.h\"\n#include \"mplutils.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n#if defined(_MSC_VER) && defined(_WIN64) && (_MSC_VER > 1400)\n    #include <io.h>\n    #define mpl_fseek _fseeki64\n    #define mpl_ftell _ftelli64\n    #define mpl_lseek _lseeki64\n    #define mpl_off_t npy_int64\n\n    #if NPY_SIZEOF_INT == 8\n        #define MPL_OFF_T_PYFMT \"i\"\n    #elif NPY_SIZEOF_LONG == 8\n        #define MPL_OFF_T_PYFMT \"l\"\n    #elif NPY_SIZEOF_LONGLONG == 8\n        #define MPL_OFF_T_PYFMT \"L\"\n    #else\n        #error Unsupported size for type off_t\n    #endif\n#else\n    #define mpl_fseek fseek\n    #define mpl_ftell ftell\n    #define mpl_lseek lseek\n    #define mpl_off_t off_t\n\n    #if NPY_SIZEOF_INT == NPY_SIZEOF_SHORT\n        #define MPL_OFF_T_PYFMT \"h\"\n    #elif NPY_SIZEOF_INT == NPY_SIZEOF_INT\n        #define MPL_OFF_T_PYFMT \"i\"\n    #elif NPY_SIZEOF_INT == NPY_SIZEOF_LONG\n        #define MPL_OFF_T_PYFMT \"l\"\n    #elif NPY_SIZEOF_INT == NPY_SIZEOF_LONGLONG\n        #define MPL_OFF_T_PYFMT \"L\"\n    #else\n        #error Unsupported size for type off_t\n    #endif\n#endif\n\n/*\n * PyFile_* compatibility\n */\n#if PY3K\n\n/*\n * Get a FILE* handle to the file represented by the Python object\n */\nstatic NPY_INLINE FILE *mpl_PyFile_Dup(PyObject *file, char *mode, mpl_off_t *orig_pos)\n{\n    int fd, fd2;\n    PyObject *ret, *os;\n    mpl_off_t pos;\n    FILE *handle;\n\n    /* Flush first to ensure things end up in the file in the correct order */\n    ret = PyObject_CallMethod(file, (char *)\"flush\", (char *)\"\");\n    if (ret == NULL) {\n        return NULL;\n    }\n    Py_DECREF(ret);\n    fd = PyObject_AsFileDescriptor(file);\n    if (fd == -1) {\n        return NULL;\n    }\n\n    /* The handle needs to be dup'd because we have to call fclose\n       at the end */\n    os = PyImport_ImportModule(\"os\");\n    if (os == NULL) {\n        return NULL;\n    }\n    ret = PyObject_CallMethod(os, (char *)\"dup\", (char *)\"i\", fd);\n    Py_DECREF(os);\n    if (ret == NULL) {\n        return NULL;\n    }\n    fd2 = PyNumber_AsSsize_t(ret, NULL);\n    Py_DECREF(ret);\n\n/* Convert to FILE* handle */\n#ifdef _WIN32\n    handle = _fdopen(fd2, mode);\n#else\n    handle = fdopen(fd2, mode);\n#endif\n    if (handle == NULL) {\n        PyErr_SetString(PyExc_IOError, \"Getting a FILE* from a Python file object failed\");\n    }\n\n    /* Record the original raw file handle position */\n    *orig_pos = mpl_ftell(handle);\n    if (*orig_pos == -1) {\n        // handle is a stream, so we don't have to worry about this\n        return handle;\n    }\n\n    /* Seek raw handle to the Python-side position */\n    ret = PyObject_CallMethod(file, (char *)\"tell\", (char *)\"\");\n    if (ret == NULL) {\n        fclose(handle);\n        return NULL;\n    }\n    pos = PyNumber_AsSsize_t(ret, PyExc_OverflowError);\n    Py_DECREF(ret);\n    if (PyErr_Occurred()) {\n        fclose(handle);\n        return NULL;\n    }\n    if (mpl_fseek(handle, pos, SEEK_SET) == -1) {\n        PyErr_SetString(PyExc_IOError, \"seeking file failed\");\n        return NULL;\n    }\n    return handle;\n}\n\n/*\n * Close the dup-ed file handle, and seek the Python one to the current position\n */\nstatic NPY_INLINE int mpl_PyFile_DupClose(PyObject *file, FILE *handle, mpl_off_t orig_pos)\n{\n    int fd;\n    PyObject *ret;\n    mpl_off_t position;\n\n    position = mpl_ftell(handle);\n\n    /* Close the FILE* handle */\n    fclose(handle);\n\n    /* Restore original file handle position, in order to not confuse\n       Python-side data structures */\n    fd = PyObject_AsFileDescriptor(file);\n    if (fd == -1) {\n        return -1;\n    }\n    if (mpl_lseek(fd, orig_pos, SEEK_SET) != -1) {\n        if (position == -1) {\n            PyErr_SetString(PyExc_IOError, \"obtaining file position failed\");\n            return -1;\n        }\n\n        /* Seek Python-side handle to the FILE* handle position */\n        ret = PyObject_CallMethod(file, (char *)\"seek\", (char *)(MPL_OFF_T_PYFMT \"i\"), position, 0);\n        if (ret == NULL) {\n            return -1;\n        }\n        Py_DECREF(ret);\n    }\n    return 0;\n}\n\nstatic NPY_INLINE int mpl_PyFile_Check(PyObject *file)\n{\n    int fd;\n    fd = PyObject_AsFileDescriptor(file);\n    if (fd == -1) {\n        PyErr_Clear();\n        return 0;\n    }\n    return 1;\n}\n\n#else\n\nstatic NPY_INLINE FILE *mpl_PyFile_Dup(PyObject *file, const char *mode, mpl_off_t *orig_pos)\n{\n    return PyFile_AsFile(file);\n}\n\nstatic NPY_INLINE int mpl_PyFile_DupClose(PyObject *file, FILE *handle, mpl_off_t orig_pos)\n{\n    // deliberately nothing\n    return 0;\n}\n\nstatic NPY_INLINE int mpl_PyFile_Check(PyObject *file)\n{\n    return PyFile_Check(file);\n}\n\n#endif\n\nstatic NPY_INLINE PyObject *mpl_PyFile_OpenFile(PyObject *filename, const char *mode)\n{\n    PyObject *open;\n    open = PyDict_GetItemString(PyEval_GetBuiltins(), \"open\");\n    if (open == NULL) {\n        return NULL;\n    }\n    return PyObject_CallFunction(open, (char *)\"Os\", filename, mode);\n}\n\nstatic NPY_INLINE int mpl_PyFile_CloseFile(PyObject *file)\n{\n    PyObject *ret;\n\n    ret = PyObject_CallMethod(file, (char *)\"close\", NULL);\n    if (ret == NULL) {\n        return -1;\n    }\n    Py_DECREF(ret);\n    return 0;\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* ifndef __FILE_COMPAT_H__ */\n", "patch": "@@ -10,12 +10,11 @@\n #ifdef __cplusplus\n extern \"C\" {\n #endif\n-\n #if defined(_MSC_VER) && defined(_WIN64) && (_MSC_VER > 1400)\n     #include <io.h>\n-    #define npy_fseek _fseeki64\n-    #define npy_ftell _ftelli64\n-    #define npy_lseek _lseeki64\n+    #define mpl_fseek _fseeki64\n+    #define mpl_ftell _ftelli64\n+    #define mpl_lseek _lseeki64\n     #define mpl_off_t npy_int64\n \n     #if NPY_SIZEOF_INT == 8\n@@ -28,9 +27,9 @@ extern \"C\" {\n         #error Unsupported size for type off_t\n     #endif\n #else\n-    #define npy_fseek fseek\n-    #define npy_ftell ftell\n-    #define npy_lseek lseek\n+    #define mpl_fseek fseek\n+    #define mpl_ftell ftell\n+    #define mpl_lseek lseek\n     #define mpl_off_t off_t\n \n     #if NPY_SIZEOF_INT == NPY_SIZEOF_SHORT\n@@ -54,16 +53,15 @@ extern \"C\" {\n /*\n  * Get a FILE* handle to the file represented by the Python object\n  */\n-static NPY_INLINE FILE*\n-mpl_PyFile_Dup(PyObject *file, char *mode, mpl_off_t *orig_pos)\n+static NPY_INLINE FILE *mpl_PyFile_Dup(PyObject *file, char *mode, mpl_off_t *orig_pos)\n {\n     int fd, fd2;\n     PyObject *ret, *os;\n     mpl_off_t pos;\n     FILE *handle;\n \n     /* Flush first to ensure things end up in the file in the correct order */\n-    ret = PyObject_CallMethod(file, \"flush\", \"\");\n+    ret = PyObject_CallMethod(file, (char *)\"flush\", (char *)\"\");\n     if (ret == NULL) {\n         return NULL;\n     }\n@@ -79,34 +77,33 @@ mpl_PyFile_Dup(PyObject *file, char *mode, mpl_off_t *orig_pos)\n     if (os == NULL) {\n         return NULL;\n     }\n-    ret = PyObject_CallMethod(os, \"dup\", \"i\", fd);\n+    ret = PyObject_CallMethod(os, (char *)\"dup\", (char *)\"i\", fd);\n     Py_DECREF(os);\n     if (ret == NULL) {\n         return NULL;\n     }\n     fd2 = PyNumber_AsSsize_t(ret, NULL);\n     Py_DECREF(ret);\n \n-    /* Convert to FILE* handle */\n+/* Convert to FILE* handle */\n #ifdef _WIN32\n     handle = _fdopen(fd2, mode);\n #else\n     handle = fdopen(fd2, mode);\n #endif\n     if (handle == NULL) {\n-        PyErr_SetString(PyExc_IOError,\n-                        \"Getting a FILE* from a Python file object failed\");\n+        PyErr_SetString(PyExc_IOError, \"Getting a FILE* from a Python file object failed\");\n     }\n \n     /* Record the original raw file handle position */\n-    *orig_pos = npy_ftell(handle);\n+    *orig_pos = mpl_ftell(handle);\n     if (*orig_pos == -1) {\n         // handle is a stream, so we don't have to worry about this\n         return handle;\n     }\n \n     /* Seek raw handle to the Python-side position */\n-    ret = PyObject_CallMethod(file, \"tell\", \"\");\n+    ret = PyObject_CallMethod(file, (char *)\"tell\", (char *)\"\");\n     if (ret == NULL) {\n         fclose(handle);\n         return NULL;\n@@ -117,7 +114,7 @@ mpl_PyFile_Dup(PyObject *file, char *mode, mpl_off_t *orig_pos)\n         fclose(handle);\n         return NULL;\n     }\n-    if (npy_fseek(handle, pos, SEEK_SET) == -1) {\n+    if (mpl_fseek(handle, pos, SEEK_SET) == -1) {\n         PyErr_SetString(PyExc_IOError, \"seeking file failed\");\n         return NULL;\n     }\n@@ -127,14 +124,13 @@ mpl_PyFile_Dup(PyObject *file, char *mode, mpl_off_t *orig_pos)\n /*\n  * Close the dup-ed file handle, and seek the Python one to the current position\n  */\n-static NPY_INLINE int\n-mpl_PyFile_DupClose(PyObject *file, FILE* handle, mpl_off_t orig_pos)\n+static NPY_INLINE int mpl_PyFile_DupClose(PyObject *file, FILE *handle, mpl_off_t orig_pos)\n {\n     int fd;\n     PyObject *ret;\n     mpl_off_t position;\n \n-    position = npy_ftell(handle);\n+    position = mpl_ftell(handle);\n \n     /* Close the FILE* handle */\n     fclose(handle);\n@@ -145,14 +141,14 @@ mpl_PyFile_DupClose(PyObject *file, FILE* handle, mpl_off_t orig_pos)\n     if (fd == -1) {\n         return -1;\n     }\n-    if (npy_lseek(fd, orig_pos, SEEK_SET) != -1) {\n+    if (mpl_lseek(fd, orig_pos, SEEK_SET) != -1) {\n         if (position == -1) {\n             PyErr_SetString(PyExc_IOError, \"obtaining file position failed\");\n             return -1;\n         }\n \n         /* Seek Python-side handle to the FILE* handle position */\n-        ret = PyObject_CallMethod(file, \"seek\", MPL_OFF_T_PYFMT \"i\", position, 0);\n+        ret = PyObject_CallMethod(file, (char *)\"seek\", (char *)(MPL_OFF_T_PYFMT \"i\"), position, 0);\n         if (ret == NULL) {\n             return -1;\n         }\n@@ -161,8 +157,7 @@ mpl_PyFile_DupClose(PyObject *file, FILE* handle, mpl_off_t orig_pos)\n     return 0;\n }\n \n-static NPY_INLINE int\n-mpl_PyFile_Check(PyObject *file)\n+static NPY_INLINE int mpl_PyFile_Check(PyObject *file)\n {\n     int fd;\n     fd = PyObject_AsFileDescriptor(file);\n@@ -175,29 +170,39 @@ mpl_PyFile_Check(PyObject *file)\n \n #else\n \n-#define mpl_PyFile_Dup(file, mode, orig_pos_p) PyFile_AsFile(file)\n-#define mpl_PyFile_DupClose(file, handle, orig_pos) (0)\n-#define mpl_PyFile_Check PyFile_Check\n+static NPY_INLINE FILE *mpl_PyFile_Dup(PyObject *file, const char *mode, mpl_off_t *orig_pos)\n+{\n+    return PyFile_AsFile(file);\n+}\n+\n+static NPY_INLINE int mpl_PyFile_DupClose(PyObject *file, FILE *handle, mpl_off_t orig_pos)\n+{\n+    // deliberately nothing\n+    return 0;\n+}\n+\n+static NPY_INLINE int mpl_PyFile_Check(PyObject *file)\n+{\n+    return PyFile_Check(file);\n+}\n \n #endif\n \n-static NPY_INLINE PyObject*\n-mpl_PyFile_OpenFile(PyObject *filename, const char *mode)\n+static NPY_INLINE PyObject *mpl_PyFile_OpenFile(PyObject *filename, const char *mode)\n {\n     PyObject *open;\n     open = PyDict_GetItemString(PyEval_GetBuiltins(), \"open\");\n     if (open == NULL) {\n         return NULL;\n     }\n-    return PyObject_CallFunction(open, (char*)\"Os\", filename, mode);\n+    return PyObject_CallFunction(open, (char *)\"Os\", filename, mode);\n }\n \n-static NPY_INLINE int\n-mpl_PyFile_CloseFile(PyObject *file)\n+static NPY_INLINE int mpl_PyFile_CloseFile(PyObject *file)\n {\n     PyObject *ret;\n \n-    ret = PyObject_CallMethod(file, (char*)\"close\", NULL);\n+    ret = PyObject_CallMethod(file, (char *)\"close\", NULL);\n     if (ret == NULL) {\n         return -1;\n     }"}
{"patches_id": 2, "files_id": 50, "language": "cpp", "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2Fft2font.cpp", "raw_code": "/* -*- mode: c++; c-basic-offset: 4 -*- */\n\n#define NO_IMPORT_ARRAY\n\n#include \"ft2font.h\"\n#include \"mplutils.h\"\n\n/**\n To improve the hinting of the fonts, this code uses a hack\n presented here:\n\n http://antigrain.com/research/font_rasterization/index.html\n\n The idea is to limit the effect of hinting in the x-direction, while\n preserving hinting in the y-direction.  Since freetype does not\n support this directly, the dpi in the x-direction is set higher than\n in the y-direction, which affects the hinting grid.  Then, a global\n transform is placed on the font to shrink it back to the desired\n size.  While it is a bit surprising that the dpi setting affects\n hinting, whereas the global transform does not, this is documented\n behavior of freetype, and therefore hopefully unlikely to change.\n The freetype 2 tutorial says:\n\n      NOTE: The transformation is applied to every glyph that is\n      loaded through FT_Load_Glyph and is completely independent of\n      any hinting process. This means that you won't get the same\n      results if you load a glyph at the size of 24 pixels, or a glyph\n      at the size at 12 pixels scaled by 2 through a transform,\n      because the hints will have been computed differently (except\n      you have disabled hints).\n */\n\nFT_Library _ft2Library;\n\nFT2Image::FT2Image() : m_dirty(true), m_buffer(NULL), m_width(0), m_height(0)\n{\n}\n\nFT2Image::FT2Image(unsigned long width, unsigned long height)\n    : m_dirty(true), m_buffer(NULL), m_width(0), m_height(0)\n{\n    resize(width, height);\n}\n\nFT2Image::~FT2Image()\n{\n    delete[] m_buffer;\n}\n\nvoid FT2Image::resize(long width, long height)\n{\n    if (width < 0) {\n        width = 1;\n    }\n    if (height < 0) {\n        height = 1;\n    }\n    size_t numBytes = width * height;\n\n    if ((unsigned long)width != m_width || (unsigned long)height != m_height) {\n        if (numBytes > m_width * m_height) {\n            delete[] m_buffer;\n            m_buffer = NULL;\n            m_buffer = new unsigned char[numBytes];\n        }\n\n        m_width = (unsigned long)width;\n        m_height = (unsigned long)height;\n    }\n\n    if (numBytes) {\n        memset(m_buffer, 0, numBytes);\n    }\n\n    m_dirty = true;\n}\n\nvoid FT2Image::draw_bitmap(FT_Bitmap *bitmap, FT_Int x, FT_Int y)\n{\n    FT_Int image_width = (FT_Int)m_width;\n    FT_Int image_height = (FT_Int)m_height;\n    FT_Int char_width = bitmap->width;\n    FT_Int char_height = bitmap->rows;\n\n    FT_Int x1 = CLAMP(x, 0, image_width);\n    FT_Int y1 = CLAMP(y, 0, image_height);\n    FT_Int x2 = CLAMP(x + char_width, 0, image_width);\n    FT_Int y2 = CLAMP(y + char_height, 0, image_height);\n\n    FT_Int x_start = MAX(0, -x);\n    FT_Int y_offset = y1 - MAX(0, -y);\n\n    if (bitmap->pixel_mode == FT_PIXEL_MODE_GRAY) {\n        for (FT_Int i = y1; i < y2; ++i) {\n            unsigned char *dst = m_buffer + (i * image_width + x1);\n            unsigned char *src = bitmap->buffer + (((i - y_offset) * bitmap->pitch) + x_start);\n            for (FT_Int j = x1; j < x2; ++j, ++dst, ++src)\n                *dst |= *src;\n        }\n    } else if (bitmap->pixel_mode == FT_PIXEL_MODE_MONO) {\n        for (FT_Int i = y1; i < y2; ++i) {\n            unsigned char *dst = m_buffer + (i * image_width + x1);\n            unsigned char *src = bitmap->buffer + ((i - y_offset) * bitmap->pitch);\n            for (FT_Int j = x1; j < x2; ++j, ++dst) {\n                int x = (j - x1 + x_start);\n                int val = *(src + (x >> 3)) & (1 << (7 - (x & 0x7)));\n                *dst = val ? 255 : *dst;\n            }\n        }\n    } else {\n        throw \"Unknown pixel mode\";\n    }\n\n    m_dirty = true;\n}\n\nvoid FT2Image::draw_rect(unsigned long x0, unsigned long y0, unsigned long x1, unsigned long y1)\n{\n    if (x0 > m_width || x1 > m_width || y0 > m_height || y1 > m_height) {\n        throw \"Rect coords outside image bounds\";\n    }\n\n    size_t top = y0 * m_width;\n    size_t bottom = y1 * m_width;\n    for (size_t i = x0; i < x1 + 1; ++i) {\n        m_buffer[i + top] = 255;\n        m_buffer[i + bottom] = 255;\n    }\n\n    for (size_t j = y0 + 1; j < y1; ++j) {\n        m_buffer[x0 + j * m_width] = 255;\n        m_buffer[x1 + j * m_width] = 255;\n    }\n\n    m_dirty = true;\n}\n\nvoid\nFT2Image::draw_rect_filled(unsigned long x0, unsigned long y0, unsigned long x1, unsigned long y1)\n{\n    x0 = std::min(x0, m_width);\n    y0 = std::min(y0, m_height);\n    x1 = std::min(x1, m_width);\n    y1 = std::min(y1, m_height);\n\n    for (size_t j = y0; j < y1 + 1; j++) {\n        for (size_t i = x0; i < x1 + 1; i++) {\n            m_buffer[i + j * m_width] = 255;\n        }\n    }\n\n    m_dirty = true;\n}\n\ninline double conv(long v)\n{\n    return double(v) / 64.0;\n}\n\nint FT2Font::get_path_count()\n{\n    // get the glyph as a path, a list of (COMMAND, *args) as desribed in matplotlib.path\n    // this code is from agg's decompose_ft_outline with minor modifications\n\n    if (!face->glyph) {\n        throw \"No glyph loaded\";\n    }\n\n    FT_Outline &outline = face->glyph->outline;\n\n    FT_Vector v_last;\n    FT_Vector v_control;\n    FT_Vector v_start;\n\n    FT_Vector *point;\n    FT_Vector *limit;\n    char *tags;\n\n    int n;     // index of contour in outline\n    int first; // index of first point in contour\n    char tag;  // current point's state\n    int count;\n\n    count = 0;\n    first = 0;\n    for (n = 0; n < outline.n_contours; n++) {\n        int last; // index of last point in contour\n        bool starts_with_last;\n\n        last = outline.contours[n];\n        limit = outline.points + last;\n\n        v_start = outline.points[first];\n        v_last = outline.points[last];\n\n        v_control = v_start;\n\n        point = outline.points + first;\n        tags = outline.tags + first;\n        tag = FT_CURVE_TAG(tags[0]);\n\n        // A contour cannot start with a cubic control point!\n        if (tag == FT_CURVE_TAG_CUBIC) {\n            throw \"A contour cannot start with a cubic control point\";\n        } else if (tag == FT_CURVE_TAG_CONIC) {\n            starts_with_last = true;\n        } else {\n            starts_with_last = false;\n        }\n\n        count++;\n\n        while (point < limit) {\n            if (!starts_with_last) {\n                point++;\n                tags++;\n            }\n            starts_with_last = false;\n\n            tag = FT_CURVE_TAG(tags[0]);\n            switch (tag) {\n            case FT_CURVE_TAG_ON: // emit a single line_to\n            {\n                count++;\n                continue;\n            }\n\n            case FT_CURVE_TAG_CONIC: // consume conic arcs\n            {\n            Count_Do_Conic:\n                if (point < limit) {\n                    point++;\n                    tags++;\n                    tag = FT_CURVE_TAG(tags[0]);\n\n                    if (tag == FT_CURVE_TAG_ON) {\n                        count += 2;\n                        continue;\n                    }\n\n                    if (tag != FT_CURVE_TAG_CONIC) {\n                        throw \"Invalid font\";\n                    }\n\n                    count += 2;\n\n                    goto Count_Do_Conic;\n                }\n\n                count += 2;\n\n                goto Count_Close;\n            }\n\n            default: // FT_CURVE_TAG_CUBIC\n            {\n                if (point + 1 > limit || FT_CURVE_TAG(tags[1]) != FT_CURVE_TAG_CUBIC) {\n                    throw \"Invalid font\";\n                }\n\n                point += 2;\n                tags += 2;\n\n                if (point <= limit) {\n                    count += 3;\n                    continue;\n                }\n\n                count += 3;\n\n                goto Count_Close;\n            }\n            }\n        }\n\n        count++;\n\n    Count_Close:\n        first = last + 1;\n    }\n\n    return count;\n}\n\nvoid FT2Font::get_path(double *outpoints, unsigned char *outcodes)\n{\n    FT_Outline &outline = face->glyph->outline;\n    bool flip_y = false; // todo, pass me as kwarg\n\n    FT_Vector v_last;\n    FT_Vector v_control;\n    FT_Vector v_start;\n\n    FT_Vector *point;\n    FT_Vector *limit;\n    char *tags;\n\n    int n;     // index of contour in outline\n    int first; // index of first point in contour\n    char tag;  // current point's state\n\n    first = 0;\n    for (n = 0; n < outline.n_contours; n++) {\n        int last; // index of last point in contour\n        bool starts_with_last;\n\n        last = outline.contours[n];\n        limit = outline.points + last;\n\n        v_start = outline.points[first];\n        v_last = outline.points[last];\n\n        v_control = v_start;\n\n        point = outline.points + first;\n        tags = outline.tags + first;\n        tag = FT_CURVE_TAG(tags[0]);\n\n        double x, y;\n        if (tag != FT_CURVE_TAG_ON) {\n            x = conv(v_last.x);\n            y = flip_y ? -conv(v_last.y) : conv(v_last.y);\n            starts_with_last = true;\n        } else {\n            x = conv(v_start.x);\n            y = flip_y ? -conv(v_start.y) : conv(v_start.y);\n            starts_with_last = false;\n        }\n\n        *(outpoints++) = x;\n        *(outpoints++) = y;\n        *(outcodes++) = MOVETO;\n\n        while (point < limit) {\n            if (!starts_with_last) {\n                point++;\n                tags++;\n            }\n            starts_with_last = false;\n\n            tag = FT_CURVE_TAG(tags[0]);\n            switch (tag) {\n            case FT_CURVE_TAG_ON: // emit a single line_to\n            {\n                double x = conv(point->x);\n                double y = flip_y ? -conv(point->y) : conv(point->y);\n                *(outpoints++) = x;\n                *(outpoints++) = y;\n                *(outcodes++) = LINETO;\n                continue;\n            }\n\n            case FT_CURVE_TAG_CONIC: // consume conic arcs\n            {\n                v_control.x = point->x;\n                v_control.y = point->y;\n\n            Do_Conic:\n                if (point < limit) {\n                    FT_Vector vec;\n                    FT_Vector v_middle;\n\n                    point++;\n                    tags++;\n                    tag = FT_CURVE_TAG(tags[0]);\n\n                    vec.x = point->x;\n                    vec.y = point->y;\n\n                    if (tag == FT_CURVE_TAG_ON) {\n                        double xctl = conv(v_control.x);\n                        double yctl = flip_y ? -conv(v_control.y) : conv(v_control.y);\n                        double xto = conv(vec.x);\n                        double yto = flip_y ? -conv(vec.y) : conv(vec.y);\n                        *(outpoints++) = xctl;\n                        *(outpoints++) = yctl;\n                        *(outpoints++) = xto;\n                        *(outpoints++) = yto;\n                        *(outcodes++) = CURVE3;\n                        *(outcodes++) = CURVE3;\n                        continue;\n                    }\n\n                    v_middle.x = (v_control.x + vec.x) / 2;\n                    v_middle.y = (v_control.y + vec.y) / 2;\n\n                    double xctl = conv(v_control.x);\n                    double yctl = flip_y ? -conv(v_control.y) : conv(v_control.y);\n                    double xto = conv(v_middle.x);\n                    double yto = flip_y ? -conv(v_middle.y) : conv(v_middle.y);\n                    *(outpoints++) = xctl;\n                    *(outpoints++) = yctl;\n                    *(outpoints++) = xto;\n                    *(outpoints++) = yto;\n                    *(outcodes++) = CURVE3;\n                    *(outcodes++) = CURVE3;\n\n                    v_control = vec;\n                    goto Do_Conic;\n                }\n                double xctl = conv(v_control.x);\n                double yctl = flip_y ? -conv(v_control.y) : conv(v_control.y);\n                double xto = conv(v_start.x);\n                double yto = flip_y ? -conv(v_start.y) : conv(v_start.y);\n\n                *(outpoints++) = xctl;\n                *(outpoints++) = yctl;\n                *(outpoints++) = xto;\n                *(outpoints++) = yto;\n                *(outcodes++) = CURVE3;\n                *(outcodes++) = CURVE3;\n\n                goto Close;\n            }\n\n            default: // FT_CURVE_TAG_CUBIC\n            {\n                FT_Vector vec1, vec2;\n\n                vec1.x = point[0].x;\n                vec1.y = point[0].y;\n                vec2.x = point[1].x;\n                vec2.y = point[1].y;\n\n                point += 2;\n                tags += 2;\n\n                if (point <= limit) {\n                    FT_Vector vec;\n\n                    vec.x = point->x;\n                    vec.y = point->y;\n\n                    double xctl1 = conv(vec1.x);\n                    double yctl1 = flip_y ? -conv(vec1.y) : conv(vec1.y);\n                    double xctl2 = conv(vec2.x);\n                    double yctl2 = flip_y ? -conv(vec2.y) : conv(vec2.y);\n                    double xto = conv(vec.x);\n                    double yto = flip_y ? -conv(vec.y) : conv(vec.y);\n\n                    (*outpoints++) = xctl1;\n                    (*outpoints++) = yctl1;\n                    (*outpoints++) = xctl2;\n                    (*outpoints++) = yctl2;\n                    (*outpoints++) = xto;\n                    (*outpoints++) = yto;\n                    (*outcodes++) = CURVE4;\n                    (*outcodes++) = CURVE4;\n                    (*outcodes++) = CURVE4;\n                    continue;\n                }\n\n                double xctl1 = conv(vec1.x);\n                double yctl1 = flip_y ? -conv(vec1.y) : conv(vec1.y);\n                double xctl2 = conv(vec2.x);\n                double yctl2 = flip_y ? -conv(vec2.y) : conv(vec2.y);\n                double xto = conv(v_start.x);\n                double yto = flip_y ? -conv(v_start.y) : conv(v_start.y);\n                (*outpoints++) = xctl1;\n                (*outpoints++) = yctl1;\n                (*outpoints++) = xctl2;\n                (*outpoints++) = yctl2;\n                (*outpoints++) = xto;\n                (*outpoints++) = yto;\n                (*outcodes++) = CURVE4;\n                (*outcodes++) = CURVE4;\n                (*outcodes++) = CURVE4;\n\n                goto Close;\n            }\n            }\n        }\n\n        (*outpoints++) = 0.0;\n        (*outpoints++) = 0.0;\n        (*outcodes++) = ENDPOLY;\n\n    Close:\n        first = last + 1;\n    }\n}\n\nFT2Font::FT2Font(FT_Open_Args &open_args, long hinting_factor_) : image(), face(NULL)\n{\n    clear();\n\n    int error = FT_Open_Face(_ft2Library, &open_args, 0, &face);\n\n    if (error == FT_Err_Unknown_File_Format) {\n        throw \"Can not load face.  Unknown file format.\";\n    } else if (error == FT_Err_Cannot_Open_Resource) {\n        throw \"Can not load face.  Can not open resource.\";\n    } else if (error == FT_Err_Invalid_File_Format) {\n        throw \"Can not load face.  Invalid file format.\";\n    } else if (error) {\n        throw \"Can not load face.\";\n    }\n\n    // set a default fontsize 12 pt at 72dpi\n    hinting_factor = hinting_factor_;\n\n    error = FT_Set_Char_Size(face, 12 * 64, 0, 72 * (unsigned int)hinting_factor, 72);\n    if (error) {\n        throw \"Could not set the fontsize\";\n    }\n\n    static FT_Matrix transform = { 65536 / hinting_factor, 0, 0, 65536 };\n    FT_Set_Transform(face, &transform, 0);\n}\n\nFT2Font::~FT2Font()\n{\n    for (size_t i = 0; i < glyphs.size(); i++) {\n        FT_Done_Glyph(glyphs[i]);\n    }\n\n    if (face) {\n        FT_Done_Face(face);\n    }\n}\n\nvoid FT2Font::clear()\n{\n    angle = 0.0;\n\n    pen.x = 0;\n    pen.y = 0;\n\n    for (size_t i = 0; i < glyphs.size(); i++) {\n        FT_Done_Glyph(glyphs[i]);\n    }\n\n    glyphs.clear();\n}\n\nvoid FT2Font::set_size(double ptsize, double dpi)\n{\n    int error = FT_Set_Char_Size(\n        face, (long)(ptsize * 64), 0, (unsigned int)(dpi * hinting_factor), (unsigned int)dpi);\n    static FT_Matrix transform = { 65536 / hinting_factor, 0, 0, 65536 };\n    FT_Set_Transform(face, &transform, 0);\n\n    if (error) {\n        throw \"Could not set the fontsize\";\n    }\n}\n\nvoid FT2Font::set_charmap(int i)\n{\n    if (i >= face->num_charmaps) {\n        throw \"i exceeds the available number of char maps\";\n    }\n    FT_CharMap charmap = face->charmaps[i];\n    if (FT_Set_Charmap(face, charmap)) {\n        throw \"Could not set the charmap\";\n    }\n}\n\nvoid FT2Font::select_charmap(unsigned long i)\n{\n    if (FT_Select_Charmap(face, (FT_Encoding)i)) {\n        throw \"Could not set the charmap\";\n    }\n}\n\nFT_BBox FT2Font::compute_string_bbox()\n{\n    FT_BBox bbox;\n    /* initialize string bbox to \"empty\" values */\n    bbox.xMin = bbox.yMin = 32000;\n    bbox.xMax = bbox.yMax = -32000;\n\n    int right_side = 0;\n    for (size_t n = 0; n < glyphs.size(); n++) {\n        FT_BBox glyph_bbox;\n        FT_Glyph_Get_CBox(glyphs[n], ft_glyph_bbox_subpixels, &glyph_bbox);\n        if (glyph_bbox.xMin < bbox.xMin) {\n            bbox.xMin = glyph_bbox.xMin;\n        }\n        if (glyph_bbox.yMin < bbox.yMin) {\n            bbox.yMin = glyph_bbox.yMin;\n        }\n        if (glyph_bbox.xMin == glyph_bbox.xMax) {\n            right_side += glyphs[n]->advance.x >> 10;\n            if (right_side > bbox.xMax) {\n                bbox.xMax = right_side;\n            }\n        } else {\n            if (glyph_bbox.xMax > bbox.xMax) {\n                bbox.xMax = glyph_bbox.xMax;\n            }\n        }\n        if (glyph_bbox.yMax > bbox.yMax)\n            bbox.yMax = glyph_bbox.yMax;\n    }\n    /* check that we really grew the string bbox */\n    if (bbox.xMin > bbox.xMax) {\n        bbox.xMin = 0;\n        bbox.yMin = 0;\n        bbox.xMax = 0;\n        bbox.yMax = 0;\n    }\n    return bbox;\n}\n\nint FT2Font::get_kerning(int left, int right, int mode)\n{\n    if (!FT_HAS_KERNING(face)) {\n        return 0;\n    }\n    FT_Vector delta;\n\n    if (!FT_Get_Kerning(face, left, right, mode, &delta)) {\n        return (int)(delta.x / hinting_factor);\n    } else {\n        return 0;\n    }\n}\n\nvoid FT2Font::set_text(\n    size_t N, uint32_t *codepoints, double angle, FT_UInt32 flags, std::vector<double> &xys)\n{\n    angle = angle / 360.0 * 2 * M_PI;\n\n    // this computes width and height in subpixels so we have to divide by 64\n    matrix.xx = (FT_Fixed)(cos(angle) * 0x10000L);\n    matrix.xy = (FT_Fixed)(-sin(angle) * 0x10000L);\n    matrix.yx = (FT_Fixed)(sin(angle) * 0x10000L);\n    matrix.yy = (FT_Fixed)(cos(angle) * 0x10000L);\n\n    FT_Bool use_kerning = FT_HAS_KERNING(face);\n    FT_UInt previous = 0;\n\n    glyphs.resize(0);\n    pen.x = 0;\n    pen.y = 0;\n\n    for (unsigned int n = 0; n < N; n++) {\n        std::string thischar(\"?\");\n        FT_UInt glyph_index;\n\n        glyph_index = FT_Get_Char_Index(face, codepoints[n]);\n\n        // retrieve kerning distance and move pen position\n        if (use_kerning && previous && glyph_index) {\n            FT_Vector delta;\n            FT_Get_Kerning(face, previous, glyph_index, FT_KERNING_DEFAULT, &delta);\n            pen.x += delta.x / hinting_factor;\n        }\n        error = FT_Load_Glyph(face, glyph_index, flags);\n        if (error) {\n            std::cerr << \"\\tcould not load glyph for \" << thischar << std::endl;\n            continue;\n        }\n        // ignore errors, jump to next glyph\n\n        // extract glyph image and store it in our table\n\n        FT_Glyph thisGlyph;\n        error = FT_Get_Glyph(face->glyph, &thisGlyph);\n\n        if (error) {\n            std::cerr << \"\\tcould not get glyph for \" << thischar << std::endl;\n            continue;\n        }\n        // ignore errors, jump to next glyph\n\n        FT_Glyph_Transform(thisGlyph, 0, &pen);\n        xys.push_back(pen.x);\n        xys.push_back(pen.y);\n        pen.x += face->glyph->advance.x;\n\n        previous = glyph_index;\n        glyphs.push_back(thisGlyph);\n    }\n\n    // now apply the rotation\n    for (unsigned int n = 0; n < glyphs.size(); n++) {\n        FT_Glyph_Transform(glyphs[n], &matrix, 0);\n    }\n}\n\nvoid FT2Font::load_char(long charcode, FT_UInt32 flags)\n{\n    int error = FT_Load_Char(face, (unsigned long)charcode, flags);\n\n    if (error) {\n        throw \"Could not load charcode\";\n    }\n\n    FT_Glyph thisGlyph;\n    error = FT_Get_Glyph(face->glyph, &thisGlyph);\n\n    if (error) {\n        throw \"Could not get glyph\";\n    }\n\n    glyphs.push_back(thisGlyph);\n}\n\nvoid FT2Font::load_glyph(FT_UInt glyph_index, FT_UInt32 flags)\n{\n    int error = FT_Load_Glyph(face, glyph_index, flags);\n\n    if (error) {\n        throw \"Could not load glyph\";\n    }\n\n    FT_Glyph thisGlyph;\n    error = FT_Get_Glyph(face->glyph, &thisGlyph);\n\n    if (error) {\n        throw \"Could not load glyph\";\n    }\n\n    glyphs.push_back(thisGlyph);\n}\n\nvoid FT2Font::get_width_height(long *width, long *height)\n{\n    FT_BBox bbox = compute_string_bbox();\n\n    *width = bbox.xMax - bbox.xMin;\n    *height = bbox.yMax - bbox.yMin;\n}\n\nlong FT2Font::get_descent()\n{\n    FT_BBox bbox = compute_string_bbox();\n    return -bbox.yMin;\n}\n\nvoid FT2Font::draw_glyphs_to_bitmap(bool antialiased)\n{\n    FT_BBox string_bbox = compute_string_bbox();\n    size_t width = (string_bbox.xMax - string_bbox.xMin) / 64 + 2;\n    size_t height = (string_bbox.yMax - string_bbox.yMin) / 64 + 2;\n\n    image.resize(width, height);\n\n    for (size_t n = 0; n < glyphs.size(); n++) {\n        FT_BBox bbox;\n        FT_Glyph_Get_CBox(glyphs[n], ft_glyph_bbox_pixels, &bbox);\n\n        error = FT_Glyph_To_Bitmap(\n            &glyphs[n], antialiased ? FT_RENDER_MODE_NORMAL : FT_RENDER_MODE_MONO, 0, 1);\n        if (error) {\n            throw \"Could not convert glyph to bitmap\";\n        }\n\n        FT_BitmapGlyph bitmap = (FT_BitmapGlyph)glyphs[n];\n        // now, draw to our target surface (convert position)\n\n        // bitmap left and top in pixel, string bbox in subpixel\n        FT_Int x = (FT_Int)(bitmap->left - (string_bbox.xMin / 64.));\n        FT_Int y = (FT_Int)((string_bbox.yMax / 64.) - bitmap->top + 1);\n\n        image.draw_bitmap(&bitmap->bitmap, x, y);\n    }\n}\n\nvoid FT2Font::get_xys(bool antialiased, std::vector<double> &xys)\n{\n    FT_BBox string_bbox = compute_string_bbox();\n\n    for (size_t n = 0; n < glyphs.size(); n++) {\n\n        FT_BBox bbox;\n        FT_Glyph_Get_CBox(glyphs[n], ft_glyph_bbox_pixels, &bbox);\n\n        error = FT_Glyph_To_Bitmap(\n            &glyphs[n], antialiased ? FT_RENDER_MODE_NORMAL : FT_RENDER_MODE_MONO, 0, 1);\n        if (error) {\n            throw \"Could not convert glyph to bitmap\";\n        }\n\n        FT_BitmapGlyph bitmap = (FT_BitmapGlyph)glyphs[n];\n\n        // bitmap left and top in pixel, string bbox in subpixel\n        FT_Int x = (FT_Int)(bitmap->left - string_bbox.xMin / 64.);\n        FT_Int y = (FT_Int)(string_bbox.yMax / 64. - bitmap->top + 1);\n        // make sure the index is non-neg\n        x = x < 0 ? 0 : x;\n        y = y < 0 ? 0 : y;\n        xys.push_back(x);\n        xys.push_back(y);\n    }\n}\n\nvoid FT2Font::draw_glyph_to_bitmap(FT2Image &im, int x, int y, size_t glyphInd, bool antialiased)\n{\n    FT_Vector sub_offset;\n    sub_offset.x = 0; // int((xd - (double)x) * 64.0);\n    sub_offset.y = 0; // int((yd - (double)y) * 64.0);\n\n    if (glyphInd >= glyphs.size()) {\n        throw \"glyph num is out of range\";\n    }\n\n    error = FT_Glyph_To_Bitmap(&glyphs[glyphInd],\n                               antialiased ? FT_RENDER_MODE_NORMAL : FT_RENDER_MODE_MONO,\n                               &sub_offset, // additional translation\n                               1 // destroy image\n                               );\n    if (error) {\n        throw \"Could not convert glyph to bitmap\";\n    }\n\n    FT_BitmapGlyph bitmap = (FT_BitmapGlyph)glyphs[glyphInd];\n\n    im.draw_bitmap(&bitmap->bitmap, x + bitmap->left, y);\n}\n\nvoid FT2Font::get_glyph_name(unsigned int glyph_number, char *buffer)\n{\n    if (!FT_HAS_GLYPH_NAMES(face)) {\n        /* Note that this generated name must match the name that\n           is generated by ttconv in ttfont_CharStrings_getname. */\n        PyOS_snprintf(buffer, 128, \"uni%08x\", glyph_number);\n    } else {\n        if (FT_Get_Glyph_Name(face, glyph_number, buffer, 128)) {\n            throw \"Could not get glyph names.\";\n        }\n    }\n}\n\nlong FT2Font::get_name_index(char *name)\n{\n    return FT_Get_Name_Index(face, (FT_String *)name);\n}\n", "patch": "@@ -1,19 +1,9 @@\n /* -*- mode: c++; c-basic-offset: 4 -*- */\n \n+#define NO_IMPORT_ARRAY\n+\n #include \"ft2font.h\"\n #include \"mplutils.h\"\n-#include <sstream>\n-\n-#include \"file_compat.h\"\n-\n-#include \"numpy/arrayobject.h\"\n-\n-/*\n- By definition, FT_FIXED as 2 16bit values stored in a single long.\n- We cast to long to ensure the correct Py::Int convertor is called\n- */\n-#define FIXED_MAJOR(val) (long) ((val & 0xffff000) >> 16)\n-#define FIXED_MINOR(val) (long) (val & 0xffff)\n \n /**\n  To improve the hinting of the fonts, this code uses a hack\n@@ -40,80 +30,56 @@\n       you have disabled hints).\n  */\n \n-\n FT_Library _ft2Library;\n \n-FT2Image::FT2Image(Py::PythonClassInstance *self, Py::Tuple &args, Py::Dict &kwds) :\n-    Py::PythonClass< FT2Image >(self, args, kwds),\n-    _isDirty(true),\n-    _buffer(NULL),\n-    _width(0), _height(0)\n+FT2Image::FT2Image() : m_dirty(true), m_buffer(NULL), m_width(0), m_height(0)\n {\n-    _VERBOSE(\"FT2Image::FT2Image\");\n-\n-    args.verify_length(2);\n-    int width = Py::Int(args[0]);\n-    int height = Py::Int(args[1]);\n-\n-    resize(width, height);\n }\n \n-FT2Image::~FT2Image() {\n-    delete [] _buffer;\n-    _buffer = NULL;\n+FT2Image::FT2Image(unsigned long width, unsigned long height)\n+    : m_dirty(true), m_buffer(NULL), m_width(0), m_height(0)\n+{\n+    resize(width, height);\n }\n \n-Py::PythonClassObject<FT2Image> FT2Image::factory(int width, int height)\n+FT2Image::~FT2Image()\n {\n-    Py::Callable class_type(type());\n-    Py::Tuple args(2);\n-    args[0] = Py::Int(width);\n-    args[1] = Py::Int(height);\n-    Py::PythonClassObject<FT2Image> o = Py::PythonClassObject<FT2Image>(\n-        class_type.apply(args, Py::Dict()));\n-    return o;\n+    delete[] m_buffer;\n }\n \n-void\n-FT2Image::resize(long width, long height)\n+void FT2Image::resize(long width, long height)\n {\n-    if (width < 0)\n-    {\n+    if (width < 0) {\n         width = 1;\n     }\n-    if (height < 0)\n-    {\n+    if (height < 0) {\n         height = 1;\n     }\n     size_t numBytes = width * height;\n \n-    if ((unsigned long)width != _width || (unsigned long)height != _height)\n-    {\n-        if (numBytes > _width*_height)\n-        {\n-            delete [] _buffer;\n-            _buffer = NULL;\n-            _buffer = new unsigned char [numBytes];\n+    if ((unsigned long)width != m_width || (unsigned long)height != m_height) {\n+        if (numBytes > m_width * m_height) {\n+            delete[] m_buffer;\n+            m_buffer = NULL;\n+            m_buffer = new unsigned char[numBytes];\n         }\n \n-        _width = (unsigned long)width;\n-        _height = (unsigned long)height;\n+        m_width = (unsigned long)width;\n+        m_height = (unsigned long)height;\n     }\n \n-    memset(_buffer, 0, numBytes);\n+    if (numBytes) {\n+        memset(m_buffer, 0, numBytes);\n+    }\n \n-    _isDirty = true;\n+    m_dirty = true;\n }\n \n-void\n-FT2Image::draw_bitmap(FT_Bitmap*  bitmap,\n-                      FT_Int      x,\n-                      FT_Int      y)\n+void FT2Image::draw_bitmap(FT_Bitmap *bitmap, FT_Int x, FT_Int y)\n {\n-    _VERBOSE(\"FT2Image::draw_bitmap\");\n-    FT_Int image_width = (FT_Int)_width;\n-    FT_Int image_height = (FT_Int)_height;\n-    FT_Int char_width =  bitmap->width;\n+    FT_Int image_width = (FT_Int)m_width;\n+    FT_Int image_height = (FT_Int)m_height;\n+    FT_Int char_width = bitmap->width;\n     FT_Int char_height = bitmap->rows;\n \n     FT_Int x1 = CLAMP(x, 0, image_width);\n@@ -125,470 +91,155 @@ FT2Image::draw_bitmap(FT_Bitmap*  bitmap,\n     FT_Int y_offset = y1 - MAX(0, -y);\n \n     if (bitmap->pixel_mode == FT_PIXEL_MODE_GRAY) {\n-        for (FT_Int i = y1; i < y2; ++i)\n-        {\n-            unsigned char* dst = _buffer + (i * image_width + x1);\n-            unsigned char* src = bitmap->buffer + (((i - y_offset) * bitmap->pitch) + x_start);\n+        for (FT_Int i = y1; i < y2; ++i) {\n+            unsigned char *dst = m_buffer + (i * image_width + x1);\n+            unsigned char *src = bitmap->buffer + (((i - y_offset) * bitmap->pitch) + x_start);\n             for (FT_Int j = x1; j < x2; ++j, ++dst, ++src)\n                 *dst |= *src;\n         }\n     } else if (bitmap->pixel_mode == FT_PIXEL_MODE_MONO) {\n-        for (FT_Int i = y1; i < y2; ++i)\n-        {\n-            unsigned char* dst = _buffer + (i * image_width + x1);\n-            unsigned char* src = bitmap->buffer + ((i - y_offset) * bitmap->pitch);\n+        for (FT_Int i = y1; i < y2; ++i) {\n+            unsigned char *dst = m_buffer + (i * image_width + x1);\n+            unsigned char *src = bitmap->buffer + ((i - y_offset) * bitmap->pitch);\n             for (FT_Int j = x1; j < x2; ++j, ++dst) {\n                 int x = (j - x1 + x_start);\n                 int val = *(src + (x >> 3)) & (1 << (7 - (x & 0x7)));\n                 *dst = val ? 255 : *dst;\n             }\n         }\n     } else {\n-        throw Py::Exception(\"Unknown pixel mode\");\n+        throw \"Unknown pixel mode\";\n     }\n \n-    _isDirty = true;\n+    m_dirty = true;\n }\n \n-void\n-FT2Image::write_bitmap(FILE *fh) const\n+void FT2Image::draw_rect(unsigned long x0, unsigned long y0, unsigned long x1, unsigned long y1)\n {\n-    for (size_t i = 0; i < _height; i++)\n-    {\n-        for (size_t j = 0; j < _width; ++j)\n-        {\n-            if (_buffer[j + i*_width])\n-            {\n-                fputc('#', fh);\n-            }\n-            else\n-            {\n-                fputc(' ', fh);\n-            }\n-        }\n-        fputc('\\n', fh);\n+    if (x0 > m_width || x1 > m_width || y0 > m_height || y1 > m_height) {\n+        throw \"Rect coords outside image bounds\";\n     }\n-}\n \n-char FT2Image::write_bitmap__doc__[] =\n-    \"write_bitmap(fname)\\n\"\n-    \"\\n\"\n-    \"Write the bitmap to file fname\\n\"\n-    ;\n-Py::Object\n-FT2Image::py_write_bitmap(const Py::Tuple & args)\n-{\n-    _VERBOSE(\"FT2Image::write_bitmap\");\n-    PyObject *py_file;\n-    FILE *fh;\n-    mpl_off_t offset;\n-\n-    args.verify_length(1);\n-\n-    if ((py_file = mpl_PyFile_OpenFile(args[0].ptr(), (char *)\"wb\")) == NULL) {\n-        throw Py::Exception();\n+    size_t top = y0 * m_width;\n+    size_t bottom = y1 * m_width;\n+    for (size_t i = x0; i < x1 + 1; ++i) {\n+        m_buffer[i + top] = 255;\n+        m_buffer[i + bottom] = 255;\n     }\n \n-    fh = mpl_PyFile_Dup(py_file, (char *)\"wb\", &offset);\n-\n-    write_bitmap(fh);\n-\n-    if (mpl_PyFile_DupClose(py_file, fh, offset))\n-    {\n-        throw Py::Exception();\n+    for (size_t j = y0 + 1; j < y1; ++j) {\n+        m_buffer[x0 + j * m_width] = 255;\n+        m_buffer[x1 + j * m_width] = 255;\n     }\n-    mpl_PyFile_CloseFile(py_file);\n-    Py_DECREF(py_file);\n \n-    return Py::Object();\n+    m_dirty = true;\n }\n-PYCXX_VARARGS_METHOD_DECL(FT2Image, py_write_bitmap)\n \n void\n-FT2Image::draw_rect(unsigned long x0, unsigned long y0,\n-                    unsigned long x1, unsigned long y1)\n-{\n-    if (x0 > _width || x1 > _width ||\n-        y0 > _height || y1 > _height)\n-    {\n-        throw Py::ValueError(\"Rect coords outside image bounds\");\n-    }\n-\n-    size_t top = y0 * _width;\n-    size_t bottom = y1 * _width;\n-    for (size_t i = x0; i < x1 + 1; ++i)\n-    {\n-        _buffer[i + top] = 255;\n-        _buffer[i + bottom] = 255;\n-    }\n-\n-    for (size_t j = y0 + 1; j < y1; ++j)\n-    {\n-        _buffer[x0 + j*_width] = 255;\n-        _buffer[x1 + j*_width] = 255;\n-    }\n-\n-    _isDirty = true;\n-}\n-\n-char FT2Image::draw_rect__doc__[] =\n-    \"draw_rect(x0, y0, x1, y1)\\n\"\n-    \"\\n\"\n-    \"Draw a rect to the image.\\n\"\n-    \"\\n\"\n-    ;\n-Py::Object\n-FT2Image::py_draw_rect(const Py::Tuple & args)\n+FT2Image::draw_rect_filled(unsigned long x0, unsigned long y0, unsigned long x1, unsigned long y1)\n {\n-    _VERBOSE(\"FT2Image::draw_rect\");\n-\n-    args.verify_length(4);\n+    x0 = std::min(x0, m_width);\n+    y0 = std::min(y0, m_height);\n+    x1 = std::min(x1, m_width);\n+    y1 = std::min(y1, m_height);\n \n-    long x0 = Py::Int(args[0]);\n-    long y0 = Py::Int(args[1]);\n-    long x1 = Py::Int(args[2]);\n-    long y1 = Py::Int(args[3]);\n-\n-    draw_rect(x0, y0, x1, y1);\n-\n-    return Py::Object();\n-}\n-PYCXX_VARARGS_METHOD_DECL(FT2Image, py_draw_rect)\n-\n-void\n-FT2Image::draw_rect_filled(unsigned long x0, unsigned long y0,\n-                           unsigned long x1, unsigned long y1)\n-{\n-    x0 = std::min(x0, _width);\n-    y0 = std::min(y0, _height);\n-    x1 = std::min(x1, _width);\n-    y1 = std::min(y1, _height);\n-\n-    for (size_t j = y0; j < y1 + 1; j++)\n-    {\n-        for (size_t i = x0; i < x1 + 1; i++)\n-        {\n-            _buffer[i + j*_width] = 255;\n+    for (size_t j = y0; j < y1 + 1; j++) {\n+        for (size_t i = x0; i < x1 + 1; i++) {\n+            m_buffer[i + j * m_width] = 255;\n         }\n     }\n \n-    _isDirty = true;\n-}\n-\n-char FT2Image::draw_rect_filled__doc__[] =\n-    \"draw_rect_filled(x0, y0, x1, y1)\\n\"\n-    \"\\n\"\n-    \"Draw a filled rect to the image.\\n\"\n-    \"\\n\"\n-    ;\n-Py::Object\n-FT2Image::py_draw_rect_filled(const Py::Tuple & args)\n-{\n-    _VERBOSE(\"FT2Image::draw_rect_filled\");\n-\n-    args.verify_length(4);\n-\n-    long x0 = Py::Int(args[0]);\n-    long y0 = Py::Int(args[1]);\n-    long x1 = Py::Int(args[2]);\n-    long y1 = Py::Int(args[3]);\n-\n-    draw_rect_filled(x0, y0, x1, y1);\n-\n-    return Py::Object();\n-}\n-PYCXX_VARARGS_METHOD_DECL(FT2Image, py_draw_rect_filled)\n-\n-char FT2Image::as_str__doc__[] =\n-    \"s = image.as_str()\\n\"\n-    \"\\n\"\n-    \"Return the image buffer as a string\\n\"\n-    \"\\n\"\n-    ;\n-Py::Object\n-FT2Image::py_as_str(const Py::Tuple & args)\n-{\n-    _VERBOSE(\"FT2Image::as_str\");\n-    args.verify_length(0);\n-\n-    return Py::asObject\n-      (PyBytes_FromStringAndSize((const char *)_buffer, _width*_height));\n-}\n-PYCXX_VARARGS_METHOD_DECL(FT2Image, py_as_str)\n-\n-char FT2Image::as_rgba_str__doc__[] =\n-    \"s = image.as_rgba_str()\\n\"\n-    \"\\n\"\n-    \"Return the image buffer as a RGBA string\\n\"\n-    \"\\n\"\n-    ;\n-Py::Object\n-FT2Image::py_as_rgba_str(const Py::Tuple & args)\n-{\n-    _VERBOSE(\"FT2Image::as_str\");\n-    args.verify_length(0);\n-\n-    Py_ssize_t size = _width*_height*4;\n-    PyObject* result = PyBytes_FromStringAndSize(NULL, size);\n-\n-    unsigned char *src     = _buffer;\n-    unsigned char *src_end = src + (_width * _height);\n-    unsigned char *dst     = (unsigned char *)PyBytes_AS_STRING(result);\n-\n-    while (src != src_end)\n-    {\n-        *dst++ = 0;\n-        *dst++ = 0;\n-        *dst++ = 0;\n-        *dst++ = *src++;\n-    }\n-\n-    return Py::asObject(result);\n-}\n-PYCXX_VARARGS_METHOD_DECL(FT2Image, py_as_rgba_str)\n-\n-/* TODO: This could take a color as an argument, but for\n-   now it defaults to black on white background */\n-char FT2Image::as_rgb_str__doc__[] =\n-    \"s = image.as_rgb_str()\\n\"\n-    \"\\n\"\n-    \"Return the image buffer as a RGB string\\n\"\n-    \"\\n\"\n-    ;\n-Py::Object\n-FT2Image::py_as_rgb_str(const Py::Tuple & args)\n-{\n-    _VERBOSE(\"FT2Image::as_str\");\n-    args.verify_length(0);\n-\n-    Py_ssize_t size = _width*_height*3;\n-    PyObject* result = PyBytes_FromStringAndSize(NULL, size);\n-\n-    unsigned char *src     = _buffer;\n-    unsigned char *src_end = src + (_width * _height);\n-    unsigned char *dst     = (unsigned char *)PyBytes_AS_STRING(result);\n-\n-    while (src != src_end)\n-    {\n-        unsigned char tmp = 255 - *src++;\n-        *dst++ = tmp;\n-        *dst++ = tmp;\n-        *dst++ = tmp;\n-    }\n-\n-    return Py::asObject(result);\n-}\n-PYCXX_VARARGS_METHOD_DECL(FT2Image, py_as_rgb_str)\n-\n-char FT2Image::as_array__doc__[] =\n-    \"x = image.as_array()\\n\"\n-    \"\\n\"\n-    \"Return the image buffer as a width x height numpy array of ubyte \\n\"\n-    \"\\n\"\n-    ;\n-Py::Object\n-FT2Image::py_as_array(const Py::Tuple & args)\n-{\n-    _VERBOSE(\"FT2Image::as_array\");\n-    args.verify_length(0);\n-\n-    npy_intp dimensions[2];\n-    dimensions[0] = get_height();  //numrows\n-    dimensions[1] = get_width();   //numcols\n-\n-\n-    PyArrayObject *A = (PyArrayObject *) PyArray_SimpleNewFromData(2, dimensions, NPY_UBYTE, _buffer);\n-\n-    return Py::asObject((PyObject*)A);\n-}\n-PYCXX_VARARGS_METHOD_DECL(FT2Image, py_as_array)\n-\n-Py::Object\n-FT2Image::py_get_width(const Py::Tuple & args)\n-{\n-    _VERBOSE(\"FT2Image::get_width\");\n-    args.verify_length(0);\n-\n-    return Py::Int((long)get_width());\n-}\n-PYCXX_VARARGS_METHOD_DECL(FT2Image, py_get_width)\n-\n-Py::Object\n-FT2Image::py_get_height(const Py::Tuple & args)\n-{\n-    _VERBOSE(\"FT2Image::get_height\");\n-    args.verify_length(0);\n-\n-    return Py::Int((long)get_height());\n-}\n-PYCXX_VARARGS_METHOD_DECL(FT2Image, py_get_height)\n-\n-Py::PythonClassObject<Glyph> Glyph::factory(\n-        const FT_Face& face, const FT_Glyph& glyph, size_t ind, long hinting_factor)\n-{\n-    Py::Callable class_type(type());\n-    Py::PythonClassObject<Glyph> obj = Py::PythonClassObject<Glyph>(\n-        class_type.apply(Py::Tuple(), Py::Dict()));\n-    Glyph* o = obj.getCxxObject();\n-\n-    o->glyphInd = ind;\n-    FT_BBox bbox;\n-    FT_Glyph_Get_CBox(glyph, ft_glyph_bbox_subpixels, &bbox);\n-\n-    o->setattro(\"width\",        Py::Int(face->glyph->metrics.width / hinting_factor));\n-    o->setattro(\"height\",       Py::Int(face->glyph->metrics.height));\n-    o->setattro(\"horiBearingX\", Py::Int(face->glyph->metrics.horiBearingX / hinting_factor));\n-    o->setattro(\"horiBearingY\", Py::Int(face->glyph->metrics.horiBearingY));\n-    o->setattro(\"horiAdvance\",  Py::Int(face->glyph->metrics.horiAdvance));\n-    o->setattro(\"linearHoriAdvance\",  Py::Int(face->glyph->linearHoriAdvance / hinting_factor));\n-    o->setattro(\"vertBearingX\", Py::Int(face->glyph->metrics.vertBearingX));\n-\n-    o->setattro(\"vertBearingY\", Py::Int(face->glyph->metrics.vertBearingY));\n-    o->setattro(\"vertAdvance\",  Py::Int(face->glyph->metrics.vertAdvance));\n-\n-    Py::Tuple abbox(4);\n-\n-    abbox[0] = Py::Int(bbox.xMin);\n-    abbox[1] = Py::Int(bbox.yMin);\n-    abbox[2] = Py::Int(bbox.xMax);\n-    abbox[3] = Py::Int(bbox.yMax);\n-    o->setattro(\"bbox\", abbox);\n-\n-    return obj;\n-}\n-\n-Glyph::~Glyph()\n-{\n-    _VERBOSE(\"Glyph::~Glyph\");\n+    m_dirty = true;\n }\n \n-int\n-Glyph::setattro(const Py::String &name, const Py::Object &value)\n-{\n-    _VERBOSE(\"Glyph::setattr\");\n-    __dict__[name] = value;\n-    return 0;\n-}\n-\n-Py::Object\n-Glyph::getattro(const Py::String &name)\n-{\n-    _VERBOSE(\"Glyph::getattr\");\n-    if (__dict__.hasKey(name)) return __dict__[name];\n-    else return genericGetAttro(name);\n-}\n-\n-inline double conv(int v)\n+inline double conv(long v)\n {\n     return double(v) / 64.0;\n }\n \n-\n-char FT2Font::get_path__doc__[] =\n-    \"get_path()\\n\"\n-    \"\\n\"\n-    \"Get the path data from the currently loaded glyph as a tuple of vertices, codes.\\n\"\n-    ;\n-Py::Object\n-FT2Font::get_path()\n+int FT2Font::get_path_count()\n {\n-    //get the glyph as a path, a list of (COMMAND, *args) as desribed in matplotlib.path\n+    // get the glyph as a path, a list of (COMMAND, *args) as desribed in matplotlib.path\n     // this code is from agg's decompose_ft_outline with minor modifications\n \n     if (!face->glyph) {\n-        throw Py::ValueError(\"No glyph loaded\");\n+        throw \"No glyph loaded\";\n     }\n \n-    enum {STOP = 0,\n-          MOVETO = 1,\n-          LINETO = 2,\n-          CURVE3 = 3,\n-          CURVE4 = 4,\n-          ENDPOLY = 0x4f};\n-    FT_Outline& outline = face->glyph->outline;\n-    bool flip_y = false; //todo, pass me as kwarg\n+    FT_Outline &outline = face->glyph->outline;\n \n-    FT_Vector   v_last;\n-    FT_Vector   v_control;\n-    FT_Vector   v_start;\n+    FT_Vector v_last;\n+    FT_Vector v_control;\n+    FT_Vector v_start;\n \n-    FT_Vector*  point;\n-    FT_Vector*  limit;\n-    char*       tags;\n+    FT_Vector *point;\n+    FT_Vector *limit;\n+    char *tags;\n \n-    int   n;         // index of contour in outline\n-    int   first;     // index of first point in contour\n-    char  tag;       // current point's state\n-    int   count;\n+    int n;     // index of contour in outline\n+    int first; // index of first point in contour\n+    char tag;  // current point's state\n+    int count;\n \n     count = 0;\n     first = 0;\n-    for (n = 0; n < outline.n_contours; n++)\n-    {\n-        int  last;  // index of last point in contour\n+    for (n = 0; n < outline.n_contours; n++) {\n+        int last; // index of last point in contour\n         bool starts_with_last;\n \n-        last  = outline.contours[n];\n+        last = outline.contours[n];\n         limit = outline.points + last;\n \n         v_start = outline.points[first];\n-        v_last  = outline.points[last];\n+        v_last = outline.points[last];\n \n         v_control = v_start;\n \n         point = outline.points + first;\n-        tags  = outline.tags  + first;\n-        tag   = FT_CURVE_TAG(tags[0]);\n+        tags = outline.tags + first;\n+        tag = FT_CURVE_TAG(tags[0]);\n \n         // A contour cannot start with a cubic control point!\n-        if (tag == FT_CURVE_TAG_CUBIC)\n-        {\n-            throw Py::RuntimeError(\"A contour cannot start with a cubic control point\");\n-        }\n-        else if (tag == FT_CURVE_TAG_CONIC)\n-        {\n+        if (tag == FT_CURVE_TAG_CUBIC) {\n+            throw \"A contour cannot start with a cubic control point\";\n+        } else if (tag == FT_CURVE_TAG_CONIC) {\n             starts_with_last = true;\n         } else {\n             starts_with_last = false;\n         }\n \n         count++;\n \n-        while (point < limit)\n-        {\n+        while (point < limit) {\n             if (!starts_with_last) {\n                 point++;\n                 tags++;\n             }\n             starts_with_last = false;\n \n             tag = FT_CURVE_TAG(tags[0]);\n-            switch (tag)\n-            {\n-            case FT_CURVE_TAG_ON:  // emit a single line_to\n+            switch (tag) {\n+            case FT_CURVE_TAG_ON: // emit a single line_to\n             {\n                 count++;\n                 continue;\n             }\n \n-            case FT_CURVE_TAG_CONIC:  // consume conic arcs\n+            case FT_CURVE_TAG_CONIC: // consume conic arcs\n             {\n             Count_Do_Conic:\n-                if (point < limit)\n-                {\n+                if (point < limit) {\n                     point++;\n                     tags++;\n                     tag = FT_CURVE_TAG(tags[0]);\n \n-                    if (tag == FT_CURVE_TAG_ON)\n-                    {\n+                    if (tag == FT_CURVE_TAG_ON) {\n                         count += 2;\n                         continue;\n                     }\n \n-                    if (tag != FT_CURVE_TAG_CONIC)\n-                    {\n-                        throw Py::RuntimeError(\"Invalid font\");\n+                    if (tag != FT_CURVE_TAG_CONIC) {\n+                        throw \"Invalid font\";\n                     }\n \n                     count += 2;\n@@ -601,18 +252,16 @@ FT2Font::get_path()\n                 goto Count_Close;\n             }\n \n-            default:  // FT_CURVE_TAG_CUBIC\n+            default: // FT_CURVE_TAG_CUBIC\n             {\n-                if (point + 1 > limit || FT_CURVE_TAG(tags[1]) != FT_CURVE_TAG_CUBIC)\n-                {\n-                    throw Py::RuntimeError(\"Invalid font\");\n+                if (point + 1 > limit || FT_CURVE_TAG(tags[1]) != FT_CURVE_TAG_CUBIC) {\n+                    throw \"Invalid font\";\n                 }\n \n                 point += 2;\n-                tags  += 2;\n+                tags += 2;\n \n-                if (point <= limit)\n-                {\n+                if (point <= limit) {\n                     count += 3;\n                     continue;\n                 }\n@@ -630,50 +279,45 @@ FT2Font::get_path()\n         first = last + 1;\n     }\n \n-    PyArrayObject* vertices = NULL;\n-    PyArrayObject* codes = NULL;\n-    Py::Tuple result(2);\n+    return count;\n+}\n+\n+void FT2Font::get_path(double *outpoints, unsigned char *outcodes)\n+{\n+    FT_Outline &outline = face->glyph->outline;\n+    bool flip_y = false; // todo, pass me as kwarg\n \n-    npy_intp vertices_dims[2] = {count, 2};\n-    vertices = (PyArrayObject*)PyArray_SimpleNew(\n-        2, vertices_dims, NPY_DOUBLE);\n-    if (vertices == NULL) {\n-        throw;\n-    }\n-    npy_intp codes_dims[1] = {count};\n-    codes = (PyArrayObject*)PyArray_SimpleNew(\n-        1, codes_dims, NPY_UINT8);\n-    if (codes == NULL) {\n-        throw;\n-    }\n+    FT_Vector v_last;\n+    FT_Vector v_control;\n+    FT_Vector v_start;\n \n-    result[0] = Py::Object((PyObject*)vertices, true);\n-    result[1] = Py::Object((PyObject*)codes, true);\n+    FT_Vector *point;\n+    FT_Vector *limit;\n+    char *tags;\n \n-    double* outpoints = (double *)PyArray_DATA(vertices);\n-    unsigned char* outcodes = (unsigned char *)PyArray_DATA(codes);\n+    int n;     // index of contour in outline\n+    int first; // index of first point in contour\n+    char tag;  // current point's state\n \n     first = 0;\n-    for (n = 0; n < outline.n_contours; n++)\n-    {\n-        int last;  // index of last point in contour\n+    for (n = 0; n < outline.n_contours; n++) {\n+        int last; // index of last point in contour\n         bool starts_with_last;\n \n-        last  = outline.contours[n];\n+        last = outline.contours[n];\n         limit = outline.points + last;\n \n         v_start = outline.points[first];\n-        v_last  = outline.points[last];\n+        v_last = outline.points[last];\n \n         v_control = v_start;\n \n         point = outline.points + first;\n-        tags  = outline.tags  + first;\n-        tag   = FT_CURVE_TAG(tags[0]);\n+        tags = outline.tags + first;\n+        tag = FT_CURVE_TAG(tags[0]);\n \n         double x, y;\n-        if (tag != FT_CURVE_TAG_ON)\n-        {\n+        if (tag != FT_CURVE_TAG_ON) {\n             x = conv(v_last.x);\n             y = flip_y ? -conv(v_last.y) : conv(v_last.y);\n             starts_with_last = true;\n@@ -687,18 +331,16 @@ FT2Font::get_path()\n         *(outpoints++) = y;\n         *(outcodes++) = MOVETO;\n \n-        while (point < limit)\n-        {\n+        while (point < limit) {\n             if (!starts_with_last) {\n                 point++;\n                 tags++;\n             }\n             starts_with_last = false;\n \n             tag = FT_CURVE_TAG(tags[0]);\n-            switch (tag)\n-            {\n-            case FT_CURVE_TAG_ON:  // emit a single line_to\n+            switch (tag) {\n+            case FT_CURVE_TAG_ON: // emit a single line_to\n             {\n                 double x = conv(point->x);\n                 double y = flip_y ? -conv(point->y) : conv(point->y);\n@@ -708,14 +350,13 @@ FT2Font::get_path()\n                 continue;\n             }\n \n-            case FT_CURVE_TAG_CONIC:  // consume conic arcs\n+            case FT_CURVE_TAG_CONIC: // consume conic arcs\n             {\n                 v_control.x = point->x;\n                 v_control.y = point->y;\n \n             Do_Conic:\n-                if (point < limit)\n-                {\n+                if (point < limit) {\n                     FT_Vector vec;\n                     FT_Vector v_middle;\n \n@@ -726,8 +367,7 @@ FT2Font::get_path()\n                     vec.x = point->x;\n                     vec.y = point->y;\n \n-                    if (tag == FT_CURVE_TAG_ON)\n-                    {\n+                    if (tag == FT_CURVE_TAG_ON) {\n                         double xctl = conv(v_control.x);\n                         double yctl = flip_y ? -conv(v_control.y) : conv(v_control.y);\n                         double xto = conv(vec.x);\n@@ -773,7 +413,7 @@ FT2Font::get_path()\n                 goto Close;\n             }\n \n-            default:  // FT_CURVE_TAG_CUBIC\n+            default: // FT_CURVE_TAG_CUBIC\n             {\n                 FT_Vector vec1, vec2;\n \n@@ -783,10 +423,9 @@ FT2Font::get_path()\n                 vec2.y = point[1].y;\n \n                 point += 2;\n-                tags  += 2;\n+                tags += 2;\n \n-                if (point <= limit)\n-                {\n+                if (point <= limit) {\n                     FT_Vector vec;\n \n                     vec.x = point->x;\n@@ -839,313 +478,123 @@ FT2Font::get_path()\n     Close:\n         first = last + 1;\n     }\n-\n-    if (outcodes - (unsigned char *)PyArray_DATA(codes) != count) {\n-        throw Py::RuntimeError(\"Font path size doesn't match\");\n-    }\n-\n-    return result;\n }\n-PYCXX_NOARGS_METHOD_DECL(FT2Font, get_path)\n \n-FT2Font::FT2Font(Py::PythonClassInstance *self, Py::Tuple &args, Py::Dict &kwds) :\n-    Py::PythonClass<FT2Font>(self, args, kwds),\n-    face(NULL),\n-    image()\n+FT2Font::FT2Font(FT_Open_Args &open_args, long hinting_factor_) : image(), face(NULL)\n {\n-    FT_Open_Args open_args;\n-\n-    /* This string is only used for error messages, so encode it in something\n-     * that we'll always be able to print. */\n-    std::string facefile = Py::String(args[0]).encode(\"unicode_escape\");\n-\n-    args.verify_length(1);\n-\n-    clear(Py::Tuple(0));\n-\n-    memset(&stream, 0, sizeof(FT_StreamRec));\n-    mem = NULL;\n-    mem_size = 0;\n-\n-    if (make_open_args(args[0].ptr(), &open_args)) {\n-        /* make_open_args sets the Python exception for us. */\n-        throw Py::Exception();\n-    }\n+    clear();\n \n     int error = FT_Open_Face(_ft2Library, &open_args, 0, &face);\n \n-    if (error == FT_Err_Unknown_File_Format)\n-    {\n-        std::ostringstream s;\n-        s << \"Could not load facefile \" << facefile << \"; Unknown_File_Format\" << std::endl;\n-        throw Py::RuntimeError(s.str());\n-    }\n-    else if (error == FT_Err_Cannot_Open_Resource)\n-    {\n-        std::ostringstream s;\n-        s << \"Could not open facefile \" << facefile << \"; Cannot_Open_Resource\" << std::endl;\n-        throw Py::RuntimeError(s.str());\n-    }\n-    else if (error == FT_Err_Invalid_File_Format)\n-    {\n-        std::ostringstream s;\n-        s << \"Could not open facefile \" << facefile << \"; Invalid_File_Format\" << std::endl;\n-        throw Py::RuntimeError(s.str());\n-    }\n-    else if (error)\n-    {\n-        std::ostringstream s;\n-        s << \"Could not open facefile \" << facefile << \"; freetype error code \" << error << std::endl;\n-        throw Py::RuntimeError(s.str());\n+    if (error == FT_Err_Unknown_File_Format) {\n+        throw \"Can not load face.  Unknown file format.\";\n+    } else if (error == FT_Err_Cannot_Open_Resource) {\n+        throw \"Can not load face.  Can not open resource.\";\n+    } else if (error == FT_Err_Invalid_File_Format) {\n+        throw \"Can not load face.  Invalid file format.\";\n+    } else if (error) {\n+        throw \"Can not load face.\";\n     }\n \n     // set a default fontsize 12 pt at 72dpi\n-    hinting_factor = 8;\n-    if (kwds.hasKey(\"hinting_factor\"))\n-    {\n-        hinting_factor = Py::Long(kwds[\"hinting_factor\"]);\n+    hinting_factor = hinting_factor_;\n+\n+    error = FT_Set_Char_Size(face, 12 * 64, 0, 72 * (unsigned int)hinting_factor, 72);\n+    if (error) {\n+        throw \"Could not set the fontsize\";\n     }\n \n-    error = FT_Set_Char_Size(face, 12 * 64, 0, 72 * hinting_factor, 72);\n     static FT_Matrix transform = { 65536 / hinting_factor, 0, 0, 65536 };\n     FT_Set_Transform(face, &transform, 0);\n-    if (error)\n-    {\n-        std::ostringstream s;\n-        s << \"Could not set the fontsize for facefile  \" << facefile << std::endl;\n-        throw Py::RuntimeError(s.str());\n-    }\n-\n-    // set some face props as attributes\n-    //small memory leak fixed after 2.1.8\n-    //fields can be null so we have to check this first\n-\n-    const char* ps_name = FT_Get_Postscript_Name(face);\n-    if (ps_name == NULL)\n-    {\n-        ps_name = \"UNAVAILABLE\";\n-    }\n-\n-    const char* family_name = face->family_name;\n-    if (family_name == NULL)\n-    {\n-        family_name = \"UNAVAILABLE\";\n-    }\n-\n-    const char* style_name = face->style_name;\n-    if (style_name == NULL)\n-    {\n-        style_name = \"UNAVAILABLE\";\n-    }\n-\n-    setattro(\"postscript_name\", Py::String(ps_name));\n-    setattro(\"num_faces\",       Py::Int(face->num_faces));\n-    setattro(\"family_name\",     Py::String(family_name));\n-    setattro(\"style_name\",      Py::String(style_name));\n-    setattro(\"face_flags\",      Py::Int(face->face_flags));\n-    setattro(\"style_flags\",     Py::Int(face->style_flags));\n-    setattro(\"num_glyphs\",      Py::Int(face->num_glyphs));\n-    setattro(\"num_fixed_sizes\", Py::Int(face->num_fixed_sizes));\n-    setattro(\"num_charmaps\",    Py::Int(face->num_charmaps));\n-\n-    int scalable = FT_IS_SCALABLE(face);\n-\n-    setattro(\"scalable\", Py::Int(scalable));\n-\n-    if (scalable)\n-    {\n-        setattro(\"units_per_EM\", Py::Int(face->units_per_EM));\n-\n-        Py::Tuple bbox(4);\n-        bbox[0] = Py::Int(face->bbox.xMin);\n-        bbox[1] = Py::Int(face->bbox.yMin);\n-        bbox[2] = Py::Int(face->bbox.xMax);\n-        bbox[3] = Py::Int(face->bbox.yMax);\n-        setattro(\"bbox\",  bbox);\n-        setattro(\"ascender\",            Py::Int(face->ascender));\n-        setattro(\"descender\",           Py::Int(face->descender));\n-        setattro(\"height\",              Py::Int(face->height));\n-        setattro(\"max_advance_width\",   Py::Int(face->max_advance_width));\n-        setattro(\"max_advance_height\",  Py::Int(face->max_advance_height));\n-        setattro(\"underline_position\",  Py::Int(face->underline_position));\n-        setattro(\"underline_thickness\", Py::Int(face->underline_thickness));\n-    }\n-\n-    setattro(\"fname\", args[0]);\n-\n-    _VERBOSE(\"FT2Font::FT2Font done\");\n }\n \n FT2Font::~FT2Font()\n {\n-    _VERBOSE(\"FT2Font::~FT2Font\");\n+    for (size_t i = 0; i < glyphs.size(); i++) {\n+        FT_Done_Glyph(glyphs[i]);\n+    }\n \n     if (face) {\n         FT_Done_Face(face);\n-\n-        for (size_t i = 0; i < glyphs.size(); i++)\n-        {\n-            FT_Done_Glyph(glyphs[i]);\n-        }\n-    }\n-\n-    if (stream.descriptor.pointer != NULL) {\n-        PyMem_Free(stream.descriptor.pointer);\n     }\n }\n \n-int\n-FT2Font::setattro(const Py::String &name, const Py::Object &value)\n-{\n-    _VERBOSE(\"FT2Font::setattr\");\n-    __dict__[name] = value;\n-    return 1;\n-}\n-\n-Py::Object\n-FT2Font::getattro(const Py::String &name)\n-{\n-    _VERBOSE(\"FT2Font::getattr\");\n-    if (__dict__.hasKey(name)) return __dict__[name];\n-    else return genericGetAttro(name);\n-}\n-\n-char FT2Font::clear__doc__[] =\n-    \"clear()\\n\"\n-    \"\\n\"\n-    \"Clear all the glyphs, reset for a new set_text\"\n-    ;\n-\n-Py::Object\n-FT2Font::clear(const Py::Tuple & args)\n+void FT2Font::clear()\n {\n-    _VERBOSE(\"FT2Font::clear\");\n-    args.verify_length(0);\n-\n     angle = 0.0;\n \n     pen.x = 0;\n     pen.y = 0;\n \n-    for (size_t i = 0; i < glyphs.size(); i++)\n-    {\n+    for (size_t i = 0; i < glyphs.size(); i++) {\n         FT_Done_Glyph(glyphs[i]);\n     }\n \n     glyphs.clear();\n-\n-    return Py::Object();\n }\n-PYCXX_VARARGS_METHOD_DECL(FT2Font, clear)\n \n-char FT2Font::set_size__doc__[] =\n-    \"set_size(ptsize, dpi)\\n\"\n-    \"\\n\"\n-    \"Set the point size and dpi of the text.\\n\"\n-    ;\n-\n-Py::Object\n-FT2Font::set_size(const Py::Tuple & args)\n+void FT2Font::set_size(double ptsize, double dpi)\n {\n-    _VERBOSE(\"FT2Font::set_size\");\n-    args.verify_length(2);\n-\n-    double ptsize = Py::Float(args[0]);\n-    double dpi = Py::Float(args[1]);\n-\n-    int error = FT_Set_Char_Size(face, (long)(ptsize * 64), 0,\n-                                 (unsigned int)dpi * hinting_factor,\n-                                 (unsigned int)dpi);\n+    int error = FT_Set_Char_Size(\n+        face, (long)(ptsize * 64), 0, (unsigned int)(dpi * hinting_factor), (unsigned int)dpi);\n     static FT_Matrix transform = { 65536 / hinting_factor, 0, 0, 65536 };\n     FT_Set_Transform(face, &transform, 0);\n \n-    if (error)\n-    {\n-        throw Py::RuntimeError(\"Could not set the fontsize\");\n+    if (error) {\n+        throw \"Could not set the fontsize\";\n     }\n-    return Py::Object();\n }\n-PYCXX_VARARGS_METHOD_DECL(FT2Font, set_size)\n \n-char FT2Font::set_charmap__doc__[] =\n-    \"set_charmap(i)\\n\"\n-    \"\\n\"\n-    \"Make the i-th charmap current\\n\"\n-    ;\n-\n-Py::Object\n-FT2Font::set_charmap(const Py::Tuple & args)\n+void FT2Font::set_charmap(int i)\n {\n-    _VERBOSE(\"FT2Font::set_charmap\");\n-    args.verify_length(1);\n-\n-    int i = Py::Int(args[0]);\n-    if (i >= face->num_charmaps)\n-    {\n-        throw Py::ValueError(\"i exceeds the available number of char maps\");\n+    if (i >= face->num_charmaps) {\n+        throw \"i exceeds the available number of char maps\";\n     }\n     FT_CharMap charmap = face->charmaps[i];\n-    if (FT_Set_Charmap(face, charmap))\n-    {\n-        throw Py::ValueError(\"Could not set the charmap\");\n+    if (FT_Set_Charmap(face, charmap)) {\n+        throw \"Could not set the charmap\";\n     }\n-    return Py::Object();\n }\n-PYCXX_VARARGS_METHOD_DECL(FT2Font, set_charmap)\n \n-char FT2Font::select_charmap__doc__[] =\n-    \"select_charmap(i)\\n\"\n-    \"\\n\"\n-    \"select charmap i where i is one of the FT_Encoding number\\n\"\n-    ;\n-\n-Py::Object\n-FT2Font::select_charmap(const Py::Tuple & args)\n+void FT2Font::select_charmap(unsigned long i)\n {\n-    _VERBOSE(\"FT2Font::set_charmap\");\n-    args.verify_length(1);\n-\n-    unsigned long i = Py::Long(args[0]);\n-    //if (FT_Select_Charmap( face, FT_ENCODING_ADOBE_CUSTOM ))\n-    if (FT_Select_Charmap(face, (FT_Encoding) i))\n-    {\n-        throw Py::ValueError(\"Could not set the charmap\");\n+    if (FT_Select_Charmap(face, (FT_Encoding)i)) {\n+        throw \"Could not set the charmap\";\n     }\n-    return Py::Object();\n }\n-PYCXX_VARARGS_METHOD_DECL(FT2Font, select_charmap)\n \n-FT_BBox\n-FT2Font::compute_string_bbox()\n+FT_BBox FT2Font::compute_string_bbox()\n {\n-    _VERBOSE(\"FT2Font::compute_string_bbox\");\n-\n     FT_BBox bbox;\n     /* initialize string bbox to \"empty\" values */\n     bbox.xMin = bbox.yMin = 32000;\n     bbox.xMax = bbox.yMax = -32000;\n \n     int right_side = 0;\n-    for (size_t n = 0; n < glyphs.size(); n++)\n-    {\n+    for (size_t n = 0; n < glyphs.size(); n++) {\n         FT_BBox glyph_bbox;\n         FT_Glyph_Get_CBox(glyphs[n], ft_glyph_bbox_subpixels, &glyph_bbox);\n-        if (glyph_bbox.xMin < bbox.xMin) bbox.xMin = glyph_bbox.xMin;\n-        if (glyph_bbox.yMin < bbox.yMin) bbox.yMin = glyph_bbox.yMin;\n-        if (glyph_bbox.xMin == glyph_bbox.xMax)\n-        {\n-            right_side += glyphs[n]->advance.x >> 10;\n-            if (right_side > bbox.xMax) bbox.xMax = right_side;\n+        if (glyph_bbox.xMin < bbox.xMin) {\n+            bbox.xMin = glyph_bbox.xMin;\n         }\n-        else\n-        {\n-            if (glyph_bbox.xMax > bbox.xMax) bbox.xMax = glyph_bbox.xMax;\n+        if (glyph_bbox.yMin < bbox.yMin) {\n+            bbox.yMin = glyph_bbox.yMin;\n+        }\n+        if (glyph_bbox.xMin == glyph_bbox.xMax) {\n+            right_side += glyphs[n]->advance.x >> 10;\n+            if (right_side > bbox.xMax) {\n+                bbox.xMax = right_side;\n+            }\n+        } else {\n+            if (glyph_bbox.xMax > bbox.xMax) {\n+                bbox.xMax = glyph_bbox.xMax;\n+            }\n         }\n-        if (glyph_bbox.yMax > bbox.yMax) bbox.yMax = glyph_bbox.yMax;\n+        if (glyph_bbox.yMax > bbox.yMax)\n+            bbox.yMax = glyph_bbox.yMax;\n     }\n     /* check that we really grew the string bbox */\n-    if (bbox.xMin > bbox.xMax)\n-    {\n+    if (bbox.xMin > bbox.xMax) {\n         bbox.xMin = 0;\n         bbox.yMin = 0;\n         bbox.xMax = 0;\n@@ -1154,84 +603,26 @@ FT2Font::compute_string_bbox()\n     return bbox;\n }\n \n-char FT2Font::get_kerning__doc__[] =\n-    \"dx = get_kerning(left, right, mode)\\n\"\n-    \"\\n\"\n-    \"Get the kerning between left char and right glyph indices\\n\"\n-    \"mode is a kerning mode constant\\n\"\n-    \"  KERNING_DEFAULT  - Return scaled and grid-fitted kerning distances\\n\"\n-    \"  KERNING_UNFITTED - Return scaled but un-grid-fitted kerning distances\\n\"\n-    \"  KERNING_UNSCALED - Return the kerning vector in original font units\\n\"\n-    ;\n-Py::Object\n-FT2Font::get_kerning(const Py::Tuple & args)\n+int FT2Font::get_kerning(int left, int right, int mode)\n {\n-    _VERBOSE(\"FT2Font::get_kerning\");\n-    args.verify_length(3);\n-    int left = Py::Int(args[0]);\n-    int right = Py::Int(args[1]);\n-    int mode = Py::Int(args[2]);\n-\n-\n-    if (!FT_HAS_KERNING(face))\n-    {\n-        return Py::Int(0);\n+    if (!FT_HAS_KERNING(face)) {\n+        return 0;\n     }\n     FT_Vector delta;\n \n-    if (!FT_Get_Kerning(face, left, right, mode, &delta))\n-    {\n-        return Py::Int(delta.x / hinting_factor);\n-    }\n-    else\n-    {\n-        return Py::Int(0);\n-\n+    if (!FT_Get_Kerning(face, left, right, mode, &delta)) {\n+        return (int)(delta.x / hinting_factor);\n+    } else {\n+        return 0;\n     }\n }\n-PYCXX_VARARGS_METHOD_DECL(FT2Font, get_kerning)\n \n-\n-char FT2Font::set_text__doc__[] =\n-    \"set_text(s, angle)\\n\"\n-    \"\\n\"\n-    \"Set the text string and angle.\\n\"\n-    \"You must call this before draw_glyphs_to_bitmap\\n\"\n-    \"A sequence of x,y positions is returned\";\n-Py::Object\n-FT2Font::set_text(const Py::Tuple & args, const Py::Dict & kwargs)\n+void FT2Font::set_text(\n+    size_t N, uint32_t *codepoints, double angle, FT_UInt32 flags, std::vector<double> &xys)\n {\n-    _VERBOSE(\"FT2Font::set_text\");\n-    args.verify_length(2);\n-\n-\n-    Py::String text(args[0]);\n-    std::string stdtext = \"\";\n-    Py_UNICODE* pcode = NULL;\n-    size_t N = 0;\n-    if (PyUnicode_Check(text.ptr()))\n-    {\n-        pcode = PyUnicode_AsUnicode(text.ptr());\n-        N = PyUnicode_GetSize(text.ptr());\n-    }\n-    else\n-    {\n-        stdtext = text.as_std_string();\n-        N = stdtext.size();\n-    }\n-\n-\n-    angle = Py::Float(args[1]);\n-\n-    angle = angle / 360.0 * 2 * 3.14159;\n+    angle = angle / 360.0 * 2 * M_PI;\n \n-    long flags = FT_LOAD_FORCE_AUTOHINT;\n-    if (kwargs.hasKey(\"flags\"))\n-    {\n-        flags = Py::Long(kwargs[\"flags\"]);\n-    }\n-\n-    //this computes width and height in subpixels so we have to divide by 64\n+    // this computes width and height in subpixels so we have to divide by 64\n     matrix.xx = (FT_Fixed)(cos(angle) * 0x10000L);\n     matrix.xy = (FT_Fixed)(-sin(angle) * 0x10000L);\n     matrix.yx = (FT_Fixed)(sin(angle) * 0x10000L);\n@@ -1244,36 +635,20 @@ FT2Font::set_text(const Py::Tuple & args, const Py::Dict & kwargs)\n     pen.x = 0;\n     pen.y = 0;\n \n-    Py::Tuple xys(N);\n-    for (unsigned int n = 0; n < N; n++)\n-    {\n+    for (unsigned int n = 0; n < N; n++) {\n         std::string thischar(\"?\");\n         FT_UInt glyph_index;\n \n-\n-        if (pcode == NULL)\n-        {\n-            // plain ol string\n-            thischar = stdtext[n];\n-            glyph_index = FT_Get_Char_Index(face, stdtext[n]);\n-        }\n-        else\n-        {\n-            //unicode\n-            glyph_index = FT_Get_Char_Index(face, pcode[n]);\n-        }\n+        glyph_index = FT_Get_Char_Index(face, codepoints[n]);\n \n         // retrieve kerning distance and move pen position\n-        if (use_kerning && previous && glyph_index)\n-        {\n+        if (use_kerning && previous && glyph_index) {\n             FT_Vector delta;\n-            FT_Get_Kerning(face, previous, glyph_index,\n-                           FT_KERNING_DEFAULT, &delta);\n+            FT_Get_Kerning(face, previous, glyph_index, FT_KERNING_DEFAULT, &delta);\n             pen.x += delta.x / hinting_factor;\n         }\n         error = FT_Load_Glyph(face, glyph_index, flags);\n-        if (error)\n-        {\n+        if (error) {\n             std::cerr << \"\\tcould not load glyph for \" << thischar << std::endl;\n             continue;\n         }\n@@ -1284,1227 +659,172 @@ FT2Font::set_text(const Py::Tuple & args, const Py::Dict & kwargs)\n         FT_Glyph thisGlyph;\n         error = FT_Get_Glyph(face->glyph, &thisGlyph);\n \n-        if (error)\n-        {\n+        if (error) {\n             std::cerr << \"\\tcould not get glyph for \" << thischar << std::endl;\n             continue;\n         }\n         // ignore errors, jump to next glyph\n \n         FT_Glyph_Transform(thisGlyph, 0, &pen);\n-        Py::Tuple xy(2);\n-        xy[0] = Py::Float(pen.x);\n-        xy[1] = Py::Float(pen.y);\n-        xys[n] = xy;\n+        xys.push_back(pen.x);\n+        xys.push_back(pen.y);\n         pen.x += face->glyph->advance.x;\n \n         previous = glyph_index;\n         glyphs.push_back(thisGlyph);\n     }\n \n     // now apply the rotation\n-    for (unsigned int n = 0; n < glyphs.size(); n++)\n-    {\n+    for (unsigned int n = 0; n < glyphs.size(); n++) {\n         FT_Glyph_Transform(glyphs[n], &matrix, 0);\n     }\n-\n-    _VERBOSE(\"FT2Font::set_text done\");\n-    return xys;\n }\n-PYCXX_KEYWORDS_METHOD_DECL(FT2Font, set_text)\n-\n-char FT2Font::get_num_glyphs__doc__[] =\n-    \"get_num_glyphs()\\n\"\n-    \"\\n\"\n-    \"Return the number of loaded glyphs\\n\"\n-    ;\n-Py::Object\n-FT2Font::get_num_glyphs(const Py::Tuple & args)\n-{\n-    _VERBOSE(\"FT2Font::get_num_glyphs\");\n-    args.verify_length(0);\n \n-    return Py::Int((long)glyphs.size());\n-}\n-PYCXX_VARARGS_METHOD_DECL(FT2Font, get_num_glyphs)\n-\n-char FT2Font::load_char__doc__[] =\n-    \"load_char(charcode, flags=LOAD_FORCE_AUTOHINT)\\n\"\n-    \"\\n\"\n-    \"Load character with charcode in current fontfile and set glyph.\\n\"\n-    \"The flags argument can be a bitwise-or of the LOAD_XXX constants.\\n\"\n-    \"Return value is a Glyph object, with attributes\\n\"\n-    \"  width          # glyph width\\n\"\n-    \"  height         # glyph height\\n\"\n-    \"  bbox           # the glyph bbox (xmin, ymin, xmax, ymax)\\n\"\n-    \"  horiBearingX   # left side bearing in horizontal layouts\\n\"\n-    \"  horiBearingY   # top side bearing in horizontal layouts\\n\"\n-    \"  horiAdvance    # advance width for horizontal layout\\n\"\n-    \"  vertBearingX   # left side bearing in vertical layouts\\n\"\n-    \"  vertBearingY   # top side bearing in vertical layouts\\n\"\n-    \"  vertAdvance    # advance height for vertical layout\\n\"\n-    ;\n-Py::Object\n-FT2Font::load_char(const Py::Tuple & args, const Py::Dict & kwargs)\n+void FT2Font::load_char(long charcode, FT_UInt32 flags)\n {\n-    _VERBOSE(\"FT2Font::load_char\");\n-    //load a char using the unsigned long charcode\n-\n-    args.verify_length(1);\n-    long charcode = Py::Long(args[0]), flags = Py::Long(FT_LOAD_FORCE_AUTOHINT);\n-    if (kwargs.hasKey(\"flags\"))\n-    {\n-        flags = Py::Long(kwargs[\"flags\"]);\n-    }\n-\n     int error = FT_Load_Char(face, (unsigned long)charcode, flags);\n \n-    if (error)\n-    {\n-        throw Py::RuntimeError(Printf(\"Could not load charcode %d\", charcode).str());\n+    if (error) {\n+        throw \"Could not load charcode\";\n     }\n \n     FT_Glyph thisGlyph;\n     error = FT_Get_Glyph(face->glyph, &thisGlyph);\n \n-    if (error)\n-    {\n-        throw Py::RuntimeError(Printf(\"Could not get glyph for char %d\", charcode).str());\n+    if (error) {\n+        throw \"Could not get glyph\";\n     }\n \n-    size_t num = glyphs.size();  //the index into the glyphs list\n     glyphs.push_back(thisGlyph);\n-    return Glyph::factory(face, thisGlyph, num, hinting_factor);\n }\n-PYCXX_KEYWORDS_METHOD_DECL(FT2Font, load_char)\n-\n-char FT2Font::load_glyph__doc__[] =\n-    \"load_glyph(glyphindex, flags=LOAD_FORCE_AUTOHINT)\\n\"\n-    \"\\n\"\n-    \"Load character with glyphindex in current fontfile and set glyph.\\n\"\n-    \"The flags argument can be a bitwise-or of the LOAD_XXX constants.\\n\"\n-    \"Return value is a Glyph object, with attributes\\n\"\n-    \"  width          # glyph width\\n\"\n-    \"  height         # glyph height\\n\"\n-    \"  bbox           # the glyph bbox (xmin, ymin, xmax, ymax)\\n\"\n-    \"  horiBearingX   # left side bearing in horizontal layouts\\n\"\n-    \"  horiBearingY   # top side bearing in horizontal layouts\\n\"\n-    \"  horiAdvance    # advance width for horizontal layout\\n\"\n-    \"  vertBearingX   # left side bearing in vertical layouts\\n\"\n-    \"  vertBearingY   # top side bearing in vertical layouts\\n\"\n-    \"  vertAdvance    # advance height for vertical layout\\n\"\n-    ;\n-Py::Object\n-FT2Font::load_glyph(const Py::Tuple & args, const Py::Dict & kwargs)\n-{\n-    _VERBOSE(\"FT2Font::load_glyph\");\n-    //load a char using the unsigned long charcode\n-\n-    args.verify_length(1);\n-    long glyph_index = Py::Long(args[0]), flags = Py::Long(FT_LOAD_FORCE_AUTOHINT);\n-    if (kwargs.hasKey(\"flags\"))\n-    {\n-        flags = Py::Long(kwargs[\"flags\"]);\n-    }\n \n+void FT2Font::load_glyph(FT_UInt glyph_index, FT_UInt32 flags)\n+{\n     int error = FT_Load_Glyph(face, glyph_index, flags);\n \n-    if (error)\n-    {\n-        throw Py::RuntimeError(Printf(\"Could not load glyph index %d\", glyph_index).str());\n+    if (error) {\n+        throw \"Could not load glyph\";\n     }\n \n     FT_Glyph thisGlyph;\n     error = FT_Get_Glyph(face->glyph, &thisGlyph);\n \n-    if (error)\n-    {\n-        throw Py::RuntimeError(Printf(\"Could not get glyph for glyph index %d\", glyph_index).str());\n+    if (error) {\n+        throw \"Could not load glyph\";\n     }\n \n-    size_t num = glyphs.size();  //the index into the glyphs list\n     glyphs.push_back(thisGlyph);\n-    return Glyph::factory(face, thisGlyph, num, hinting_factor);\n }\n-PYCXX_KEYWORDS_METHOD_DECL(FT2Font, load_glyph)\n-\n-char FT2Font::get_width_height__doc__[] =\n-    \"w, h = get_width_height()\\n\"\n-    \"\\n\"\n-    \"Get the width and height in 26.6 subpixels of the current string set by set_text\\n\"\n-    \"The rotation of the string is accounted for.  To get width and height\\n\"\n-    \"in pixels, divide these values by 64\\n\"\n-    ;\n-Py::Object\n-FT2Font::get_width_height(const Py::Tuple & args)\n-{\n-    _VERBOSE(\"FT2Font::get_width_height\");\n-    args.verify_length(0);\n \n+void FT2Font::get_width_height(long *width, long *height)\n+{\n     FT_BBox bbox = compute_string_bbox();\n \n-    Py::Tuple ret(2);\n-    ret[0] = Py::Int(bbox.xMax - bbox.xMin);\n-    ret[1] = Py::Int(bbox.yMax - bbox.yMin);\n-    return ret;\n+    *width = bbox.xMax - bbox.xMin;\n+    *height = bbox.yMax - bbox.yMin;\n }\n-PYCXX_VARARGS_METHOD_DECL(FT2Font, get_width_height)\n-\n-char FT2Font::get_descent__doc__[] =\n-    \"d = get_descent()\\n\"\n-    \"\\n\"\n-    \"Get the descent of the current string set by set_text in 26.6 subpixels.\\n\"\n-    \"The rotation of the string is accounted for.  To get the descent\\n\"\n-    \"in pixels, divide this value by 64.\\n\"\n-    ;\n-Py::Object\n-FT2Font::get_descent(const Py::Tuple & args)\n-{\n-    _VERBOSE(\"FT2Font::get_descent\");\n-    args.verify_length(0);\n \n+long FT2Font::get_descent()\n+{\n     FT_BBox bbox = compute_string_bbox();\n-    return Py::Int(- bbox.yMin);;\n+    return -bbox.yMin;\n }\n-PYCXX_VARARGS_METHOD_DECL(FT2Font, get_descent)\n-\n-char FT2Font::draw_glyphs_to_bitmap__doc__[] =\n-    \"draw_glyphs_to_bitmap()\\n\"\n-    \"\\n\"\n-    \"Draw the glyphs that were loaded by set_text to the bitmap\\n\"\n-    \"The bitmap size will be automatically set to include the glyphs\\n\"\n-    ;\n-Py::Object\n-FT2Font::draw_glyphs_to_bitmap(const Py::Tuple &args, const Py::Dict &kwargs)\n-{\n-\n-    _VERBOSE(\"FT2Font::draw_glyphs_to_bitmap\");\n-    args.verify_length(0);\n-\n-    long antialiased = 1;\n-    if (kwargs.hasKey(\"antialiased\"))\n-    {\n-        antialiased = Py::Long(kwargs[\"antialiased\"]);\n-    }\n \n+void FT2Font::draw_glyphs_to_bitmap(bool antialiased)\n+{\n     FT_BBox string_bbox = compute_string_bbox();\n     size_t width = (string_bbox.xMax - string_bbox.xMin) / 64 + 2;\n     size_t height = (string_bbox.yMax - string_bbox.yMin) / 64 + 2;\n \n-    image = FT2Image::factory(width, height);\n-    FT2Image* image_cxx = Py::PythonClassObject<FT2Image>(image).getCxxObject();\n+    image.resize(width, height);\n \n-    for (size_t n = 0; n < glyphs.size(); n++)\n-    {\n+    for (size_t n = 0; n < glyphs.size(); n++) {\n         FT_BBox bbox;\n         FT_Glyph_Get_CBox(glyphs[n], ft_glyph_bbox_pixels, &bbox);\n \n         error = FT_Glyph_To_Bitmap(\n-            &glyphs[n],\n-            antialiased ? FT_RENDER_MODE_NORMAL : FT_RENDER_MODE_MONO,\n-            0,\n-            1);\n-        if (error)\n-        {\n-            throw Py::RuntimeError(\"Could not convert glyph to bitmap\");\n+            &glyphs[n], antialiased ? FT_RENDER_MODE_NORMAL : FT_RENDER_MODE_MONO, 0, 1);\n+        if (error) {\n+            throw \"Could not convert glyph to bitmap\";\n         }\n \n         FT_BitmapGlyph bitmap = (FT_BitmapGlyph)glyphs[n];\n         // now, draw to our target surface (convert position)\n \n-        //bitmap left and top in pixel, string bbox in subpixel\n+        // bitmap left and top in pixel, string bbox in subpixel\n         FT_Int x = (FT_Int)(bitmap->left - (string_bbox.xMin / 64.));\n         FT_Int y = (FT_Int)((string_bbox.yMax / 64.) - bitmap->top + 1);\n \n-        image_cxx->draw_bitmap(&bitmap->bitmap, x, y);\n+        image.draw_bitmap(&bitmap->bitmap, x, y);\n     }\n-\n-    return Py::Object();\n }\n-PYCXX_KEYWORDS_METHOD_DECL(FT2Font, draw_glyphs_to_bitmap)\n-\n-char FT2Font::get_xys__doc__[] =\n-    \"get_xys()\\n\"\n-    \"\\n\"\n-    \"Get the xy locations of the current glyphs\\n\"\n-    ;\n-Py::Object\n-FT2Font::get_xys(const Py::Tuple &args, const Py::Dict &kwargs)\n-{\n-    _VERBOSE(\"FT2Font::get_xys\");\n-    args.verify_length(0);\n-\n-    long antialiased = 1;\n-    if (kwargs.hasKey(\"antialiased\"))\n-    {\n-        antialiased = Py::Long(kwargs[\"antialiased\"]);\n-    }\n \n+void FT2Font::get_xys(bool antialiased, std::vector<double> &xys)\n+{\n     FT_BBox string_bbox = compute_string_bbox();\n-    Py::Tuple xys(glyphs.size());\n \n-    for (size_t n = 0; n < glyphs.size(); n++)\n-    {\n+    for (size_t n = 0; n < glyphs.size(); n++) {\n \n         FT_BBox bbox;\n         FT_Glyph_Get_CBox(glyphs[n], ft_glyph_bbox_pixels, &bbox);\n \n         error = FT_Glyph_To_Bitmap(\n-            &glyphs[n],\n-            antialiased ? FT_RENDER_MODE_NORMAL : FT_RENDER_MODE_MONO,\n-            0,\n-            1);\n-        if (error)\n-        {\n-            throw Py::RuntimeError(\"Could not convert glyph to bitmap\");\n+            &glyphs[n], antialiased ? FT_RENDER_MODE_NORMAL : FT_RENDER_MODE_MONO, 0, 1);\n+        if (error) {\n+            throw \"Could not convert glyph to bitmap\";\n         }\n \n         FT_BitmapGlyph bitmap = (FT_BitmapGlyph)glyphs[n];\n \n-\n-        //bitmap left and top in pixel, string bbox in subpixel\n+        // bitmap left and top in pixel, string bbox in subpixel\n         FT_Int x = (FT_Int)(bitmap->left - string_bbox.xMin / 64.);\n         FT_Int y = (FT_Int)(string_bbox.yMax / 64. - bitmap->top + 1);\n-        //make sure the index is non-neg\n+        // make sure the index is non-neg\n         x = x < 0 ? 0 : x;\n         y = y < 0 ? 0 : y;\n-        Py::Tuple xy(2);\n-        xy[0] = Py::Float(x);\n-        xy[1] = Py::Float(y);\n-        xys[n] = xy;\n+        xys.push_back(x);\n+        xys.push_back(y);\n     }\n-\n-    return xys;\n }\n-PYCXX_KEYWORDS_METHOD_DECL(FT2Font, get_xys)\n-\n-char FT2Font::draw_glyph_to_bitmap__doc__[] =\n-    \"draw_glyph_to_bitmap(bitmap, x, y, glyph)\\n\"\n-    \"\\n\"\n-    \"Draw a single glyph to the bitmap at pixel locations x,y\\n\"\n-    \"Note it is your responsibility to set up the bitmap manually\\n\"\n-    \"with set_bitmap_size(w,h) before this call is made.\\n\"\n-    \"\\n\"\n-    \"If you want automatic layout, use set_text in combinations with\\n\"\n-    \"draw_glyphs_to_bitmap.  This function is intended for people who\\n\"\n-    \"want to render individual glyphs at precise locations, eg, a\\n\"\n-    \"a glyph returned by load_char\\n\";\n-\n-Py::Object\n-FT2Font::draw_glyph_to_bitmap(const Py::Tuple &args, const Py::Dict &kwargs)\n-{\n-    _VERBOSE(\"FT2Font::draw_glyph_to_bitmap\");\n-    args.verify_length(4);\n \n-    FT2Image* im = Py::PythonClassObject<FT2Image>(args[0]).getCxxObject();\n-\n-    double xd = Py::Float(args[1]);\n-    double yd = Py::Float(args[2]);\n-    long x = (long)xd;\n-    long y = (long)yd;\n+void FT2Font::draw_glyph_to_bitmap(FT2Image &im, int x, int y, size_t glyphInd, bool antialiased)\n+{\n     FT_Vector sub_offset;\n     sub_offset.x = 0; // int((xd - (double)x) * 64.0);\n     sub_offset.y = 0; // int((yd - (double)y) * 64.0);\n \n-    Glyph* glyph = Py::PythonClassObject<Glyph>(args[3]).getCxxObject();\n-\n-    long antialiased = 1;\n-    if (kwargs.hasKey(\"antialiased\"))\n-    {\n-        antialiased = Py::Long(kwargs[\"antialiased\"]);\n-    }\n-\n-    if (glyph->glyphInd >= glyphs.size())\n-    {\n-        throw Py::ValueError(\"glyph num is out of range\");\n+    if (glyphInd >= glyphs.size()) {\n+        throw \"glyph num is out of range\";\n     }\n \n-    error = FT_Glyph_To_Bitmap(\n-        &glyphs[glyph->glyphInd],\n-        antialiased ? FT_RENDER_MODE_NORMAL : FT_RENDER_MODE_MONO,\n-        &sub_offset,  // additional translation\n-        1   //destroy image\n-        );\n-    if (error)\n-    {\n-        throw Py::RuntimeError(\"Could not convert glyph to bitmap\");\n+    error = FT_Glyph_To_Bitmap(&glyphs[glyphInd],\n+                               antialiased ? FT_RENDER_MODE_NORMAL : FT_RENDER_MODE_MONO,\n+                               &sub_offset, // additional translation\n+                               1 // destroy image\n+                               );\n+    if (error) {\n+        throw \"Could not convert glyph to bitmap\";\n     }\n \n-    FT_BitmapGlyph bitmap = (FT_BitmapGlyph)glyphs[glyph->glyphInd];\n+    FT_BitmapGlyph bitmap = (FT_BitmapGlyph)glyphs[glyphInd];\n \n-    im->draw_bitmap(&bitmap->bitmap, x + bitmap->left, y);\n-    return Py::Object();\n+    im.draw_bitmap(&bitmap->bitmap, x + bitmap->left, y);\n }\n-PYCXX_KEYWORDS_METHOD_DECL(FT2Font, draw_glyph_to_bitmap)\n-\n-char FT2Font::get_glyph_name__doc__[] =\n-    \"get_glyph_name(index)\\n\"\n-    \"\\n\"\n-    \"Retrieves the ASCII name of a given glyph in a face.\\n\"\n-    ;\n-Py::Object\n-FT2Font::get_glyph_name(const Py::Tuple & args)\n-{\n-    _VERBOSE(\"FT2Font::get_glyph_name\");\n-    args.verify_length(1);\n-\n-    char buffer[128];\n-    FT_UInt glyph_number = (FT_UInt)(unsigned long long)Py::Int(args[0]);\n \n-    if (!FT_HAS_GLYPH_NAMES(face))\n-    {\n+void FT2Font::get_glyph_name(unsigned int glyph_number, char *buffer)\n+{\n+    if (!FT_HAS_GLYPH_NAMES(face)) {\n         /* Note that this generated name must match the name that\n            is generated by ttconv in ttfont_CharStrings_getname. */\n         PyOS_snprintf(buffer, 128, \"uni%08x\", glyph_number);\n     } else {\n-        if (FT_Get_Glyph_Name(face, glyph_number, buffer, 128))\n-        {\n-            throw Py::RuntimeError(\"Could not get glyph names.\");\n-        }\n-     }\n-\n-    return Py::String(buffer);\n-}\n-PYCXX_VARARGS_METHOD_DECL(FT2Font, get_glyph_name)\n-\n-char FT2Font::get_charmap__doc__[] =\n-    \"get_charmap()\\n\"\n-    \"\\n\"\n-    \"Returns a dictionary that maps the character codes of the selected charmap\\n\"\n-    \"(Unicode by default) to their corresponding glyph indices.\\n\"\n-    ;\n-Py::Object\n-FT2Font::get_charmap(const Py::Tuple & args)\n-{\n-    _VERBOSE(\"FT2Font::get_charmap\");\n-    args.verify_length(0);\n-\n-    FT_UInt index;\n-    Py::Dict charmap;\n-\n-    //std::cout << \"asd\" << face->charmaps[1]->encoding << std::endl;\n-    FT_ULong code = FT_Get_First_Char(face, &index);\n-    while (index != 0)\n-    {\n-        charmap[Py::Long((long) code)] = Py::Int((int) index);\n-        code = FT_Get_Next_Char(face, code, &index);\n-    }\n-    return charmap;\n-}\n-PYCXX_VARARGS_METHOD_DECL(FT2Font, get_charmap)\n-\n-// ID        Platform       Encoding\n-// 0         Unicode        Reserved (set to 0)\n-// 1         Macintoch      The Script Manager code\n-// 2         ISO            ISO encoding\n-// 3         Microsoft      Microsoft encoding\n-// 240-255   User-defined   Reserved for all nonregistered platforms\n-\n-// Code      ISO encoding scheme\n-// 0         7-bit ASCII\n-// 1         ISO 10646\n-// 2         ISO 8859-1\n-\n-// Code      Language       Code      Language       Code\n-// 0         English        10        Hebrew         20        Urdu\n-// 1         French         11        Japanese       21        Hindi\n-// 2         German         12        Arabic         22        Thai\n-// 3         Italian        13        Finnish\n-// 4         Dutch          14        Greek\n-// 5         Swedish        15        Icelandic\n-// 6         Spanish        16        Maltese\n-// 7         Danish         17        Turkish\n-// 8         Portuguese     18        Yugoslavian\n-// 9         Norwegian      19        Chinese\n-\n-// Code      Meaning        Description\n-// 0         Copyright notice     e.g. \"Copyright Apple Computer, Inc. 1992\n-// 1         Font family name     e.g. \"New York\"\n-// 2         Font style           e.g. \"Bold\"\n-// 3         Font identification  e.g. \"Apple Computer New York Bold Ver 1\"\n-// 4         Full font name       e.g. \"New York Bold\"\n-// 5         Version string       e.g. \"August 10, 1991, 1.08d21\"\n-// 6         Postscript name      e.g. \"Times-Bold\"\n-// 7         Trademark\n-// 8         Designer             e.g. \"Apple Computer\"\n-\n-char FT2Font::get_sfnt__doc__[] =\n-    \"get_sfnt(name)\\n\"\n-    \"\\n\"\n-    \"Get all values from the SFNT names table.  Result is a dictionary whose\"\n-    \"key is the platform-ID, ISO-encoding-scheme, language-code, and\"\n-    \"description.\\n\"\n-    /*\n-      \"The font name identifier codes are:\\n\"\n-      \"\\n\"\n-      \"  0    Copyright notice     e.g. Copyright Apple Computer, Inc. 1992\\n\"\n-      \"  1    Font family name     e.g. New York\\n\"\n-      \"  2    Font style           e.g. Bold\\n\"\n-      \"  3    Font identification  e.g. Apple Computer New York Bold Ver 1\\n\"\n-      \"  4    Full font name       e.g. New York Bold\\n\"\n-      \"  5    Version string       e.g. August 10, 1991, 1.08d21\\n\"\n-      \"  6    Postscript name      e.g. Times-Bold\\n\"\n-      \"  7    Trademark            \\n\"\n-      \"  8    Designer             e.g. Apple Computer\\n\"\n-      \"  11   URL                  e.g. http://www.apple.com\\n\"\n-      \"  13   Copyright license    \\n\"\n-    */\n-    ;\n-Py::Object\n-FT2Font::get_sfnt(const Py::Tuple & args)\n-{\n-    _VERBOSE(\"FT2Font::get_sfnt\");\n-    args.verify_length(0);\n-\n-    if (!(face->face_flags & FT_FACE_FLAG_SFNT))\n-    {\n-        throw Py::RuntimeError(\"No SFNT name table\");\n-    }\n-\n-    size_t count = FT_Get_Sfnt_Name_Count(face);\n-\n-    Py::Dict names;\n-    for (size_t j = 0; j < count; j++)\n-    {\n-        FT_SfntName sfnt;\n-        FT_Error error = FT_Get_Sfnt_Name(face, j, &sfnt);\n-\n-        if (error)\n-        {\n-            throw Py::RuntimeError(\"Could not get SFNT name\");\n-        }\n-\n-        Py::Tuple key(4);\n-        key[0] = Py::Int(sfnt.platform_id);\n-        key[1] = Py::Int(sfnt.encoding_id);\n-        key[2] = Py::Int(sfnt.language_id);\n-        key[3] = Py::Int(sfnt.name_id);\n-\n-        names[key] = Py::asObject\n-            (PyBytes_FromStringAndSize(\n-                (const char *)sfnt.string, sfnt.string_len));\n-    }\n-    return names;\n-}\n-PYCXX_VARARGS_METHOD_DECL(FT2Font, get_sfnt)\n-\n-char FT2Font::get_name_index__doc__[] =\n-    \"get_name_index(name)\\n\"\n-    \"\\n\"\n-    \"Returns the glyph index of a given glyph name.\\n\"\n-    \"The glyph index 0 means `undefined character code'.\\n\"\n-    ;\n-Py::Object\n-FT2Font::get_name_index(const Py::Tuple & args)\n-{\n-    _VERBOSE(\"FT2Font::get_name_index\");\n-    args.verify_length(1);\n-    std::string glyphname = Py::String(args[0]).encode(\"ascii\");\n-\n-    return Py::Long((long)\n-                    FT_Get_Name_Index(face, (FT_String *) glyphname.c_str()));\n-}\n-PYCXX_VARARGS_METHOD_DECL(FT2Font, get_name_index)\n-\n-char FT2Font::get_ps_font_info__doc__[] =\n-    \"get_ps_font_info()\\n\"\n-    \"\\n\"\n-    \"Return the information in the PS Font Info structure.\\n\"\n-    ;\n-Py::Object\n-FT2Font::get_ps_font_info(const Py::Tuple & args)\n-{\n-    _VERBOSE(\"FT2Font::get_ps_font_info\");\n-    args.verify_length(0);\n-    PS_FontInfoRec fontinfo;\n-\n-    FT_Error error = FT_Get_PS_Font_Info(face, &fontinfo);\n-    if (error)\n-    {\n-        Py::RuntimeError(\"Could not get PS font info\");\n-        return Py::Object();\n-    }\n-\n-    Py::Tuple info(9);\n-    info[0] = Py::String(fontinfo.version ? fontinfo.version : \"\");\n-    info[1] = Py::String(fontinfo.notice ? fontinfo.notice : \"\");\n-    info[2] = Py::String(fontinfo.full_name ? fontinfo.full_name : \"\");\n-    info[3] = Py::String(fontinfo.family_name ? fontinfo.family_name : \"\");\n-    info[4] = Py::String(fontinfo.weight ? fontinfo.weight : \"\");\n-    info[5] = Py::Long(fontinfo.italic_angle);\n-    info[6] = Py::Int(fontinfo.is_fixed_pitch);\n-    info[7] = Py::Int(fontinfo.underline_position);\n-    info[8] = Py::Int(fontinfo.underline_thickness);\n-    return info;\n-}\n-PYCXX_VARARGS_METHOD_DECL(FT2Font, get_ps_font_info)\n-\n-char FT2Font::get_sfnt_table__doc__[] =\n-    \"get_sfnt_table(name)\\n\"\n-    \"\\n\"\n-    \"Return one of the following SFNT tables: head, maxp, OS/2, hhea, \"\n-    \"vhea, post, or pclt.\\n\"\n-    ;\n-Py::Object\n-FT2Font::get_sfnt_table(const Py::Tuple & args)\n-{\n-    _VERBOSE(\"FT2Font::get_sfnt_table\");\n-    args.verify_length(1);\n-    std::string tagname = Py::String(args[0]).encode(\"ascii\");\n-\n-    int tag;\n-    const char *tags[] = {\"head\", \"maxp\", \"OS/2\", \"hhea\",\n-                          \"vhea\", \"post\", \"pclt\",  NULL\n-                         };\n-\n-    for (tag = 0; tags[tag] != NULL; tag++)\n-    {\n-        if (strcmp(tagname.c_str(), tags[tag]) == 0)\n-        {\n-            break;\n-        }\n-    }\n-\n-    void *table = FT_Get_Sfnt_Table(face, (FT_Sfnt_Tag) tag);\n-    if (!table)\n-    {\n-        return Py::Object();\n-    }\n-\n-    switch (tag)\n-    {\n-    case 0:\n-        {\n-            char head_dict[] = \"{s:(h,h), s:(h,h), s:l, s:l, s:i, s:i,\"\n-                \"s:(l,l), s:(l,l), s:h, s:h, s:h, s:h, s:i, s:i, s:h, s:h, s:h}\";\n-            TT_Header *t = (TT_Header *)table;\n-            return Py::asObject(Py_BuildValue(head_dict,\n-                                              \"version\",\n-                                              FIXED_MAJOR(t->Table_Version),\n-                                              FIXED_MINOR(t->Table_Version),\n-                                              \"fontRevision\",\n-                                              FIXED_MAJOR(t->Font_Revision),\n-                                              FIXED_MINOR(t->Font_Revision),\n-                                              \"checkSumAdjustment\", t->CheckSum_Adjust,\n-                                              \"magicNumber\" ,       t->Magic_Number,\n-                                              \"flags\", (unsigned)t->Flags,\n-                                              \"unitsPerEm\", (unsigned)t->Units_Per_EM,\n-                                              \"created\",            t->Created[0], t->Created[1],\n-                                              \"modified\",           t->Modified[0], t->Modified[1],\n-                                              \"xMin\",               t->xMin,\n-                                              \"yMin\",               t->yMin,\n-                                              \"xMax\",               t->xMax,\n-                                              \"yMax\",               t->yMax,\n-                                              \"macStyle\", (unsigned)t->Mac_Style,\n-                                              \"lowestRecPPEM\", (unsigned)t->Lowest_Rec_PPEM,\n-                                              \"fontDirectionHint\",  t->Font_Direction,\n-                                              \"indexToLocFormat\",   t->Index_To_Loc_Format,\n-                                              \"glyphDataFormat\",    t->Glyph_Data_Format));\n-        }\n-    case 1:\n-        {\n-            char maxp_dict[] = \"{s:(h,h), s:i, s:i, s:i, s:i, s:i, s:i,\"\n-                \"s:i, s:i, s:i, s:i, s:i, s:i, s:i, s:i}\";\n-            TT_MaxProfile *t = (TT_MaxProfile *)table;\n-            return Py::asObject(Py_BuildValue(maxp_dict,\n-                                              \"version\",\n-                                              FIXED_MAJOR(t->version),\n-                                              FIXED_MINOR(t->version),\n-                                              \"numGlyphs\", (unsigned)t->numGlyphs,\n-                                              \"maxPoints\", (unsigned)t->maxPoints,\n-                                              \"maxContours\", (unsigned)t->maxContours,\n-                                              \"maxComponentPoints\",\n-                                              (unsigned)t->maxCompositePoints,\n-                                              \"maxComponentContours\",\n-                                              (unsigned)t->maxCompositeContours,\n-                                              \"maxZones\", (unsigned)t->maxZones,\n-                                              \"maxTwilightPoints\", (unsigned)t->maxTwilightPoints,\n-                                              \"maxStorage\", (unsigned)t->maxStorage,\n-                                              \"maxFunctionDefs\", (unsigned)t->maxFunctionDefs,\n-                                              \"maxInstructionDefs\",\n-                                              (unsigned)t->maxInstructionDefs,\n-                                              \"maxStackElements\", (unsigned)t->maxStackElements,\n-                                              \"maxSizeOfInstructions\",\n-                                              (unsigned)t->maxSizeOfInstructions,\n-                                              \"maxComponentElements\",\n-                                              (unsigned)t->maxComponentElements,\n-                                              \"maxComponentDepth\",\n-                                              (unsigned)t->maxComponentDepth));\n-        }\n-    case 2:\n-        {\n-            #if PY3K\n-            char os_2_dict[] = \"{s:h, s:h, s:h, s:h, s:h, s:h, s:h, s:h,\"\n-                \"s:h, s:h, s:h, s:h, s:h, s:h, s:h, s:h, s:y#, s:(llll),\"\n-                \"s:y#, s:h, s:h, s:h}\";\n-            #else\n-            char os_2_dict[] = \"{s:h, s:h, s:h, s:h, s:h, s:h, s:h, s:h,\"\n-                \"s:h, s:h, s:h, s:h, s:h, s:h, s:h, s:h, s:s#, s:(llll),\"\n-                \"s:s#, s:h, s:h, s:h}\";\n-            #endif\n-            TT_OS2 *t = (TT_OS2 *)table;\n-            return Py::asObject(Py_BuildValue(os_2_dict,\n-                                              \"version\", (unsigned)t->version,\n-                                              \"xAvgCharWidth\",      t->xAvgCharWidth,\n-                                              \"usWeightClass\", (unsigned)t->usWeightClass,\n-                                              \"usWidthClass\", (unsigned)t->usWidthClass,\n-                                              \"fsType\",             t->fsType,\n-                                              \"ySubscriptXSize\",    t->ySubscriptXSize,\n-                                              \"ySubscriptYSize\",    t->ySubscriptYSize,\n-                                              \"ySubscriptXOffset\",  t->ySubscriptXOffset,\n-                                              \"ySubscriptYOffset\",  t->ySubscriptYOffset,\n-                                              \"ySuperscriptXSize\",  t->ySuperscriptXSize,\n-                                              \"ySuperscriptYSize\",  t->ySuperscriptYSize,\n-                                              \"ySuperscriptXOffset\", t->ySuperscriptXOffset,\n-                                              \"ySuperscriptYOffset\", t->ySuperscriptYOffset,\n-                                              \"yStrikeoutSize\",     t->yStrikeoutSize,\n-                                              \"yStrikeoutPosition\", t->yStrikeoutPosition,\n-                                              \"sFamilyClass\",       t->sFamilyClass,\n-                                              \"panose\",             t->panose, 10,\n-                                              \"ulCharRange\",\n-                                              (unsigned long) t->ulUnicodeRange1,\n-                                              (unsigned long) t->ulUnicodeRange2,\n-                                              (unsigned long) t->ulUnicodeRange3,\n-                                              (unsigned long) t->ulUnicodeRange4,\n-                                              \"achVendID\",          t->achVendID, 4,\n-                                              \"fsSelection\", (unsigned)t->fsSelection,\n-                                              \"fsFirstCharIndex\", (unsigned)t->usFirstCharIndex,\n-                                              \"fsLastCharIndex\", (unsigned)t->usLastCharIndex));\n-        }\n-    case 3:\n-        {\n-            char hhea_dict[] = \"{s:(h,h), s:h, s:h, s:h, s:i, s:h, s:h, s:h,\"\n-                \"s:h, s:h, s:h, s:h, s:i}\";\n-            TT_HoriHeader *t = (TT_HoriHeader *)table;\n-            return Py::asObject(Py_BuildValue(hhea_dict,\n-                                              \"version\",\n-                                              FIXED_MAJOR(t->Version),\n-                                              FIXED_MINOR(t->Version),\n-                                              \"ascent\",             t->Ascender,\n-                                              \"descent\",            t->Descender,\n-                                              \"lineGap\",            t->Line_Gap,\n-                                              \"advanceWidthMax\", (unsigned)t->advance_Width_Max,\n-                                              \"minLeftBearing\",     t->min_Left_Side_Bearing,\n-                                              \"minRightBearing\",    t->min_Right_Side_Bearing,\n-                                              \"xMaxExtent\",         t->xMax_Extent,\n-                                              \"caretSlopeRise\",     t->caret_Slope_Rise,\n-                                              \"caretSlopeRun\",      t->caret_Slope_Run,\n-                                              \"caretOffset\",        t->caret_Offset,\n-                                              \"metricDataFormat\",   t->metric_Data_Format,\n-                                              \"numOfLongHorMetrics\",\n-                                              (unsigned)t->number_Of_HMetrics));\n-        }\n-    case 4:\n-        {\n-            char vhea_dict[] = \"{s:(h,h), s:h, s:h, s:h, s:i, s:h, s:h, s:h,\"\n-                \"s:h, s:h, s:h, s:h, s:i}\";\n-            TT_VertHeader *t = (TT_VertHeader *)table;\n-            return Py::asObject(Py_BuildValue(vhea_dict,\n-                                              \"version\",\n-                                              FIXED_MAJOR(t->Version),\n-                                              FIXED_MINOR(t->Version),\n-                                              \"vertTypoAscender\",   t->Ascender,\n-                                              \"vertTypoDescender\",  t->Descender,\n-                                              \"vertTypoLineGap\",    t->Line_Gap,\n-                                              \"advanceHeightMax\", (unsigned)t->advance_Height_Max,\n-                                              \"minTopSideBearing\",  t->min_Top_Side_Bearing,\n-                                              \"minBottomSizeBearing\", t->min_Bottom_Side_Bearing,\n-                                              \"yMaxExtent\",         t->yMax_Extent,\n-                                              \"caretSlopeRise\",     t->caret_Slope_Rise,\n-                                              \"caretSlopeRun\",      t->caret_Slope_Run,\n-                                              \"caretOffset\",        t->caret_Offset,\n-                                              \"metricDataFormat\",   t->metric_Data_Format,\n-                                              \"numOfLongVerMetrics\",\n-                                              (unsigned)t->number_Of_VMetrics));\n-        }\n-    case 5:\n-        {\n-            TT_Postscript *t = (TT_Postscript *)table;\n-            Py::Dict post;\n-            Py::Tuple format(2), angle(2);\n-            format[0] = Py::Int(FIXED_MAJOR(t->FormatType));\n-            format[1] = Py::Int(FIXED_MINOR(t->FormatType));\n-            post[\"format\"]             = format;\n-            angle[0]  = Py::Int(FIXED_MAJOR(t->italicAngle));\n-            angle[1]  = Py::Int(FIXED_MINOR(t->italicAngle));\n-            post[\"italicAngle\"]        = angle;\n-            post[\"underlinePosition\"]  = Py::Int(t->underlinePosition);\n-            post[\"underlineThickness\"] = Py::Int(t->underlineThickness);\n-            post[\"isFixedPitch\"]       = Py::Long((long) t->isFixedPitch);\n-            post[\"minMemType42\"]       = Py::Long((long) t->minMemType42);\n-            post[\"maxMemType42\"]       = Py::Long((long) t->maxMemType42);\n-            post[\"minMemType1\"]        = Py::Long((long) t->minMemType1);\n-            post[\"maxMemType1\"]        = Py::Long((long) t->maxMemType1);\n-            return post;\n-        }\n-    case 6:\n-        {\n-            TT_PCLT *t = (TT_PCLT *)table;\n-            Py::Dict pclt;\n-            Py::Tuple version(2);\n-            version[0] = Py::Int(FIXED_MAJOR(t->Version));\n-            version[1] = Py::Int(FIXED_MINOR(t->Version));\n-            pclt[\"version\"]            = version;\n-            pclt[\"fontNumber\"]         = Py::Long((long) t->FontNumber);\n-            pclt[\"pitch\"]              = Py::Int((short) t->Pitch);\n-            pclt[\"xHeight\"]            = Py::Int((short) t->xHeight);\n-            pclt[\"style\"]              = Py::Int((short) t->Style);\n-            pclt[\"typeFamily\"]         = Py::Int((short) t->TypeFamily);\n-            pclt[\"capHeight\"]          = Py::Int((short) t->CapHeight);\n-            pclt[\"symbolSet\"]          = Py::Int((short) t->SymbolSet);\n-            #if PY3K\n-            pclt[\"typeFace\"]           = Py::String((char *) t->TypeFace, 16, \"latin-1\");\n-            pclt[\"characterComplement\"] = Py::Bytes((char *) t->CharacterComplement, 8);\n-            #else\n-            pclt[\"typeFace\"]           = Py::String((char *) t->TypeFace, 16);\n-            pclt[\"characterComplement\"] = Py::String((char *) t->CharacterComplement, 8);\n-            #endif\n-            // pclt[\"filename\"]           = Py::String((char *) t->FileName, 6);\n-            pclt[\"strokeWeight\"]       = Py::Int((int) t->StrokeWeight);\n-            pclt[\"widthType\"]          = Py::Int((int) t->WidthType);\n-            pclt[\"serifStyle\"]         = Py::Int((int) t->SerifStyle);\n-            return pclt;\n-        }\n-    default:\n-        return Py::Object();\n-    }\n-}\n-PYCXX_VARARGS_METHOD_DECL(FT2Font, get_sfnt_table)\n-\n-char FT2Font::get_image__doc__ [] =\n-    \"get_image()\\n\"\n-    \"\\n\"\n-    \"Returns the underlying image buffer for this font object.\\n\";\n-Py::Object\n-FT2Font::get_image(const Py::Tuple &args)\n-{\n-    args.verify_length(0);\n-    if (!image.isNone())\n-    {\n-        return image;\n-    }\n-    throw Py::RuntimeError(\"You must call .set_text() before .get_image()\");\n-}\n-PYCXX_VARARGS_METHOD_DECL(FT2Font, get_image)\n-\n-char FT2Font::attach_file__doc__ [] =\n-    \"attach_file(filename)\\n\"\n-    \"\\n\"\n-    \"Attach a file with extra information on the font\\n\"\n-    \"(in practice, an AFM file with the metrics of a Type 1 font).\\n\"\n-    \"Throws an exception if unsuccessful.\\n\";\n-Py::Object\n-FT2Font::attach_file(const Py::Tuple &args)\n-{\n-    FT_Open_Args open_args;\n-\n-    args.verify_length(1);\n-\n-    std::string filename = Py::String(args[0]).encode(\"utf-8\");\n-\n-    if (make_open_args(args[0].ptr(), &open_args))\n-    {\n-        /* make_open_args sets the Python exception for us. */\n-        throw Py::Exception();\n-    }\n-\n-    FT_Error error = FT_Attach_Stream(face, &open_args);\n-\n-    if (error)\n-    {\n-        std::ostringstream s;\n-        s << \"Could not attach file \" << filename\n-        << \" (freetype error code \" << error << \")\" << std::endl;\n-        throw Py::RuntimeError(s.str());\n-    }\n-    return Py::Object();\n-}\n-PYCXX_VARARGS_METHOD_DECL(FT2Font, attach_file)\n-\n-\n-typedef struct\n-{\n-    PyObject *py_file;\n-    FILE *fp;\n-    int close_file;\n-    mpl_off_t offset;\n-} py_file_def;\n-\n-\n-static unsigned long read_from_file_callback(\n-    FT_Stream stream, unsigned long offset, unsigned char *buffer,\n-    unsigned long count) {\n-\n-    py_file_def *def = (py_file_def *)stream->descriptor.pointer;\n-\n-    if (fseek(def->fp, offset, SEEK_SET) == -1) {\n-        return 0;\n-    }\n-\n-    if (count > 0) {\n-        return fread(buffer, 1, count, def->fp);\n-    }\n-\n-    return 0;\n-}\n-\n-\n-static void close_file_callback(FT_Stream stream)\n-{\n-    py_file_def *def = (py_file_def *)stream->descriptor.pointer;\n-\n-    if (mpl_PyFile_DupClose(def->py_file, def->fp, def->offset))\n-    {\n-        throw Py::Exception();\n-    }\n-\n-    if (def->close_file) {\n-        mpl_PyFile_CloseFile(def->py_file);\n-    }\n-\n-    Py_DECREF(def->py_file);\n-}\n-\n-\n-int\n-FT2Font::make_open_args(PyObject *py_file_arg, FT_Open_Args *open_args)\n-{\n-    PyObject *py_file = NULL;\n-    int close_file = 0;\n-    FILE *fp;\n-    PyObject *data = NULL;\n-    char *data_ptr;\n-    Py_ssize_t data_len;\n-    py_file_def *stream_info = NULL;\n-    long file_size;\n-    FT_Byte *new_memory;\n-    mpl_off_t offset = 0;\n-\n-    int result = -1;\n-\n-    memset((void *)open_args, 0, sizeof(FT_Open_Args));\n-\n-    if (PyBytes_Check(py_file_arg) || PyUnicode_Check(py_file_arg)) {\n-        if ((py_file = mpl_PyFile_OpenFile(py_file_arg, (char *)\"rb\")) == NULL) {\n-            goto exit;\n-        }\n-        close_file = 1;\n-    } else {\n-        Py_INCREF(py_file_arg);\n-        py_file = py_file_arg;\n-    }\n-\n-    if ((fp = mpl_PyFile_Dup(py_file, (char *)\"rb\", &offset))) {\n-        stream_info = (py_file_def *)PyMem_Malloc(sizeof(py_file_def));\n-        if (stream_info == NULL) {\n-            goto exit;\n-        }\n-        memset(stream_info, 0, sizeof(py_file_def));\n-\n-        Py_INCREF(py_file);\n-        stream_info->py_file = py_file;\n-        stream_info->close_file = close_file;\n-        stream_info->fp = fp;\n-        stream_info->offset = offset;\n-        fseek(fp, 0, SEEK_END);\n-        file_size = ftell(fp);\n-        fseek(fp, 0, SEEK_SET);\n-\n-        stream.base = NULL;\n-        stream.size = (unsigned long)file_size;\n-        stream.pos = 0;\n-        stream.descriptor.pointer = stream_info;\n-        stream.read = &read_from_file_callback;\n-        stream.close = &close_file_callback;\n-\n-        open_args->flags = FT_OPEN_STREAM;\n-        open_args->stream = &stream;\n-    } else {\n-        if (PyObject_HasAttrString(py_file_arg, \"read\") &&\n-            (data = PyObject_CallMethod(py_file_arg, (char*)\"read\", (char*)\"\"))) {\n-            if (PyBytes_AsStringAndSize(data, &data_ptr, &data_len)) {\n-                goto exit;\n-            }\n-\n-            if (mem) {\n-                free(mem);\n-            }\n-            mem = (FT_Byte *)PyMem_Malloc(mem_size + data_len);\n-            if (mem == NULL) {\n-                goto exit;\n-            }\n-            new_memory = mem + mem_size;\n-            mem_size += data_len;\n-\n-            memcpy(new_memory, data_ptr, data_len);\n-            open_args->flags = FT_OPEN_MEMORY;\n-            open_args->memory_base = new_memory;\n-            open_args->memory_size = data_len;\n-            open_args->stream = NULL;\n-        } else {\n-            PyErr_SetString(\n-                PyExc_TypeError,\n-                \"First argument must be a path or file object reading bytes\");\n-            goto exit;\n+        if (FT_Get_Glyph_Name(face, glyph_number, buffer, 128)) {\n+            throw \"Could not get glyph names.\";\n         }\n     }\n-\n-    result = 0;\n-\n- exit:\n-\n-    Py_XDECREF(py_file);\n-    Py_XDECREF(data);\n-\n-    return result;\n-}\n-\n-void\n-FT2Image::init_type(void)\n-{\n-    _VERBOSE(\"FT2Image::init_type\");\n-    behaviors().name(\"FT2Image\");\n-    behaviors().doc(\"FT2Image\");\n-\n-    PYCXX_ADD_VARARGS_METHOD(write_bitmap, py_write_bitmap,\n-                             FT2Image::write_bitmap__doc__);\n-    PYCXX_ADD_VARARGS_METHOD(draw_rect, py_draw_rect,\n-                             FT2Image::draw_rect__doc__);\n-    PYCXX_ADD_VARARGS_METHOD(draw_rect_filled, py_draw_rect_filled,\n-                             FT2Image::draw_rect_filled__doc__);\n-    PYCXX_ADD_VARARGS_METHOD(as_array, py_as_array,\n-                             FT2Image::as_array__doc__);\n-    PYCXX_ADD_VARARGS_METHOD(as_str, py_as_str,\n-                             FT2Image::as_str__doc__);\n-    PYCXX_ADD_VARARGS_METHOD(as_rgb_str, py_as_rgb_str,\n-                             FT2Image::as_rgb_str__doc__);\n-    PYCXX_ADD_VARARGS_METHOD(as_rgba_str, py_as_rgba_str,\n-                             FT2Image::as_rgba_str__doc__);\n-    PYCXX_ADD_VARARGS_METHOD(get_width, py_get_width,\n-                             \"Returns the width of the image\");\n-    PYCXX_ADD_VARARGS_METHOD(get_height, py_get_height,\n-                             \"Returns the height of the image\");\n-\n-    behaviors().readyType();\n-}\n-\n-void\n-Glyph::init_type()\n-{\n-    _VERBOSE(\"Glyph::init_type\");\n-    behaviors().name(\"Glyph\");\n-    behaviors().doc(\"Glyph\");\n-    behaviors().supportGetattro();\n-    behaviors().supportSetattro();\n-    behaviors().readyType();\n-}\n-\n-void\n-FT2Font::init_type()\n-{\n-    _VERBOSE(\"FT2Font::init_type\");\n-    behaviors().name(\"FT2Font\");\n-    behaviors().doc(\"FT2Font\");\n-    behaviors().supportGetattro();\n-    behaviors().supportSetattro();\n-\n-    PYCXX_ADD_VARARGS_METHOD(clear, clear,\n-                             FT2Font::clear__doc__);\n-    PYCXX_ADD_KEYWORDS_METHOD(draw_glyph_to_bitmap, draw_glyph_to_bitmap,\n-                             FT2Font::draw_glyph_to_bitmap__doc__);\n-    PYCXX_ADD_KEYWORDS_METHOD(draw_glyphs_to_bitmap, draw_glyphs_to_bitmap,\n-                             FT2Font::draw_glyphs_to_bitmap__doc__);\n-    PYCXX_ADD_KEYWORDS_METHOD(get_xys, get_xys,\n-                             FT2Font::get_xys__doc__);\n-\n-    PYCXX_ADD_VARARGS_METHOD(get_num_glyphs, get_num_glyphs,\n-                             FT2Font::get_num_glyphs__doc__);\n-    PYCXX_ADD_KEYWORDS_METHOD(load_char, load_char,\n-                              FT2Font::load_char__doc__);\n-    PYCXX_ADD_KEYWORDS_METHOD(load_glyph, load_glyph,\n-                              FT2Font::load_glyph__doc__);\n-    PYCXX_ADD_KEYWORDS_METHOD(set_text, set_text,\n-                              FT2Font::set_text__doc__);\n-    PYCXX_ADD_VARARGS_METHOD(set_size, set_size,\n-                             FT2Font::set_size__doc__);\n-    PYCXX_ADD_VARARGS_METHOD(set_charmap, set_charmap,\n-                             FT2Font::set_charmap__doc__);\n-    PYCXX_ADD_VARARGS_METHOD(select_charmap, select_charmap,\n-                             FT2Font::select_charmap__doc__);\n-\n-    PYCXX_ADD_VARARGS_METHOD(get_width_height, get_width_height,\n-                             FT2Font::get_width_height__doc__);\n-    PYCXX_ADD_VARARGS_METHOD(get_descent, get_descent,\n-                             FT2Font::get_descent__doc__);\n-    PYCXX_ADD_VARARGS_METHOD(get_glyph_name, get_glyph_name,\n-                             FT2Font::get_glyph_name__doc__);\n-    PYCXX_ADD_VARARGS_METHOD(get_charmap, get_charmap,\n-                             FT2Font::get_charmap__doc__);\n-    PYCXX_ADD_VARARGS_METHOD(get_kerning, get_kerning,\n-                             FT2Font::get_kerning__doc__);\n-    PYCXX_ADD_VARARGS_METHOD(get_sfnt, get_sfnt,\n-                             FT2Font::get_sfnt__doc__);\n-    PYCXX_ADD_VARARGS_METHOD(get_name_index, get_name_index,\n-                             FT2Font::get_name_index__doc__);\n-    PYCXX_ADD_VARARGS_METHOD(get_ps_font_info, get_ps_font_info,\n-                             FT2Font::get_ps_font_info__doc__);\n-    PYCXX_ADD_VARARGS_METHOD(get_sfnt_table, get_sfnt_table,\n-                             FT2Font::get_sfnt_table__doc__);\n-    PYCXX_ADD_VARARGS_METHOD(get_image, get_image,\n-                             FT2Font::get_image__doc__);\n-    PYCXX_ADD_VARARGS_METHOD(attach_file, attach_file,\n-                             FT2Font::attach_file__doc__);\n-    PYCXX_ADD_NOARGS_METHOD(get_path, get_path,\n-                            FT2Font::get_path__doc__);\n-\n-    behaviors().readyType();\n-}\n-\n-//todo add module docs strings\n-\n-char ft2font__doc__[] =\n-    \"ft2font\\n\"\n-    \"\\n\"\n-    \"Methods:\\n\"\n-    \"  FT2Font(ttffile)\\n\"\n-    \"Face Constants\\n\"\n-    \"  SCALABLE               scalable\\n\"\n-    \"  FIXED_SIZES            \\n\"\n-    \"  FIXED_WIDTH            \\n\"\n-    \"  SFNT                   \\n\"\n-    \"  HORIZONTAL             \\n\"\n-    \"  VERTICAL               \\n\"\n-    \"  KERNING                \\n\"\n-    \"  FAST_GLYPHS            \\n\"\n-    \"  MULTIPLE_MASTERS       \\n\"\n-    \"  GLYPH_NAMES            \\n\"\n-    \"  EXTERNAL_STREAM        \\n\"\n-    \"Style Constants\\n\"\n-    \"  ITALIC                 \\n\"\n-    \"  BOLD                   \\n\"\n-    ;\n-\n-/* Function of no arguments returning new FT2Font object */\n-char ft2font_new__doc__[] =\n-    \"FT2Font(ttffile)\\n\"\n-    \"\\n\"\n-    \"Create a new FT2Font object\\n\"\n-    \"The following global font attributes are defined:\\n\"\n-    \"  num_faces              number of faces in file\\n\"\n-    \"  face_flags             face flags  (int type); see the ft2font constants\\n\"\n-    \"  style_flags            style flags  (int type); see the ft2font constants\\n\"\n-    \"  num_glyphs             number of glyphs in the face\\n\"\n-    \"  family_name            face family name\\n\"\n-    \"  style_name             face syle name\\n\"\n-    \"  num_fixed_sizes        number of bitmap in the face\\n\"\n-    \"  scalable               face is scalable\\n\"\n-    \"\\n\"\n-    \"The following are available, if scalable is true:\\n\"\n-    \"  bbox                   face global bounding box (xmin, ymin, xmax, ymax)\\n\"\n-    \"  units_per_EM           number of font units covered by the EM\\n\"\n-    \"  ascender               ascender in 26.6 units\\n\"\n-    \"  descender              descender in 26.6 units\\n\"\n-    \"  height                 height in 26.6 units; used to compute a default\\n\"\n-    \"                         line spacing (baseline-to-baseline distance)\\n\"\n-    \"  max_advance_width      maximum horizontal cursor advance for all glyphs\\n\"\n-    \"  max_advance_height     same for vertical layout\\n\"\n-    \"  underline_position     vertical position of the underline bar\\n\"\n-    \"  underline_thickness    vertical thickness of the underline\\n\"\n-    \"  postscript_name        PostScript name of the font\\n\"\n-    ;\n-\n-ft2font_module::ft2font_module()\n-    : Py::ExtensionModule<ft2font_module>(\"ft2font\")\n-{\n-    FT2Image::init_type();\n-    Glyph::init_type();\n-    FT2Font::init_type();\n-\n-    initialize(\"The ft2font module\");\n-\n-    Py::Dict d(moduleDictionary());\n-    Py::Object ft2font_type(FT2Font::type());\n-    d[\"FT2Font\"] = ft2font_type;\n-    Py::Object ft2image_type(FT2Image::type());\n-    d[\"FT2Image\"] = ft2image_type;\n }\n \n-ft2font_module::~ft2font_module()\n+long FT2Font::get_name_index(char *name)\n {\n-    FT_Done_FreeType(_ft2Library);\n-}\n-\n-PyMODINIT_FUNC\n-#if PY3K\n-PyInit_ft2font(void)\n-#else\n-initft2font(void)\n-#endif\n-{\n-    static ft2font_module* ft2font = new ft2font_module;\n-    Py::Dict d = ft2font->moduleDictionary();\n-    d[\"SCALABLE\"]         = Py::Int(FT_FACE_FLAG_SCALABLE);\n-    d[\"FIXED_SIZES\"]      = Py::Int(FT_FACE_FLAG_FIXED_SIZES);\n-    d[\"FIXED_WIDTH\"]      = Py::Int(FT_FACE_FLAG_FIXED_WIDTH);\n-    d[\"SFNT\"]             = Py::Int(FT_FACE_FLAG_SFNT);\n-    d[\"HORIZONTAL\"]       = Py::Int(FT_FACE_FLAG_HORIZONTAL);\n-    d[\"VERTICAL\"]         = Py::Int(FT_FACE_FLAG_SCALABLE);\n-    d[\"KERNING\"]          = Py::Int(FT_FACE_FLAG_KERNING);\n-    d[\"FAST_GLYPHS\"]      = Py::Int(FT_FACE_FLAG_FAST_GLYPHS);\n-    d[\"MULTIPLE_MASTERS\"] = Py::Int(FT_FACE_FLAG_MULTIPLE_MASTERS);\n-    d[\"GLYPH_NAMES\"]      = Py::Int(FT_FACE_FLAG_GLYPH_NAMES);\n-    d[\"EXTERNAL_STREAM\"]  = Py::Int(FT_FACE_FLAG_EXTERNAL_STREAM);\n-    d[\"ITALIC\"]           = Py::Int(FT_STYLE_FLAG_ITALIC);\n-    d[\"BOLD\"]             = Py::Int(FT_STYLE_FLAG_BOLD);\n-    d[\"KERNING_DEFAULT\"]  = Py::Int(FT_KERNING_DEFAULT);\n-    d[\"KERNING_UNFITTED\"]  = Py::Int(FT_KERNING_UNFITTED);\n-    d[\"KERNING_UNSCALED\"]  = Py::Int(FT_KERNING_UNSCALED);\n-\n-    d[\"LOAD_DEFAULT\"]          = Py::Long(FT_LOAD_DEFAULT);\n-    d[\"LOAD_NO_SCALE\"]         = Py::Long(FT_LOAD_NO_SCALE);\n-    d[\"LOAD_NO_HINTING\"]       = Py::Long(FT_LOAD_NO_HINTING);\n-    d[\"LOAD_RENDER\"]           = Py::Long(FT_LOAD_RENDER);\n-    d[\"LOAD_NO_BITMAP\"]        = Py::Long(FT_LOAD_NO_BITMAP);\n-    d[\"LOAD_VERTICAL_LAYOUT\"]  = Py::Long(FT_LOAD_VERTICAL_LAYOUT);\n-    d[\"LOAD_FORCE_AUTOHINT\"]   = Py::Long(FT_LOAD_FORCE_AUTOHINT);\n-    d[\"LOAD_CROP_BITMAP\"]      = Py::Long(FT_LOAD_CROP_BITMAP);\n-    d[\"LOAD_PEDANTIC\"]         = Py::Long(FT_LOAD_PEDANTIC);\n-    d[\"LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH\"] =\n-        Py::Long(FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH);\n-    d[\"LOAD_NO_RECURSE\"]       = Py::Long(FT_LOAD_NO_RECURSE);\n-    d[\"LOAD_IGNORE_TRANSFORM\"] = Py::Long(FT_LOAD_IGNORE_TRANSFORM);\n-    d[\"LOAD_MONOCHROME\"]       = Py::Long(FT_LOAD_MONOCHROME);\n-    d[\"LOAD_LINEAR_DESIGN\"]    = Py::Long(FT_LOAD_LINEAR_DESIGN);\n-    // These need casting because large-valued numeric literals could\n-    // be either longs or unsigned longs:\n-    d[\"LOAD_NO_AUTOHINT\"]      = Py::Long((unsigned long)FT_LOAD_NO_AUTOHINT);\n-    d[\"LOAD_TARGET_NORMAL\"]    = Py::Long((unsigned long)FT_LOAD_TARGET_NORMAL);\n-    d[\"LOAD_TARGET_LIGHT\"]     = Py::Long((unsigned long)FT_LOAD_TARGET_LIGHT);\n-    d[\"LOAD_TARGET_MONO\"]      = Py::Long((unsigned long)FT_LOAD_TARGET_MONO);\n-    d[\"LOAD_TARGET_LCD\"]       = Py::Long((unsigned long)FT_LOAD_TARGET_LCD);\n-    d[\"LOAD_TARGET_LCD_V\"]     = Py::Long((unsigned long)FT_LOAD_TARGET_LCD_V);\n-\n-    //initialize library\n-    int error = FT_Init_FreeType(&_ft2Library);\n-\n-    if (error)\n-    {\n-        throw Py::RuntimeError(\"Could not find initialize the freetype2 library\");\n-    }\n-\n-    {\n-        FT_Int major, minor, patch;\n-        char version_string[64];\n-\n-        FT_Library_Version(_ft2Library, &major, &minor, &patch);\n-        sprintf(version_string, \"%d.%d.%d\", major, minor, patch);\n-\n-        d[\"__freetype_version__\"] = Py::String(version_string);\n-    }\n-\n-    import_array();\n-\n-    #if PY3K\n-    return ft2font->module().ptr();\n-    #endif\n+    return FT_Get_Name_Index(face, (FT_String *)name);\n }"}
{"patches_id": 2, "files_id": 51, "language": "h", "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2Fft2font.h", "raw_code": "/* -*- mode: c++; c-basic-offset: 4 -*- */\n\n/* A python interface to freetype2 */\n#ifndef _FT2FONT_H\n#define _FT2FONT_H\n#include <vector>\n#include <stdint.h>\n\nextern \"C\" {\n#include <ft2build.h>\n#include FT_FREETYPE_H\n#include FT_GLYPH_H\n#include FT_SFNT_NAMES_H\n#include FT_TYPE1_TABLES_H\n#include FT_TRUETYPE_TABLES_H\n}\n\n/*\n By definition, FT_FIXED as 2 16bit values stored in a single long.\n */\n#define FIXED_MAJOR(val) (long)((val & 0xffff000) >> 16)\n#define FIXED_MINOR(val) (long)(val & 0xffff)\n\n// the freetype string rendered into a width, height buffer\nclass FT2Image\n{\n  public:\n    FT2Image();\n    FT2Image(unsigned long width, unsigned long height);\n    virtual ~FT2Image();\n\n    void resize(long width, long height);\n    void draw_bitmap(FT_Bitmap *bitmap, FT_Int x, FT_Int y);\n    void write_bitmap(FILE *fp) const;\n    void draw_rect(unsigned long x0, unsigned long y0, unsigned long x1, unsigned long y1);\n    void draw_rect_filled(unsigned long x0, unsigned long y0, unsigned long x1, unsigned long y1);\n\n    unsigned char *get_buffer()\n    {\n        return m_buffer;\n    }\n    unsigned long get_width()\n    {\n        return m_width;\n    }\n    unsigned long get_height()\n    {\n        return m_height;\n    }\n\n  private:\n    bool m_dirty;\n    unsigned char *m_buffer;\n    unsigned long m_width;\n    unsigned long m_height;\n\n    // prevent copying\n    FT2Image(const FT2Image &);\n    FT2Image &operator=(const FT2Image &);\n};\n\nextern FT_Library _ft2Library;\n\nclass FT2Font\n{\n\n  public:\n    FT2Font(FT_Open_Args &open_args, long hinting_factor);\n    virtual ~FT2Font();\n    void clear();\n    void set_size(double ptsize, double dpi);\n    void set_charmap(int i);\n    void select_charmap(unsigned long i);\n    void set_text(\n        size_t N, uint32_t *codepoints, double angle, FT_UInt32 flags, std::vector<double> &xys);\n    int get_kerning(int left, int right, int mode);\n    void load_char(long charcode, FT_UInt32 flags);\n    void load_glyph(FT_UInt glyph_index, FT_UInt32 flags);\n    void get_width_height(long *width, long *height);\n    long get_descent();\n    // TODO: Since we know the size of the array upfront, we probably don't\n    // need to dynamically allocate like this\n    void get_xys(bool antialiased, std::vector<double> &xys);\n    void draw_glyphs_to_bitmap(bool antialiased);\n    void draw_glyph_to_bitmap(FT2Image &im, int x, int y, size_t glyphInd, bool antialiased);\n    void get_glyph_name(unsigned int glyph_number, char *buffer);\n    long get_name_index(char *name);\n    int get_path_count();\n    void get_path(double *outpoints, unsigned char *outcodes);\n\n    FT_Face &get_face()\n    {\n        return face;\n    }\n    FT2Image &get_image()\n    {\n        return image;\n    }\n    FT_Glyph &get_last_glyph()\n    {\n        return glyphs.back();\n    }\n    size_t get_last_glyph_index()\n    {\n        return glyphs.size() - 1;\n    }\n    size_t get_num_glyphs()\n    {\n        return glyphs.size();\n    }\n    long get_hinting_factor()\n    {\n        return hinting_factor;\n    }\n\n  private:\n    FT2Image image;\n    FT_Face face;\n    FT_Matrix matrix; /* transformation matrix */\n    FT_Vector pen;    /* untransformed origin  */\n    FT_Error error;\n    std::vector<FT_Glyph> glyphs;\n    std::vector<FT_Vector> pos;\n    double angle;\n    double ptsize;\n    double dpi;\n    long hinting_factor;\n\n    FT_BBox compute_string_bbox();\n    void set_scalable_attributes();\n\n    // prevent copying\n    FT2Font(const FT2Font &);\n    FT2Font &operator=(const FT2Font &);\n};\n\n#endif\n", "patch": "@@ -3,16 +3,10 @@\n /* A python interface to freetype2 */\n #ifndef _FT2FONT_H\n #define _FT2FONT_H\n-#include \"CXX/Extensions.hxx\"\n-#include \"CXX/Objects.hxx\"\n-#include <iostream>\n #include <vector>\n-#include <string>\n-#include <cmath>\n-#include <utility>\n+#include <stdint.h>\n \n-extern \"C\"\n-{\n+extern \"C\" {\n #include <ft2build.h>\n #include FT_FREETYPE_H\n #include FT_GLYPH_H\n@@ -21,129 +15,110 @@ extern \"C\"\n #include FT_TRUETYPE_TABLES_H\n }\n \n+/*\n+ By definition, FT_FIXED as 2 16bit values stored in a single long.\n+ */\n+#define FIXED_MAJOR(val) (long)((val & 0xffff000) >> 16)\n+#define FIXED_MINOR(val) (long)(val & 0xffff)\n+\n // the freetype string rendered into a width, height buffer\n-class FT2Image : public Py::PythonClass<FT2Image>\n+class FT2Image\n {\n-public:\n-    FT2Image(Py::PythonClassInstance *self, Py::Tuple &args, Py::Dict &kwds);\n+  public:\n+    FT2Image();\n+    FT2Image(unsigned long width, unsigned long height);\n     virtual ~FT2Image();\n-    static Py::PythonClassObject<FT2Image> factory(int width, int height);\n-\n-    static void init_type();\n \n-    void draw_bitmap(FT_Bitmap* bitmap, FT_Int x, FT_Int y);\n-    void write_bitmap(FILE* fp) const;\n-    void draw_rect(unsigned long x0, unsigned long y0,\n-                   unsigned long x1, unsigned long y1);\n-    void draw_rect_filled(unsigned long x0, unsigned long y0,\n-                          unsigned long x1, unsigned long y1);\n+    void resize(long width, long height);\n+    void draw_bitmap(FT_Bitmap *bitmap, FT_Int x, FT_Int y);\n+    void write_bitmap(FILE *fp) const;\n+    void draw_rect(unsigned long x0, unsigned long y0, unsigned long x1, unsigned long y1);\n+    void draw_rect_filled(unsigned long x0, unsigned long y0, unsigned long x1, unsigned long y1);\n \n-    unsigned int get_width() const\n+    unsigned char *get_buffer()\n     {\n-        return _width;\n-    };\n-    unsigned int get_height() const\n+        return m_buffer;\n+    }\n+    unsigned long get_width()\n     {\n-        return _height;\n-    };\n-    const unsigned char *const get_buffer() const\n+        return m_width;\n+    }\n+    unsigned long get_height()\n     {\n-        return _buffer;\n-    };\n-\n-    static char write_bitmap__doc__ [];\n-    Py::Object py_write_bitmap(const Py::Tuple & args);\n-    static char draw_rect__doc__ [];\n-    Py::Object py_draw_rect(const Py::Tuple & args);\n-    static char draw_rect_filled__doc__ [];\n-    Py::Object py_draw_rect_filled(const Py::Tuple & args);\n-    static char as_array__doc__ [];\n-    Py::Object py_as_array(const Py::Tuple & args);\n-    static char as_str__doc__ [];\n-    Py::Object py_as_str(const Py::Tuple & args);\n-    static char as_rgb_str__doc__ [];\n-    Py::Object py_as_rgb_str(const Py::Tuple & args);\n-    static char as_rgba_str__doc__ [];\n-    Py::Object py_as_rgba_str(const Py::Tuple & args);\n-    Py::Object py_get_width(const Py::Tuple & args);\n-    Py::Object py_get_height(const Py::Tuple & args);\n-\n-private:\n-    bool _isDirty;\n-    unsigned char *_buffer;\n-    unsigned long _width;\n-    unsigned long _height;\n+        return m_height;\n+    }\n \n-    void resize(long width, long height);\n+  private:\n+    bool m_dirty;\n+    unsigned char *m_buffer;\n+    unsigned long m_width;\n+    unsigned long m_height;\n \n     // prevent copying\n-    FT2Image(const FT2Image&);\n-    FT2Image& operator=(const FT2Image&);\n+    FT2Image(const FT2Image &);\n+    FT2Image &operator=(const FT2Image &);\n };\n \n-class Glyph : public Py::PythonClass<Glyph>\n-{\n-public:\n-    Glyph(Py::PythonClassInstance *self, Py::Tuple &args, Py::Dict &kwds) :\n-        Py::PythonClass<Glyph>(self, args, kwds) { }\n-    virtual ~Glyph();\n-    static Py::PythonClassObject<Glyph> factory(const FT_Face&, const FT_Glyph&, size_t, long);\n-    int setattro(const Py::String &name, const Py::Object &value);\n-    Py::Object getattro(const Py::String &name);\n-    static void init_type(void);\n-    size_t glyphInd;\n-private:\n-    Py::Dict __dict__;\n+extern FT_Library _ft2Library;\n \n-    // prevent copying\n-    Glyph(const Glyph&);\n-    Glyph& operator=(const Glyph&);\n-};\n-\n-class FT2Font : public Py::PythonClass<FT2Font>\n+class FT2Font\n {\n \n-public:\n-    FT2Font(Py::PythonClassInstance *self, Py::Tuple &args, Py::Dict &kwds);\n+  public:\n+    FT2Font(FT_Open_Args &open_args, long hinting_factor);\n     virtual ~FT2Font();\n-    static void init_type(void);\n-    Py::Object clear(const Py::Tuple & args);\n-    Py::Object set_size(const Py::Tuple & args);\n-    Py::Object set_charmap(const Py::Tuple & args);\n-    Py::Object select_charmap(const Py::Tuple & args);\n-    Py::Object set_text(const Py::Tuple & args, const Py::Dict & kwargs);\n-    Py::Object get_kerning(const Py::Tuple & args);\n-    Py::Object get_num_glyphs(const Py::Tuple & args);\n-    Py::Object load_char(const Py::Tuple & args, const Py::Dict & kws);\n-    Py::Object load_glyph(const Py::Tuple & args, const Py::Dict & kws);\n-    Py::Object get_width_height(const Py::Tuple & args);\n-    Py::Object get_descent(const Py::Tuple & args);\n-    Py::Object draw_rect_filled(const Py::Tuple & args);\n-    Py::Object get_xys(const Py::Tuple & args, const Py::Dict & kws);\n-    Py::Object draw_glyphs_to_bitmap(const Py::Tuple & args, const Py::Dict & kws);\n-    Py::Object draw_glyph_to_bitmap(const Py::Tuple & args, const Py::Dict & kws);\n-    Py::Object get_glyph_name(const Py::Tuple & args);\n-    Py::Object get_charmap(const Py::Tuple & args);\n-    Py::Object get_sfnt(const Py::Tuple & args);\n-    Py::Object get_name_index(const Py::Tuple & args);\n-    Py::Object get_ps_font_info(const Py::Tuple & args);\n-    Py::Object get_sfnt_table(const Py::Tuple & args);\n-    Py::Object get_image(const Py::Tuple & args);\n-    Py::Object attach_file(const Py::Tuple & args);\n-    int setattro(const Py::String &name, const Py::Object &value);\n-    Py::Object getattro(const Py::String &name);\n-    Py::Object get_path();\n-    Py::Object image;\n-\n-private:\n-    Py::Dict __dict__;\n-    FT_Face       face;\n-    FT_Matrix     matrix;                 /* transformation matrix */\n-    FT_Vector     pen;                    /* untransformed origin  */\n-    FT_Error      error;\n-    FT_StreamRec  stream;\n-    FT_Byte *     mem;\n-    size_t        mem_size;\n+    void clear();\n+    void set_size(double ptsize, double dpi);\n+    void set_charmap(int i);\n+    void select_charmap(unsigned long i);\n+    void set_text(\n+        size_t N, uint32_t *codepoints, double angle, FT_UInt32 flags, std::vector<double> &xys);\n+    int get_kerning(int left, int right, int mode);\n+    void load_char(long charcode, FT_UInt32 flags);\n+    void load_glyph(FT_UInt glyph_index, FT_UInt32 flags);\n+    void get_width_height(long *width, long *height);\n+    long get_descent();\n+    // TODO: Since we know the size of the array upfront, we probably don't\n+    // need to dynamically allocate like this\n+    void get_xys(bool antialiased, std::vector<double> &xys);\n+    void draw_glyphs_to_bitmap(bool antialiased);\n+    void draw_glyph_to_bitmap(FT2Image &im, int x, int y, size_t glyphInd, bool antialiased);\n+    void get_glyph_name(unsigned int glyph_number, char *buffer);\n+    long get_name_index(char *name);\n+    int get_path_count();\n+    void get_path(double *outpoints, unsigned char *outcodes);\n+\n+    FT_Face &get_face()\n+    {\n+        return face;\n+    }\n+    FT2Image &get_image()\n+    {\n+        return image;\n+    }\n+    FT_Glyph &get_last_glyph()\n+    {\n+        return glyphs.back();\n+    }\n+    size_t get_last_glyph_index()\n+    {\n+        return glyphs.size() - 1;\n+    }\n+    size_t get_num_glyphs()\n+    {\n+        return glyphs.size();\n+    }\n+    long get_hinting_factor()\n+    {\n+        return hinting_factor;\n+    }\n+\n+  private:\n+    FT2Image image;\n+    FT_Face face;\n+    FT_Matrix matrix; /* transformation matrix */\n+    FT_Vector pen;    /* untransformed origin  */\n+    FT_Error error;\n     std::vector<FT_Glyph> glyphs;\n     std::vector<FT_Vector> pos;\n     double angle;\n@@ -154,49 +129,9 @@ class FT2Font : public Py::PythonClass<FT2Font>\n     FT_BBox compute_string_bbox();\n     void set_scalable_attributes();\n \n-    int make_open_args(PyObject *fileobj, FT_Open_Args *open_args);\n-\n-    static char clear__doc__ [];\n-    static char set_size__doc__ [];\n-    static char set_charmap__doc__ [];\n-    static char select_charmap__doc__ [];\n-    static char set_text__doc__ [];\n-    static char get_glyph__doc__ [];\n-    static char get_num_glyphs__doc__ [];\n-    static char load_char__doc__ [];\n-    static char load_glyph__doc__ [];\n-    static char get_width_height__doc__ [];\n-    static char get_descent__doc__ [];\n-    static char get_kerning__doc__ [];\n-    static char draw_glyphs_to_bitmap__doc__ [];\n-    static char get_xys__doc__ [];\n-    static char draw_glyph_to_bitmap__doc__ [];\n-    static char get_glyph_name__doc__[];\n-    static char get_charmap__doc__[];\n-    static char get_sfnt__doc__ [];\n-    static char get_name_index__doc__[];\n-    static char get_ps_font_info__doc__[];\n-    static char get_sfnt_table__doc__[];\n-    static char get_image__doc__[];\n-    static char attach_file__doc__[];\n-    static char get_path__doc__[];\n-\n-    // prevent copying\n-    FT2Font(const FT2Font&);\n-    FT2Font& operator=(const FT2Font&);\n-};\n-\n-// the extension module\n-class ft2font_module : public Py::ExtensionModule<ft2font_module>\n-{\n-public:\n-    ft2font_module();\n-    virtual ~ft2font_module();\n-\n-private:\n     // prevent copying\n-    ft2font_module(const ft2font_module&);\n-    ft2font_module operator=(const ft2font_module&);\n+    FT2Font(const FT2Font &);\n+    FT2Font &operator=(const FT2Font &);\n };\n \n #endif"}
{"patches_id": 3, "files_id": 64, "language": "py", "raw_url": "https://github.com/saltstack/salt/raw/e39116fb87bf4db9bcb9aade8258c66df87d41fe/salt%2Fmaster.py", "raw_code": "\"\"\"\nThis module contains all of the routines needed to set up a master server, this\ninvolves preparing the three listeners and the workers needed by the master.\n\"\"\"\n\nimport collections\nimport copy\nimport ctypes\nimport functools\nimport logging\nimport multiprocessing\nimport os\nimport re\nimport signal\nimport stat\nimport sys\nimport threading\nimport time\n\nimport salt.acl\nimport salt.auth\nimport salt.channel.server\nimport salt.client\nimport salt.client.ssh.client\nimport salt.crypt\nimport salt.daemons.masterapi\nimport salt.defaults.exitcodes\nimport salt.engines\nimport salt.exceptions\nimport salt.ext.tornado.gen\nimport salt.key\nimport salt.minion\nimport salt.payload\nimport salt.pillar\nimport salt.runner\nimport salt.serializers.msgpack\nimport salt.state\nimport salt.utils.args\nimport salt.utils.atomicfile\nimport salt.utils.event\nimport salt.utils.files\nimport salt.utils.gitfs\nimport salt.utils.gzip_util\nimport salt.utils.jid\nimport salt.utils.job\nimport salt.utils.master\nimport salt.utils.minions\nimport salt.utils.platform\nimport salt.utils.process\nimport salt.utils.schedule\nimport salt.utils.ssdp\nimport salt.utils.stringutils\nimport salt.utils.user\nimport salt.utils.verify\nimport salt.utils.zeromq\nimport salt.wheel\nfrom salt.config import DEFAULT_INTERVAL\nfrom salt.defaults import DEFAULT_TARGET_DELIM\nfrom salt.ext.tornado.stack_context import StackContext\nfrom salt.transport import TRANSPORTS\nfrom salt.utils.channel import iter_transport_opts\nfrom salt.utils.ctx import RequestContext\nfrom salt.utils.debug import (\n    enable_sigusr1_handler,\n    enable_sigusr2_handler,\n    inspect_stack,\n)\nfrom salt.utils.event import tagify\nfrom salt.utils.odict import OrderedDict\nfrom salt.utils.zeromq import ZMQ_VERSION_INFO, zmq\n\ntry:\n    import resource\n\n    HAS_RESOURCE = True\nexcept ImportError:\n    # resource is not available on windows\n    HAS_RESOURCE = False\n\nlog = logging.getLogger(__name__)\n\n\nclass SMaster:\n    \"\"\"\n    Create a simple salt-master, this will generate the top-level master\n    \"\"\"\n\n    secrets = (\n        {}\n    )  # mapping of key -> {'secret': multiprocessing type, 'reload': FUNCTION}\n\n    def __init__(self, opts):\n        \"\"\"\n        Create a salt master server instance\n\n        :param dict opts: The salt options dictionary\n        \"\"\"\n        self.opts = opts\n        self.master_key = salt.crypt.MasterKeys(self.opts)\n        self.key = self.__prep_key()\n\n    # We need __setstate__ and __getstate__ to also pickle 'SMaster.secrets'.\n    # Otherwise, 'SMaster.secrets' won't be copied over to the spawned process\n    # on Windows since spawning processes on Windows requires pickling.\n    # These methods are only used when pickling so will not be used on\n    # non-Windows platforms.\n    def __setstate__(self, state):\n        super().__setstate__(state)\n        self.master_key = state[\"master_key\"]\n        self.key = state[\"key\"]\n        SMaster.secrets = state[\"secrets\"]\n\n    def __getstate__(self):\n        state = super().__getstate__()\n        state.update(\n            {\n                \"key\": self.key,\n                \"master_key\": self.master_key,\n                \"secrets\": SMaster.secrets,\n            }\n        )\n        return state\n\n    def __prep_key(self):\n        \"\"\"\n        A key needs to be placed in the filesystem with permissions 0400 so\n        clients are required to run as root.\n        \"\"\"\n        return salt.daemons.masterapi.access_keys(self.opts)\n\n    @classmethod\n    def get_serial(cls, opts=None, event=None):\n        with cls.secrets[\"aes\"][\"secret\"].get_lock():\n            if cls.secrets[\"aes\"][\"serial\"].value == sys.maxsize:\n                cls.rotate_secrets(opts, event, use_lock=False)\n            else:\n                cls.secrets[\"aes\"][\"serial\"].value += 1\n            return cls.secrets[\"aes\"][\"serial\"].value\n\n    @classmethod\n    def rotate_secrets(cls, opts=None, event=None, use_lock=True):\n        log.info(\"Rotating master AES key\")\n        if opts is None:\n            opts = {}\n\n        for secret_key, secret_map in cls.secrets.items():\n            # should be unnecessary-- since no one else should be modifying\n            if use_lock:\n                with secret_map[\"secret\"].get_lock():\n                    secret_map[\"secret\"].value = salt.utils.stringutils.to_bytes(\n                        secret_map[\"reload\"]()\n                    )\n                    if \"serial\" in secret_map:\n                        secret_map[\"serial\"].value = 0\n            else:\n                secret_map[\"secret\"].value = salt.utils.stringutils.to_bytes(\n                    secret_map[\"reload\"]()\n                )\n                if \"serial\" in secret_map:\n                    secret_map[\"serial\"].value = 0\n            if event:\n                event.fire_event({f\"rotate_{secret_key}_key\": True}, tag=\"key\")\n\n        if opts.get(\"ping_on_rotate\"):\n            # Ping all minions to get them to pick up the new key\n            log.debug(\"Pinging all connected minions due to key rotation\")\n            salt.utils.master.ping_all_connected_minions(opts)\n\n\nclass Maintenance(salt.utils.process.SignalHandlingProcess):\n    \"\"\"\n    A generalized maintenance process which performs maintenance routines.\n    \"\"\"\n\n    def __init__(self, opts, **kwargs):\n        \"\"\"\n        Create a maintenance instance\n\n        :param dict opts: The salt options\n        \"\"\"\n        self.master_secrets = kwargs.pop(\"master_secrets\", None)\n        super().__init__(**kwargs)\n        self.opts = opts\n        # How often do we perform the maintenance tasks\n        self.loop_interval = int(self.opts[\"loop_interval\"])\n        # Track key rotation intervals\n        self.rotate = int(time.time())\n        # A serializer for general maint operations\n        self.restart_interval = int(self.opts[\"maintenance_interval\"])\n\n    def _post_fork_init(self):\n        \"\"\"\n        Some things need to be init'd after the fork has completed\n        The easiest example is that one of these module types creates a thread\n        in the parent process, then once the fork happens you'll start getting\n        errors like \"WARNING: Mixing fork() and threads detected; memory leaked.\"\n        \"\"\"\n        if self.master_secrets is not None:\n            SMaster.secrets = self.master_secrets\n        # Load Runners\n        ropts = dict(self.opts)\n        ropts[\"quiet\"] = True\n        runner_client = salt.runner.RunnerClient(ropts)\n        # Load Returners\n        self.returners = salt.loader.returners(self.opts, {})\n\n        # Init Scheduler\n        self.schedule = salt.utils.schedule.Schedule(\n            self.opts, runner_client.functions_dict(), returners=self.returners\n        )\n        self.ckminions = salt.utils.minions.CkMinions(self.opts)\n        # Make Event bus for firing\n        self.event = salt.utils.event.get_master_event(\n            self.opts, self.opts[\"sock_dir\"], listen=False\n        )\n        # Init any values needed by the git ext pillar\n        self.git_pillar = salt.daemons.masterapi.init_git_pillar(self.opts)\n\n        if self.opts[\"maintenance_niceness\"] and not salt.utils.platform.is_windows():\n            log.info(\n                \"setting Maintenance niceness to %d\", self.opts[\"maintenance_niceness\"]\n            )\n            os.nice(self.opts[\"maintenance_niceness\"])\n\n        self.presence_events = False\n        if self.opts.get(\"presence_events\", False):\n            tcp_only = True\n            for transport, _ in iter_transport_opts(self.opts):\n                if transport != \"tcp\":\n                    tcp_only = False\n            if not tcp_only:\n                # For a TCP only transport, the presence events will be\n                # handled in the transport code.\n                self.presence_events = True\n\n    def run(self):\n        \"\"\"\n        This is the general passive maintenance process controller for the Salt\n        master.\n\n        This is where any data that needs to be cleanly maintained from the\n        master is maintained.\n        \"\"\"\n        # init things that need to be done after the process is forked\n        self._post_fork_init()\n\n        # Start of process for maintenance process restart interval\n        start = time.time()\n\n        # Unset last value will cause the interval items to run on the first\n        # loop iteration. This ensurs we always run them even if\n        # maintenance_interval happens to be less than loop_interval or\n        # git_update_interval\n        last = None\n\n        # update git_pillar on first loop\n        last_git_pillar_update = 0\n        now = int(time.time())\n\n        git_pillar_update_interval = self.opts.get(\"git_pillar_update_interval\", 0)\n        old_present = set()\n        while time.time() - start < self.restart_interval:\n            log.trace(\"Running maintenance routines\")\n            if not last or (now - last) >= self.loop_interval:\n                salt.daemons.masterapi.clean_old_jobs(self.opts)\n                salt.daemons.masterapi.clean_expired_tokens(self.opts)\n                salt.daemons.masterapi.clean_pub_auth(self.opts)\n            if not last or (now - last_git_pillar_update) >= git_pillar_update_interval:\n                last_git_pillar_update = now\n                self.handle_git_pillar()\n            self.handle_schedule()\n            self.handle_key_cache()\n            self.handle_presence(old_present)\n            self.handle_key_rotate(now)\n            salt.utils.verify.check_max_open_files(self.opts)\n            last = now\n            now = int(time.time())\n            time.sleep(self.loop_interval)\n\n    def handle_key_cache(self):\n        \"\"\"\n        Evaluate accepted keys and create a msgpack file\n        which contains a list\n        \"\"\"\n        if self.opts[\"key_cache\"] == \"sched\":\n            keys = []\n            # TODO DRY from CKMinions\n            if self.opts[\"transport\"] in TRANSPORTS:\n                acc = \"minions\"\n            else:\n                acc = \"accepted\"\n\n            for fn_ in os.listdir(os.path.join(self.opts[\"pki_dir\"], acc)):\n                if not fn_.startswith(\".\") and os.path.isfile(\n                    os.path.join(self.opts[\"pki_dir\"], acc, fn_)\n                ):\n                    keys.append(fn_)\n            log.debug(\"Writing master key cache\")\n            # Write a temporary file securely\n            with salt.utils.atomicfile.atomic_open(\n                os.path.join(self.opts[\"pki_dir\"], acc, \".key_cache\"), mode=\"wb\"\n            ) as cache_file:\n                salt.payload.dump(keys, cache_file)\n\n    def handle_key_rotate(self, now):\n        \"\"\"\n        Rotate the AES key rotation\n        \"\"\"\n        to_rotate = False\n        dfn = os.path.join(self.opts[\"cachedir\"], \".dfn\")\n        try:\n            stats = os.stat(dfn)\n            # Basic Windows permissions don't distinguish between\n            # user/group/all. Check for read-only state instead.\n            if salt.utils.platform.is_windows() and not os.access(dfn, os.W_OK):\n                to_rotate = True\n                # Cannot delete read-only files on Windows.\n                os.chmod(dfn, stat.S_IRUSR | stat.S_IWUSR)\n            elif stats.st_mode == 0o100400:\n                to_rotate = True\n            else:\n                log.error(\"Found dropfile with incorrect permissions, ignoring...\")\n            os.remove(dfn)\n        except OSError:\n            pass\n\n        if self.opts.get(\"publish_session\"):\n            if now - self.rotate >= self.opts[\"publish_session\"]:\n                to_rotate = True\n\n        if to_rotate:\n            SMaster.rotate_secrets(self.opts, self.event)\n            self.rotate = now\n\n    def handle_git_pillar(self):\n        \"\"\"\n        Update git pillar\n        \"\"\"\n        try:\n            for pillar in self.git_pillar:\n                pillar.fetch_remotes()\n        except Exception as exc:  # pylint: disable=broad-except\n            log.error(\"Exception caught while updating git_pillar\", exc_info=True)\n\n    def handle_schedule(self):\n        \"\"\"\n        Evaluate the scheduler\n        \"\"\"\n        try:\n            self.schedule.eval()\n            # Check if scheduler requires lower loop interval than\n            # the loop_interval setting\n            if self.schedule.loop_interval < self.loop_interval:\n                self.loop_interval = self.schedule.loop_interval\n        except Exception as exc:  # pylint: disable=broad-except\n            log.error(\"Exception %s occurred in scheduled job\", exc)\n        self.schedule.cleanup_subprocesses()\n\n    def handle_presence(self, old_present):\n        \"\"\"\n        Fire presence events if enabled\n        \"\"\"\n        # On the first run it may need more time for the EventPublisher\n        # to come up and be ready. Set the timeout to account for this.\n        if self.presence_events and self.event.connect_pull(timeout=3):\n            present = self.ckminions.connected_ids()\n            new = present.difference(old_present)\n            lost = old_present.difference(present)\n            if new or lost:\n                # Fire new minions present event\n                data = {\"new\": list(new), \"lost\": list(lost)}\n                self.event.fire_event(data, tagify(\"change\", \"presence\"))\n            data = {\"present\": list(present)}\n            self.event.fire_event(data, tagify(\"present\", \"presence\"))\n            old_present.clear()\n            old_present.update(present)\n\n\nclass FileserverUpdate(salt.utils.process.SignalHandlingProcess):\n    \"\"\"\n    A process from which to update any dynamic fileserver backends\n    \"\"\"\n\n    def __init__(self, opts, **kwargs):\n        super().__init__(**kwargs)\n        self.opts = opts\n        self.update_threads = {}\n        # Avoid circular import\n        import salt.fileserver\n\n        self.fileserver = salt.fileserver.Fileserver(self.opts)\n        self.fill_buckets()\n\n    def fill_buckets(self):\n        \"\"\"\n        Get the configured backends and the intervals for any backend which\n        supports them, and set up the update \"buckets\". There will be one\n        bucket for each thing being updated at a given interval.\n        \"\"\"\n        update_intervals = self.fileserver.update_intervals()\n        self.buckets = {}\n        for backend in self.fileserver.backends():\n            fstr = f\"{backend}.update\"\n            try:\n                update_func = self.fileserver.servers[fstr]\n            except KeyError:\n                log.debug(\"No update function for the %s filserver backend\", backend)\n                continue\n            if backend in update_intervals:\n                # Variable intervals are supported for this backend\n                for id_, interval in update_intervals[backend].items():\n                    if not interval:\n                        # Don't allow an interval of 0\n                        interval = DEFAULT_INTERVAL\n                        log.debug(\n                            \"An update_interval of 0 is not supported, \"\n                            \"falling back to %s\",\n                            interval,\n                        )\n                    i_ptr = self.buckets.setdefault(interval, OrderedDict())\n                    # Backend doesn't technically need to be present in the\n                    # key, all we *really* need is the function reference, but\n                    # having it there makes it easier to provide meaningful\n                    # debug logging in the update threads.\n                    i_ptr.setdefault((backend, update_func), []).append(id_)\n            else:\n                # Variable intervals are not supported for this backend, so\n                # fall back to the global interval for that fileserver. Since\n                # this backend doesn't support variable updates, we have\n                # nothing to pass to the backend's update func, so we'll just\n                # set the value to None.\n                try:\n                    interval_key = f\"{backend}_update_interval\"\n                    interval = self.opts[interval_key]\n                except KeyError:\n                    interval = DEFAULT_INTERVAL\n                    log.warning(\n                        \"%s key missing from configuration. Falling back to \"\n                        \"default interval of %d seconds\",\n                        interval_key,\n                        interval,\n                    )\n                self.buckets.setdefault(interval, OrderedDict())[\n                    (backend, update_func)\n                ] = None\n\n    @staticmethod\n    def _do_update(backends):\n        \"\"\"\n        Perform fileserver updates\n        \"\"\"\n        for backend, update_args in backends.items():\n            backend_name, update_func = backend\n            try:\n                if update_args:\n                    log.debug(\n                        \"Updating %s fileserver cache for the following targets: %s\",\n                        backend_name,\n                        update_args,\n                    )\n                    args = (update_args,)\n                else:\n                    log.debug(\"Updating %s fileserver cache\", backend_name)\n                    args = ()\n\n                update_func(*args)\n            except Exception as exc:  # pylint: disable=broad-except\n                log.exception(\n                    \"Uncaught exception while updating %s fileserver cache\",\n                    backend_name,\n                )\n\n    @classmethod\n    def update(cls, interval, backends, timeout):\n        \"\"\"\n        Threading target which handles all updates for a given wait interval\n        \"\"\"\n        start = time.time()\n        condition = threading.Condition()\n        while time.time() - start < timeout:\n            log.debug(\n                \"Performing fileserver updates for items with an update interval of %d\",\n                interval,\n            )\n            cls._do_update(backends)\n            log.debug(\n                \"Completed fileserver updates for items with an update \"\n                \"interval of %d, waiting %d seconds\",\n                interval,\n                interval,\n            )\n            with condition:\n                condition.wait(interval)\n\n    def run(self):\n        \"\"\"\n        Start the update threads\n        \"\"\"\n        if (\n            self.opts[\"fileserver_update_niceness\"]\n            and not salt.utils.platform.is_windows()\n        ):\n            log.info(\n                \"setting FileServerUpdate niceness to %d\",\n                self.opts[\"fileserver_update_niceness\"],\n            )\n            os.nice(self.opts[\"fileserver_update_niceness\"])\n\n        # Clean out the fileserver backend cache\n        salt.daemons.masterapi.clean_fsbackend(self.opts)\n\n        for interval in self.buckets:\n            self.update_threads[interval] = threading.Thread(\n                target=self.update,\n                args=(\n                    interval,\n                    self.buckets[interval],\n                    self.opts[\"fileserver_interval\"],\n                ),\n            )\n            self.update_threads[interval].start()\n\n        while self.update_threads:\n            for name, thread in list(self.update_threads.items()):\n                thread.join(1)\n                if not thread.is_alive():\n                    self.update_threads.pop(name)\n\n\nclass Master(SMaster):\n    \"\"\"\n    The salt master server\n    \"\"\"\n\n    def __init__(self, opts):\n        \"\"\"\n        Create a salt master server instance\n\n        :param dict: The salt options\n        \"\"\"\n        if zmq and ZMQ_VERSION_INFO < (3, 2):\n            log.warning(\n                \"You have a version of ZMQ less than ZMQ 3.2! There are \"\n                \"known connection keep-alive issues with ZMQ < 3.2 which \"\n                \"may result in loss of contact with minions. Please \"\n                \"upgrade your ZMQ!\"\n            )\n        SMaster.__init__(self, opts)\n\n    def __set_max_open_files(self):\n        if not HAS_RESOURCE:\n            return\n        # Let's check to see how our max open files(ulimit -n) setting is\n        mof_s, mof_h = resource.getrlimit(resource.RLIMIT_NOFILE)\n        if mof_h == resource.RLIM_INFINITY:\n            # Unclear what to do with infinity... macOS reports RLIM_INFINITY as\n            # hard limit,but raising to anything above soft limit fails...\n            mof_h = mof_s\n        log.info(\n            \"Current values for max open files soft/hard setting: %s/%s\", mof_s, mof_h\n        )\n        # Let's grab, from the configuration file, the value to raise max open\n        # files to\n        mof_c = self.opts[\"max_open_files\"]\n        if mof_c > mof_h:\n            # The configured value is higher than what's allowed\n            log.info(\n                \"The value for the 'max_open_files' setting, %s, is higher \"\n                \"than the highest value the user running salt is allowed to \"\n                \"set (%s). Defaulting to %s.\",\n                mof_c,\n                mof_h,\n                mof_h,\n            )\n            mof_c = mof_h\n\n        if mof_s < mof_c:\n            # There's room to raise the value. Raise it!\n            log.info(\"Raising max open files value to %s\", mof_c)\n            resource.setrlimit(resource.RLIMIT_NOFILE, (mof_c, mof_h))\n            try:\n                mof_s, mof_h = resource.getrlimit(resource.RLIMIT_NOFILE)\n                log.info(\n                    \"New values for max open files soft/hard values: %s/%s\",\n                    mof_s,\n                    mof_h,\n                )\n            except ValueError:\n                # https://github.com/saltstack/salt/issues/1991#issuecomment-13025595\n                # A user under macOS reported that our 100000 default value is\n                # still too high.\n                log.critical(\n                    \"Failed to raise max open files setting to %s. If this \"\n                    \"value is too low, the salt-master will most likely fail \"\n                    \"to run properly.\",\n                    mof_c,\n                )\n\n    def _pre_flight(self):\n        \"\"\"\n        Run pre flight checks. If anything in this method fails then the master\n        should not start up.\n        \"\"\"\n        errors = []\n        critical_errors = []\n\n        try:\n            os.chdir(\"/\")\n        except OSError as err:\n            errors.append(f\"Cannot change to root directory ({err})\")\n\n        if self.opts.get(\"fileserver_verify_config\", True):\n            # Avoid circular import\n            import salt.fileserver\n\n            fileserver = salt.fileserver.Fileserver(self.opts)\n            if not fileserver.servers:\n                errors.append(\n                    \"Failed to load fileserver backends, the configured backends \"\n                    \"are: {}\".format(\", \".join(self.opts[\"fileserver_backend\"]))\n                )\n            else:\n                # Run init() for all backends which support the function, to\n                # double-check configuration\n                try:\n                    fileserver.init()\n                except salt.exceptions.FileserverConfigError as exc:\n                    critical_errors.append(f\"{exc}\")\n\n        if not self.opts[\"fileserver_backend\"]:\n            errors.append(\"No fileserver backends are configured\")\n\n        # Check to see if we need to create a pillar cache dir\n        if self.opts[\"pillar_cache\"] and not os.path.isdir(\n            os.path.join(self.opts[\"cachedir\"], \"pillar_cache\")\n        ):\n            try:\n                with salt.utils.files.set_umask(0o077):\n                    os.mkdir(os.path.join(self.opts[\"cachedir\"], \"pillar_cache\"))\n            except OSError:\n                pass\n\n        if self.opts.get(\"git_pillar_verify_config\", True):\n            try:\n                git_pillars = [\n                    x\n                    for x in self.opts.get(\"ext_pillar\", [])\n                    if \"git\" in x and not isinstance(x[\"git\"], str)\n                ]\n            except TypeError:\n                git_pillars = []\n                critical_errors.append(\n                    \"Invalid ext_pillar configuration. It is likely that the \"\n                    \"external pillar type was not specified for one or more \"\n                    \"external pillars.\"\n                )\n            if git_pillars:\n                try:\n                    new_opts = copy.deepcopy(self.opts)\n                    import salt.pillar.git_pillar\n\n                    for repo in git_pillars:\n                        new_opts[\"ext_pillar\"] = [repo]\n                        try:\n                            git_pillar = salt.utils.gitfs.GitPillar(\n                                new_opts,\n                                repo[\"git\"],\n                                per_remote_overrides=salt.pillar.git_pillar.PER_REMOTE_OVERRIDES,\n                                per_remote_only=salt.pillar.git_pillar.PER_REMOTE_ONLY,\n                                global_only=salt.pillar.git_pillar.GLOBAL_ONLY,\n                            )\n                        except salt.exceptions.FileserverConfigError as exc:\n                            critical_errors.append(exc.strerror)\n                finally:\n                    del new_opts\n\n        if errors or critical_errors:\n            for error in errors:\n                log.error(error)\n            for error in critical_errors:\n                log.critical(error)\n            log.critical(\"Master failed pre flight checks, exiting\\n\")\n            sys.exit(salt.defaults.exitcodes.EX_GENERIC)\n\n    def start(self):\n        \"\"\"\n        Turn on the master server components\n        \"\"\"\n        self._pre_flight()\n        log.info(\"salt-master is starting as user '%s'\", salt.utils.user.get_user())\n\n        enable_sigusr1_handler()\n        enable_sigusr2_handler()\n\n        self.__set_max_open_files()\n\n        # Reset signals to default ones before adding processes to the process\n        # manager. We don't want the processes being started to inherit those\n        # signal handlers\n        with salt.utils.process.default_signals(signal.SIGINT, signal.SIGTERM):\n\n            # Setup the secrets here because the PubServerChannel may need\n            # them as well.\n            SMaster.secrets[\"aes\"] = {\n                \"secret\": multiprocessing.Array(\n                    ctypes.c_char,\n                    salt.utils.stringutils.to_bytes(\n                        salt.crypt.Crypticle.generate_key_string()\n                    ),\n                ),\n                \"serial\": multiprocessing.Value(\n                    ctypes.c_longlong, lock=False  # We'll use the lock from 'secret'\n                ),\n                \"reload\": salt.crypt.Crypticle.generate_key_string,\n            }\n\n            log.info(\"Creating master process manager\")\n            # Since there are children having their own ProcessManager we should wait for kill more time.\n            self.process_manager = salt.utils.process.ProcessManager(wait_for_kill=5)\n            pub_channels = []\n            log.info(\"Creating master publisher process\")\n            for _, opts in iter_transport_opts(self.opts):\n                chan = salt.channel.server.PubServerChannel.factory(opts)\n                chan.pre_fork(self.process_manager, kwargs={\"secrets\": SMaster.secrets})\n                pub_channels.append(chan)\n\n            log.info(\"Creating master event publisher process\")\n            self.process_manager.add_process(\n                salt.utils.event.EventPublisher,\n                args=(self.opts,),\n                name=\"EventPublisher\",\n            )\n\n            if self.opts.get(\"reactor\"):\n                if isinstance(self.opts[\"engines\"], list):\n                    rine = False\n                    for item in self.opts[\"engines\"]:\n                        if \"reactor\" in item:\n                            rine = True\n                            break\n                    if not rine:\n                        self.opts[\"engines\"].append({\"reactor\": {}})\n                else:\n                    if \"reactor\" not in self.opts[\"engines\"]:\n                        log.info(\"Enabling the reactor engine\")\n                        self.opts[\"engines\"][\"reactor\"] = {}\n\n            salt.engines.start_engines(self.opts, self.process_manager)\n\n            # must be after channels\n            log.info(\"Creating master maintenance process\")\n            self.process_manager.add_process(\n                Maintenance,\n                args=(self.opts,),\n                kwargs={\"master_secrets\": SMaster.secrets},\n                name=\"Maintenance\",\n            )\n\n            if self.opts.get(\"event_return\"):\n                log.info(\"Creating master event return process\")\n                self.process_manager.add_process(\n                    salt.utils.event.EventReturn, args=(self.opts,), name=\"EventReturn\"\n                )\n\n            ext_procs = self.opts.get(\"ext_processes\", [])\n            for proc in ext_procs:\n                log.info(\"Creating ext_processes process: %s\", proc)\n                try:\n                    mod = \".\".join(proc.split(\".\")[:-1])\n                    cls = proc.split(\".\")[-1]\n                    _tmp = __import__(mod, globals(), locals(), [cls], -1)\n                    cls = _tmp.__getattribute__(  # pylint: disable=unnecessary-dunder-call\n                        cls\n                    )\n                    name = f\"ExtProcess({cls.__qualname__})\"\n                    self.process_manager.add_process(cls, args=(self.opts,), name=name)\n                except Exception:  # pylint: disable=broad-except\n                    log.error(\"Error creating ext_processes process: %s\", proc)\n\n            # TODO: remove, or at least push into the transport stuff (pre-fork probably makes sense there)\n            if self.opts[\"con_cache\"]:\n                log.info(\"Creating master concache process\")\n                self.process_manager.add_process(\n                    salt.utils.master.ConnectedCache,\n                    args=(self.opts,),\n                    name=\"ConnectedCache\",\n                )\n                # workaround for issue #16315, race condition\n                log.debug(\"Sleeping for two seconds to let concache rest\")\n                time.sleep(2)\n\n            log.info(\"Creating master request server process\")\n            kwargs = {}\n            if salt.utils.platform.spawning_platform():\n                kwargs[\"secrets\"] = SMaster.secrets\n\n            self.process_manager.add_process(\n                ReqServer,\n                args=(self.opts, self.key, self.master_key),\n                kwargs=kwargs,\n                name=\"ReqServer\",\n            )\n\n            self.process_manager.add_process(\n                FileserverUpdate, args=(self.opts,), name=\"FileServerUpdate\"\n            )\n\n            # Fire up SSDP discovery publisher\n            if self.opts[\"discovery\"]:\n                if salt.utils.ssdp.SSDPDiscoveryServer.is_available():\n                    self.process_manager.add_process(\n                        salt.utils.ssdp.SSDPDiscoveryServer(\n                            port=self.opts[\"discovery\"][\"port\"],\n                            listen_ip=self.opts[\"interface\"],\n                            answer={\n                                \"mapping\": self.opts[\"discovery\"].get(\"mapping\", {})\n                            },\n                        ).run,\n                        name=\"SSDPDiscoveryServer\",\n                    )\n                else:\n                    log.error(\"Unable to load SSDP: asynchronous IO is not available.\")\n                    if sys.version_info.major == 2:\n                        log.error(\n                            'You are using Python 2, please install \"trollius\" module'\n                            \" to enable SSDP discovery.\"\n                        )\n\n        # Install the SIGINT/SIGTERM handlers if not done so far\n        if signal.getsignal(signal.SIGINT) is signal.SIG_DFL:\n            # No custom signal handling was added, install our own\n            signal.signal(signal.SIGINT, self._handle_signals)\n\n        if signal.getsignal(signal.SIGTERM) is signal.SIG_DFL:\n            # No custom signal handling was added, install our own\n            signal.signal(signal.SIGTERM, self._handle_signals)\n\n        self.process_manager.run()\n\n    def _handle_signals(self, signum, sigframe):\n        # escalate the signals to the process manager\n        self.process_manager._handle_signals(signum, sigframe)\n        time.sleep(1)\n        sys.exit(0)\n\n\nclass ReqServer(salt.utils.process.SignalHandlingProcess):\n    \"\"\"\n    Starts up the master request server, minions send results to this\n    interface.\n    \"\"\"\n\n    def __init__(self, opts, key, mkey, secrets=None, **kwargs):\n        \"\"\"\n        Create a request server\n\n        :param dict opts: The salt options dictionary\n        :key dict: The user starting the server and the AES key\n        :mkey dict: The user starting the server and the RSA key\n\n        :rtype: ReqServer\n        :returns: Request server\n        \"\"\"\n        super().__init__(**kwargs)\n        self.opts = opts\n        self.master_key = mkey\n        # Prepare the AES key\n        self.key = key\n        self.secrets = secrets\n\n    def _handle_signals(self, signum, sigframe):  # pylint: disable=unused-argument\n        self.destroy(signum)\n        super()._handle_signals(signum, sigframe)\n\n    def __bind(self):\n        \"\"\"\n        Binds the reply server\n        \"\"\"\n        if self.secrets is not None:\n            SMaster.secrets = self.secrets\n\n        dfn = os.path.join(self.opts[\"cachedir\"], \".dfn\")\n        if os.path.isfile(dfn):\n            try:\n                if salt.utils.platform.is_windows() and not os.access(dfn, os.W_OK):\n                    # Cannot delete read-only files on Windows.\n                    os.chmod(dfn, stat.S_IRUSR | stat.S_IWUSR)\n                os.remove(dfn)\n            except OSError:\n                pass\n\n        # Wait for kill should be less then parent's ProcessManager.\n        self.process_manager = salt.utils.process.ProcessManager(\n            name=\"ReqServer_ProcessManager\", wait_for_kill=1\n        )\n\n        req_channels = []\n        for transport, opts in iter_transport_opts(self.opts):\n            chan = salt.channel.server.ReqServerChannel.factory(opts)\n            chan.pre_fork(self.process_manager)\n            req_channels.append(chan)\n\n        if self.opts[\"req_server_niceness\"] and not salt.utils.platform.is_windows():\n            log.info(\n                \"setting ReqServer_ProcessManager niceness to %d\",\n                self.opts[\"req_server_niceness\"],\n            )\n            os.nice(self.opts[\"req_server_niceness\"])\n\n        # Reset signals to default ones before adding processes to the process\n        # manager. We don't want the processes being started to inherit those\n        # signal handlers\n        with salt.utils.process.default_signals(signal.SIGINT, signal.SIGTERM):\n            for ind in range(int(self.opts[\"worker_threads\"])):\n                name = f\"MWorker-{ind}\"\n                self.process_manager.add_process(\n                    MWorker,\n                    args=(self.opts, self.master_key, self.key, req_channels),\n                    name=name,\n                )\n        self.process_manager.run()\n\n    def run(self):\n        \"\"\"\n        Start up the ReqServer\n        \"\"\"\n        self.__bind()\n\n    def destroy(self, signum=signal.SIGTERM):\n        if hasattr(self, \"process_manager\"):\n            self.process_manager.stop_restarting()\n            self.process_manager.send_signal_to_processes(signum)\n            self.process_manager.kill_children()\n\n    # pylint: disable=W1701\n    def __del__(self):\n        self.destroy()\n\n    # pylint: enable=W1701\n\n\nclass MWorker(salt.utils.process.SignalHandlingProcess):\n    \"\"\"\n    The worker multiprocess instance to manage the backend operations for the\n    salt master.\n    \"\"\"\n\n    def __init__(self, opts, mkey, key, req_channels, **kwargs):\n        \"\"\"\n        Create a salt master worker process\n\n        :param dict opts: The salt options\n        :param dict mkey: The user running the salt master and the RSA key\n        :param dict key: The user running the salt master and the AES key\n\n        :rtype: MWorker\n        :return: Master worker\n        \"\"\"\n        super().__init__(**kwargs)\n        self.opts = opts\n        self.req_channels = req_channels\n\n        self.mkey = mkey\n        self.key = key\n        self.k_mtime = 0\n        self.stats = collections.defaultdict(lambda: {\"mean\": 0, \"runs\": 0})\n        self.stat_clock = time.time()\n\n    # We need __setstate__ and __getstate__ to also pickle 'SMaster.secrets'.\n    # Otherwise, 'SMaster.secrets' won't be copied over to the spawned process\n    # on Windows since spawning processes on Windows requires pickling.\n    # These methods are only used when pickling so will not be used on\n    # non-Windows platforms.\n    def __setstate__(self, state):\n        super().__setstate__(state)\n        self.k_mtime = state[\"k_mtime\"]\n        SMaster.secrets = state[\"secrets\"]\n\n    def __getstate__(self):\n        state = super().__getstate__()\n        state.update({\"k_mtime\": self.k_mtime, \"secrets\": SMaster.secrets})\n        return state\n\n    def _handle_signals(self, signum, sigframe):\n        for channel in getattr(self, \"req_channels\", ()):\n            try:\n                channel.close()\n            except Exception:  # pylint: disable=broad-except\n                # Don't stop closing additional channels because an\n                # exception occurred.\n                pass\n        clear_funcs = getattr(self, \"clear_funcs\", None)\n        if clear_funcs is not None:\n            try:\n                clear_funcs.destroy()\n            except Exception:  # pylint: disable=broad-except\n                # Don't stop signal handling because an exception occurred.\n                pass\n        super()._handle_signals(signum, sigframe)\n\n    def __bind(self):\n        \"\"\"\n        Bind to the local port\n        \"\"\"\n        self.io_loop = salt.ext.tornado.ioloop.IOLoop()\n        self.io_loop.make_current()\n        for req_channel in self.req_channels:\n            req_channel.post_fork(\n                self._handle_payload, io_loop=self.io_loop\n            )  # TODO: cleaner? Maybe lazily?\n        try:\n            self.io_loop.start()\n        except (KeyboardInterrupt, SystemExit):\n            # Tornado knows what to do\n            pass\n\n    @salt.ext.tornado.gen.coroutine\n    def _handle_payload(self, payload):\n        \"\"\"\n        The _handle_payload method is the key method used to figure out what\n        needs to be done with communication to the server\n\n        Example cleartext payload generated for 'salt myminion test.ping':\n\n        {'enc': 'clear',\n         'load': {'arg': [],\n                  'cmd': 'publish',\n                  'fun': 'test.ping',\n                  'jid': '',\n                  'key': 'alsdkjfa.,maljf-==adflkjadflkjalkjadfadflkajdflkj',\n                  'kwargs': {'show_jid': False, 'show_timeout': False},\n                  'ret': '',\n                  'tgt': 'myminion',\n                  'tgt_type': 'glob',\n                  'user': 'root'}}\n\n        :param dict payload: The payload route to the appropriate handler\n        \"\"\"\n        key = payload[\"enc\"]\n        load = payload[\"load\"]\n        if key == \"aes\":\n            ret = self._handle_aes(load)\n        else:\n            ret = self._handle_clear(load)\n        raise salt.ext.tornado.gen.Return(ret)\n\n    def _post_stats(self, start, cmd):\n        \"\"\"\n        Calculate the master stats and fire events with stat info\n        \"\"\"\n        end = time.time()\n        duration = end - start\n        self.stats[cmd][\"mean\"] = (\n            self.stats[cmd][\"mean\"] * (self.stats[cmd][\"runs\"] - 1) + duration\n        ) / self.stats[cmd][\"runs\"]\n        if end - self.stat_clock > self.opts[\"master_stats_event_iter\"]:\n            # Fire the event with the stats and wipe the tracker\n            self.aes_funcs.event.fire_event(\n                {\n                    \"time\": end - self.stat_clock,\n                    \"worker\": self.name,\n                    \"stats\": self.stats,\n                },\n                tagify(self.name, \"stats\"),\n            )\n            self.stats = collections.defaultdict(lambda: {\"mean\": 0, \"runs\": 0})\n            self.stat_clock = end\n\n    def _handle_clear(self, load):\n        \"\"\"\n        Process a cleartext command\n\n        :param dict load: Cleartext payload\n        :return: The result of passing the load to a function in ClearFuncs corresponding to\n                 the command specified in the load's 'cmd' key.\n        \"\"\"\n        log.trace(\"Clear payload received with command %s\", load[\"cmd\"])\n        cmd = load[\"cmd\"]\n        method = self.clear_funcs.get_method(cmd)\n        if not method:\n            return {}, {\"fun\": \"send_clear\"}\n        if self.opts[\"master_stats\"]:\n            start = time.time()\n            self.stats[cmd][\"runs\"] += 1\n        ret = method(load), {\"fun\": \"send_clear\"}\n        if self.opts[\"master_stats\"]:\n            self._post_stats(start, cmd)\n        return ret\n\n    def _handle_aes(self, data):\n        \"\"\"\n        Process a command sent via an AES key\n\n        :param str load: Encrypted payload\n        :return: The result of passing the load to a function in AESFuncs corresponding to\n                 the command specified in the load's 'cmd' key.\n        \"\"\"\n        if \"cmd\" not in data:\n            log.error(\"Received malformed command %s\", data)\n            return {}\n        cmd = data[\"cmd\"]\n        log.trace(\"AES payload received with command %s\", data[\"cmd\"])\n        method = self.aes_funcs.get_method(cmd)\n        if not method:\n            return {}, {\"fun\": \"send\"}\n        if self.opts[\"master_stats\"]:\n            start = time.time()\n            self.stats[cmd][\"runs\"] += 1\n\n        def run_func(data):\n            return self.aes_funcs.run_func(data[\"cmd\"], data)\n\n        with StackContext(\n            functools.partial(RequestContext, {\"data\": data, \"opts\": self.opts})\n        ):\n            ret = run_func(data)\n\n        if self.opts[\"master_stats\"]:\n            self._post_stats(start, cmd)\n        return ret\n\n    def run(self):\n        \"\"\"\n        Start a Master Worker\n        \"\"\"\n        # if we inherit req_server level without our own, reset it\n        if not salt.utils.platform.is_windows():\n            enforce_mworker_niceness = True\n            if self.opts[\"req_server_niceness\"]:\n                if salt.utils.user.get_user() == \"root\":\n                    log.info(\n                        \"%s decrementing inherited ReqServer niceness to 0\", self.name\n                    )\n                    os.nice(-1 * self.opts[\"req_server_niceness\"])\n                else:\n                    log.error(\n                        \"%s unable to decrement niceness for MWorker, not running as\"\n                        \" root\",\n                        self.name,\n                    )\n                    enforce_mworker_niceness = False\n\n            # else set what we're explicitly asked for\n            if enforce_mworker_niceness and self.opts[\"mworker_niceness\"]:\n                log.info(\n                    \"setting %s niceness to %i\",\n                    self.name,\n                    self.opts[\"mworker_niceness\"],\n                )\n                os.nice(self.opts[\"mworker_niceness\"])\n\n        self.clear_funcs = ClearFuncs(\n            self.opts,\n            self.key,\n        )\n        self.clear_funcs.connect()\n        self.aes_funcs = AESFuncs(self.opts)\n        self.__bind()\n\n\nclass TransportMethods:\n    \"\"\"\n    Expose methods to the transport layer, methods with their names found in\n    the class attribute 'expose_methods' will be exposed to the transport layer\n    via 'get_method'.\n    \"\"\"\n\n    expose_methods = ()\n\n    def get_method(self, name):\n        \"\"\"\n        Get a method which should be exposed to the transport layer\n        \"\"\"\n        if name in self.expose_methods:\n            try:\n                return getattr(self, name)\n            except AttributeError:\n                log.error(\"Requested method not exposed: %s\", name)\n        else:\n            log.error(\"Requested method not exposed: %s\", name)\n\n\n# TODO: rename? No longer tied to \"AES\", just \"encrypted\" or \"private\" requests\nclass AESFuncs(TransportMethods):\n    \"\"\"\n    Set up functions that are available when the load is encrypted with AES\n    \"\"\"\n\n    expose_methods = (\n        \"verify_minion\",\n        \"_master_tops\",\n        \"_master_opts\",\n        \"_mine_get\",\n        \"_mine\",\n        \"_mine_delete\",\n        \"_mine_flush\",\n        \"_file_recv\",\n        \"_pillar\",\n        \"_minion_event\",\n        \"_return\",\n        \"_syndic_return\",\n        \"minion_runner\",\n        \"pub_ret\",\n        \"minion_pub\",\n        \"minion_publish\",\n        \"revoke_auth\",\n        \"_serve_file\",\n        \"_file_find\",\n        \"_file_hash\",\n        \"_file_hash_and_stat\",\n        \"_file_list\",\n        \"_file_list_emptydirs\",\n        \"_dir_list\",\n        \"_symlink_list\",\n        \"_file_envs\",\n    )\n\n    def __init__(self, opts):\n        \"\"\"\n        Create a new AESFuncs\n\n        :param dict opts: The salt options\n\n        :rtype: AESFuncs\n        :returns: Instance for handling AES operations\n        \"\"\"\n        self.opts = opts\n        self.event = salt.utils.event.get_master_event(\n            self.opts, self.opts[\"sock_dir\"], listen=False\n        )\n        self.ckminions = salt.utils.minions.CkMinions(opts)\n        # Make a client\n        self.local = salt.client.get_local_client(self.opts[\"conf_file\"])\n        # Create the master minion to access the external job cache\n        self.mminion = salt.minion.MasterMinion(\n            self.opts, states=False, rend=False, ignore_config_errors=True\n        )\n        self.__setup_fileserver()\n        self.masterapi = salt.daemons.masterapi.RemoteFuncs(opts)\n\n    def __setup_fileserver(self):\n        \"\"\"\n        Set the local file objects from the file server interface\n        \"\"\"\n        # Avoid circular import\n        import salt.fileserver\n\n        self.fs_ = salt.fileserver.Fileserver(self.opts)\n        self._serve_file = self.fs_.serve_file\n        self._file_find = self.fs_._find_file\n        self._file_hash = self.fs_.file_hash\n        self._file_hash_and_stat = self.fs_.file_hash_and_stat\n        self._file_list = self.fs_.file_list\n        self._file_list_emptydirs = self.fs_.file_list_emptydirs\n        self._dir_list = self.fs_.dir_list\n        self._symlink_list = self.fs_.symlink_list\n        self._file_envs = self.fs_.file_envs\n\n    def __verify_minion(self, id_, token):\n        \"\"\"\n        Take a minion id and a string signed with the minion private key\n        The string needs to verify as 'salt' with the minion public key\n\n        :param str id_: A minion ID\n        :param str token: A string signed with the minion private key\n\n        :rtype: bool\n        :return: Boolean indicating whether or not the token can be verified.\n        \"\"\"\n        if not salt.utils.verify.valid_id(self.opts, id_):\n            return False\n        pub_path = salt.utils.verify.clean_join(self.opts[\"pki_dir\"], \"minions\", id_)\n\n        try:\n            pub = salt.crypt.PublicKey(pub_path)\n        except OSError:\n            log.warning(\n                \"Salt minion claiming to be %s attempted to communicate with \"\n                \"master, but key could not be read and verification was denied.\",\n                id_,\n            )\n            return False\n        except (ValueError, IndexError, TypeError) as err:\n            log.error('Unable to load public key \"%s\": %s', pub_path, err)\n        try:\n            if pub.decrypt(token) == b\"salt\":\n                return True\n        except ValueError as err:\n            log.error(\"Unable to decrypt token: %s\", err)\n\n        log.error(\n            \"Salt minion claiming to be %s has attempted to communicate with \"\n            \"the master and could not be verified\",\n            id_,\n        )\n        return False\n\n    def verify_minion(self, id_, token):\n        \"\"\"\n        Take a minion id and a string signed with the minion private key\n        The string needs to verify as 'salt' with the minion public key\n\n        :param str id_: A minion ID\n        :param str token: A string signed with the minion private key\n\n        :rtype: bool\n        :return: Boolean indicating whether or not the token can be verified.\n        \"\"\"\n        return self.__verify_minion(id_, token)\n\n    def __verify_minion_publish(self, clear_load):\n        \"\"\"\n        Verify that the passed information authorized a minion to execute\n\n        :param dict clear_load: A publication load from a minion\n\n        :rtype: bool\n        :return: A boolean indicating if the minion is allowed to publish the command in the load\n        \"\"\"\n        # Verify that the load is valid\n        if \"peer\" not in self.opts:\n            return False\n        if not isinstance(self.opts[\"peer\"], dict):\n            return False\n        if any(\n            key not in clear_load for key in (\"fun\", \"arg\", \"tgt\", \"ret\", \"tok\", \"id\")\n        ):\n            return False\n        # If the command will make a recursive publish don't run\n        if clear_load[\"fun\"].startswith(\"publish.\"):\n            return False\n        # Check the permissions for this minion\n        if not self.__verify_minion(clear_load[\"id\"], clear_load[\"tok\"]):\n            # The minion is not who it says it is!\n            # We don't want to listen to it!\n            log.warning(\n                \"Minion id %s is not who it says it is and is attempting \"\n                \"to issue a peer command\",\n                clear_load[\"id\"],\n            )\n            return False\n        clear_load.pop(\"tok\")\n        perms = []\n        for match in self.opts[\"peer\"]:\n            if re.match(match, clear_load[\"id\"]):\n                # This is the list of funcs/modules!\n                if isinstance(self.opts[\"peer\"][match], list):\n                    perms.extend(self.opts[\"peer\"][match])\n        if \",\" in clear_load[\"fun\"]:\n            # 'arg': [['cat', '/proc/cpuinfo'], [], ['foo']]\n            clear_load[\"fun\"] = clear_load[\"fun\"].split(\",\")\n            arg_ = []\n            for arg in clear_load[\"arg\"]:\n                arg_.append(arg.split())\n            clear_load[\"arg\"] = arg_\n\n        # finally, check the auth of the load\n        return self.ckminions.auth_check(\n            perms,\n            clear_load[\"fun\"],\n            clear_load[\"arg\"],\n            clear_load[\"tgt\"],\n            clear_load.get(\"tgt_type\", \"glob\"),\n            publish_validate=True,\n        )\n\n    def __verify_load(self, load, verify_keys):\n        \"\"\"\n        A utility function to perform common verification steps.\n\n        :param dict load: A payload received from a minion\n        :param list verify_keys: A list of strings that should be present in a\n        given load\n\n        :rtype: bool\n        :rtype: dict\n        :return: The original load (except for the token) if the load can be\n        verified. False if the load is invalid.\n        \"\"\"\n        if any(key not in load for key in verify_keys):\n            return False\n        if \"tok\" not in load:\n            log.error(\n                \"Received incomplete call from %s for '%s', missing '%s'\",\n                load[\"id\"],\n                inspect_stack()[\"co_name\"],\n                \"tok\",\n            )\n            return False\n        if not self.__verify_minion(load[\"id\"], load[\"tok\"]):\n            # The minion is not who it says it is!\n            # We don't want to listen to it!\n            log.warning(\"Minion id %s is not who it says it is!\", load[\"id\"])\n            return False\n\n        if \"tok\" in load:\n            load.pop(\"tok\")\n\n        return load\n\n    def _master_tops(self, load):\n        \"\"\"\n        Return the results from an external node classifier if one is\n        specified\n\n        :param dict load: A payload received from a minion\n        :return: The results from an external node classifier\n        \"\"\"\n        load = self.__verify_load(load, (\"id\", \"tok\"))\n        if load is False:\n            return {}\n        return self.masterapi._master_tops(load, skip_verify=True)\n\n    def _master_opts(self, load):\n        \"\"\"\n        Return the master options to the minion\n\n        :param dict load: A payload received from a minion\n\n        :rtype: dict\n        :return: The master options\n        \"\"\"\n        mopts = {}\n        file_roots = {}\n        envs = self._file_envs()\n        for saltenv in envs:\n            if saltenv not in file_roots:\n                file_roots[saltenv] = []\n        mopts[\"file_roots\"] = file_roots\n        mopts[\"top_file_merging_strategy\"] = self.opts[\"top_file_merging_strategy\"]\n        mopts[\"env_order\"] = self.opts[\"env_order\"]\n        mopts[\"default_top\"] = self.opts[\"default_top\"]\n        if load.get(\"env_only\"):\n            return mopts\n        mopts[\"renderer\"] = self.opts[\"renderer\"]\n        mopts[\"failhard\"] = self.opts[\"failhard\"]\n        mopts[\"state_top\"] = self.opts[\"state_top\"]\n        mopts[\"state_top_saltenv\"] = self.opts[\"state_top_saltenv\"]\n        mopts[\"nodegroups\"] = self.opts[\"nodegroups\"]\n        mopts[\"state_auto_order\"] = self.opts[\"state_auto_order\"]\n        mopts[\"state_events\"] = self.opts[\"state_events\"]\n        mopts[\"state_aggregate\"] = self.opts[\"state_aggregate\"]\n        mopts[\"jinja_env\"] = self.opts[\"jinja_env\"]\n        mopts[\"jinja_sls_env\"] = self.opts[\"jinja_sls_env\"]\n        mopts[\"jinja_lstrip_blocks\"] = self.opts[\"jinja_lstrip_blocks\"]\n        mopts[\"jinja_trim_blocks\"] = self.opts[\"jinja_trim_blocks\"]\n        return mopts\n\n    def _mine_get(self, load):\n        \"\"\"\n        Gathers the data from the specified minions' mine\n\n        :param dict load: A payload received from a minion\n\n        :rtype: dict\n        :return: Mine data from the specified minions\n        \"\"\"\n        load = self.__verify_load(load, (\"id\", \"tgt\", \"fun\", \"tok\"))\n        if load is False:\n            return {}\n        else:\n            return self.masterapi._mine_get(load, skip_verify=True)\n\n    def _mine(self, load):\n        \"\"\"\n        Store the mine data\n\n        :param dict load: A payload received from a minion\n\n        :rtype: bool\n        :return: True if the data has been stored in the mine\n        \"\"\"\n        load = self.__verify_load(load, (\"id\", \"data\", \"tok\"))\n        if load is False:\n            return {}\n        return self.masterapi._mine(load, skip_verify=True)\n\n    def _mine_delete(self, load):\n        \"\"\"\n        Allow the minion to delete a specific function from its own mine\n\n        :param dict load: A payload received from a minion\n\n        :rtype: bool\n        :return: Boolean indicating whether or not the given function was deleted from the mine\n        \"\"\"\n        load = self.__verify_load(load, (\"id\", \"fun\", \"tok\"))\n        if load is False:\n            return {}\n        else:\n            return self.masterapi._mine_delete(load)\n\n    def _mine_flush(self, load):\n        \"\"\"\n        Allow the minion to delete all of its own mine contents\n\n        :param dict load: A payload received from a minion\n        \"\"\"\n        load = self.__verify_load(load, (\"id\", \"tok\"))\n        if load is False:\n            return {}\n        else:\n            return self.masterapi._mine_flush(load, skip_verify=True)\n\n    def _file_recv(self, load):\n        \"\"\"\n        Allows minions to send files to the master, files are sent to the\n        master file cache\n        \"\"\"\n        if any(key not in load for key in (\"id\", \"path\", \"loc\")):\n            return False\n        if not isinstance(load[\"path\"], list):\n            return False\n        if not self.opts[\"file_recv\"]:\n            return False\n        if not salt.utils.verify.valid_id(self.opts, load[\"id\"]):\n            return False\n        file_recv_max_size = 1024 * 1024 * self.opts[\"file_recv_max_size\"]\n\n        if \"loc\" in load and load[\"loc\"] < 0:\n            log.error(\"Invalid file pointer: load[loc] < 0\")\n            return False\n\n        if len(load[\"data\"]) + load.get(\"loc\", 0) > file_recv_max_size:\n            log.error(\n                \"file_recv_max_size limit of %d MB exceeded! %s will be \"\n                \"truncated. To successfully push this file, adjust \"\n                \"file_recv_max_size to an integer (in MB) large enough to \"\n                \"accommodate it.\",\n                file_recv_max_size,\n                load[\"path\"],\n            )\n            return False\n        if \"tok\" not in load:\n            log.error(\n                \"Received incomplete call from %s for '%s', missing '%s'\",\n                load[\"id\"],\n                inspect_stack()[\"co_name\"],\n                \"tok\",\n            )\n            return False\n        if not self.__verify_minion(load[\"id\"], load[\"tok\"]):\n            # The minion is not who it says it is!\n            # We don't want to listen to it!\n            log.warning(\"Minion id %s is not who it says it is!\", load[\"id\"])\n            return {}\n        load.pop(\"tok\")\n\n        # Join path\n        sep_path = os.sep.join(load[\"path\"])\n\n        # Path normalization should have been done by the sending\n        # minion but we can't guarantee it. Re-do it here.\n        normpath = os.path.normpath(sep_path)\n\n        # Ensure that this safety check is done after the path\n        # have been normalized.\n        if os.path.isabs(normpath) or \"../\" in load[\"path\"]:\n            # Can overwrite master files!!\n            return False\n\n        rpath = os.path.join(self.opts[\"cachedir\"], \"minions\", load[\"id\"], \"files\")\n        cpath = os.path.join(rpath, normpath)\n        # One last safety check here\n        if not salt.utils.verify.clean_path(rpath, cpath):\n            log.warning(\n                \"Attempt to write received file outside of master cache \"\n                \"directory! Requested path: %s. Access denied.\",\n                cpath,\n            )\n            return False\n        cdir = os.path.dirname(cpath)\n        if not os.path.isdir(cdir):\n            try:\n                os.makedirs(cdir)\n            except OSError:\n                pass\n        if os.path.isfile(cpath) and load[\"loc\"] != 0:\n            mode = \"ab\"\n        else:\n            mode = \"wb\"\n        with salt.utils.files.fopen(cpath, mode) as fp_:\n            if load[\"loc\"]:\n                fp_.seek(load[\"loc\"])\n\n            fp_.write(salt.utils.stringutils.to_bytes(load[\"data\"]))\n        return True\n\n    def _pillar(self, load):\n        \"\"\"\n        Return the pillar data for the minion\n\n        :param dict load: Minion payload\n\n        :rtype: dict\n        :return: The pillar data for the minion\n        \"\"\"\n        if any(key not in load for key in (\"id\", \"grains\")):\n            return False\n        if not salt.utils.verify.valid_id(self.opts, load[\"id\"]):\n            return False\n        load[\"grains\"][\"id\"] = load[\"id\"]\n\n        pillar = salt.pillar.get_pillar(\n            self.opts,\n            load[\"grains\"],\n            load[\"id\"],\n            load.get(\"saltenv\", load.get(\"env\")),\n            ext=load.get(\"ext\"),\n            pillar_override=load.get(\"pillar_override\", {}),\n            pillarenv=load.get(\"pillarenv\"),\n            extra_minion_data=load.get(\"extra_minion_data\"),\n            clean_cache=load.get(\"clean_cache\"),\n        )\n        data = pillar.compile_pillar()\n        self.fs_.update_opts()\n        if self.opts.get(\"minion_data_cache\", False):\n            self.masterapi.cache.store(\n                \"minions/{}\".format(load[\"id\"]),\n                \"data\",\n                {\"grains\": load[\"grains\"], \"pillar\": data},\n            )\n            if self.opts.get(\"minion_data_cache_events\") is True:\n                self.event.fire_event(\n                    {\"Minion data cache refresh\": load[\"id\"]},\n                    tagify(load[\"id\"], \"refresh\", \"minion\"),\n                )\n        return data\n\n    def _minion_event(self, load):\n        \"\"\"\n        Receive an event from the minion and fire it on the master event\n        interface\n\n        :param dict load: The minion payload\n        \"\"\"\n        load = self.__verify_load(load, (\"id\", \"tok\"))\n        if load is False:\n            return {}\n        # Route to master event bus\n        self.masterapi._minion_event(load)\n        # Process locally\n        self._handle_minion_event(load)\n\n    def _handle_minion_event(self, load):\n        \"\"\"\n        Act on specific events from minions\n        \"\"\"\n        id_ = load[\"id\"]\n        if load.get(\"tag\", \"\") == \"_salt_error\":\n            log.error(\n                \"Received minion error from [%s]: %s\", id_, load[\"data\"][\"message\"]\n            )\n\n        for event in load.get(\"events\", []):\n            event_data = event.get(\"data\", {})\n            if \"minions\" in event_data:\n                jid = event_data.get(\"jid\")\n                if not jid:\n                    continue\n                minions = event_data[\"minions\"]\n                try:\n                    salt.utils.job.store_minions(\n                        self.opts, jid, minions, mminion=self.mminion, syndic_id=id_\n                    )\n                except (KeyError, salt.exceptions.SaltCacheError) as exc:\n                    log.error(\n                        \"Could not add minion(s) %s for job %s: %s\", minions, jid, exc\n                    )\n\n    def _return(self, load):\n        \"\"\"\n        Handle the return data sent from the minions.\n\n        Takes the return, verifies it and fires it on the master event bus.\n        Typically, this event is consumed by the Salt CLI waiting on the other\n        end of the event bus but could be heard by any listener on the bus.\n\n        :param dict load: The minion payload\n        \"\"\"\n        if self.opts[\"require_minion_sign_messages\"] and \"sig\" not in load:\n            log.critical(\n                \"_return: Master is requiring minions to sign their \"\n                \"messages, but there is no signature in this payload from \"\n                \"%s.\",\n                load[\"id\"],\n            )\n            return False\n\n        if \"sig\" in load:\n            log.trace(\"Verifying signed event publish from minion\")\n            sig = load.pop(\"sig\")\n            this_minion_pubkey = salt.utils.clean_join(\n                self.opts[\"pki_dir\"], \"minions\", load[\"id\"]\n            )\n            serialized_load = salt.serializers.msgpack.serialize(load)\n            if not salt.crypt.verify_signature(\n                this_minion_pubkey, serialized_load, sig\n            ):\n                log.info(\"Failed to verify event signature from minion %s.\", load[\"id\"])\n                if self.opts[\"drop_messages_signature_fail\"]:\n                    log.critical(\n                        \"drop_messages_signature_fail is enabled, dropping \"\n                        \"message from %s\",\n                        load[\"id\"],\n                    )\n                    return False\n                else:\n                    log.info(\n                        \"But 'drop_message_signature_fail' is disabled, so message is\"\n                        \" still accepted.\"\n                    )\n            load[\"sig\"] = sig\n\n        try:\n            salt.utils.job.store_job(\n                self.opts, load, event=self.event, mminion=self.mminion\n            )\n        except salt.exceptions.SaltCacheError:\n            log.error(\"Could not store job information for load: %s\", load)\n\n    def _syndic_return(self, load):\n        \"\"\"\n        Receive a syndic minion return and format it to look like returns from\n        individual minions.\n\n        :param dict load: The minion payload\n        \"\"\"\n        loads = load.get(\"load\")\n        if not isinstance(loads, list):\n            loads = [load]  # support old syndics not aggregating returns\n        for load in loads:\n            # Verify the load\n            if any(key not in load for key in (\"return\", \"jid\", \"id\")):\n                continue\n            # if we have a load, save it\n            if load.get(\"load\") and self.opts[\"master_job_cache\"]:\n                fstr = \"{}.save_load\".format(self.opts[\"master_job_cache\"])\n                self.mminion.returners[fstr](load[\"jid\"], load[\"load\"])\n\n            # Register the syndic\n\n            # We are creating a path using user suplied input. Use the\n            # clean_path to prevent a directory traversal.\n            root = os.path.join(self.opts[\"cachedir\"], \"syndics\")\n            syndic_cache_path = os.path.join(\n                self.opts[\"cachedir\"], \"syndics\", load[\"id\"]\n            )\n            if salt.utils.verify.clean_path(\n                root, syndic_cache_path\n            ) and not os.path.exists(syndic_cache_path):\n                path_name = os.path.split(syndic_cache_path)[0]\n                if not os.path.exists(path_name):\n                    os.makedirs(path_name)\n                with salt.utils.files.fopen(syndic_cache_path, \"w\") as wfh:\n                    wfh.write(\"\")\n\n            # Format individual return loads\n            for key, item in load[\"return\"].items():\n                ret = {\"jid\": load[\"jid\"], \"id\": key}\n                ret.update(item)\n                if \"master_id\" in load:\n                    ret[\"master_id\"] = load[\"master_id\"]\n                if \"fun\" in load:\n                    ret[\"fun\"] = load[\"fun\"]\n                if \"fun_args\" in load:\n                    ret[\"fun_args\"] = load[\"fun_args\"]\n                if \"out\" in load:\n                    ret[\"out\"] = load[\"out\"]\n                if \"sig\" in load:\n                    ret[\"sig\"] = load[\"sig\"]\n                self._return(ret)\n\n    def minion_runner(self, clear_load):\n        \"\"\"\n        Execute a runner from a minion, return the runner's function data\n\n        :param dict clear_load: The minion payload\n\n        :rtype: dict\n        :return: The runner function data\n        \"\"\"\n        load = self.__verify_load(clear_load, (\"fun\", \"arg\", \"id\", \"tok\"))\n        if load is False:\n            return {}\n        else:\n            return self.masterapi.minion_runner(clear_load)\n\n    def pub_ret(self, load):\n        \"\"\"\n        Request the return data from a specific jid, only allowed\n        if the requesting minion also initiated the execution.\n\n        :param dict load: The minion payload\n\n        :rtype: dict\n        :return: Return data corresponding to a given JID\n        \"\"\"\n        load = self.__verify_load(load, (\"jid\", \"id\", \"tok\"))\n        if load is False:\n            return {}\n        # Check that this minion can access this data\n        auth_cache = os.path.join(self.opts[\"cachedir\"], \"publish_auth\")\n        if not os.path.isdir(auth_cache):\n            os.makedirs(auth_cache)\n        jid_fn = salt.utils.verify.clean_join(auth_cache, str(load[\"jid\"]))\n        with salt.utils.files.fopen(jid_fn, \"r\") as fp_:\n            if not load[\"id\"] == fp_.read():\n                return {}\n        # Grab the latest and return\n        return self.local.get_cache_returns(load[\"jid\"])\n\n    def minion_pub(self, clear_load):\n        \"\"\"\n        Publish a command initiated from a minion, this method executes minion\n        restrictions so that the minion publication will only work if it is\n        enabled in the config.\n\n        The configuration on the master allows minions to be matched to\n        salt functions, so the minions can only publish allowed salt functions\n\n        The config will look like this:\n\n        .. code-block:: bash\n\n            peer:\n                .*:\n                    - .*\n\n        This configuration will enable all minions to execute all commands:\n\n        .. code-block:: bash\n\n            peer:\n                foo.example.com:\n                    - test.*\n\n        The above configuration will only allow the minion foo.example.com to\n        execute commands from the test module.\n\n        :param dict clear_load: The minion pay\n        \"\"\"\n        if not self.__verify_minion_publish(clear_load):\n            return {}\n        else:\n            return self.masterapi.minion_pub(clear_load)\n\n    def minion_publish(self, clear_load):\n        \"\"\"\n        Publish a command initiated from a minion, this method executes minion\n        restrictions so that the minion publication will only work if it is\n        enabled in the config.\n\n        The configuration on the master allows minions to be matched to\n        salt functions, so the minions can only publish allowed salt functions\n\n        The config will look like this:\n\n        .. code-block:: bash\n\n            peer:\n                .*:\n                    - .*\n\n        This configuration will enable all minions to execute all commands.\n        peer:\n\n        .. code-block:: bash\n\n            foo.example.com:\n                - test.*\n\n        The above configuration will only allow the minion foo.example.com to\n        execute commands from the test module.\n\n        :param dict clear_load: The minion payload\n        \"\"\"\n        if not self.__verify_minion_publish(clear_load):\n            return {}\n        else:\n            return self.masterapi.minion_publish(clear_load)\n\n    def revoke_auth(self, load):\n        \"\"\"\n        Allow a minion to request revocation of its own key\n\n        :param dict load: The minion payload\n\n        :rtype: dict\n        :return: If the load is invalid, it may be returned. No key operation is performed.\n\n        :rtype: bool\n        :return: True if key was revoked, False if not\n        \"\"\"\n        load = self.__verify_load(load, (\"id\", \"tok\"))\n\n        if not self.opts.get(\"allow_minion_key_revoke\", False):\n            log.warning(\n                \"Minion %s requested key revoke, but allow_minion_key_revoke \"\n                \"is set to False\",\n                load[\"id\"],\n            )\n            return load\n\n        if load is False:\n            return load\n        else:\n            return self.masterapi.revoke_auth(load)\n\n    def run_func(self, func, load):\n        \"\"\"\n        Wrapper for running functions executed with AES encryption\n\n        :param function func: The function to run\n        :return: The result of the master function that was called\n        \"\"\"\n        # Don't honor private functions\n        if func.startswith(\"__\"):\n            # TODO: return some error? Seems odd to return {}\n            return {}, {\"fun\": \"send\"}\n        # Run the func\n        if hasattr(self, func):\n            try:\n                start = time.time()\n                ret = getattr(self, func)(load)\n                log.trace(\n                    \"Master function call %s took %s seconds\", func, time.time() - start\n                )\n            except Exception:  # pylint: disable=broad-except\n                ret = \"\"\n                log.error(\"Error in function %s:\\n\", func, exc_info=True)\n        else:\n            log.error(\n                \"Received function %s which is unavailable on the master, \"\n                \"returning False\",\n                func,\n            )\n            return False, {\"fun\": \"send\"}\n        # Don't encrypt the return value for the _return func\n        # (we don't care about the return value, so why encrypt it?)\n        if func == \"_return\":\n            return ret, {\"fun\": \"send\"}\n        if func == \"_pillar\" and \"id\" in load:\n            if load.get(\"ver\") != \"2\" and self.opts[\"pillar_version\"] == 1:\n                # Authorized to return old pillar proto\n                return ret, {\"fun\": \"send\"}\n            return ret, {\"fun\": \"send_private\", \"key\": \"pillar\", \"tgt\": load[\"id\"]}\n        # Encrypt the return\n        return ret, {\"fun\": \"send\"}\n\n    def destroy(self):\n        self.masterapi.destroy()\n        if self.local is not None:\n            self.local.destroy()\n            self.local = None\n\n\nclass ClearFuncs(TransportMethods):\n    \"\"\"\n    Set up functions that are safe to execute when commands sent to the master\n    without encryption and authentication\n    \"\"\"\n\n    # These methods will be exposed to the transport layer by\n    # MWorker._handle_clear\n    expose_methods = (\n        \"ping\",\n        \"publish\",\n        \"get_token\",\n        \"mk_token\",\n        \"wheel\",\n        \"runner\",\n    )\n\n    # The ClearFuncs object encapsulates the functions that can be executed in\n    # the clear:\n    # publish (The publish from the LocalClient)\n    # _auth\n    def __init__(self, opts, key):\n        self.opts = opts\n        self.key = key\n        # Create the event manager\n        self.event = salt.utils.event.get_master_event(\n            self.opts, self.opts[\"sock_dir\"], listen=False\n        )\n        # Make a client\n        self.local = salt.client.get_local_client(self.opts[\"conf_file\"])\n        # Make an minion checker object\n        self.ckminions = salt.utils.minions.CkMinions(opts)\n        # Make an Auth object\n        self.loadauth = salt.auth.LoadAuth(opts)\n        # Stand up the master Minion to access returner data\n        self.mminion = salt.minion.MasterMinion(\n            self.opts, states=False, rend=False, ignore_config_errors=True\n        )\n        # Make a wheel object\n        self.wheel_ = salt.wheel.Wheel(opts)\n        # Make a masterapi object\n        self.masterapi = salt.daemons.masterapi.LocalFuncs(opts, key)\n        self.channels = []\n\n    def runner(self, clear_load):\n        \"\"\"\n        Send a master control function back to the runner system\n        \"\"\"\n        # All runner ops pass through eauth\n        auth_type, err_name, key, sensitive_load_keys = self._prep_auth_info(clear_load)\n\n        # Authenticate\n        auth_check = self.loadauth.check_authentication(clear_load, auth_type, key=key)\n        error = auth_check.get(\"error\")\n\n        if error:\n            # Authentication error occurred: do not continue.\n            return {\"error\": error}\n\n        # Authorize\n        username = auth_check.get(\"username\")\n        if auth_type != \"user\":\n            runner_check = self.ckminions.runner_check(\n                auth_check.get(\"auth_list\", []),\n                clear_load[\"fun\"],\n                clear_load.get(\"kwarg\", {}),\n            )\n            if not runner_check:\n                return {\n                    \"error\": {\n                        \"name\": err_name,\n                        \"message\": (\n                            'Authentication failure of type \"{}\" occurred for '\n                            \"user {}.\".format(auth_type, username)\n                        ),\n                    }\n                }\n            elif isinstance(runner_check, dict) and \"error\" in runner_check:\n                # A dictionary with an error name/message was handled by ckminions.runner_check\n                return runner_check\n\n            # No error occurred, consume sensitive settings from the clear_load if passed.\n            for item in sensitive_load_keys:\n                clear_load.pop(item, None)\n        else:\n            if \"user\" in clear_load:\n                username = clear_load[\"user\"]\n                if salt.auth.AuthUser(username).is_sudo():\n                    username = self.opts.get(\"user\", \"root\")\n            else:\n                username = salt.utils.user.get_user()\n\n        # Authorized. Do the job!\n        try:\n            fun = clear_load.pop(\"fun\")\n            runner_client = salt.runner.RunnerClient(self.opts)\n            return runner_client.asynchronous(\n                fun, clear_load.get(\"kwarg\", {}), username, local=True\n            )\n        except Exception as exc:  # pylint: disable=broad-except\n            log.error(\"Exception occurred while introspecting %s: %s\", fun, exc)\n            return {\n                \"error\": {\n                    \"name\": exc.__class__.__name__,\n                    \"args\": exc.args,\n                    \"message\": str(exc),\n                }\n            }\n\n    def wheel(self, clear_load):\n        \"\"\"\n        Send a master control function back to the wheel system\n        \"\"\"\n        # All wheel ops pass through eauth\n        auth_type, err_name, key, sensitive_load_keys = self._prep_auth_info(clear_load)\n\n        # Authenticate\n        auth_check = self.loadauth.check_authentication(clear_load, auth_type, key=key)\n        error = auth_check.get(\"error\")\n\n        if error:\n            # Authentication error occurred: do not continue.\n            return {\"error\": error}\n\n        # Authorize\n        username = auth_check.get(\"username\")\n        if auth_type != \"user\":\n            wheel_check = self.ckminions.wheel_check(\n                auth_check.get(\"auth_list\", []),\n                clear_load[\"fun\"],\n                clear_load.get(\"kwarg\", {}),\n            )\n            if not wheel_check:\n                return {\n                    \"error\": {\n                        \"name\": err_name,\n                        \"message\": (\n                            'Authentication failure of type \"{}\" occurred for '\n                            \"user {}.\".format(auth_type, username)\n                        ),\n                    }\n                }\n            elif isinstance(wheel_check, dict) and \"error\" in wheel_check:\n                # A dictionary with an error name/message was handled by ckminions.wheel_check\n                return wheel_check\n\n            # No error occurred, consume sensitive settings from the clear_load if passed.\n            for item in sensitive_load_keys:\n                clear_load.pop(item, None)\n        else:\n            if \"user\" in clear_load:\n                username = clear_load[\"user\"]\n                if salt.auth.AuthUser(username).is_sudo():\n                    username = self.opts.get(\"user\", \"root\")\n            else:\n                username = salt.utils.user.get_user()\n\n        # Authorized. Do the job!\n        try:\n            jid = salt.utils.jid.gen_jid(self.opts)\n            fun = clear_load.pop(\"fun\")\n            tag = tagify(jid, prefix=\"wheel\")\n            data = {\n                \"fun\": f\"wheel.{fun}\",\n                \"jid\": jid,\n                \"tag\": tag,\n                \"user\": username,\n            }\n\n            self.event.fire_event(data, tagify([jid, \"new\"], \"wheel\"))\n            ret = self.wheel_.call_func(fun, full_return=True, **clear_load)\n            data[\"return\"] = ret[\"return\"]\n            data[\"success\"] = ret[\"success\"]\n            self.event.fire_event(data, tagify([jid, \"ret\"], \"wheel\"))\n            return {\"tag\": tag, \"data\": data}\n        except Exception as exc:  # pylint: disable=broad-except\n            log.error(\"Exception occurred while introspecting %s: %s\", fun, exc)\n            data[\"return\"] = \"Exception occurred in wheel {}: {}: {}\".format(\n                fun,\n                exc.__class__.__name__,\n                exc,\n            )\n            data[\"success\"] = False\n            self.event.fire_event(data, tagify([jid, \"ret\"], \"wheel\"))\n            return {\"tag\": tag, \"data\": data}\n\n    def mk_token(self, clear_load):\n        \"\"\"\n        Create and return an authentication token, the clear load needs to\n        contain the eauth key and the needed authentication creds.\n        \"\"\"\n        token = self.loadauth.mk_token(clear_load)\n        if not token:\n            log.warning('Authentication failure of type \"eauth\" occurred.')\n            return \"\"\n        return token\n\n    def get_token(self, clear_load):\n        \"\"\"\n        Return the name associated with a token or False if the token is invalid\n        \"\"\"\n        if \"token\" not in clear_load:\n            return False\n        return self.loadauth.get_tok(clear_load[\"token\"])\n\n    def publish(self, clear_load):\n        \"\"\"\n        This method sends out publications to the minions, it can only be used\n        by the LocalClient.\n        \"\"\"\n        extra = clear_load.get(\"kwargs\", {})\n\n        publisher_acl = salt.acl.PublisherACL(self.opts[\"publisher_acl_blacklist\"])\n\n        if publisher_acl.user_is_blacklisted(\n            clear_load[\"user\"]\n        ) or publisher_acl.cmd_is_blacklisted(clear_load[\"fun\"]):\n            log.error(\n                \"%s does not have permissions to run %s. Please contact \"\n                \"your local administrator if you believe this is in \"\n                \"error.\\n\",\n                clear_load[\"user\"],\n                clear_load[\"fun\"],\n            )\n            return {\n                \"error\": {\n                    \"name\": \"AuthorizationError\",\n                    \"message\": \"Authorization error occurred.\",\n                }\n            }\n\n        # Retrieve the minions list\n        delimiter = extra.get(\"delimiter\", DEFAULT_TARGET_DELIM)\n\n        _res = self.ckminions.check_minions(\n            clear_load[\"tgt\"], clear_load.get(\"tgt_type\", \"glob\"), delimiter\n        )\n        minions = _res.get(\"minions\", list())\n        missing = _res.get(\"missing\", list())\n        ssh_minions = _res.get(\"ssh_minions\", False)\n\n        auth_key = clear_load.get(\"key\", None)\n\n        # Check for external auth calls and authenticate\n        auth_type, err_name, key, sensitive_load_keys = self._prep_auth_info(extra)\n        if auth_type == \"user\":\n            auth_check = self.loadauth.check_authentication(\n                clear_load, auth_type, key=key\n            )\n        else:\n            auth_check = self.loadauth.check_authentication(extra, auth_type)\n\n        # Setup authorization list\n        syndic_auth_list = None\n        if \"auth_list\" in extra:\n            syndic_auth_list = extra.pop(\"auth_list\", [])\n        # An auth_list was provided by the syndic and we're running as the same\n        # user as the salt master process.\n        if (\n            syndic_auth_list is not None\n            and auth_key == key[self.opts.get(\"user\", \"root\")]\n        ):\n            auth_list = syndic_auth_list\n        else:\n            auth_list = auth_check.get(\"auth_list\", [])\n\n        err_msg = f'Authentication failure of type \"{auth_type}\" occurred.'\n\n        if auth_check.get(\"error\"):\n            # Authentication error occurred: do not continue.\n            log.warning(err_msg)\n            err = {\n                \"error\": {\n                    \"name\": \"AuthenticationError\",\n                    \"message\": \"Authentication error occurred.\",\n                }\n            }\n            if \"jid\" in clear_load:\n                self.event.fire_event(\n                    {**clear_load, **err}, tagify([clear_load[\"jid\"], \"error\"], \"job\")\n                )\n            return err\n        # All Token, Eauth, and non-root users must pass the authorization check\n        if auth_type != \"user\" or (auth_type == \"user\" and auth_list):\n            # Authorize the request\n            authorized = self.ckminions.auth_check(\n                auth_list,\n                clear_load[\"fun\"],\n                clear_load[\"arg\"],\n                clear_load[\"tgt\"],\n                clear_load.get(\"tgt_type\", \"glob\"),\n                minions=minions,\n                # always accept find_job\n                whitelist=[\"saltutil.find_job\"],\n            )\n\n            if not authorized:\n                # Authorization error occurred. Do not continue.\n                if (\n                    auth_type == \"eauth\"\n                    and not auth_list\n                    and \"username\" in extra\n                    and \"eauth\" in extra\n                ):\n                    log.debug(\n                        'Auth configuration for eauth \"%s\" and user \"%s\" is empty',\n                        extra[\"eauth\"],\n                        extra[\"username\"],\n                    )\n                log.warning(err_msg)\n                err = {\n                    \"error\": {\n                        \"name\": \"AuthorizationError\",\n                        \"message\": \"Authorization error occurred.\",\n                    }\n                }\n                if \"jid\" in clear_load:\n                    self.event.fire_event(\n                        {**clear_load, **err},\n                        tagify([clear_load[\"jid\"], \"error\"], \"job\"),\n                    )\n                return err\n\n            # Perform some specific auth_type tasks after the authorization check\n            if auth_type == \"token\":\n                username = auth_check.get(\"username\")\n                clear_load[\"user\"] = username\n                log.debug('Minion tokenized user = \"%s\"', username)\n            elif auth_type == \"eauth\":\n                # The username we are attempting to auth with\n                clear_load[\"user\"] = self.loadauth.load_name(extra)\n\n        # If we order masters (via a syndic), don't short circuit if no minions\n        # are found\n        if not self.opts.get(\"order_masters\"):\n            # Check for no minions\n            if not minions:\n                return {\n                    \"enc\": \"clear\",\n                    \"load\": {\n                        \"jid\": None,\n                        \"minions\": minions,\n                        \"error\": (\n                            \"Master could not resolve minions for target {}\".format(\n                                clear_load[\"tgt\"]\n                            )\n                        ),\n                    },\n                }\n        jid = self._prep_jid(clear_load, extra)\n        if jid is None:\n            return {\"enc\": \"clear\", \"load\": {\"error\": \"Master failed to assign jid\"}}\n        payload = self._prep_pub(minions, jid, clear_load, extra, missing)\n\n        if self.opts.get(\"order_masters\"):\n            payload[\"auth_list\"] = auth_list\n\n        # Send it!\n        self._send_ssh_pub(payload, ssh_minions=ssh_minions)\n        self._send_pub(payload)\n\n        return {\n            \"enc\": \"clear\",\n            \"load\": {\"jid\": clear_load[\"jid\"], \"minions\": minions, \"missing\": missing},\n        }\n\n    def _prep_auth_info(self, clear_load):\n        sensitive_load_keys = []\n        key = None\n        if \"token\" in clear_load:\n            auth_type = \"token\"\n            err_name = \"TokenAuthenticationError\"\n            sensitive_load_keys = [\"token\"]\n        elif \"eauth\" in clear_load:\n            auth_type = \"eauth\"\n            err_name = \"EauthAuthenticationError\"\n            sensitive_load_keys = [\"username\", \"password\"]\n        else:\n            auth_type = \"user\"\n            err_name = \"UserAuthenticationError\"\n            key = self.key\n\n        return auth_type, err_name, key, sensitive_load_keys\n\n    def _prep_jid(self, clear_load, extra):\n        \"\"\"\n        Return a jid for this publication\n        \"\"\"\n        # the jid in clear_load can be None, '', or something else. this is an\n        # attempt to clean up the value before passing to plugins\n        passed_jid = clear_load[\"jid\"] if clear_load.get(\"jid\") else None\n        nocache = extra.get(\"nocache\", False)\n\n        # Retrieve the jid\n        fstr = \"{}.prep_jid\".format(self.opts[\"master_job_cache\"])\n        try:\n            # Retrieve the jid\n            jid = self.mminion.returners[fstr](nocache=nocache, passed_jid=passed_jid)\n        except (KeyError, TypeError):\n            # The returner is not present\n            msg = (\n                \"Failed to allocate a jid. The requested returner '{}' \"\n                \"could not be loaded.\".format(fstr.split(\".\")[0])\n            )\n            log.error(msg)\n            return {\"error\": msg}\n        return jid\n\n    def _send_pub(self, load):\n        \"\"\"\n        Take a load and send it across the network to connected minions\n        \"\"\"\n        if not self.channels:\n            for transport, opts in iter_transport_opts(self.opts):\n                chan = salt.channel.server.PubServerChannel.factory(opts)\n                self.channels.append(chan)\n        for chan in self.channels:\n            chan.publish(load)\n\n    @property\n    def ssh_client(self):\n        if not hasattr(self, \"_ssh_client\"):\n            self._ssh_client = salt.client.ssh.client.SSHClient(mopts=self.opts)\n        return self._ssh_client\n\n    def _send_ssh_pub(self, load, ssh_minions=False):\n        \"\"\"\n        Take a load and send it across the network to ssh minions\n        \"\"\"\n        if self.opts[\"enable_ssh_minions\"] is True and ssh_minions is True:\n            log.debug(\"Send payload to ssh minions\")\n            threading.Thread(target=self.ssh_client.cmd, kwargs=load).start()\n\n    def _prep_pub(self, minions, jid, clear_load, extra, missing):\n        \"\"\"\n        Take a given load and perform the necessary steps\n        to prepare a publication.\n\n        TODO: This is really only bound by temporal cohesion\n        and thus should be refactored even further.\n        \"\"\"\n        clear_load[\"jid\"] = jid\n        delimiter = clear_load.get(\"kwargs\", {}).get(\"delimiter\", DEFAULT_TARGET_DELIM)\n\n        # TODO Error reporting over the master event bus\n        self.event.fire_event({\"minions\": minions}, clear_load[\"jid\"])\n        new_job_load = {\n            \"jid\": clear_load[\"jid\"],\n            \"tgt_type\": clear_load[\"tgt_type\"],\n            \"tgt\": clear_load[\"tgt\"],\n            \"user\": clear_load[\"user\"],\n            \"fun\": clear_load[\"fun\"],\n            \"arg\": clear_load[\"arg\"],\n            \"minions\": minions,\n            \"missing\": missing,\n        }\n\n        # Announce the job on the event bus\n        self.event.fire_event(new_job_load, tagify([clear_load[\"jid\"], \"new\"], \"job\"))\n\n        if self.opts[\"ext_job_cache\"]:\n            fstr = \"{}.save_load\".format(self.opts[\"ext_job_cache\"])\n            save_load_func = True\n\n            # Get the returner's save_load arg_spec.\n            try:\n                arg_spec = salt.utils.args.get_function_argspec(\n                    self.mminion.returners[fstr]\n                )\n\n                # Check if 'minions' is included in returner's save_load arg_spec.\n                # This may be missing in custom returners, which we should warn about.\n                if \"minions\" not in arg_spec.args:\n                    log.critical(\n                        \"The specified returner used for the external job cache \"\n                        \"'%s' does not have a 'minions' kwarg in the returner's \"\n                        \"save_load function.\",\n                        self.opts[\"ext_job_cache\"],\n                    )\n            except (AttributeError, KeyError):\n                save_load_func = False\n                log.critical(\n                    \"The specified returner used for the external job cache \"\n                    '\"%s\" does not have a save_load function!',\n                    self.opts[\"ext_job_cache\"],\n                )\n\n            if save_load_func:\n                try:\n                    self.mminion.returners[fstr](\n                        clear_load[\"jid\"], clear_load, minions=minions\n                    )\n                except Exception:  # pylint: disable=broad-except\n                    log.critical(\n                        \"The specified returner threw a stack trace:\\n\", exc_info=True\n                    )\n\n        # always write out to the master job caches\n        try:\n            fstr = \"{}.save_load\".format(self.opts[\"master_job_cache\"])\n            self.mminion.returners[fstr](clear_load[\"jid\"], clear_load, minions)\n        except KeyError:\n            log.critical(\n                \"The specified returner used for the master job cache \"\n                '\"%s\" does not have a save_load function!',\n                self.opts[\"master_job_cache\"],\n            )\n        except Exception:  # pylint: disable=broad-except\n            log.critical(\"The specified returner threw a stack trace:\\n\", exc_info=True)\n        # Set up the payload\n        payload = {\"enc\": \"aes\"}\n        # Altering the contents of the publish load is serious!! Changes here\n        # break compatibility with minion/master versions and even tiny\n        # additions can have serious implications on the performance of the\n        # publish commands.\n        #\n        # In short, check with Thomas Hatch before you even think about\n        # touching this stuff, we can probably do what you want to do another\n        # way that won't have a negative impact.\n        load = {\n            \"fun\": clear_load[\"fun\"],\n            \"arg\": clear_load[\"arg\"],\n            \"tgt\": clear_load[\"tgt\"],\n            \"jid\": clear_load[\"jid\"],\n            \"ret\": clear_load[\"ret\"],\n        }\n        # if you specified a master id, lets put that in the load\n        if \"master_id\" in self.opts:\n            load[\"master_id\"] = self.opts[\"master_id\"]\n        # if someone passed us one, use that\n        if \"master_id\" in extra:\n            load[\"master_id\"] = extra[\"master_id\"]\n        # Only add the delimiter to the pub data if it is non-default\n        if delimiter != DEFAULT_TARGET_DELIM:\n            load[\"delimiter\"] = delimiter\n\n        if \"id\" in extra:\n            load[\"id\"] = extra[\"id\"]\n        if \"tgt_type\" in clear_load:\n            load[\"tgt_type\"] = clear_load[\"tgt_type\"]\n        if \"to\" in clear_load:\n            load[\"to\"] = clear_load[\"to\"]\n\n        if \"kwargs\" in clear_load:\n            if \"ret_config\" in clear_load[\"kwargs\"]:\n                load[\"ret_config\"] = clear_load[\"kwargs\"].get(\"ret_config\")\n\n            if \"metadata\" in clear_load[\"kwargs\"]:\n                load[\"metadata\"] = clear_load[\"kwargs\"].get(\"metadata\")\n\n            if \"module_executors\" in clear_load[\"kwargs\"]:\n                load[\"module_executors\"] = clear_load[\"kwargs\"].get(\"module_executors\")\n\n            if \"executor_opts\" in clear_load[\"kwargs\"]:\n                load[\"executor_opts\"] = clear_load[\"kwargs\"].get(\"executor_opts\")\n\n            if \"ret_kwargs\" in clear_load[\"kwargs\"]:\n                load[\"ret_kwargs\"] = clear_load[\"kwargs\"].get(\"ret_kwargs\")\n\n        if \"user\" in clear_load:\n            log.info(\n                \"User %s Published command %s with jid %s\",\n                clear_load[\"user\"],\n                clear_load[\"fun\"],\n                clear_load[\"jid\"],\n            )\n            load[\"user\"] = clear_load[\"user\"]\n        else:\n            log.info(\n                \"Published command %s with jid %s\", clear_load[\"fun\"], clear_load[\"jid\"]\n            )\n        log.debug(\"Published command details %s\", load)\n        return load\n\n    def ping(self, clear_load):\n        \"\"\"\n        Send the load back to the sender.\n        \"\"\"\n        return clear_load\n\n    def destroy(self):\n        if self.masterapi is not None:\n            self.masterapi.destroy()\n            self.masterapi = None\n        if self.local is not None:\n            self.local.destroy()\n            self.local = None\n        while self.channels:\n            chan = self.channels.pop()\n            chan.close()\n\n    def connect(self):\n        if self.channels:\n            return\n        for transport, opts in iter_transport_opts(self.opts):\n            chan = salt.channel.server.PubServerChannel.factory(opts)\n            self.channels.append(chan)\n", "patch": "@@ -1269,7 +1269,7 @@ def __verify_minion(self, id_, token):\n         \"\"\"\n         if not salt.utils.verify.valid_id(self.opts, id_):\n             return False\n-        pub_path = os.path.join(self.opts[\"pki_dir\"], \"minions\", id_)\n+        pub_path = salt.utils.verify.clean_join(self.opts[\"pki_dir\"], \"minions\", id_)\n \n         try:\n             pub = salt.crypt.PublicKey(pub_path)\n@@ -1690,8 +1690,8 @@ def _return(self, load):\n         if \"sig\" in load:\n             log.trace(\"Verifying signed event publish from minion\")\n             sig = load.pop(\"sig\")\n-            this_minion_pubkey = os.path.join(\n-                self.opts[\"pki_dir\"], \"minions/{}\".format(load[\"id\"])\n+            this_minion_pubkey = salt.utils.clean_join(\n+                self.opts[\"pki_dir\"], \"minions\", load[\"id\"]\n             )\n             serialized_load = salt.serializers.msgpack.serialize(load)\n             if not salt.crypt.verify_signature(\n@@ -1803,7 +1803,7 @@ def pub_ret(self, load):\n         auth_cache = os.path.join(self.opts[\"cachedir\"], \"publish_auth\")\n         if not os.path.isdir(auth_cache):\n             os.makedirs(auth_cache)\n-        jid_fn = os.path.join(auth_cache, str(load[\"jid\"]))\n+        jid_fn = salt.utils.verify.clean_join(auth_cache, str(load[\"jid\"]))\n         with salt.utils.files.fopen(jid_fn, \"r\") as fp_:\n             if not load[\"id\"] == fp_.read():\n                 return {}"}
{"patches_id": 3, "files_id": 65, "language": "py", "raw_url": "https://github.com/saltstack/salt/raw/e39116fb87bf4db9bcb9aade8258c66df87d41fe/tests%2Fpytests%2Funit%2Ftest_master.py", "raw_code": "import pathlib\nimport time\n\nimport pytest\n\nimport salt.master\nimport salt.utils.files\nimport salt.utils.platform\nfrom tests.support.mock import patch\n\n\n@pytest.fixture\ndef encrypted_requests(tmp_path):\n    # To honor the comment on AESFuncs\n    (tmp_path / \"pki\").mkdir()\n    return salt.master.AESFuncs(\n        opts={\n            \"pki_dir\": str(tmp_path / \"pki\"),\n            \"cachedir\": str(tmp_path / \"cache\"),\n            \"sock_dir\": str(tmp_path / \"sock_drawer\"),\n            \"conf_file\": str(tmp_path / \"config.conf\"),\n            \"fileserver_backend\": [\"local\"],\n            \"master_job_cache\": False,\n        }\n    )\n\n\ndef test_maintenance_duration():\n    \"\"\"\n    Validate Maintenance process duration.\n    \"\"\"\n    opts = {\n        \"loop_interval\": 10,\n        \"maintenance_interval\": 1,\n        \"cachedir\": \"/tmp\",\n        \"sock_dir\": \"/tmp\",\n        \"maintenance_niceness\": 1,\n        \"key_cache\": \"sched\",\n        \"conf_file\": \"\",\n        \"master_job_cache\": \"\",\n        \"pki_dir\": \"/tmp\",\n        \"eauth_tokens\": \"\",\n    }\n    mp = salt.master.Maintenance(opts)\n    with patch(\"salt.utils.verify.check_max_open_files\") as check_files, patch.object(\n        mp, \"handle_key_cache\"\n    ) as handle_key_cache, patch(\"salt.daemons\") as salt_daemons, patch.object(\n        mp, \"handle_git_pillar\"\n    ) as handle_git_pillar:\n        mp.run()\n    assert salt_daemons.masterapi.clean_old_jobs.called\n    assert salt_daemons.masterapi.clean_expired_tokens.called\n    assert salt_daemons.masterapi.clean_pub_auth.called\n    assert handle_git_pillar.called\n\n\ndef test_fileserver_duration():\n    \"\"\"\n    Validate Fileserver process duration.\n    \"\"\"\n    with patch(\"salt.master.FileserverUpdate._do_update\") as update:\n        start = time.time()\n        salt.master.FileserverUpdate.update(1, {}, 1)\n        end = time.time()\n        # Interval is equal to timeout so the _do_update method will be called\n        # one time.\n        update.assert_called_once()\n        # Timeout is 1 second\n        duration = end - start\n        if duration > 2 and salt.utils.platform.spawning_platform():\n            # Give spawning platforms some slack\n            duration = round(duration, 1)\n        assert 2 > duration > 1\n\n\n@pytest.mark.parametrize(\n    \"expected_return, payload\",\n    (\n        (\n            {\n                \"jid\": \"20221107162714826470\",\n                \"id\": \"example-minion\",\n                \"return\": {\n                    \"pkg_|-linux-install-utils_|-curl_|-installed\": {\n                        \"name\": \"curl\",\n                        \"changes\": {},\n                        \"result\": True,\n                        \"comment\": \"All specified packages are already installed\",\n                        \"__sls__\": \"base-linux.base\",\n                        \"__run_num__\": 0,\n                        \"start_time\": \"08:27:17.594038\",\n                        \"duration\": 32.963,\n                        \"__id__\": \"linux-install-utils\",\n                    },\n                },\n                \"retcode\": 0,\n                \"success\": True,\n                \"fun_args\": [\"base-linux\", {\"pillar\": {\"test\": \"value\"}}],\n                \"fun\": \"state.sls\",\n                \"out\": \"highstate\",\n            },\n            {\n                \"cmd\": \"_syndic_return\",\n                \"load\": [\n                    {\n                        \"id\": \"aws.us-east-1.salt-syndic\",\n                        \"jid\": \"20221107162714826470\",\n                        \"fun\": \"state.sls\",\n                        \"arg\": None,\n                        \"tgt\": None,\n                        \"tgt_type\": None,\n                        \"load\": {\n                            \"arg\": [\n                                \"base-linux\",\n                                {\"pillar\": {\"test\": \"value\"}, \"__kwarg__\": True},\n                            ],\n                            \"cmd\": \"publish\",\n                            \"fun\": \"state.sls\",\n                            \"jid\": \"20221107162714826470\",\n                            \"ret\": \"\",\n                            \"tgt\": \"example-minion\",\n                            \"user\": \"sudo_ubuntu\",\n                            \"kwargs\": {\n                                \"show_jid\": False,\n                                \"delimiter\": \":\",\n                                \"show_timeout\": True,\n                            },\n                            \"tgt_type\": \"glob\",\n                        },\n                        \"return\": {\n                            \"example-minion\": {\n                                \"return\": {\n                                    \"pkg_|-linux-install-utils_|-curl_|-installed\": {\n                                        \"name\": \"curl\",\n                                        \"changes\": {},\n                                        \"result\": True,\n                                        \"comment\": \"All specified packages are already installed\",\n                                        \"__sls__\": \"base-linux.base\",\n                                        \"__run_num__\": 0,\n                                        \"start_time\": \"08:27:17.594038\",\n                                        \"duration\": 32.963,\n                                        \"__id__\": \"linux-install-utils\",\n                                    },\n                                },\n                                \"retcode\": 0,\n                                \"success\": True,\n                                \"fun_args\": [\n                                    \"base-linux\",\n                                    {\"pillar\": {\"test\": \"value\"}},\n                                ],\n                            }\n                        },\n                        \"out\": \"highstate\",\n                    }\n                ],\n                \"_stamp\": \"2022-11-07T16:27:17.965404\",\n            },\n        ),\n    ),\n)\ndef test_when_syndic_return_processes_load_then_correct_values_should_be_returned(\n    expected_return, payload, encrypted_requests\n):\n    with patch.object(encrypted_requests, \"_return\", autospec=True) as fake_return:\n        encrypted_requests._syndic_return(payload)\n        fake_return.assert_called_with(expected_return)\n\n\ndef test_syndic_return_cache_dir_creation(encrypted_requests):\n    \"\"\"master's cachedir for a syndic will be created by AESFuncs._syndic_return method\"\"\"\n    cachedir = pathlib.Path(encrypted_requests.opts[\"cachedir\"])\n    assert not (cachedir / \"syndics\").exists()\n    encrypted_requests._syndic_return(\n        {\n            \"id\": \"mamajama\",\n            \"jid\": \"\",\n            \"return\": {},\n        }\n    )\n    assert (cachedir / \"syndics\").exists()\n    assert (cachedir / \"syndics\" / \"mamajama\").exists()\n\n\ndef test_syndic_return_cache_dir_creation_traversal(encrypted_requests):\n    \"\"\"\n    master's  AESFuncs._syndic_return method cachdir creation is not vulnerable to a directory traversal\n    \"\"\"\n    cachedir = pathlib.Path(encrypted_requests.opts[\"cachedir\"])\n    assert not (cachedir / \"syndics\").exists()\n    encrypted_requests._syndic_return(\n        {\n            \"id\": \"../mamajama\",\n            \"jid\": \"\",\n            \"return\": {},\n        }\n    )\n    assert not (cachedir / \"syndics\").exists()\n    assert not (cachedir / \"mamajama\").exists()\n\n\ndef test_pub_ret_traversal(encrypted_requests, tmp_path):\n    \"\"\"\n    master's  AESFuncs._syndic_return method cachdir creation is not vulnerable to a directory traversal\n    \"\"\"\n    salt.crypt.gen_keys(tmp_path, \"minion\", 2048)\n\n    minions = pathlib.Path(encrypted_requests.opts[\"pki_dir\"]) / \"minions\"\n    minions.mkdir()\n\n    with salt.utils.files.fopen(minions / \"minion\", \"wb\") as wfp:\n        with salt.utils.files.fopen(tmp_path / \"minion.pub\", \"rb\") as rfp:\n            wfp.write(rfp.read())\n\n    priv = salt.crypt.PrivateKey(tmp_path / \"minion.pem\")\n    with pytest.raises(salt.exceptions.SaltValidationError):\n        encrypted_requests.pub_ret(\n            {\n                \"tok\": priv.encrypt(b\"salt\"),\n                \"id\": \"minion\",\n                \"jid\": \"asdf/../../../sdf\",\n                \"return\": {},\n            }\n        )\n", "patch": "@@ -4,19 +4,22 @@\n import pytest\n \n import salt.master\n+import salt.utils.files\n import salt.utils.platform\n from tests.support.mock import patch\n \n \n @pytest.fixture\n def encrypted_requests(tmp_path):\n     # To honor the comment on AESFuncs\n+    (tmp_path / \"pki\").mkdir()\n     return salt.master.AESFuncs(\n         opts={\n+            \"pki_dir\": str(tmp_path / \"pki\"),\n             \"cachedir\": str(tmp_path / \"cache\"),\n             \"sock_dir\": str(tmp_path / \"sock_drawer\"),\n             \"conf_file\": str(tmp_path / \"config.conf\"),\n-            \"fileserver_backend\": \"local\",\n+            \"fileserver_backend\": [\"local\"],\n             \"master_job_cache\": False,\n         }\n     )\n@@ -193,3 +196,28 @@ def test_syndic_return_cache_dir_creation_traversal(encrypted_requests):\n     )\n     assert not (cachedir / \"syndics\").exists()\n     assert not (cachedir / \"mamajama\").exists()\n+\n+\n+def test_pub_ret_traversal(encrypted_requests, tmp_path):\n+    \"\"\"\n+    master's  AESFuncs._syndic_return method cachdir creation is not vulnerable to a directory traversal\n+    \"\"\"\n+    salt.crypt.gen_keys(tmp_path, \"minion\", 2048)\n+\n+    minions = pathlib.Path(encrypted_requests.opts[\"pki_dir\"]) / \"minions\"\n+    minions.mkdir()\n+\n+    with salt.utils.files.fopen(minions / \"minion\", \"wb\") as wfp:\n+        with salt.utils.files.fopen(tmp_path / \"minion.pub\", \"rb\") as rfp:\n+            wfp.write(rfp.read())\n+\n+    priv = salt.crypt.PrivateKey(tmp_path / \"minion.pem\")\n+    with pytest.raises(salt.exceptions.SaltValidationError):\n+        encrypted_requests.pub_ret(\n+            {\n+                \"tok\": priv.encrypt(b\"salt\"),\n+                \"id\": \"minion\",\n+                \"jid\": \"asdf/../../../sdf\",\n+                \"return\": {},\n+            }\n+        )"}
