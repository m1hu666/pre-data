{"patches_id": 1, "files_id": 1, "language": "go", "raw_url": "https://github.com/juju/juju/raw/ef803e2a13692d355b784b7da8b4b1f01dab1556/apiserver%2Fapiserver.go", "raw_code": "// Copyright 2013 Canonical Ltd.\n// Licensed under the AGPLv3, see LICENCE file for details.\n\npackage apiserver\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/juju/clock\"\n\t\"github.com/juju/errors\"\n\t\"github.com/juju/loggo\"\n\t\"github.com/juju/names/v4\"\n\t\"github.com/juju/pubsub/v2\"\n\t\"github.com/juju/ratelimit\"\n\t\"github.com/juju/worker/v3/dependency\"\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"gopkg.in/tomb.v2\"\n\n\t\"github.com/juju/juju/apiserver/apiserverhttp\"\n\t\"github.com/juju/juju/apiserver/common\"\n\t\"github.com/juju/juju/apiserver/common/apihttp\"\n\t\"github.com/juju/juju/apiserver/common/crossmodel\"\n\tapiservererrors \"github.com/juju/juju/apiserver/errors\"\n\t\"github.com/juju/juju/apiserver/facade\"\n\t\"github.com/juju/juju/apiserver/httpcontext\"\n\t\"github.com/juju/juju/apiserver/logsink\"\n\t\"github.com/juju/juju/apiserver/observer\"\n\t\"github.com/juju/juju/apiserver/stateauthenticator\"\n\t\"github.com/juju/juju/apiserver/websocket\"\n\t\"github.com/juju/juju/controller\"\n\t\"github.com/juju/juju/core/auditlog\"\n\t\"github.com/juju/juju/core/cache\"\n\t\"github.com/juju/juju/core/lease\"\n\t\"github.com/juju/juju/core/multiwatcher\"\n\t\"github.com/juju/juju/core/presence\"\n\t\"github.com/juju/juju/core/resources\"\n\t\"github.com/juju/juju/feature\"\n\t\"github.com/juju/juju/pubsub/apiserver\"\n\tcontrollermsg \"github.com/juju/juju/pubsub/controller\"\n\t\"github.com/juju/juju/resource\"\n\t\"github.com/juju/juju/rpc\"\n\t\"github.com/juju/juju/rpc/jsoncodec\"\n\t\"github.com/juju/juju/state\"\n\t\"github.com/juju/juju/worker/syslogger\"\n)\n\nvar logger = loggo.GetLogger(\"juju.apiserver\")\n\nvar defaultHTTPMethods = []string{\"GET\", \"POST\", \"HEAD\", \"PUT\", \"DELETE\", \"OPTIONS\"}\n\n// Server holds the server side of the API.\ntype Server struct {\n\ttomb      tomb.Tomb\n\tclock     clock.Clock\n\tpingClock clock.Clock\n\twg        sync.WaitGroup\n\n\tshared *sharedServerContext\n\n\t// tag of the machine where the API server is running.\n\ttag                    names.Tag\n\tdataDir                string\n\tlogDir                 string\n\tfacades                *facade.Registry\n\tauthenticator          httpcontext.LocalMacaroonAuthenticator\n\tofferAuthCtxt          *crossmodel.AuthContext\n\tlastConnectionID       uint64\n\tnewObserver            observer.ObserverFactory\n\tallowModelAccess       bool\n\tlogSinkWriter          io.WriteCloser\n\tlogsinkRateLimitConfig logsink.RateLimitConfig\n\tapiServerLoggers       apiServerLoggers\n\tgetAuditConfig         func() auditlog.Config\n\tupgradeComplete        func() bool\n\trestoreStatus          func() state.RestoreStatus\n\tmux                    *apiserverhttp.Mux\n\tmetricsCollector       *Collector\n\texecEmbeddedCommand    ExecEmbeddedCommandFunc\n\n\t// mu guards the fields below it.\n\tmu sync.Mutex\n\n\t// healthStatus is returned from the health endpoint.\n\thealthStatus string\n\n\t// publicDNSName_ holds the value that will be returned in\n\t// LoginResult.PublicDNSName. Currently this is set once and does\n\t// not change but in the future it may change when a server\n\t// certificate is explicitly set, hence it's here guarded by the\n\t// mutex.\n\tpublicDNSName_ string\n\n\t// agentRateLimitMax and agentRateLimitRate are values used to create\n\t// the token bucket that ratelimits the agent connections. These values\n\t// come from controller config, and can be updated on the fly to adjust\n\t// the rate limiting.\n\tagentRateLimitMax  int\n\tagentRateLimitRate time.Duration\n\tagentRateLimit     *ratelimit.Bucket\n\n\t// resourceLock is used to limit the number of\n\t// concurrent resource downloads to units.\n\tresourceLock resource.ResourceDownloadLock\n\n\t// registerIntrospectionHandlers is a function that will\n\t// call a function with (path, http.Handler) tuples. This\n\t// is to support registering the handlers underneath the\n\t// \"/introspection\" prefix.\n\tregisterIntrospectionHandlers func(func(string, http.Handler))\n}\n\n// ServerConfig holds parameters required to set up an API server.\ntype ServerConfig struct {\n\tClock         clock.Clock\n\tPingClock     clock.Clock\n\tTag           names.Tag\n\tDataDir       string\n\tLogDir        string\n\tHub           *pubsub.StructuredHub\n\tPresence      presence.Recorder\n\tMux           *apiserverhttp.Mux\n\tAuthenticator httpcontext.LocalMacaroonAuthenticator\n\n\t// MultiwatcherFactory is used by the API server to create\n\t// multiwatchers. The real factory is managed by the multiwatcher\n\t// worker.\n\tMultiwatcherFactory multiwatcher.Factory\n\n\t// StatePool is the StatePool used for looking up State\n\t// to pass to facades. StatePool will not be closed by the\n\t// server; it is the callers responsibility to close it\n\t// after the apiserver has exited.\n\tStatePool *state.StatePool\n\n\t// Controller is the in-memory representation of the models\n\t// in the controller. It is kept up to date with an all model\n\t// watcher and the modelcache worker.\n\tController *cache.Controller\n\n\t// UpgradeComplete is a function that reports whether or not\n\t// the if the agent running the API server has completed\n\t// running upgrade steps. This is used by the API server to\n\t// limit logins during upgrades.\n\tUpgradeComplete func() bool\n\n\t// RestoreStatus is a function that reports the restore\n\t// status most recently observed by the agent running the\n\t// API server. This is used by the API server to limit logins\n\t// during a restore.\n\tRestoreStatus func() state.RestoreStatus\n\n\t// PublicDNSName is reported to the API clients who connect.\n\tPublicDNSName string\n\n\t// AllowModelAccess holds whether users will be allowed to\n\t// access models that they have access rights to even when\n\t// they don't have access to the controller.\n\tAllowModelAccess bool\n\n\t// NewObserver is a function which will return an observer. This\n\t// is used per-connection to instantiate a new observer to be\n\t// notified of key events during API requests.\n\tNewObserver observer.ObserverFactory\n\n\t// RegisterIntrospectionHandlers is a function that will\n\t// call a function with (path, http.Handler) tuples. This\n\t// is to support registering the handlers underneath the\n\t// \"/introspection\" prefix.\n\tRegisterIntrospectionHandlers func(func(string, http.Handler))\n\n\t// LogSinkConfig holds parameters to control the API server's\n\t// logsink endpoint behaviour. If this is nil, the values from\n\t// DefaultLogSinkConfig() will be used.\n\tLogSinkConfig *LogSinkConfig\n\n\t// SysLogger is a logger that will tee the output from logging\n\t// to the local syslog.\n\tSysLogger syslogger.SysLogger\n\n\t// GetAuditConfig holds a function that returns the current audit\n\t// logging config. The function may return updated values, so\n\t// should be called every time a new login is handled.\n\tGetAuditConfig func() auditlog.Config\n\n\t// LeaseManager gives access to leadership and singular claimers\n\t// and checkers for use in API facades.\n\tLeaseManager lease.Manager\n\n\t// MetricsCollector defines all the metrics to be collected for the\n\t// apiserver\n\tMetricsCollector *Collector\n\n\t// ExecEmbeddedCommand is a function which creates an embedded Juju CLI instance.\n\tExecEmbeddedCommand ExecEmbeddedCommandFunc\n\n\t// RaftOpQueue is used by the API to apply operations to the raft\n\t// instance.\n\tRaftOpQueue Queue\n}\n\n// Validate validates the API server configuration.\nfunc (c ServerConfig) Validate() error {\n\tif c.StatePool == nil {\n\t\treturn errors.NotValidf(\"missing StatePool\")\n\t}\n\tif c.Controller == nil {\n\t\treturn errors.NotValidf(\"missing Controller\")\n\t}\n\tif c.MultiwatcherFactory == nil {\n\t\treturn errors.NotValidf(\"missing MultiwatcherFactory\")\n\t}\n\tif c.Hub == nil {\n\t\treturn errors.NotValidf(\"missing Hub\")\n\t}\n\tif c.Presence == nil {\n\t\treturn errors.NotValidf(\"missing Presence\")\n\t}\n\tif c.Mux == nil {\n\t\treturn errors.NotValidf(\"missing Mux\")\n\t}\n\tif c.Authenticator == nil {\n\t\treturn errors.NotValidf(\"missing Authenticator\")\n\t}\n\tif c.Clock == nil {\n\t\treturn errors.NotValidf(\"missing Clock\")\n\t}\n\tif c.NewObserver == nil {\n\t\treturn errors.NotValidf(\"missing NewObserver\")\n\t}\n\tif c.UpgradeComplete == nil {\n\t\treturn errors.NotValidf(\"nil UpgradeComplete\")\n\t}\n\tif c.RestoreStatus == nil {\n\t\treturn errors.NotValidf(\"nil RestoreStatus\")\n\t}\n\tif c.GetAuditConfig == nil {\n\t\treturn errors.NotValidf(\"missing GetAuditConfig\")\n\t}\n\tif c.LogSinkConfig != nil {\n\t\tif err := c.LogSinkConfig.Validate(); err != nil {\n\t\t\treturn errors.Annotate(err, \"validating logsink configuration\")\n\t\t}\n\t}\n\tif c.SysLogger == nil {\n\t\treturn errors.NotValidf(\"nil SysLogger\")\n\t}\n\tif c.MetricsCollector == nil {\n\t\treturn errors.NotValidf(\"missing MetricsCollector\")\n\t}\n\tif c.RaftOpQueue == nil {\n\t\treturn errors.NotValidf(\"missing RaftOpQueue\")\n\t}\n\treturn nil\n}\n\nfunc (c ServerConfig) pingClock() clock.Clock {\n\tif c.PingClock == nil {\n\t\treturn c.Clock\n\t}\n\treturn c.PingClock\n}\n\n// NewServer serves API requests using the given configuration.\nfunc NewServer(cfg ServerConfig) (*Server, error) {\n\tif cfg.LogSinkConfig == nil {\n\t\tlogSinkConfig := DefaultLogSinkConfig()\n\t\tcfg.LogSinkConfig = &logSinkConfig\n\t}\n\tif err := cfg.Validate(); err != nil {\n\t\treturn nil, errors.Trace(err)\n\t}\n\t// Important note:\n\t// Do not manipulate the state within NewServer as the API\n\t// server needs to run before mongo upgrades have happened and\n\t// any state manipulation may be be relying on features of the\n\t// database added by upgrades. Here be dragons.\n\treturn newServer(cfg)\n}\n\nconst readyTimeout = time.Second * 30\n\nfunc newServer(cfg ServerConfig) (_ *Server, err error) {\n\tsystemState, err := cfg.StatePool.SystemState()\n\tif err != nil {\n\t\treturn nil, errors.Trace(err)\n\t}\n\tcontrollerConfig, err := systemState.ControllerConfig()\n\tif err != nil {\n\t\treturn nil, errors.Annotate(err, \"unable to get controller config\")\n\t}\n\n\tshared, err := newSharedServerContext(sharedServerConfig{\n\t\tstatePool:           cfg.StatePool,\n\t\tcontroller:          cfg.Controller,\n\t\tmultiwatcherFactory: cfg.MultiwatcherFactory,\n\t\tcentralHub:          cfg.Hub,\n\t\tpresence:            cfg.Presence,\n\t\tleaseManager:        cfg.LeaseManager,\n\t\tcontrollerConfig:    controllerConfig,\n\t\traftOpQueue:         cfg.RaftOpQueue,\n\t\tlogger:              loggo.GetLogger(\"juju.apiserver\"),\n\t})\n\tif err != nil {\n\t\treturn nil, errors.Trace(err)\n\t}\n\n\tsystemState, err = cfg.StatePool.SystemState()\n\tif err != nil {\n\t\treturn nil, errors.Trace(err)\n\t}\n\tmodel, err := systemState.Model()\n\tif err != nil {\n\t\treturn nil, errors.Trace(err)\n\t}\n\n\tmodelConfig, err := model.Config()\n\tif err != nil {\n\t\treturn nil, errors.Trace(err)\n\t}\n\tloggingOutputs, _ := modelConfig.LoggingOutput()\n\tif !controllerConfig.Features().Contains(feature.LoggingOutput) {\n\t\tloggingOutputs = []string{}\n\t}\n\n\tsrv := &Server{\n\t\tclock:                         cfg.Clock,\n\t\tpingClock:                     cfg.pingClock(),\n\t\tnewObserver:                   cfg.NewObserver,\n\t\tshared:                        shared,\n\t\ttag:                           cfg.Tag,\n\t\tdataDir:                       cfg.DataDir,\n\t\tlogDir:                        cfg.LogDir,\n\t\tupgradeComplete:               cfg.UpgradeComplete,\n\t\trestoreStatus:                 cfg.RestoreStatus,\n\t\tfacades:                       AllFacades(),\n\t\tmux:                           cfg.Mux,\n\t\tauthenticator:                 cfg.Authenticator,\n\t\tallowModelAccess:              cfg.AllowModelAccess,\n\t\tpublicDNSName_:                cfg.PublicDNSName,\n\t\tregisterIntrospectionHandlers: cfg.RegisterIntrospectionHandlers,\n\t\tlogsinkRateLimitConfig: logsink.RateLimitConfig{\n\t\t\tRefill: cfg.LogSinkConfig.RateLimitRefill,\n\t\t\tBurst:  cfg.LogSinkConfig.RateLimitBurst,\n\t\t\tClock:  cfg.Clock,\n\t\t},\n\t\tgetAuditConfig: cfg.GetAuditConfig,\n\t\tapiServerLoggers: apiServerLoggers{\n\t\t\tsyslogger:           cfg.SysLogger,\n\t\t\tloggingOutputs:      loggingOutputs,\n\t\t\tclock:               cfg.Clock,\n\t\t\tloggerBufferSize:    cfg.LogSinkConfig.DBLoggerBufferSize,\n\t\t\tloggerFlushInterval: cfg.LogSinkConfig.DBLoggerFlushInterval,\n\t\t},\n\t\tmetricsCollector:    cfg.MetricsCollector,\n\t\texecEmbeddedCommand: cfg.ExecEmbeddedCommand,\n\n\t\thealthStatus: \"starting\",\n\t}\n\tsrv.updateAgentRateLimiter(controllerConfig)\n\tsrv.updateResourceDownloadLimiters(controllerConfig)\n\n\t// We are able to get the current controller config before subscribing to changes\n\t// because the changes are only ever published in response to an API call,\n\t// and we know that we can't make any API calls until the server has started.\n\tunsubscribeControllerConfig, err := cfg.Hub.Subscribe(\n\t\tcontrollermsg.ConfigChanged,\n\t\tfunc(topic string, data controllermsg.ConfigChangedMessage, err error) {\n\t\t\tif err != nil {\n\t\t\t\tlogger.Criticalf(\"programming error in %s message data: %v\", topic, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tsrv.updateAgentRateLimiter(data.Config)\n\t\t\tsrv.updateResourceDownloadLimiters(data.Config)\n\t\t})\n\tif err != nil {\n\t\tlogger.Criticalf(\"programming error in subscribe function: %v\", err)\n\t\treturn nil, errors.Trace(err)\n\t}\n\n\tsrv.shared.cancel = srv.tomb.Dying()\n\n\t// The auth context for authenticating access to application offers.\n\tsrv.offerAuthCtxt, err = newOfferAuthcontext(cfg.StatePool)\n\tif err != nil {\n\t\tunsubscribeControllerConfig()\n\t\treturn nil, errors.Trace(err)\n\t}\n\n\tif model.Type() == state.ModelTypeCAAS {\n\t\t// CAAS controller writes log to stdout. We should ensure that we don't\n\t\t// close the logSinkWriter when we stopping the tomb, otherwise we get\n\t\t// no output to stdout anymore.\n\t\tsrv.logSinkWriter = nonCloseableWriter{\n\t\t\tWriteCloser: os.Stdout,\n\t\t}\n\t} else {\n\t\tsrv.logSinkWriter, err = logsink.NewFileWriter(\n\t\t\tfilepath.Join(srv.logDir, \"logsink.log\"),\n\t\t\tcontrollerConfig.AgentLogfileMaxSizeMB(),\n\t\t\tcontrollerConfig.AgentLogfileMaxBackups(),\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, errors.Annotate(err, \"creating logsink writer\")\n\t\t}\n\t}\n\n\tunsubscribe, err := cfg.Hub.Subscribe(apiserver.RestartTopic, func(string, map[string]interface{}) {\n\t\tsrv.tomb.Kill(dependency.ErrBounce)\n\t})\n\tif err != nil {\n\t\tunsubscribeControllerConfig()\n\t\treturn nil, errors.Annotate(err, \"unable to subscribe to restart message\")\n\t}\n\n\tready := make(chan struct{})\n\tsrv.tomb.Go(func() error {\n\t\tdefer srv.apiServerLoggers.dispose()\n\t\tdefer srv.logSinkWriter.Close()\n\t\tdefer srv.shared.Close()\n\t\tdefer unsubscribe()\n\t\tdefer unsubscribeControllerConfig()\n\t\treturn srv.loop(ready)\n\t})\n\n\t// Don't return until all handlers have been registered.\n\tselect {\n\tcase <-ready:\n\tcase <-srv.clock.After(readyTimeout):\n\t\treturn nil, errors.New(\"loop never signalled ready\")\n\t}\n\n\treturn srv, nil\n}\n\n// nonCloseableWriter ensures that we never close the underlying writer. If the\n// underlying writer is os.stdout and we close that, then nothing will be\n// written until a new instance of the program is launched.\ntype nonCloseableWriter struct {\n\tio.WriteCloser\n}\n\n// Close does not do anything in this instance.\nfunc (nonCloseableWriter) Close() error {\n\treturn nil\n}\n\n// Report is shown in the juju_engine_report.\nfunc (srv *Server) Report() map[string]interface{} {\n\tsrv.mu.Lock()\n\tdefer srv.mu.Unlock()\n\tresult := map[string]interface{}{\n\t\t\"agent-ratelimit-max\":  srv.agentRateLimitMax,\n\t\t\"agent-ratelimit-rate\": srv.agentRateLimitRate,\n\t}\n\n\tif srv.publicDNSName_ != \"\" {\n\t\tresult[\"public-dns-name\"] = srv.publicDNSName_\n\t}\n\treturn result\n}\n\n// Dead returns a channel that signals when the server has exited.\nfunc (srv *Server) Dead() <-chan struct{} {\n\treturn srv.tomb.Dead()\n}\n\n// Stop stops the server and returns when all running requests\n// have completed.\nfunc (srv *Server) Stop() error {\n\tsrv.tomb.Kill(nil)\n\treturn srv.tomb.Wait()\n}\n\n// Kill implements worker.Worker.Kill.\nfunc (srv *Server) Kill() {\n\tsrv.tomb.Kill(nil)\n}\n\n// Wait implements worker.Worker.Wait.\nfunc (srv *Server) Wait() error {\n\treturn srv.tomb.Wait()\n}\n\nfunc (srv *Server) updateAgentRateLimiter(cfg controller.Config) {\n\tsrv.mu.Lock()\n\tdefer srv.mu.Unlock()\n\tsrv.agentRateLimitMax = cfg.AgentRateLimitMax()\n\tsrv.agentRateLimitRate = cfg.AgentRateLimitRate()\n\tif srv.agentRateLimitMax > 0 {\n\t\tsrv.agentRateLimit = ratelimit.NewBucketWithClock(\n\t\t\tsrv.agentRateLimitRate, int64(srv.agentRateLimitMax), rateClock{srv.clock})\n\t} else {\n\t\tsrv.agentRateLimit = nil\n\t}\n}\n\nfunc (srv *Server) updateResourceDownloadLimiters(cfg controller.Config) {\n\tsrv.mu.Lock()\n\tdefer srv.mu.Unlock()\n\tglobalLimit := cfg.ControllerResourceDownloadLimit()\n\tappLimit := cfg.ApplicationResourceDownloadLimit()\n\tsrv.resourceLock = resource.NewResourceDownloadLimiter(globalLimit, appLimit)\n}\n\nfunc (srv *Server) getResourceDownloadLimiter() resource.ResourceDownloadLock {\n\tsrv.mu.Lock()\n\tdefer srv.mu.Unlock()\n\treturn srv.resourceLock\n}\n\ntype rateClock struct {\n\tclock.Clock\n}\n\nfunc (rateClock) Sleep(time.Duration) {\n\t// no-op, we don't sleep.\n}\n\nfunc (srv *Server) getAgentToken() error {\n\tsrv.mu.Lock()\n\tdefer srv.mu.Unlock()\n\t// agentRateLimit is nil if rate limiting is disabled.\n\tif srv.agentRateLimit == nil {\n\t\treturn nil\n\t}\n\n\t// Try to take one token, but don't wait any time for it.\n\tif _, ok := srv.agentRateLimit.TakeMaxDuration(1, 0); !ok {\n\t\treturn apiservererrors.ErrTryAgain\n\t}\n\treturn nil\n}\n\n// logsinkMetricsCollectorWrapper defines a wrapper for exposing the essentials\n// for the logsink api handler to interact with the metrics collector.\ntype logsinkMetricsCollectorWrapper struct {\n\tcollector *Collector\n}\n\nfunc (w logsinkMetricsCollectorWrapper) TotalConnections() prometheus.Counter {\n\treturn w.collector.TotalConnections\n}\n\nfunc (w logsinkMetricsCollectorWrapper) Connections() prometheus.Gauge {\n\treturn w.collector.APIConnections.WithLabelValues(\"logsink\")\n}\n\nfunc (w logsinkMetricsCollectorWrapper) PingFailureCount(modelUUID string) prometheus.Counter {\n\treturn w.collector.PingFailureCount.WithLabelValues(modelUUID, \"logsink\")\n}\n\nfunc (w logsinkMetricsCollectorWrapper) LogWriteCount(modelUUID, state string) prometheus.Counter {\n\treturn w.collector.LogWriteCount.WithLabelValues(modelUUID, state)\n}\n\nfunc (w logsinkMetricsCollectorWrapper) LogReadCount(modelUUID, state string) prometheus.Counter {\n\treturn w.collector.LogReadCount.WithLabelValues(modelUUID, state)\n}\n\n// httpRequestRecorderWrapper defines a wrapper from exposing the\n// essentials for the http request recorder.\ntype httpRequestRecorderWrapper struct {\n\tcollector *Collector\n\tmodelUUID string\n}\n\n// Record an outgoing request which produced an http.Response.\nfunc (w httpRequestRecorderWrapper) Record(method string, url *url.URL, res *http.Response, rtt time.Duration) {\n\t// Note: Do not log url.Path as REST queries _can_ include the name of the\n\t// entities (charms, architectures, etc).\n\tw.collector.TotalRequests.WithLabelValues(w.modelUUID, url.Host, strconv.FormatInt(int64(res.StatusCode), 10)).Inc()\n\tif res.StatusCode >= 400 {\n\t\tw.collector.TotalRequestErrors.WithLabelValues(w.modelUUID, url.Host).Inc()\n\t}\n\tw.collector.TotalRequestsDuration.WithLabelValues(w.modelUUID, url.Host).Observe(rtt.Seconds())\n}\n\n// Record an outgoing request which returned back an error.\nfunc (w httpRequestRecorderWrapper) RecordError(method string, url *url.URL, err error) {\n\t// Note: Do not log url.Path as REST queries _can_ include the name of the\n\t// entities (charms, architectures, etc).\n\tw.collector.TotalRequests.WithLabelValues(w.modelUUID, url.Host, \"unknown\").Inc()\n\tw.collector.TotalRequestErrors.WithLabelValues(w.modelUUID, url.Host).Inc()\n}\n\n// loop is the main loop for the server.\nfunc (srv *Server) loop(ready chan struct{}) error {\n\t// for pat based handlers, they are matched in-order of being\n\t// registered, first match wins. So more specific ones have to be\n\t// registered first.\n\tendpoints, err := srv.endpoints()\n\tif err != nil {\n\t\treturn errors.Trace(err)\n\t}\n\tfor _, ep := range endpoints {\n\t\t_ = srv.mux.AddHandler(ep.Method, ep.Pattern, ep.Handler)\n\t\tdefer srv.mux.RemoveHandler(ep.Method, ep.Pattern)\n\t\tif ep.Method == \"GET\" {\n\t\t\t_ = srv.mux.AddHandler(\"HEAD\", ep.Pattern, ep.Handler)\n\t\t\tdefer srv.mux.RemoveHandler(\"HEAD\", ep.Pattern)\n\t\t}\n\t}\n\n\tclose(ready)\n\tsrv.mu.Lock()\n\tsrv.healthStatus = \"running\"\n\tsrv.mu.Unlock()\n\n\t<-srv.tomb.Dying()\n\n\tsrv.mu.Lock()\n\tsrv.healthStatus = \"stopping\"\n\tsrv.mu.Unlock()\n\n\tsrv.wg.Wait() // wait for any outstanding requests to complete.\n\treturn tomb.ErrDying\n}\n\nfunc (srv *Server) endpoints() ([]apihttp.Endpoint, error) {\n\tconst modelRoutePrefix = \"/model/:modeluuid\"\n\n\ttype handler struct {\n\t\tpattern         string\n\t\tmethods         []string\n\t\thandler         http.Handler\n\t\tunauthenticated bool\n\t\tauthorizer      httpcontext.Authorizer\n\t\ttracked         bool\n\t\tnoModelUUID     bool\n\t}\n\tvar endpoints []apihttp.Endpoint\n\tsystemState, err := srv.shared.statePool.SystemState()\n\tif err != nil {\n\t\treturn nil, errors.Trace(err)\n\t}\n\tcontrollerModelUUID := systemState.ModelUUID()\n\taddHandler := func(handler handler) {\n\t\tmethods := handler.methods\n\t\tif methods == nil {\n\t\t\tmethods = defaultHTTPMethods\n\t\t}\n\t\th := handler.handler\n\t\tif handler.tracked {\n\t\t\th = srv.trackRequests(h)\n\t\t}\n\t\tif !handler.unauthenticated {\n\t\t\th = &httpcontext.BasicAuthHandler{\n\t\t\t\tHandler:       h,\n\t\t\t\tAuthenticator: srv.authenticator,\n\t\t\t\tAuthorizer:    handler.authorizer,\n\t\t\t}\n\t\t}\n\t\tif !handler.noModelUUID {\n\t\t\tif strings.HasPrefix(handler.pattern, modelRoutePrefix) {\n\t\t\t\th = &httpcontext.QueryModelHandler{\n\t\t\t\t\tHandler: h,\n\t\t\t\t\tQuery:   \":modeluuid\",\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\th = &httpcontext.ImpliedModelHandler{\n\t\t\t\t\tHandler:   h,\n\t\t\t\t\tModelUUID: controllerModelUUID,\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor _, method := range methods {\n\t\t\tendpoints = append(endpoints, apihttp.Endpoint{\n\t\t\t\tPattern: handler.pattern,\n\t\t\t\tMethod:  method,\n\t\t\t\tHandler: h,\n\t\t\t})\n\t\t}\n\t}\n\n\thttpCtxt := httpContext{srv: srv}\n\tmainAPIHandler := http.HandlerFunc(srv.apiHandler)\n\thealthHandler := http.HandlerFunc(srv.healthHandler)\n\tlogStreamHandler := newLogStreamEndpointHandler(httpCtxt)\n\tembeddedCLIHandler := newEmbeddedCLIHandler(httpCtxt)\n\tdebugLogHandler := newDebugLogDBHandler(\n\t\thttpCtxt, srv.authenticator,\n\t\ttagKindAuthorizer{names.MachineTagKind, names.ControllerAgentTagKind, names.UserTagKind, names.ApplicationTagKind})\n\tpubsubHandler := newPubSubHandler(httpCtxt, srv.shared.centralHub)\n\tlogSinkHandler := logsink.NewHTTPHandler(\n\t\tnewAgentLogWriteCloserFunc(httpCtxt, srv.logSinkWriter, &srv.apiServerLoggers),\n\t\thttpCtxt.stop(),\n\t\t&srv.logsinkRateLimitConfig,\n\t\tlogsinkMetricsCollectorWrapper{collector: srv.metricsCollector},\n\t\tcontrollerModelUUID,\n\t)\n\tlogSinkAuthorizer := tagKindAuthorizer(stateauthenticator.AgentTags)\n\tlogTransferHandler := logsink.NewHTTPHandler(\n\t\t// We don't need to save the migrated logs\n\t\t// to a logfile as well as to the DB.\n\t\tnewMigrationLogWriteCloserFunc(httpCtxt, &srv.apiServerLoggers),\n\t\thttpCtxt.stop(),\n\t\tnil, // no rate-limiting\n\t\tlogsinkMetricsCollectorWrapper{collector: srv.metricsCollector},\n\t\tcontrollerModelUUID,\n\t)\n\tmodelRestHandler := &modelRestHandler{\n\t\tctxt:          httpCtxt,\n\t\tdataDir:       srv.dataDir,\n\t\tstateAuthFunc: httpCtxt.stateForRequestAuthenticatedUser,\n\t}\n\tmodelRestServer := &RestHTTPHandler{\n\t\tGetHandler: modelRestHandler.ServeGet,\n\t}\n\tmodelCharmsHandler := &charmsHandler{\n\t\tctxt:          httpCtxt,\n\t\tdataDir:       srv.dataDir,\n\t\tstateAuthFunc: httpCtxt.stateForRequestAuthenticatedUser,\n\t}\n\tmodelCharmsHTTPHandler := &CharmsHTTPHandler{\n\t\tPostHandler: modelCharmsHandler.ServePost,\n\t\tGetHandler:  modelCharmsHandler.ServeGet,\n\t}\n\tmodelCharmsUploadAuthorizer := tagKindAuthorizer{names.UserTagKind}\n\tmodelToolsUploadHandler := &toolsUploadHandler{\n\t\tctxt:          httpCtxt,\n\t\tstateAuthFunc: httpCtxt.stateForRequestAuthenticatedUser,\n\t}\n\tmodelToolsUploadAuthorizer := tagKindAuthorizer{names.UserTagKind}\n\tmodelToolsDownloadHandler := newToolsDownloadHandler(httpCtxt)\n\tresourcesHandler := &ResourcesHandler{\n\t\tStateAuthFunc: func(req *http.Request, tagKinds ...string) (ResourcesBackend, state.PoolHelper, names.Tag, error) {\n\t\t\tst, entity, err := httpCtxt.stateForRequestAuthenticatedTag(req, tagKinds...)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, nil, errors.Trace(err)\n\t\t\t}\n\t\t\trst := st.Resources()\n\t\t\treturn rst, st, entity.Tag(), nil\n\t\t},\n\t\tChangeAllowedFunc: func(req *http.Request) error {\n\t\t\tst, err := httpCtxt.stateForRequestUnauthenticated(req)\n\t\t\tif err != nil {\n\t\t\t\treturn errors.Trace(err)\n\t\t\t}\n\t\t\tblockChecker := common.NewBlockChecker(st)\n\t\t\tif err := blockChecker.ChangeAllowed(); err != nil {\n\t\t\t\treturn errors.Trace(err)\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t}\n\tunitResourcesHandler := &UnitResourcesHandler{\n\t\tNewOpener: func(req *http.Request, tagKinds ...string) (resources.Opener, state.PoolHelper, error) {\n\t\t\tst, _, err := httpCtxt.stateForRequestAuthenticatedTag(req, tagKinds...)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, errors.Trace(err)\n\t\t\t}\n\t\t\ttagStr := req.URL.Query().Get(\":unit\")\n\t\t\ttag, err := names.ParseUnitTag(tagStr)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, errors.Trace(err)\n\t\t\t}\n\t\t\topener, err := resource.NewResourceOpener(st.State, srv.getResourceDownloadLimiter, tag.Id())\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, errors.Trace(err)\n\t\t\t}\n\t\t\treturn opener, st, nil\n\t\t},\n\t}\n\n\tcontrollerAdminAuthorizer := controllerAdminAuthorizer{systemState}\n\tmigrateCharmsHandler := &charmsHandler{\n\t\tctxt:          httpCtxt,\n\t\tdataDir:       srv.dataDir,\n\t\tstateAuthFunc: httpCtxt.stateForMigrationImporting,\n\t}\n\tmigrateCharmsHTTPHandler := &CharmsHTTPHandler{\n\t\tPostHandler: migrateCharmsHandler.ServePost,\n\t\tGetHandler:  migrateCharmsHandler.ServeUnsupported,\n\t}\n\tmigrateToolsUploadHandler := &toolsUploadHandler{\n\t\tctxt:          httpCtxt,\n\t\tstateAuthFunc: httpCtxt.stateForMigrationImporting,\n\t}\n\tresourcesMigrationUploadHandler := &resourcesMigrationUploadHandler{\n\t\tctxt:          httpCtxt,\n\t\tstateAuthFunc: httpCtxt.stateForMigrationImporting,\n\t}\n\tbackupHandler := &backupHandler{ctxt: httpCtxt}\n\tregisterHandler := &registerUserHandler{ctxt: httpCtxt}\n\tguiArchiveHandler := &guiArchiveHandler{ctxt: httpCtxt}\n\tguiVersionHandler := &guiVersionHandler{ctxt: httpCtxt}\n\n\t// HTTP handler for application offer macaroon authentication.\n\taddOfferAuthHandlers(srv.offerAuthCtxt, srv.mux)\n\n\thandlers := []handler{{\n\t\t// This handler is model specific even though it only\n\t\t// ever makes sense for a controller because the API\n\t\t// caller that is handed to the worker that is forwarding\n\t\t// the messages between controllers is bound to the\n\t\t// /model/:modeluuid namespace.\n\t\tpattern:    modelRoutePrefix + \"/pubsub\",\n\t\thandler:    pubsubHandler,\n\t\ttracked:    true,\n\t\tauthorizer: controllerAuthorizer{},\n\t}, {\n\t\tpattern: modelRoutePrefix + \"/logstream\",\n\t\thandler: logStreamHandler,\n\t\ttracked: true,\n\t}, {\n\t\tpattern: modelRoutePrefix + \"/log\",\n\t\thandler: debugLogHandler,\n\t\ttracked: true,\n\t\t// The authentication is handled within the debugLogHandler in order\n\t\t// for discharge required errors to be handled correctly.\n\t\tunauthenticated: true,\n\t}, {\n\t\tpattern:    modelRoutePrefix + \"/logsink\",\n\t\thandler:    logSinkHandler,\n\t\ttracked:    true,\n\t\tauthorizer: logSinkAuthorizer,\n\t}, {\n\t\tpattern:         modelRoutePrefix + \"/api\",\n\t\thandler:         mainAPIHandler,\n\t\ttracked:         true,\n\t\tunauthenticated: true,\n\t}, {\n\t\tpattern:         modelRoutePrefix + \"/commands\",\n\t\thandler:         embeddedCLIHandler,\n\t\ttracked:         true,\n\t\tunauthenticated: true,\n\t}, {\n\t\tpattern: modelRoutePrefix + \"/rest/1.0/:entity/:name/:attribute\",\n\t\thandler: modelRestServer,\n\t}, {\n\t\t// GET /charms has no authorizer\n\t\tpattern: modelRoutePrefix + \"/charms\",\n\t\tmethods: []string{\"GET\"},\n\t\thandler: modelCharmsHTTPHandler,\n\t}, {\n\t\tpattern:    modelRoutePrefix + \"/charms\",\n\t\tmethods:    []string{\"POST\"},\n\t\thandler:    modelCharmsHTTPHandler,\n\t\tauthorizer: modelCharmsUploadAuthorizer,\n\t}, {\n\t\tpattern:    modelRoutePrefix + \"/tools\",\n\t\thandler:    modelToolsUploadHandler,\n\t\tauthorizer: modelToolsUploadAuthorizer,\n\t}, {\n\t\tpattern:         modelRoutePrefix + \"/tools/:version\",\n\t\thandler:         modelToolsDownloadHandler,\n\t\tunauthenticated: true,\n\t}, {\n\t\tpattern: modelRoutePrefix + \"/applications/:application/resources/:resource\",\n\t\thandler: resourcesHandler,\n\t}, {\n\t\tpattern: modelRoutePrefix + \"/units/:unit/resources/:resource\",\n\t\thandler: unitResourcesHandler,\n\t}, {\n\t\tpattern:    modelRoutePrefix + \"/backups\",\n\t\thandler:    backupHandler,\n\t\tauthorizer: controllerAdminAuthorizer,\n\t}, {\n\t\tpattern:    \"/migrate/charms\",\n\t\thandler:    migrateCharmsHTTPHandler,\n\t\tauthorizer: controllerAdminAuthorizer,\n\t}, {\n\t\tpattern:    \"/migrate/tools\",\n\t\thandler:    migrateToolsUploadHandler,\n\t\tauthorizer: controllerAdminAuthorizer,\n\t}, {\n\t\tpattern:    \"/migrate/resources\",\n\t\thandler:    resourcesMigrationUploadHandler,\n\t\tauthorizer: controllerAdminAuthorizer,\n\t}, {\n\t\tpattern:    \"/migrate/logtransfer\",\n\t\thandler:    logTransferHandler,\n\t\ttracked:    true,\n\t\tauthorizer: controllerAdminAuthorizer,\n\t}, {\n\t\tpattern:         \"/api\",\n\t\thandler:         mainAPIHandler,\n\t\ttracked:         true,\n\t\tunauthenticated: true,\n\t\tnoModelUUID:     true,\n\t}, {\n\t\tpattern:         \"/commands\",\n\t\thandler:         embeddedCLIHandler,\n\t\tunauthenticated: true,\n\t\tnoModelUUID:     true,\n\t}, {\n\t\t// Serve the API at / for backward compatibility. Note that the\n\t\t// pat muxer special-cases / so that it does not serve all\n\t\t// possible endpoints, but only / itself.\n\t\tpattern:         \"/\",\n\t\thandler:         mainAPIHandler,\n\t\ttracked:         true,\n\t\tunauthenticated: true,\n\t\tnoModelUUID:     true,\n\t}, {\n\t\tpattern:         \"/health\",\n\t\tmethods:         []string{\"GET\"},\n\t\thandler:         healthHandler,\n\t\tunauthenticated: true,\n\t\tnoModelUUID:     true,\n\t}, {\n\t\tpattern:         \"/register\",\n\t\thandler:         registerHandler,\n\t\tunauthenticated: true,\n\t}, {\n\t\tpattern:    \"/tools\",\n\t\thandler:    modelToolsUploadHandler,\n\t\tauthorizer: modelToolsUploadAuthorizer,\n\t}, {\n\t\tpattern:         \"/tools/:version\",\n\t\thandler:         modelToolsDownloadHandler,\n\t\tunauthenticated: true,\n\t}, {\n\t\tpattern: \"/log\",\n\t\thandler: debugLogHandler,\n\t\ttracked: true,\n\t\t// The authentication is handled within the debugLogHandler in order\n\t\t// for discharge required errors to be handled correctly.\n\t\tunauthenticated: true,\n\t}, {\n\t\t// GET /charms has no authorizer\n\t\tpattern: \"/charms\",\n\t\tmethods: []string{\"GET\"},\n\t\thandler: modelCharmsHTTPHandler,\n\t}, {\n\t\tpattern:    \"/charms\",\n\t\tmethods:    []string{\"POST\"},\n\t\thandler:    modelCharmsHTTPHandler,\n\t\tauthorizer: modelCharmsUploadAuthorizer,\n\t}, {\n\t\tpattern: \"/gui-archive\",\n\t\tmethods: []string{\"POST\"},\n\t\thandler: guiArchiveHandler,\n\t}, {\n\t\tpattern:         \"/gui-archive\",\n\t\tmethods:         []string{\"GET\"},\n\t\thandler:         guiArchiveHandler,\n\t\tunauthenticated: true,\n\t}, {\n\t\tpattern: \"/gui-version\",\n\t\thandler: guiVersionHandler,\n\t}}\n\tif srv.registerIntrospectionHandlers != nil {\n\t\tadd := func(subpath string, h http.Handler) {\n\t\t\thandlers = append(handlers, handler{\n\t\t\t\tpattern: path.Join(\"/introspection/\", subpath),\n\t\t\t\thandler: introspectionHandler{httpCtxt, h},\n\t\t\t})\n\t\t}\n\t\tsrv.registerIntrospectionHandlers(add)\n\t}\n\n\t// Construct endpoints from handler structs.\n\tfor _, handler := range handlers {\n\t\taddHandler(handler)\n\t}\n\n\t// Finally, register GUI content endpoints.\n\n\t// Add the legacy GUI handler.\n\tguiEndpoints := guiEndpoints(guiURLPathPrefix, srv.dataDir, httpCtxt)\n\tendpoints = append(endpoints, guiEndpoints...)\n\t// And the new dashboard handler\n\tdashboardEndpoints := dashboardEndpoints(dashboardURLPathPrefix, srv.dataDir, httpCtxt)\n\tendpoints = append(endpoints, dashboardEndpoints...)\n\n\treturn endpoints, nil\n}\n\n// trackRequests wraps a http.Handler, incrementing and decrementing\n// the apiserver's WaitGroup and blocking request when the apiserver\n// is shutting down.\n//\n// Note: It is only safe to use trackRequests with API handlers which\n// are interruptible (i.e. they pay attention to the apiserver tomb)\n// or are guaranteed to be short-lived. If it's used with long running\n// API handlers which don't watch the apiserver's tomb, apiserver\n// shutdown will be blocked until the API handler returns.\nfunc (srv *Server) trackRequests(handler http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t// Care must be taken to not increment the waitgroup count\n\t\t// after the listener has closed.\n\t\t//\n\t\t// First we check to see if the tomb has not yet been killed\n\t\t// because the closure of the listener depends on the tomb being\n\t\t// killed to trigger the defer block in srv.run.\n\t\tselect {\n\t\tcase <-srv.tomb.Dying():\n\t\t\t// This request was accepted before the listener was closed\n\t\t\t// but after the tomb was killed. As we're in the process of\n\t\t\t// shutting down, do not consider this request as in progress,\n\t\t\t// just send a 503 and return.\n\t\t\thttp.Error(w, \"apiserver shutdown in progress\", http.StatusServiceUnavailable)\n\t\tdefault:\n\t\t\t// If we get here then the tomb was not killed therefore the\n\t\t\t// listener is still open. It is safe to increment the\n\t\t\t// wg counter as wg.Wait in srv.run has not yet been called.\n\t\t\tsrv.wg.Add(1)\n\t\t\tdefer srv.wg.Done()\n\t\t\thandler.ServeHTTP(w, r)\n\t\t}\n\t})\n}\n\nfunc (srv *Server) healthHandler(w http.ResponseWriter, req *http.Request) {\n\tsrv.mu.Lock()\n\tstatus := srv.healthStatus\n\tsrv.mu.Unlock()\n\tif status != \"running\" {\n\t\tw.WriteHeader(http.StatusServiceUnavailable)\n\t}\n\n\tfmt.Fprintf(w, \"%s\\n\", status)\n}\n\nfunc (srv *Server) apiHandler(w http.ResponseWriter, req *http.Request) {\n\tsrv.metricsCollector.TotalConnections.Inc()\n\n\tgauge := srv.metricsCollector.APIConnections.WithLabelValues(\"api\")\n\tgauge.Inc()\n\tdefer gauge.Dec()\n\n\tconnectionID := atomic.AddUint64(&srv.lastConnectionID, 1)\n\n\tapiObserver := srv.newObserver()\n\tapiObserver.Join(req, connectionID)\n\tdefer apiObserver.Leave()\n\n\twebsocket.Serve(w, req, func(conn *websocket.Conn) {\n\t\tmodelUUID := httpcontext.RequestModelUUID(req)\n\t\tlogger.Tracef(\"got a request for model %q\", modelUUID)\n\t\tif err := srv.serveConn(\n\t\t\treq.Context(),\n\t\t\tconn,\n\t\t\tmodelUUID,\n\t\t\tconnectionID,\n\t\t\tapiObserver,\n\t\t\treq.Host,\n\t\t); err != nil {\n\t\t\tlogger.Errorf(\"error serving RPCs: %v\", err)\n\t\t}\n\t})\n}\n\nfunc (srv *Server) serveConn(\n\tctx context.Context,\n\twsConn *websocket.Conn,\n\tmodelUUID string,\n\tconnectionID uint64,\n\tapiObserver observer.Observer,\n\thost string,\n) error {\n\tcodec := jsoncodec.NewWebsocket(wsConn.Conn)\n\trecorderFactory := observer.NewRecorderFactory(\n\t\tapiObserver, nil, observer.NoCaptureArgs)\n\tconn := rpc.NewConn(codec, recorderFactory)\n\n\t// Note that we don't overwrite modelUUID here because\n\t// newAPIHandler treats an empty modelUUID as signifying\n\t// the API version used.\n\tresolvedModelUUID := modelUUID\n\tstatePool := srv.shared.statePool\n\tif modelUUID == \"\" {\n\t\tsystemState, err := statePool.SystemState()\n\t\tif err != nil {\n\t\t\treturn errors.Trace(err)\n\t\t}\n\t\tresolvedModelUUID = systemState.ModelUUID()\n\t}\n\tvar (\n\t\tst *state.PooledState\n\t\th  *apiHandler\n\t)\n\n\tst, err := statePool.Get(resolvedModelUUID)\n\tif err == nil {\n\t\tdefer st.Release()\n\t\th, err = newAPIHandler(srv, st.State, conn, modelUUID, connectionID, host)\n\t}\n\tif errors.IsNotFound(err) {\n\t\terr = fmt.Errorf(\"%w: %q\", apiservererrors.UnknownModelError, resolvedModelUUID)\n\t}\n\n\tif err != nil {\n\t\tconn.ServeRoot(&errRoot{errors.Trace(err)}, recorderFactory, serverError)\n\t} else {\n\t\t// Set up the admin apis used to accept logins and direct\n\t\t// requests to the relevant business facade.\n\t\t// There may be more than one since we need a new API each\n\t\t// time login changes in a non-backwards compatible way.\n\t\tadminAPIs := make(map[int]interface{})\n\t\tfor apiVersion, factory := range adminAPIFactories {\n\t\t\tadminAPIs[apiVersion] = factory(srv, h, apiObserver)\n\t\t}\n\t\tconn.ServeRoot(newAdminRoot(h, adminAPIs), recorderFactory, serverError)\n\t}\n\tconn.Start(ctx)\n\tselect {\n\tcase <-conn.Dead():\n\tcase <-srv.tomb.Dying():\n\t}\n\treturn conn.Close()\n}\n\n// publicDNSName returns the current public hostname.\nfunc (srv *Server) publicDNSName() string {\n\tsrv.mu.Lock()\n\tdefer srv.mu.Unlock()\n\treturn srv.publicDNSName_\n}\n\nfunc serverError(err error) error {\n\treturn apiservererrors.ServerError(err)\n}\n\n// GetAuditConfig returns a copy of the current audit logging\n// configuration.\nfunc (srv *Server) GetAuditConfig() auditlog.Config {\n\t// Delegates to the getter passed in.\n\treturn srv.getAuditConfig()\n}\n", "patch": "@@ -864,8 +864,9 @@ func (srv *Server) endpoints() ([]apihttp.Endpoint, error) {\n \t\tpattern: modelRoutePrefix + \"/units/:unit/resources/:resource\",\n \t\thandler: unitResourcesHandler,\n \t}, {\n-\t\tpattern: modelRoutePrefix + \"/backups\",\n-\t\thandler: backupHandler,\n+\t\tpattern:    modelRoutePrefix + \"/backups\",\n+\t\thandler:    backupHandler,\n+\t\tauthorizer: controllerAdminAuthorizer,\n \t}, {\n \t\tpattern:    \"/migrate/charms\",\n \t\thandler:    migrateCharmsHTTPHandler,"}
{"patches_id": 1, "files_id": 2, "language": "go", "raw_url": "https://github.com/juju/juju/raw/ef803e2a13692d355b784b7da8b4b1f01dab1556/apiserver%2Fbackup.go", "raw_code": "// Copyright 2014 Canonical Ltd.\n// Licensed under the AGPLv3, see LICENCE file for details.\n\npackage apiserver\n\nimport (\n\t\"encoding/json\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"github.com/juju/errors\"\n\n\tapiservererrors \"github.com/juju/juju/apiserver/errors\"\n\t\"github.com/juju/juju/rpc/params\"\n\t\"github.com/juju/juju/state/backups\"\n)\n\nvar newBackups = backups.NewBackups\n\n// backupHandler handles backup requests.\ntype backupHandler struct {\n\tctxt httpContext\n}\n\nfunc (h *backupHandler) ServeHTTP(resp http.ResponseWriter, req *http.Request) {\n\t// Validate before authenticate because the authentication is dependent\n\t// on the state connection that is determined during the validation.\n\tst, err := h.ctxt.stateForRequestAuthenticatedUser(req)\n\tif err != nil {\n\t\th.sendError(resp, err)\n\t\treturn\n\t}\n\tdefer st.Release()\n\n\tif !st.IsController() {\n\t\th.sendError(resp, errors.New(\"requested model is not the controller model\"))\n\t\treturn\n\t}\n\n\tswitch req.Method {\n\tcase \"GET\":\n\t\tlogger.Infof(\"handling backups download request\")\n\t\tmodel, err := st.Model()\n\t\tif err != nil {\n\t\t\th.sendError(resp, err)\n\t\t\treturn\n\t\t}\n\t\tmodelConfig, err := model.ModelConfig()\n\t\tif err != nil {\n\t\t\th.sendError(resp, err)\n\t\t\treturn\n\t\t}\n\t\tbackupDir := modelConfig.BackupDir()\n\t\tif backupDir == \"\" {\n\t\t\tbackupDir = os.TempDir()\n\t\t}\n\n\t\tpaths := &backups.Paths{\n\t\t\tBackupDir: backupDir,\n\t\t}\n\t\tid, err := h.download(newBackups(paths), resp, req)\n\t\tif err != nil {\n\t\t\th.sendError(resp, err)\n\t\t\treturn\n\t\t}\n\t\tlogger.Infof(\"backups download request successful for %q\", id)\n\tdefault:\n\t\th.sendError(resp, errors.MethodNotAllowedf(\"unsupported method: %q\", req.Method))\n\t}\n}\n\nfunc (h *backupHandler) download(backups backups.Backups, resp http.ResponseWriter, req *http.Request) (string, error) {\n\targs, err := h.parseGETArgs(req)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tlogger.Infof(\"backups download request for %q\", args.ID)\n\n\tmeta, archive, err := backups.Get(args.ID)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer archive.Close()\n\n\terr = h.sendFile(archive, meta.Checksum(), resp)\n\treturn args.ID, err\n}\n\nfunc (h *backupHandler) read(req *http.Request, expectedType string) ([]byte, error) {\n\tdefer req.Body.Close()\n\n\tctype := req.Header.Get(\"Content-Type\")\n\tif ctype != expectedType {\n\t\treturn nil, errors.Errorf(\"expected Content-Type %q, got %q\", expectedType, ctype)\n\t}\n\n\tbody, err := ioutil.ReadAll(req.Body)\n\tif err != nil {\n\t\treturn nil, errors.Annotate(err, \"while reading request body\")\n\t}\n\n\treturn body, nil\n}\n\nfunc (h *backupHandler) parseGETArgs(req *http.Request) (*params.BackupsDownloadArgs, error) {\n\tbody, err := h.read(req, params.ContentTypeJSON)\n\tif err != nil {\n\t\treturn nil, errors.Trace(err)\n\t}\n\n\tvar args params.BackupsDownloadArgs\n\tif err := json.Unmarshal(body, &args); err != nil {\n\t\treturn nil, errors.Annotate(err, \"while de-serializing args\")\n\t}\n\n\treturn &args, nil\n}\n\nfunc (h *backupHandler) sendFile(file io.Reader, checksum string, resp http.ResponseWriter) error {\n\t// We don't set the Content-Length header, leaving it at -1.\n\tresp.Header().Set(\"Content-Type\", params.ContentTypeRaw)\n\tresp.Header().Set(\"Digest\", params.EncodeChecksum(checksum))\n\tresp.WriteHeader(http.StatusOK)\n\tif _, err := io.Copy(resp, file); err != nil {\n\t\treturn errors.Annotate(err, \"while streaming archive\")\n\t}\n\treturn nil\n}\n\n// sendError sends a JSON-encoded error response.\n// Note the difference from the error response sent by\n// the sendError function - the error is encoded directly\n// rather than in the Error field.\nfunc (h *backupHandler) sendError(w http.ResponseWriter, err error) {\n\terr, status := apiservererrors.ServerErrorAndStatus(err)\n\tif err := sendStatusAndJSON(w, status, err); err != nil {\n\t\tlogger.Errorf(\"%v\", err)\n\t}\n}\n", "patch": "@@ -8,6 +8,7 @@ import (\n \t\"io\"\n \t\"io/ioutil\"\n \t\"net/http\"\n+\t\"os\"\n \n \t\"github.com/juju/errors\"\n \n@@ -41,7 +42,25 @@ func (h *backupHandler) ServeHTTP(resp http.ResponseWriter, req *http.Request) {\n \tswitch req.Method {\n \tcase \"GET\":\n \t\tlogger.Infof(\"handling backups download request\")\n-\t\tid, err := h.download(newBackups(), resp, req)\n+\t\tmodel, err := st.Model()\n+\t\tif err != nil {\n+\t\t\th.sendError(resp, err)\n+\t\t\treturn\n+\t\t}\n+\t\tmodelConfig, err := model.ModelConfig()\n+\t\tif err != nil {\n+\t\t\th.sendError(resp, err)\n+\t\t\treturn\n+\t\t}\n+\t\tbackupDir := modelConfig.BackupDir()\n+\t\tif backupDir == \"\" {\n+\t\t\tbackupDir = os.TempDir()\n+\t\t}\n+\n+\t\tpaths := &backups.Paths{\n+\t\t\tBackupDir: backupDir,\n+\t\t}\n+\t\tid, err := h.download(newBackups(paths), resp, req)\n \t\tif err != nil {\n \t\t\th.sendError(resp, err)\n \t\t\treturn"}
{"patches_id": 1, "files_id": 3, "language": "go", "raw_url": "https://github.com/juju/juju/raw/ef803e2a13692d355b784b7da8b4b1f01dab1556/apiserver%2Fbackup_test.go", "raw_code": "// Copyright 2014 Canonical Ltd.\n// Licensed under the AGPLv3, see LICENCE file for details.\n\npackage apiserver_test\n\nimport (\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\n\t\"github.com/juju/errors\"\n\tjc \"github.com/juju/testing/checkers\"\n\t\"github.com/juju/utils/v3\"\n\tgc \"gopkg.in/check.v1\"\n\n\t\"github.com/juju/juju/apiserver\"\n\tapitesting \"github.com/juju/juju/apiserver/testing\"\n\t\"github.com/juju/juju/rpc/params\"\n\t\"github.com/juju/juju/state\"\n\t\"github.com/juju/juju/state/backups\"\n\tbackupstesting \"github.com/juju/juju/state/backups/testing\"\n)\n\nvar _ = gc.Suite(&backupsSuite{})\n\ntype backupsSuite struct {\n\tapiserverBaseSuite\n\tbackupURL string\n\tfake      *backupstesting.FakeBackups\n}\n\nfunc (s *backupsSuite) SetUpTest(c *gc.C) {\n\ts.apiserverBaseSuite.SetUpTest(c)\n\n\ts.backupURL = s.server.URL + fmt.Sprintf(\"/model/%s/backups\", s.State.ModelUUID())\n\ts.fake = &backupstesting.FakeBackups{}\n\ts.PatchValue(apiserver.NewBackups,\n\t\tfunc(path *backups.Paths) backups.Backups {\n\t\t\treturn s.fake\n\t\t},\n\t)\n}\n\nfunc (s *backupsSuite) assertErrorResponse(c *gc.C, resp *http.Response, statusCode int, msg string) *params.Error {\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tc.Assert(err, jc.ErrorIsNil)\n\n\tc.Assert(resp.StatusCode, gc.Equals, statusCode, gc.Commentf(\"body: %s\", body))\n\tc.Assert(resp.Header.Get(\"Content-Type\"), gc.Equals, params.ContentTypeJSON, gc.Commentf(\"body: %q\", body))\n\n\tvar failure params.Error\n\terr = json.Unmarshal(body, &failure)\n\tc.Assert(err, jc.ErrorIsNil)\n\tc.Assert(&failure, gc.ErrorMatches, msg, gc.Commentf(\"body: %s\", body))\n\treturn &failure\n}\n\nfunc (s *backupsSuite) TestRequiresAuth(c *gc.C) {\n\tresp := apitesting.SendHTTPRequest(c, apitesting.HTTPRequestParams{Method: \"GET\", URL: s.backupURL})\n\tdefer resp.Body.Close()\n\n\tc.Assert(resp.StatusCode, gc.Equals, http.StatusUnauthorized)\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tc.Assert(err, jc.ErrorIsNil)\n\tc.Assert(string(body), gc.Equals, \"authentication failed: no credentials provided\\n\")\n}\n\nfunc (s *backupsSuite) checkInvalidMethod(c *gc.C, method, url string) {\n\tresp := s.sendHTTPRequest(c, apitesting.HTTPRequestParams{Method: method, URL: url})\n\ts.assertErrorResponse(c, resp, http.StatusMethodNotAllowed, `unsupported method: \"`+method+`\"`)\n}\n\nfunc (s *backupsSuite) TestInvalidHTTPMethods(c *gc.C) {\n\turl := s.backupURL\n\tfor _, method := range []string{\"PUT\", \"POST\", \"DELETE\", \"OPTIONS\"} {\n\t\tc.Log(\"testing HTTP method: \" + method)\n\t\ts.checkInvalidMethod(c, method, url)\n\t}\n}\n\nfunc (s *backupsSuite) TestAuthRequiresClientNotMachine(c *gc.C) {\n\t// Add a machine and try to login.\n\tmachine, err := s.State.AddMachine(\"quantal\", state.JobHostUnits)\n\tc.Assert(err, jc.ErrorIsNil)\n\terr = machine.SetProvisioned(\"foo\", \"\", \"fake_nonce\", nil)\n\tc.Assert(err, jc.ErrorIsNil)\n\tpassword, err := utils.RandomPassword()\n\tc.Assert(err, jc.ErrorIsNil)\n\terr = machine.SetPassword(password)\n\tc.Assert(err, jc.ErrorIsNil)\n\n\tresp := apitesting.SendHTTPRequest(c, apitesting.HTTPRequestParams{\n\t\tTag:      machine.Tag().String(),\n\t\tPassword: password,\n\t\tMethod:   \"GET\",\n\t\tURL:      s.backupURL,\n\t\tNonce:    \"fake_nonce\",\n\t})\n\tc.Assert(resp.StatusCode, gc.Equals, http.StatusForbidden)\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tc.Assert(err, jc.ErrorIsNil)\n\tc.Assert(string(body), gc.Equals, \"authorization failed: machine 0 is not a user\\n\")\n\n\t// Now try a user login.\n\tresp = s.sendHTTPRequest(c, apitesting.HTTPRequestParams{Method: \"POST\", URL: s.backupURL})\n\ts.assertErrorResponse(c, resp, http.StatusMethodNotAllowed, `unsupported method: \"POST\"`)\n}\n\n// sendValid sends a valid GET request to the backups endpoint\n// and returns the response and the expected contents of the\n// archive if the request succeeds.\nfunc (s *backupsSuite) sendValidGet(c *gc.C) (resp *http.Response, archiveBytes []byte) {\n\tmeta := backupstesting.NewMetadata()\n\tarchive, err := backupstesting.NewArchiveBasic(meta)\n\tc.Assert(err, jc.ErrorIsNil)\n\tarchiveBytes = archive.Bytes()\n\ts.fake.Meta = meta\n\ts.fake.Archive = ioutil.NopCloser(archive)\n\n\treturn s.sendHTTPRequest(c, apitesting.HTTPRequestParams{\n\t\tMethod:      \"GET\",\n\t\tURL:         s.backupURL,\n\t\tContentType: params.ContentTypeJSON,\n\t\tJSONBody: params.BackupsDownloadArgs{\n\t\t\tID: meta.ID(),\n\t\t},\n\t}), archiveBytes\n}\n\nfunc (s *backupsSuite) TestCalls(c *gc.C) {\n\tresp, _ := s.sendValidGet(c)\n\tdefer resp.Body.Close()\n\n\tc.Check(s.fake.Calls, gc.DeepEquals, []string{\"Get\"})\n\tc.Check(s.fake.IDArg, gc.Equals, s.fake.Meta.ID())\n}\n\nfunc (s *backupsSuite) TestResponse(c *gc.C) {\n\tresp, _ := s.sendValidGet(c)\n\tdefer resp.Body.Close()\n\tmeta := s.fake.Meta\n\n\tc.Check(resp.StatusCode, gc.Equals, http.StatusOK)\n\texpectedChecksum := base64.StdEncoding.EncodeToString([]byte(meta.Checksum()))\n\tc.Check(resp.Header.Get(\"Digest\"), gc.Equals, string(params.DigestSHA256)+\"=\"+expectedChecksum)\n\tc.Check(resp.Header.Get(\"Content-Type\"), gc.Equals, params.ContentTypeRaw)\n}\n\nfunc (s *backupsSuite) TestBody(c *gc.C) {\n\tresp, archiveBytes := s.sendValidGet(c)\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tc.Assert(err, jc.ErrorIsNil)\n\tc.Check(body, jc.DeepEquals, archiveBytes)\n}\n\nfunc (s *backupsSuite) TestErrorWhenGetFails(c *gc.C) {\n\ts.fake.Error = errors.New(\"failed!\")\n\tresp, _ := s.sendValidGet(c)\n\tdefer resp.Body.Close()\n\n\ts.assertErrorResponse(c, resp, http.StatusInternalServerError, \"failed!\")\n}\n", "patch": "@@ -37,7 +37,7 @@ func (s *backupsSuite) SetUpTest(c *gc.C) {\n \ts.backupURL = s.server.URL + fmt.Sprintf(\"/model/%s/backups\", s.State.ModelUUID())\n \ts.fake = &backupstesting.FakeBackups{}\n \ts.PatchValue(apiserver.NewBackups,\n-\t\tfunc() backups.Backups {\n+\t\tfunc(path *backups.Paths) backups.Backups {\n \t\t\treturn s.fake\n \t\t},\n \t)\n@@ -98,7 +98,10 @@ func (s *backupsSuite) TestAuthRequiresClientNotMachine(c *gc.C) {\n \t\tURL:      s.backupURL,\n \t\tNonce:    \"fake_nonce\",\n \t})\n-\ts.assertErrorResponse(c, resp, http.StatusInternalServerError, \"tag kind machine not valid\")\n+\tc.Assert(resp.StatusCode, gc.Equals, http.StatusForbidden)\n+\tbody, err := ioutil.ReadAll(resp.Body)\n+\tc.Assert(err, jc.ErrorIsNil)\n+\tc.Assert(string(body), gc.Equals, \"authorization failed: machine 0 is not a user\\n\")\n \n \t// Now try a user login.\n \tresp = s.sendHTTPRequest(c, apitesting.HTTPRequestParams{Method: \"POST\", URL: s.backupURL})"}
{"patches_id": 1, "files_id": 4, "language": "go", "raw_url": "https://github.com/juju/juju/raw/ef803e2a13692d355b784b7da8b4b1f01dab1556/apiserver%2Ffacades%2Fclient%2Fbackups%2Fbackups.go", "raw_code": "// Copyright 2014 Canonical Ltd.\n// Licensed under the AGPLv3, see LICENCE file for details.\n\npackage backups\n\nimport (\n\t\"os\"\n\n\t\"github.com/juju/errors\"\n\t\"github.com/juju/mgo/v2\"\n\t\"github.com/juju/names/v4\"\n\n\t\"github.com/juju/juju/apiserver/common\"\n\tapiservererrors \"github.com/juju/juju/apiserver/errors\"\n\t\"github.com/juju/juju/apiserver/facade\"\n\t\"github.com/juju/juju/controller\"\n\t\"github.com/juju/juju/core/permission\"\n\t\"github.com/juju/juju/core/series\"\n\t\"github.com/juju/juju/environs/config\"\n\t\"github.com/juju/juju/rpc/params\"\n\t\"github.com/juju/juju/state\"\n\t\"github.com/juju/juju/state/backups\"\n)\n\n// Backend exposes state.State functionality needed by the backups Facade.\ntype Backend interface {\n\tIsController() bool\n\tMachine(id string) (Machine, error)\n\tMachineSeries(id string) (string, error)\n\tMongoSession() *mgo.Session\n\tMongoVersion() (string, error)\n\tModelTag() names.ModelTag\n\tModelType() state.ModelType\n\tControllerTag() names.ControllerTag\n\tModelConfig() (*config.Config, error)\n\tControllerConfig() (controller.Config, error)\n\tStateServingInfo() (controller.StateServingInfo, error)\n\tRestoreInfo() *state.RestoreInfo\n\tControllerNodes() ([]state.ControllerNode, error)\n}\n\n// API provides backup-specific API methods.\ntype API struct {\n\tbackend Backend\n\tpaths   *backups.Paths\n\n\t// machineID is the ID of the machine where the API server is running.\n\tmachineID string\n}\n\n// APIv2 serves backup-specific API methods for version 2.\ntype APIv2 struct {\n\t*API\n}\n\n// APIv3 serves backup-specific API methods for version 3.\ntype APIv3 struct {\n\t*APIv2\n}\n\n// NewAPIv3 returns a v3 api facade.\nfunc NewAPIv3(backend Backend, resources facade.Resources, authorizer facade.Authorizer) (*APIv3, error) {\n\tapi, err := NewAPIv2(backend, resources, authorizer)\n\tif err != nil {\n\t\treturn nil, errors.Trace(err)\n\t}\n\treturn &APIv3{api}, nil\n}\n\n// NewAPIv2 returns a v2 api facade.\nfunc NewAPIv2(backend Backend, resources facade.Resources, authorizer facade.Authorizer) (*APIv2, error) {\n\tapi, err := NewAPI(backend, resources, authorizer)\n\tif err != nil {\n\t\treturn nil, errors.Trace(err)\n\t}\n\treturn &APIv2{api}, nil\n}\n\n// NewAPI creates a new instance of the Backups API facade.\nfunc NewAPI(backend Backend, resources facade.Resources, authorizer facade.Authorizer) (*API, error) {\n\tisControllerAdmin, err := authorizer.HasPermission(permission.SuperuserAccess, backend.ControllerTag())\n\tif err != nil && !errors.IsNotFound(err) {\n\t\treturn nil, errors.Trace(err)\n\t}\n\n\tif !authorizer.AuthClient() || !isControllerAdmin {\n\t\treturn nil, apiservererrors.ErrPerm\n\t}\n\n\t// For now, backup operations are only permitted on the controller model.\n\tif !backend.IsController() {\n\t\treturn nil, errors.New(\"backups are only supported from the controller model\\nUse juju switch to select the controller model\")\n\t}\n\n\tif backend.ModelType() == state.ModelTypeCAAS {\n\t\treturn nil, errors.NotSupportedf(\"backups on kubernetes controllers\")\n\t}\n\n\t// Get the backup paths.\n\tdataDir, err := extractResourceValue(resources, \"dataDir\")\n\tif err != nil {\n\t\treturn nil, errors.Trace(err)\n\t}\n\tlogsDir, err := extractResourceValue(resources, \"logDir\")\n\tif err != nil {\n\t\treturn nil, errors.Trace(err)\n\t}\n\n\tmodelConfig, err := backend.ModelConfig()\n\tif err != nil {\n\t\treturn nil, errors.Trace(err)\n\t}\n\tbackupDir := modelConfig.BackupDir()\n\tif backupDir == \"\" {\n\t\tbackupDir = os.TempDir()\n\t}\n\n\tpaths := backups.Paths{\n\t\tBackupDir: backupDir,\n\t\tDataDir:   dataDir,\n\t\tLogsDir:   logsDir,\n\t}\n\n\t// Build the API.\n\tmachineID, err := extractResourceValue(resources, \"machineID\")\n\tif err != nil {\n\t\treturn nil, errors.Trace(err)\n\t}\n\tb := API{\n\t\tbackend:   backend,\n\t\tpaths:     &paths,\n\t\tmachineID: machineID,\n\t}\n\treturn &b, nil\n}\n\nfunc extractResourceValue(resources facade.Resources, key string) (string, error) {\n\tres := resources.Get(key)\n\tstrRes, ok := res.(common.StringResource)\n\tif !ok {\n\t\tif res == nil {\n\t\t\tstrRes = \"\"\n\t\t} else {\n\t\t\treturn \"\", errors.Errorf(\"invalid %s resource: %v\", key, res)\n\t\t}\n\t}\n\treturn strRes.String(), nil\n}\n\nvar newBackups = backups.NewBackups\n\n// CreateResult updates the result with the information in the\n// metadata value.\nfunc CreateResult(meta *backups.Metadata, filename string) params.BackupsMetadataResult {\n\tvar result params.BackupsMetadataResult\n\n\tresult.ID = meta.ID()\n\n\tresult.Checksum = meta.Checksum()\n\tresult.ChecksumFormat = meta.ChecksumFormat()\n\tresult.Size = meta.Size()\n\tif meta.Stored() != nil {\n\t\tresult.Stored = *(meta.Stored())\n\t}\n\n\tresult.Started = meta.Started\n\tif meta.Finished != nil {\n\t\tresult.Finished = *meta.Finished\n\t}\n\tresult.Notes = meta.Notes\n\n\tresult.Model = meta.Origin.Model\n\tresult.Machine = meta.Origin.Machine\n\tresult.Hostname = meta.Origin.Hostname\n\tresult.Version = meta.Origin.Version\n\tbase, _ := series.GetBaseFromSeries(meta.Origin.Series)\n\tresult.Series = meta.Origin.Series\n\tresult.Base = base.String()\n\n\tresult.ControllerUUID = meta.Controller.UUID\n\tresult.FormatVersion = meta.FormatVersion\n\tresult.HANodes = meta.Controller.HANodes\n\tresult.ControllerMachineID = meta.Controller.MachineID\n\tresult.ControllerMachineInstanceID = meta.Controller.MachineInstanceID\n\tresult.Filename = filename\n\n\treturn result\n}\n", "patch": "@@ -4,6 +4,8 @@\n package backups\n \n import (\n+\t\"os\"\n+\n \t\"github.com/juju/errors\"\n \t\"github.com/juju/mgo/v2\"\n \t\"github.com/juju/names/v4\"\n@@ -109,6 +111,9 @@ func NewAPI(backend Backend, resources facade.Resources, authorizer facade.Autho\n \t\treturn nil, errors.Trace(err)\n \t}\n \tbackupDir := modelConfig.BackupDir()\n+\tif backupDir == \"\" {\n+\t\tbackupDir = os.TempDir()\n+\t}\n \n \tpaths := backups.Paths{\n \t\tBackupDir: backupDir,"}
{"patches_id": 1, "files_id": 5, "language": "go", "raw_url": "https://github.com/juju/juju/raw/ef803e2a13692d355b784b7da8b4b1f01dab1556/apiserver%2Ffacades%2Fclient%2Fbackups%2Fbackups_test.go", "raw_code": "// Copyright 2014 Canonical Ltd.\n// Licensed under the AGPLv3, see LICENCE file for details.\n\npackage backups_test\n\nimport (\n\t\"github.com/juju/errors\"\n\t\"github.com/juju/names/v4\"\n\tjc \"github.com/juju/testing/checkers\"\n\tgc \"gopkg.in/check.v1\"\n\n\t\"github.com/juju/juju/apiserver/common\"\n\tapiservererrors \"github.com/juju/juju/apiserver/errors\"\n\tbackupsAPI \"github.com/juju/juju/apiserver/facades/client/backups\"\n\tapiservertesting \"github.com/juju/juju/apiserver/testing\"\n\t\"github.com/juju/juju/controller\"\n\t\"github.com/juju/juju/juju/testing\"\n\t\"github.com/juju/juju/state\"\n\t\"github.com/juju/juju/state/backups\"\n\tbackupstesting \"github.com/juju/juju/state/backups/testing\"\n)\n\ntype backupsSuite struct {\n\ttesting.JujuConnSuite\n\tresources  *common.Resources\n\tauthorizer *apiservertesting.FakeAuthorizer\n\tapi        *backupsAPI.APIv2\n\tmeta       *backups.Metadata\n\tmachineTag names.MachineTag\n}\n\nvar _ = gc.Suite(&backupsSuite{})\n\nfunc (s *backupsSuite) SetUpTest(c *gc.C) {\n\ts.JujuConnSuite.SetUpTest(c)\n\n\ts.machineTag = names.NewMachineTag(\"0\")\n\ts.resources = common.NewResources()\n\ts.resources.RegisterNamed(\"dataDir\", common.StringResource(s.DataDir()))\n\ts.resources.RegisterNamed(\"machineID\", common.StringResource(s.machineTag.Id()))\n\n\tssInfo, err := s.State.StateServingInfo()\n\tc.Assert(err, jc.ErrorIsNil)\n\tagentConfig := s.AgentConfigForTag(c, s.machineTag)\n\tagentConfig.SetStateServingInfo(controller.StateServingInfo{\n\t\tPrivateKey:   ssInfo.PrivateKey,\n\t\tCert:         ssInfo.Cert,\n\t\tCAPrivateKey: ssInfo.CAPrivateKey,\n\t\tSharedSecret: ssInfo.SharedSecret,\n\t\tAPIPort:      ssInfo.APIPort,\n\t\tStatePort:    ssInfo.StatePort,\n\t})\n\terr = agentConfig.Write()\n\tc.Assert(err, jc.ErrorIsNil)\n\n\ttag := names.NewLocalUserTag(\"admin\")\n\ts.authorizer = &apiservertesting.FakeAuthorizer{Tag: tag}\n\tshim := &stateShim{\n\t\tState:            s.State,\n\t\tModel:            s.Model,\n\t\tcontrollerNodesF: func() ([]state.ControllerNode, error) { return nil, nil },\n\t\tmachineF:         func(id string) (backupsAPI.Machine, error) { return &testMachine{}, nil },\n\t}\n\ts.api, err = backupsAPI.NewAPIv2(shim, s.resources, s.authorizer)\n\tc.Assert(err, jc.ErrorIsNil)\n\ts.meta = backupstesting.NewMetadataStarted()\n}\n\nfunc (s *backupsSuite) setBackups(c *gc.C, meta *backups.Metadata, err string) *backupstesting.FakeBackups {\n\tfake := backupstesting.FakeBackups{\n\t\tMeta:     meta,\n\t\tFilename: \"test-filename\",\n\t}\n\tif meta != nil {\n\t\tfake.MetaList = append(fake.MetaList, meta)\n\t}\n\tif err != \"\" {\n\t\tfake.Error = errors.Errorf(err)\n\t}\n\ts.PatchValue(backupsAPI.NewBackups,\n\t\tfunc(paths *backups.Paths) backups.Backups {\n\t\t\treturn &fake\n\t\t},\n\t)\n\treturn &fake\n}\n\nfunc (s *backupsSuite) TestNewAPIOkay(c *gc.C) {\n\t_, err := backupsAPI.NewAPIv2(&stateShim{State: s.State, Model: s.Model}, s.resources, s.authorizer)\n\tc.Check(err, jc.ErrorIsNil)\n}\n\nfunc (s *backupsSuite) TestNewAPINotAuthorized(c *gc.C) {\n\ts.authorizer.Tag = names.NewApplicationTag(\"eggs\")\n\t_, err := backupsAPI.NewAPIv2(&stateShim{State: s.State, Model: s.Model}, s.resources, s.authorizer)\n\tc.Check(errors.Cause(err), gc.Equals, apiservererrors.ErrPerm)\n}\n\nfunc (s *backupsSuite) TestNewAPIHostedEnvironmentFails(c *gc.C) {\n\totherState := s.Factory.MakeModel(c, nil)\n\tdefer otherState.Close()\n\totherModel, err := otherState.Model()\n\tc.Assert(err, jc.ErrorIsNil)\n\t_, err = backupsAPI.NewAPIv2(&stateShim{State: otherState, Model: otherModel}, s.resources, s.authorizer)\n\tc.Check(err, gc.ErrorMatches, \"backups are only supported from the controller model\\nUse juju switch to select the controller model\")\n}\n\nfunc (s *backupsSuite) TestBackupsCAASFails(c *gc.C) {\n\totherState := s.Factory.MakeCAASModel(c, nil)\n\tdefer otherState.Close()\n\totherModel, err := otherState.Model()\n\tc.Assert(err, jc.ErrorIsNil)\n\n\tisController := true\n\t_, err = backupsAPI.NewAPIv2(&stateShim{State: otherState, Model: otherModel, isController: &isController}, s.resources, s.authorizer)\n\tc.Assert(err, gc.ErrorMatches, \"backups on kubernetes controllers not supported\")\n}\n", "patch": "@@ -78,7 +78,7 @@ func (s *backupsSuite) setBackups(c *gc.C, meta *backups.Metadata, err string) *\n \t\tfake.Error = errors.Errorf(err)\n \t}\n \ts.PatchValue(backupsAPI.NewBackups,\n-\t\tfunc() backups.Backups {\n+\t\tfunc(paths *backups.Paths) backups.Backups {\n \t\t\treturn &fake\n \t\t},\n \t)"}
{"patches_id": 1, "files_id": 6, "language": "go", "raw_url": "https://github.com/juju/juju/raw/ef803e2a13692d355b784b7da8b4b1f01dab1556/apiserver%2Ffacades%2Fclient%2Fbackups%2Fcreate.go", "raw_code": "// Copyright 2014 Canonical Ltd.\n// Licensed under the AGPLv3, see LICENCE file for details.\n\npackage backups\n\nimport (\n\t\"github.com/juju/errors\"\n\t\"github.com/juju/mgo/v2\"\n\t\"github.com/juju/replicaset/v2\"\n\n\t\"github.com/juju/juju/mongo\"\n\t\"github.com/juju/juju/rpc/params\"\n\t\"github.com/juju/juju/state/backups\"\n)\n\nvar waitUntilReady = func(s *mgo.Session, timeout int) error {\n\treturn replicaset.WaitUntilReady(s, timeout)\n}\n\n// Create is the API method that requests juju to create a new backup\n// of its state.  It returns the metadata for that backup.\n//\n// NOTE(hml) this provides backwards compatibility for facade version 1.\nfunc (a *API) Create(args params.BackupsCreateArgs) (params.BackupsMetadataResult, error) {\n\targs.NoDownload = true\n\n\tapiv2 := APIv2{a}\n\tresult, err := apiv2.Create(args)\n\tif err != nil {\n\t\treturn result, errors.Trace(err)\n\t}\n\treturn result, nil\n}\n\nfunc (a *APIv2) Create(args params.BackupsCreateArgs) (params.BackupsMetadataResult, error) {\n\tbackupsMethods := newBackups(a.paths)\n\n\tsession := a.backend.MongoSession().Copy()\n\tdefer session.Close()\n\n\tresult := params.BackupsMetadataResult{}\n\t// Don't go if HA isn't ready.\n\terr := waitUntilReady(session, 60)\n\tif err != nil {\n\t\treturn result, errors.Annotatef(err, \"HA not ready; try again later\")\n\t}\n\n\tmgoInfo, err := mongoInfo(a.paths.DataDir, a.machineID)\n\tif err != nil {\n\t\treturn result, errors.Annotatef(err, \"getting mongo info\")\n\t}\n\tv, err := a.backend.MongoVersion()\n\tif err != nil {\n\t\treturn result, errors.Annotatef(err, \"discovering mongo version\")\n\t}\n\tmongoVersion, err := mongo.NewVersion(v)\n\tif err != nil {\n\t\treturn result, errors.Trace(err)\n\t}\n\tdbInfo, err := backups.NewDBInfo(mgoInfo, sessionShim{session}, mongoVersion)\n\tif err != nil {\n\t\treturn result, errors.Trace(err)\n\t}\n\tmSeries, err := a.backend.MachineSeries(a.machineID)\n\tif err != nil {\n\t\treturn result, errors.Trace(err)\n\t}\n\n\tmeta, err := backups.NewMetadataState(a.backend, a.machineID, mSeries)\n\tif err != nil {\n\t\treturn result, errors.Trace(err)\n\t}\n\tmeta.Notes = args.Notes\n\tmeta.Controller.MachineID = a.machineID\n\tm, err := a.backend.Machine(a.machineID)\n\tif err != nil {\n\t\treturn result, errors.Trace(err)\n\t}\n\tinstanceID, err := m.InstanceId()\n\tif err != nil {\n\t\treturn result, errors.Trace(err)\n\t}\n\tmeta.Controller.MachineInstanceID = string(instanceID)\n\n\tnodes, err := a.backend.ControllerNodes()\n\tif err != nil {\n\t\treturn result, errors.Trace(err)\n\t}\n\tmeta.Controller.HANodes = int64(len(nodes))\n\n\tfileName, err := backupsMethods.Create(meta, dbInfo)\n\tif err != nil {\n\t\treturn result, errors.Trace(err)\n\t}\n\n\tresult = CreateResult(meta, fileName)\n\treturn result, nil\n}\n", "patch": "@@ -33,7 +33,7 @@ func (a *API) Create(args params.BackupsCreateArgs) (params.BackupsMetadataResul\n }\n \n func (a *APIv2) Create(args params.BackupsCreateArgs) (params.BackupsMetadataResult, error) {\n-\tbackupsMethods := newBackups()\n+\tbackupsMethods := newBackups(a.paths)\n \n \tsession := a.backend.MongoSession().Copy()\n \tdefer session.Close()\n@@ -88,7 +88,7 @@ func (a *APIv2) Create(args params.BackupsCreateArgs) (params.BackupsMetadataRes\n \t}\n \tmeta.Controller.HANodes = int64(len(nodes))\n \n-\tfileName, err := backupsMethods.Create(meta, a.paths, dbInfo)\n+\tfileName, err := backupsMethods.Create(meta, dbInfo)\n \tif err != nil {\n \t\treturn result, errors.Trace(err)\n \t}"}
{"patches_id": 1, "files_id": 7, "language": "go", "raw_url": "https://github.com/juju/juju/raw/ef803e2a13692d355b784b7da8b4b1f01dab1556/state%2Fbackups%2Fbackups.go", "raw_code": "// Copyright 2014 Canonical Ltd.\n// Licensed under the AGPLv3, see LICENCE file for details.\n\npackage backups\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"io/fs\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/dustin/go-humanize\"\n\t\"github.com/juju/errors\"\n\t\"github.com/juju/loggo\"\n\t\"github.com/juju/utils/v3/du\"\n)\n\nconst (\n\t// FilenamePrefix is the prefix used for backup archive files.\n\tFilenamePrefix = \"juju-backup-\"\n\n\t// FilenameTemplate is used with time.Time.Format to generate a filename.\n\tFilenameTemplate = FilenamePrefix + \"20060102-150405.tar.gz\"\n)\n\nvar logger = loggo.GetLogger(\"juju.state.backups\")\n\nvar (\n\tgetFilesToBackUp = GetFilesToBackUp\n\tgetDBDumper      = NewDBDumper\n\trunCreate        = create\n\tfinishMeta       = func(meta *Metadata, result *createResult) error {\n\t\treturn meta.MarkComplete(result.size, result.checksum)\n\t}\n\tavailableDisk = func(path string) uint64 {\n\t\treturn du.NewDiskUsage(path).Available()\n\t}\n\ttotalDisk = func(path string) uint64 {\n\t\treturn du.NewDiskUsage(path).Size()\n\t}\n\tdirSize = totalDirSize\n)\n\n// Backups is an abstraction around all juju backup-related functionality.\ntype Backups interface {\n\t// Create creates a new juju backup archive. It updates\n\t// the provided metadata.\n\tCreate(meta *Metadata, dbInfo *DBInfo) (string, error)\n\n\t// Get returns the metadata and specified archive file.\n\tGet(fileName string) (*Metadata, io.ReadCloser, error)\n}\n\ntype backups struct {\n\tpaths *Paths\n}\n\n// NewBackups creates a new Backups value using the FileStorage provided.\nfunc NewBackups(paths *Paths) Backups {\n\treturn &backups{\n\t\tpaths: paths,\n\t}\n}\n\nfunc totalDirSize(path string) (int64, error) {\n\tvar size int64\n\terr := filepath.Walk(path, func(_ string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif !info.IsDir() {\n\t\t\tsize += info.Size()\n\t\t}\n\t\treturn err\n\t})\n\treturn size, err\n}\n\n// Create creates and stores a new juju backup archive (based on arguments)\n// and updates the provided metadata.  A filename to download the backup is provided.\nfunc (b *backups) Create(meta *Metadata, dbInfo *DBInfo) (string, error) {\n\t// TODO(fwereade): 2016-03-17 lp:1558657\n\tmeta.Started = time.Now().UTC()\n\n\t// The metadata file will not contain the ID or the \"finished\" data.\n\t// However, that information is not as critical. The alternatives\n\t// are either adding the metadata file to the archive after the fact\n\t// or adding placeholders here for the finished data and filling\n\t// them in afterward.  Neither is particularly trivial.\n\tmetadataFile, err := meta.AsJSONBuffer()\n\tif err != nil {\n\t\treturn \"\", errors.Annotate(err, \"while preparing the metadata\")\n\t}\n\n\t// Create the archive.\n\tfilesToBackUp, err := getFilesToBackUp(\"\", b.paths)\n\tif err != nil {\n\t\treturn \"\", errors.Annotate(err, \"while listing files to back up\")\n\t}\n\n\tvar totalFileSizes int64\n\tfor _, f := range filesToBackUp {\n\t\tsize, err := dirSize(f)\n\t\tif err != nil {\n\t\t\treturn \"\", errors.Trace(err)\n\t\t}\n\t\ttotalFileSizes += size\n\t}\n\n\ttotalFizeSizesMiB := int64(dbInfo.ApproxSizeMB) + totalFileSizes/humanize.MiByte\n\tlogger.Infof(\"backing up %dMiB (files) and %dMiB (database) = %dMiB\",\n\t\ttotalFizeSizesMiB, dbInfo.ApproxSizeMB, int(totalFizeSizesMiB)+dbInfo.ApproxSizeMB)\n\n\tdestinationDir := b.paths.BackupDir\n\tif _, err := os.Stat(destinationDir); err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn \"\", errors.Errorf(\"backup destination directory %q does not exist\", destinationDir)\n\t\t}\n\t\treturn \"\", errors.NewNotValid(nil, fmt.Sprintf(\"invalid backup destination directory %q: %v\", destinationDir, err))\n\t}\n\tif !filepath.IsAbs(destinationDir) {\n\t\treturn \"\", errors.Errorf(\"cannot use relative backup destination directory %q\", destinationDir)\n\t}\n\n\t// We require space equal to the larger of:\n\t// - smaller of 5GB or 10% of the total disk size\n\t// - 20% of the backup size\n\t// on top of the approximate backup size to be available.\n\tconst minFreeAbsolute = 5 * humanize.GiByte\n\n\tdiskSizeMargin := float64(totalDisk(destinationDir)) * 0.10\n\tif diskSizeMargin > minFreeAbsolute {\n\t\tdiskSizeMargin = minFreeAbsolute\n\t}\n\tbackupSizeMargin := float64(totalFizeSizesMiB) * 0.20 * humanize.MiByte\n\tif backupSizeMargin < diskSizeMargin {\n\t\tbackupSizeMargin = diskSizeMargin\n\t}\n\twantFree := uint64(totalFizeSizesMiB) + uint64(backupSizeMargin/humanize.MiByte)\n\n\tavailable := availableDisk(destinationDir) / humanize.MiByte\n\tlogger.Infof(\"free disk on volume hosting %q: %dMiB\", destinationDir, available)\n\tif available < wantFree {\n\t\treturn \"\", errors.Errorf(\"not enough free space in %q; want %dMiB, have %dMiB\", destinationDir, wantFree, available)\n\t}\n\n\tdumper, err := getDBDumper(dbInfo)\n\tif err != nil {\n\t\treturn \"\", errors.Annotate(err, \"while preparing for DB dump\")\n\t}\n\n\targs := createArgs{\n\t\tdestinationDir: destinationDir,\n\t\tfilesToBackUp:  filesToBackUp,\n\t\tdb:             dumper,\n\t\tmetadataReader: metadataFile,\n\t}\n\tresult, err := runCreate(&args)\n\tif err != nil {\n\t\treturn \"\", errors.Annotate(err, \"while creating backup archive\")\n\t}\n\tdefer func() { _ = result.archiveFile.Close() }()\n\n\t// Finalize the metadata.\n\terr = finishMeta(meta, result)\n\tif err != nil {\n\t\treturn \"\", errors.Annotate(err, \"while updating metadata\")\n\t}\n\n\treturn result.filename, nil\n}\n\nfunc isValidFilepath(root string, filePath string) (bool, error) {\n\tif !filepath.IsAbs(filePath) {\n\t\treturn false, nil\n\t}\n\tif !strings.HasPrefix(filepath.Base(filePath), FilenamePrefix) {\n\t\treturn false, nil\n\t}\n\tresult := false\n\terr := filepath.WalkDir(root, func(path string, d fs.DirEntry, err error) error {\n\t\tif d.IsDir() {\n\t\t\treturn nil\n\t\t}\n\t\tif path == filePath {\n\t\t\tresult = true\n\t\t\treturn nil\n\t\t}\n\t\treturn nil\n\t})\n\treturn result, err\n}\n\n// Get retrieves the associated metadata and archive file a file on the machine.\nfunc (b *backups) Get(fileName string) (_ *Metadata, _ io.ReadCloser, err error) {\n\tvalid, err := isValidFilepath(b.paths.BackupDir, fileName)\n\tif err != nil {\n\t\treturn nil, nil, errors.Trace(err)\n\t}\n\tif !valid {\n\t\treturn nil, nil, errors.NotValidf(\"backup file %q\", fileName)\n\t}\n\tdefer func() {\n\t\t// On success, remove the retrieved file.\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err2 := os.Remove(fileName); err2 != nil && !os.IsNotExist(err2) {\n\t\t\tlogger.Errorf(\"error removing backup archive: %v\", err2.Error())\n\t\t}\n\t}()\n\n\treadCloser, err := os.Open(fileName)\n\tif err != nil {\n\t\treturn nil, nil, errors.Annotate(err, \"while opening archive file for download\")\n\t}\n\n\tmeta, err := BuildMetadata(readCloser)\n\tif err != nil {\n\t\treturn nil, nil, errors.Annotate(err, \"while creating metadata for archive file to download\")\n\t}\n\n\t// BuildMetadata copied readCloser, so reset handle to beginning of the file\n\t_, err = readCloser.Seek(0, io.SeekStart)\n\tif err != nil {\n\t\treturn nil, nil, errors.Annotate(err, \"while resetting archive file to download\")\n\t}\n\n\treturn meta, readCloser, nil\n}\n", "patch": "@@ -6,8 +6,10 @@ package backups\n import (\n \t\"fmt\"\n \t\"io\"\n+\t\"io/fs\"\n \t\"os\"\n \t\"path/filepath\"\n+\t\"strings\"\n \t\"time\"\n \n \t\"github.com/dustin/go-humanize\"\n@@ -46,17 +48,21 @@ var (\n type Backups interface {\n \t// Create creates a new juju backup archive. It updates\n \t// the provided metadata.\n-\tCreate(meta *Metadata, paths *Paths, dbInfo *DBInfo) (string, error)\n+\tCreate(meta *Metadata, dbInfo *DBInfo) (string, error)\n \n \t// Get returns the metadata and specified archive file.\n \tGet(fileName string) (*Metadata, io.ReadCloser, error)\n }\n \n-type backups struct{}\n+type backups struct {\n+\tpaths *Paths\n+}\n \n // NewBackups creates a new Backups value using the FileStorage provided.\n-func NewBackups() Backups {\n-\treturn &backups{}\n+func NewBackups(paths *Paths) Backups {\n+\treturn &backups{\n+\t\tpaths: paths,\n+\t}\n }\n \n func totalDirSize(path string) (int64, error) {\n@@ -75,7 +81,7 @@ func totalDirSize(path string) (int64, error) {\n \n // Create creates and stores a new juju backup archive (based on arguments)\n // and updates the provided metadata.  A filename to download the backup is provided.\n-func (b *backups) Create(meta *Metadata, paths *Paths, dbInfo *DBInfo) (string, error) {\n+func (b *backups) Create(meta *Metadata, dbInfo *DBInfo) (string, error) {\n \t// TODO(fwereade): 2016-03-17 lp:1558657\n \tmeta.Started = time.Now().UTC()\n \n@@ -90,7 +96,7 @@ func (b *backups) Create(meta *Metadata, paths *Paths, dbInfo *DBInfo) (string,\n \t}\n \n \t// Create the archive.\n-\tfilesToBackUp, err := getFilesToBackUp(\"\", paths)\n+\tfilesToBackUp, err := getFilesToBackUp(\"\", b.paths)\n \tif err != nil {\n \t\treturn \"\", errors.Annotate(err, \"while listing files to back up\")\n \t}\n@@ -108,11 +114,7 @@ func (b *backups) Create(meta *Metadata, paths *Paths, dbInfo *DBInfo) (string,\n \tlogger.Infof(\"backing up %dMiB (files) and %dMiB (database) = %dMiB\",\n \t\ttotalFizeSizesMiB, dbInfo.ApproxSizeMB, int(totalFizeSizesMiB)+dbInfo.ApproxSizeMB)\n \n-\tdestinationDir := paths.BackupDir\n-\tif destinationDir == \"\" {\n-\t\tdestinationDir = os.TempDir()\n-\t}\n-\n+\tdestinationDir := b.paths.BackupDir\n \tif _, err := os.Stat(destinationDir); err != nil {\n \t\tif os.IsNotExist(err) {\n \t\t\treturn \"\", errors.Errorf(\"backup destination directory %q does not exist\", destinationDir)\n@@ -171,8 +173,36 @@ func (b *backups) Create(meta *Metadata, paths *Paths, dbInfo *DBInfo) (string,\n \treturn result.filename, nil\n }\n \n+func isValidFilepath(root string, filePath string) (bool, error) {\n+\tif !filepath.IsAbs(filePath) {\n+\t\treturn false, nil\n+\t}\n+\tif !strings.HasPrefix(filepath.Base(filePath), FilenamePrefix) {\n+\t\treturn false, nil\n+\t}\n+\tresult := false\n+\terr := filepath.WalkDir(root, func(path string, d fs.DirEntry, err error) error {\n+\t\tif d.IsDir() {\n+\t\t\treturn nil\n+\t\t}\n+\t\tif path == filePath {\n+\t\t\tresult = true\n+\t\t\treturn nil\n+\t\t}\n+\t\treturn nil\n+\t})\n+\treturn result, err\n+}\n+\n // Get retrieves the associated metadata and archive file a file on the machine.\n func (b *backups) Get(fileName string) (_ *Metadata, _ io.ReadCloser, err error) {\n+\tvalid, err := isValidFilepath(b.paths.BackupDir, fileName)\n+\tif err != nil {\n+\t\treturn nil, nil, errors.Trace(err)\n+\t}\n+\tif !valid {\n+\t\treturn nil, nil, errors.NotValidf(\"backup file %q\", fileName)\n+\t}\n \tdefer func() {\n \t\t// On success, remove the retrieved file.\n \t\tif err != nil {"}
{"patches_id": 1, "files_id": 8, "language": "go", "raw_url": "https://github.com/juju/juju/raw/ef803e2a13692d355b784b7da8b4b1f01dab1556/state%2Fbackups%2Fbackups_test.go", "raw_code": "// Copyright 2013,2014 Canonical Ltd.\n// Licensed under the AGPLv3, see LICENCE file for details.\n\npackage backups_test\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\n\t\"github.com/dustin/go-humanize\"\n\t\"github.com/juju/collections/set\"\n\t\"github.com/juju/errors\"\n\tjc \"github.com/juju/testing/checkers\"\n\tgc \"gopkg.in/check.v1\"\n\n\t\"github.com/juju/juju/mongo\"\n\t\"github.com/juju/juju/state/backups\"\n\tbackupstesting \"github.com/juju/juju/state/backups/testing\"\n)\n\ntype backupsSuite struct {\n\tbackupstesting.BaseSuite\n\n\tpaths *backups.Paths\n\tapi   backups.Backups\n\n\ttotalDiskMiB     uint64\n\tavailableDiskMiB uint64\n\tdirSizeBytes     int64\n\tdbSizeMiB        int\n}\n\nvar _ = gc.Suite(&backupsSuite{}) // Register the suite.\n\nfunc (s *backupsSuite) SetUpTest(c *gc.C) {\n\ts.BaseSuite.SetUpTest(c)\n\n\ts.paths = &backups.Paths{\n\t\tBackupDir: c.MkDir(),\n\t\tDataDir:   c.MkDir(),\n\t}\n\ts.api = backups.NewBackups(s.paths)\n\ts.PatchValue(backups.AvailableDisk, func(string) uint64 {\n\t\treturn s.availableDiskMiB\n\t})\n\ts.PatchValue(backups.TotalDisk, func(string) uint64 {\n\t\treturn s.totalDiskMiB\n\t})\n\ts.PatchValue(backups.DirSize, func(path string) (int64, error) {\n\t\treturn s.dirSizeBytes, nil\n\t})\n}\n\ntype fakeDumper struct{}\n\nfunc (*fakeDumper) Dump(dumpDir string) error {\n\treturn nil\n}\n\nfunc (s *backupsSuite) checkFailure(c *gc.C, expected string) {\n\ts.PatchValue(backups.GetDBDumper, func(*backups.DBInfo) (backups.DBDumper, error) {\n\t\treturn &fakeDumper{}, nil\n\t})\n\n\ttargets := set.NewStrings(\"juju\", \"admin\")\n\tdbInfo := backups.DBInfo{\n\t\tAddress: \"a\", Username: \"b\", Password: \"c\",\n\t\tTargets:      targets,\n\t\tMongoVersion: mongo.Mongo32wt, ApproxSizeMB: s.dbSizeMiB}\n\tmeta := backupstesting.NewMetadataStarted()\n\tmeta.Notes = \"some notes\"\n\n\t_, err := s.api.Create(meta, &dbInfo)\n\tc.Check(err, gc.ErrorMatches, expected)\n}\n\nfunc (s *backupsSuite) TestCreateOkay(c *gc.C) {\n\t// Patch the internals.\n\tarchiveFile := ioutil.NopCloser(bytes.NewBufferString(\"<compressed tarball>\"))\n\tresult := backups.NewTestCreateResult(\n\t\tarchiveFile,\n\t\t10,\n\t\t\"<checksum>\",\n\t\tpath.Join(s.paths.BackupDir, \"test-backup.tar.gz\"))\n\treceived, testCreate := backups.NewTestCreate(result)\n\ts.PatchValue(backups.RunCreate, testCreate)\n\n\trootDir := \"<was never set>\"\n\ts.PatchValue(backups.TestGetFilesToBackUp, func(root string, paths *backups.Paths) ([]string, error) {\n\t\trootDir = root\n\t\treturn []string{\"<some file>\"}, nil\n\t})\n\n\tvar receivedDBInfo *backups.DBInfo\n\ts.PatchValue(backups.GetDBDumper, func(info *backups.DBInfo) (backups.DBDumper, error) {\n\t\treceivedDBInfo = info\n\t\treturn nil, nil\n\t})\n\n\t// Run the backup.\n\ttargets := set.NewStrings(\"juju\", \"admin\")\n\tdbInfo := backups.DBInfo{\n\t\tAddress: \"a\", Username: \"b\", Password: \"c\",\n\t\tTargets:      targets,\n\t\tMongoVersion: mongo.Mongo32wt, ApproxSizeMB: s.dbSizeMiB}\n\tmeta := backupstesting.NewMetadataStarted()\n\tbackupstesting.SetOrigin(meta, \"<model ID>\", \"<machine ID>\", \"<hostname>\")\n\tmeta.Notes = \"some notes\"\n\tresultFilename, err := s.api.Create(meta, &dbInfo)\n\tc.Assert(err, jc.ErrorIsNil)\n\tc.Assert(resultFilename, gc.Equals, path.Join(s.paths.BackupDir, \"test-backup.tar.gz\"))\n\n\t// Test the call values.\n\tresultBackupDir, filesToBackUp, _ := backups.ExposeCreateArgs(received)\n\tc.Check(resultBackupDir, gc.Equals, s.paths.BackupDir)\n\tc.Check(filesToBackUp, jc.SameContents, []string{\"<some file>\"})\n\n\tc.Check(receivedDBInfo.Address, gc.Equals, \"a\")\n\tc.Check(receivedDBInfo.Username, gc.Equals, \"b\")\n\tc.Check(receivedDBInfo.Password, gc.Equals, \"c\")\n\tc.Check(receivedDBInfo.Targets, gc.DeepEquals, targets)\n\n\tc.Check(rootDir, gc.Equals, \"\")\n\n\t// Check the resulting metadata.\n\tc.Check(meta.Size(), gc.Equals, int64(10))\n\tc.Check(meta.Checksum(), gc.Equals, \"<checksum>\")\n\tc.Check(meta.Origin.Model, gc.Equals, \"<model ID>\")\n\tc.Check(meta.Origin.Machine, gc.Equals, \"<machine ID>\")\n\tc.Check(meta.Origin.Hostname, gc.Equals, \"<hostname>\")\n\tc.Check(meta.Notes, gc.Equals, \"some notes\")\n}\n\nfunc (s *backupsSuite) TestCreateFailToListFiles(c *gc.C) {\n\ts.PatchValue(backups.TestGetFilesToBackUp, func(root string, paths *backups.Paths) ([]string, error) {\n\t\treturn nil, errors.New(\"failed!\")\n\t})\n\n\ts.checkFailure(c, \"while listing files to back up: failed!\")\n}\n\nfunc (s *backupsSuite) TestCreateFailToCreate(c *gc.C) {\n\ts.PatchValue(backups.TestGetFilesToBackUp, func(root string, paths *backups.Paths) ([]string, error) {\n\t\treturn []string{}, nil\n\t})\n\ts.PatchValue(backups.RunCreate, backups.NewTestCreateFailure(\"failed!\"))\n\n\ts.checkFailure(c, \"while creating backup archive: failed!\")\n}\n\nfunc (s *backupsSuite) TestCreateFailToFinishMeta(c *gc.C) {\n\ts.PatchValue(backups.TestGetFilesToBackUp, func(root string, paths *backups.Paths) ([]string, error) {\n\t\treturn []string{}, nil\n\t})\n\t_, testCreate := backups.NewTestCreate(nil)\n\ts.PatchValue(backups.RunCreate, testCreate)\n\ts.PatchValue(backups.FinishMeta, backups.NewTestMetaFinisher(\"failed!\"))\n\n\ts.checkFailure(c, \"while updating metadata: failed!\")\n}\n\nfunc (s *backupsSuite) TestNotEnoughDiskSpaceSmallBackup(c *gc.C) {\n\ts.PatchValue(backups.TestGetFilesToBackUp, func(root string, paths *backups.Paths) ([]string, error) {\n\t\treturn []string{\"file1\"}, nil\n\t})\n\ts.dbSizeMiB = 6\n\ts.dirSizeBytes = 3 * humanize.MiByte\n\ts.availableDiskMiB = 10 * humanize.MiByte\n\ts.totalDiskMiB = 200 * humanize.GiByte\n\n\ts.checkFailure(c, \"not enough free space in .*; want 5129MiB, have 10MiB\")\n}\n\nfunc (s *backupsSuite) TestNotEnoughDiskSpaceLargeBackup(c *gc.C) {\n\ts.PatchValue(backups.TestGetFilesToBackUp, func(root string, paths *backups.Paths) ([]string, error) {\n\t\treturn []string{\"file1\"}, nil\n\t})\n\ts.dbSizeMiB = 100\n\ts.dirSizeBytes = 50 * humanize.GiByte\n\ts.availableDiskMiB = 10 * humanize.MiByte\n\ts.totalDiskMiB = 200 * humanize.GiByte\n\n\ts.checkFailure(c, \"not enough free space in .*; want 61560MiB, have 10MiB\")\n}\n\nfunc (s *backupsSuite) TestNotEnoughDiskSpaceSmallDisk(c *gc.C) {\n\ts.PatchValue(backups.TestGetFilesToBackUp, func(root string, paths *backups.Paths) ([]string, error) {\n\t\treturn []string{\"file1\"}, nil\n\t})\n\ts.dbSizeMiB = 6\n\ts.dirSizeBytes = 3 * humanize.MiByte\n\ts.availableDiskMiB = 10 * humanize.MiByte\n\ts.totalDiskMiB = 20 * humanize.GiByte\n\n\ts.checkFailure(c, \"not enough free space in .*; want 2057MiB, have 10MiB\")\n}\n\nfunc (s *backupsSuite) TestGetFileName(c *gc.C) {\n\tbackupSubDir := filepath.Join(s.paths.BackupDir, \"a\", \"b\")\n\terr := os.MkdirAll(backupSubDir, 0755)\n\tc.Assert(err, jc.ErrorIsNil)\n\tbackupFilename := path.Join(backupSubDir, \"juju-backup-123.tar.gz\")\n\tbackupFile, err := os.Create(backupFilename)\n\tc.Assert(err, jc.ErrorIsNil)\n\t_, err = backupFile.Write([]byte(\"archive file testing\"))\n\tc.Assert(err, jc.ErrorIsNil)\n\n\t_, _, err = s.api.Get(\"/etc/hostname\")\n\tc.Assert(err, gc.ErrorMatches, `backup file \"/etc/hostname\" not valid`)\n\n\tresultMeta, resultArchive, err := s.api.Get(backupFilename)\n\tc.Assert(err, jc.ErrorIsNil)\n\tdefer resultArchive.Close()\n\tresultMeta.FileMetadata.Checksum()\n\n\t// Purpose for metadata here is for the checksum to be used by the\n\t// caller, so check it here.\n\tc.Assert(resultMeta.FileMetadata.Checksum(), gc.NotNil)\n\tb, err := ioutil.ReadAll(resultArchive)\n\tc.Assert(err, jc.ErrorIsNil)\n\tc.Assert(string(b), gc.Equals, \"archive file testing\")\n\n\t_, err = os.Stat(backupFilename)\n\tc.Assert(err, gc.ErrorMatches, fmt.Sprintf(\"stat %s: no such file or directory\", backupFilename))\n}\n", "patch": "@@ -9,6 +9,7 @@ import (\n \t\"io/ioutil\"\n \t\"os\"\n \t\"path\"\n+\t\"path/filepath\"\n \n \t\"github.com/dustin/go-humanize\"\n \t\"github.com/juju/collections/set\"\n@@ -24,7 +25,8 @@ import (\n type backupsSuite struct {\n \tbackupstesting.BaseSuite\n \n-\tapi backups.Backups\n+\tpaths *backups.Paths\n+\tapi   backups.Backups\n \n \ttotalDiskMiB     uint64\n \tavailableDiskMiB uint64\n@@ -37,7 +39,11 @@ var _ = gc.Suite(&backupsSuite{}) // Register the suite.\n func (s *backupsSuite) SetUpTest(c *gc.C) {\n \ts.BaseSuite.SetUpTest(c)\n \n-\ts.api = backups.NewBackups()\n+\ts.paths = &backups.Paths{\n+\t\tBackupDir: c.MkDir(),\n+\t\tDataDir:   c.MkDir(),\n+\t}\n+\ts.api = backups.NewBackups(s.paths)\n \ts.PatchValue(backups.AvailableDisk, func(string) uint64 {\n \t\treturn s.availableDiskMiB\n \t})\n@@ -60,7 +66,6 @@ func (s *backupsSuite) checkFailure(c *gc.C, expected string) {\n \t\treturn &fakeDumper{}, nil\n \t})\n \n-\tpaths := backups.Paths{DataDir: \"/var/lib/juju\"}\n \ttargets := set.NewStrings(\"juju\", \"admin\")\n \tdbInfo := backups.DBInfo{\n \t\tAddress: \"a\", Username: \"b\", Password: \"c\",\n@@ -69,20 +74,18 @@ func (s *backupsSuite) checkFailure(c *gc.C, expected string) {\n \tmeta := backupstesting.NewMetadataStarted()\n \tmeta.Notes = \"some notes\"\n \n-\t_, err := s.api.Create(meta, &paths, &dbInfo)\n+\t_, err := s.api.Create(meta, &dbInfo)\n \tc.Check(err, gc.ErrorMatches, expected)\n }\n \n func (s *backupsSuite) TestCreateOkay(c *gc.C) {\n-\tdataDir := c.MkDir()\n-\tbackupDir := c.MkDir()\n \t// Patch the internals.\n \tarchiveFile := ioutil.NopCloser(bytes.NewBufferString(\"<compressed tarball>\"))\n \tresult := backups.NewTestCreateResult(\n \t\tarchiveFile,\n \t\t10,\n \t\t\"<checksum>\",\n-\t\tpath.Join(backupDir, \"test-backup.tar.gz\"))\n+\t\tpath.Join(s.paths.BackupDir, \"test-backup.tar.gz\"))\n \treceived, testCreate := backups.NewTestCreate(result)\n \ts.PatchValue(backups.RunCreate, testCreate)\n \n@@ -99,7 +102,6 @@ func (s *backupsSuite) TestCreateOkay(c *gc.C) {\n \t})\n \n \t// Run the backup.\n-\tpaths := backups.Paths{BackupDir: backupDir, DataDir: dataDir}\n \ttargets := set.NewStrings(\"juju\", \"admin\")\n \tdbInfo := backups.DBInfo{\n \t\tAddress: \"a\", Username: \"b\", Password: \"c\",\n@@ -108,13 +110,13 @@ func (s *backupsSuite) TestCreateOkay(c *gc.C) {\n \tmeta := backupstesting.NewMetadataStarted()\n \tbackupstesting.SetOrigin(meta, \"<model ID>\", \"<machine ID>\", \"<hostname>\")\n \tmeta.Notes = \"some notes\"\n-\tresultFilename, err := s.api.Create(meta, &paths, &dbInfo)\n+\tresultFilename, err := s.api.Create(meta, &dbInfo)\n \tc.Assert(err, jc.ErrorIsNil)\n-\tc.Assert(resultFilename, gc.Equals, path.Join(backupDir, \"test-backup.tar.gz\"))\n+\tc.Assert(resultFilename, gc.Equals, path.Join(s.paths.BackupDir, \"test-backup.tar.gz\"))\n \n \t// Test the call values.\n \tresultBackupDir, filesToBackUp, _ := backups.ExposeCreateArgs(received)\n-\tc.Check(resultBackupDir, gc.Equals, backupDir)\n+\tc.Check(resultBackupDir, gc.Equals, s.paths.BackupDir)\n \tc.Check(filesToBackUp, jc.SameContents, []string{\"<some file>\"})\n \n \tc.Check(receivedDBInfo.Address, gc.Equals, \"a\")\n@@ -198,15 +200,18 @@ func (s *backupsSuite) TestNotEnoughDiskSpaceSmallDisk(c *gc.C) {\n }\n \n func (s *backupsSuite) TestGetFileName(c *gc.C) {\n-\tbackupDir := c.MkDir()\n-\terr := os.MkdirAll(backupDir, 0644)\n+\tbackupSubDir := filepath.Join(s.paths.BackupDir, \"a\", \"b\")\n+\terr := os.MkdirAll(backupSubDir, 0755)\n \tc.Assert(err, jc.ErrorIsNil)\n-\tbackupFilename := path.Join(backupDir, \"test-backup.tar.gz\")\n+\tbackupFilename := path.Join(backupSubDir, \"juju-backup-123.tar.gz\")\n \tbackupFile, err := os.Create(backupFilename)\n \tc.Assert(err, jc.ErrorIsNil)\n \t_, err = backupFile.Write([]byte(\"archive file testing\"))\n \tc.Assert(err, jc.ErrorIsNil)\n \n+\t_, _, err = s.api.Get(\"/etc/hostname\")\n+\tc.Assert(err, gc.ErrorMatches, `backup file \"/etc/hostname\" not valid`)\n+\n \tresultMeta, resultArchive, err := s.api.Get(backupFilename)\n \tc.Assert(err, jc.ErrorIsNil)\n \tdefer resultArchive.Close()"}
{"patches_id": 1, "files_id": 9, "language": "go", "raw_url": "https://github.com/juju/juju/raw/ef803e2a13692d355b784b7da8b4b1f01dab1556/state%2Fbackups%2Ftesting%2Ffakes.go", "raw_code": "// Copyright 2014 Canonical Ltd.\n// Licensed under the AGPLv3, see LICENCE file for details.\n\npackage testing\n\nimport (\n\t\"io\"\n\n\t\"github.com/juju/juju/core/instance\"\n\t\"github.com/juju/juju/state/backups\"\n)\n\n// FakeBackups is an implementation of Backups to use for testing.\n// TODO: (hml) 2018-04-25\n// Let's change FakeBackups to using gomock or base.APICaller.\n// Checking calls made and arguments is a pain.\ntype FakeBackups struct {\n\t// Calls contains the order in which methods were called.\n\tCalls []string\n\n\t// Meta holds the Metadata to return.\n\tMeta *backups.Metadata\n\t// MetaList holds the Metadata list to return.\n\tMetaList []*backups.Metadata\n\t// Archive holds the archive file to return.\n\tArchive io.ReadCloser\n\t// Error holds the error to return.\n\tError error\n\t// Filename holds the name of the file to return.\n\tFilename string\n\n\t// IDArg holds the ID that was passed in.\n\tIDArg string\n\t// DBInfoArg holds the ConnInfo that was passed in.\n\tDBInfoArg *backups.DBInfo\n\t// MetaArg holds the backup metadata that was passed in.\n\tMetaArg *backups.Metadata\n\t// PrivateAddr Holds the address for the internal network of the machine.\n\tPrivateAddr string\n\t// InstanceId is the id of the machine to be restored.\n\tInstanceId instance.Id\n\t// ArchiveArg holds the backup archive that was passed in.\n\tArchiveArg io.Reader\n}\n\nvar _ backups.Backups = (*FakeBackups)(nil)\n\n// Create creates and stores a new juju backup archive and returns\n// its associated metadata.\nfunc (b *FakeBackups) Create(\n\tmeta *backups.Metadata,\n\tdbInfo *backups.DBInfo,\n) (string, error) {\n\tb.Calls = append(b.Calls, \"Create\")\n\n\tb.DBInfoArg = dbInfo\n\tb.MetaArg = meta\n\n\tif b.Meta != nil {\n\t\t*meta = *b.Meta\n\t}\n\n\treturn b.Filename, b.Error\n}\n\n// Get returns the metadata and archive file associated with the ID.\nfunc (b *FakeBackups) Get(id string) (*backups.Metadata, io.ReadCloser, error) {\n\tb.Calls = append(b.Calls, \"Get\")\n\tb.IDArg = id\n\treturn b.Meta, b.Archive, b.Error\n}\n", "patch": "@@ -31,8 +31,6 @@ type FakeBackups struct {\n \n \t// IDArg holds the ID that was passed in.\n \tIDArg string\n-\t// PathsArg holds the Paths that was passed in.\n-\tPathsArg *backups.Paths\n \t// DBInfoArg holds the ConnInfo that was passed in.\n \tDBInfoArg *backups.DBInfo\n \t// MetaArg holds the backup metadata that was passed in.\n@@ -51,12 +49,10 @@ var _ backups.Backups = (*FakeBackups)(nil)\n // its associated metadata.\n func (b *FakeBackups) Create(\n \tmeta *backups.Metadata,\n-\tpaths *backups.Paths,\n \tdbInfo *backups.DBInfo,\n ) (string, error) {\n \tb.Calls = append(b.Calls, \"Create\")\n \n-\tb.PathsArg = paths\n \tb.DBInfoArg = dbInfo\n \tb.MetaArg = meta\n "}
{"patches_id": 2, "files_id": 10, "language": "c", "raw_url": "https://github.com/LibVNC/libvncserver/raw/54220248886b5001fbbb9fa73c4e1a2cb9413fed/libvncclient%2Fcursor.c", "raw_code": "/*\n *  Copyright (C) 2001,2002 Constantin Kaplinsky.  All Rights Reserved.\n *\n *  This is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This software is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this software; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n *  USA.\n */\n\n/*\n * cursor.c - code to support cursor shape updates (XCursor and\n * RichCursor preudo-encodings).\n */\n\n#include <rfb/rfbclient.h>\n\n\n#define OPER_SAVE     0\n#define OPER_RESTORE  1\n\n#define MAX_CURSOR_SIZE 1024\n\n#define RGB24_TO_PIXEL(bpp,r,g,b)                                       \\\n   ((((uint##bpp##_t)(r) & 0xFF) * client->format.redMax + 127) / 255             \\\n    << client->format.redShift |                                              \\\n    (((uint##bpp##_t)(g) & 0xFF) * client->format.greenMax + 127) / 255           \\\n    << client->format.greenShift |                                            \\\n    (((uint##bpp##_t)(b) & 0xFF) * client->format.blueMax + 127) / 255            \\\n    << client->format.blueShift)\n\n\nrfbBool HandleCursorShape(rfbClient* client,int xhot, int yhot, int width, int height, uint32_t enc)\n{\n  int bytesPerPixel;\n  size_t bytesPerRow, bytesMaskData;\n  rfbXCursorColors rgb;\n  uint32_t colors[2];\n  char *buf;\n  uint8_t *ptr;\n  int x, y, b;\n\n  bytesPerPixel = client->format.bitsPerPixel / 8;\n  bytesPerRow = (width + 7) / 8;\n  bytesMaskData = bytesPerRow * height;\n\n  if (width * height == 0)\n    return TRUE;\n\n  if (width >= MAX_CURSOR_SIZE || height >= MAX_CURSOR_SIZE)\n    return FALSE;\n\n  /* Allocate memory for pixel data and temporary mask data. */\n  if(client->rcSource)\n    free(client->rcSource);\n\n  client->rcSource = malloc(width * height * bytesPerPixel);\n  if (client->rcSource == NULL)\n    return FALSE;\n\n  buf = malloc(bytesMaskData);\n  if (buf == NULL) {\n    free(client->rcSource);\n    client->rcSource = NULL;\n    return FALSE;\n  }\n\n  /* Read and decode cursor pixel data, depending on the encoding type. */\n\n  if (enc == rfbEncodingXCursor) {\n    /* Read and convert background and foreground colors. */\n    if (!ReadFromRFBServer(client, (char *)&rgb, sz_rfbXCursorColors)) {\n      free(client->rcSource);\n      client->rcSource = NULL;\n      free(buf);\n      return FALSE;\n    }\n    colors[0] = RGB24_TO_PIXEL(32, rgb.backRed, rgb.backGreen, rgb.backBlue);\n    colors[1] = RGB24_TO_PIXEL(32, rgb.foreRed, rgb.foreGreen, rgb.foreBlue);\n\n    /* Read 1bpp pixel data into a temporary buffer. */\n    if (!ReadFromRFBServer(client, buf, bytesMaskData)) {\n      free(client->rcSource);\n      client->rcSource = NULL;\n      free(buf);\n      return FALSE;\n    }\n\n    /* Convert 1bpp data to byte-wide color indices. */\n    ptr = client->rcSource;\n    for (y = 0; y < height; y++) {\n      for (x = 0; x < width / 8; x++) {\n\tfor (b = 7; b >= 0; b--) {\n\t  *ptr = buf[y * bytesPerRow + x] >> b & 1;\n\t  ptr += bytesPerPixel;\n\t}\n      }\n      for (b = 7; b > 7 - width % 8; b--) {\n\t*ptr = buf[y * bytesPerRow + x] >> b & 1;\n\tptr += bytesPerPixel;\n      }\n    }\n\n    /* Convert indices into the actual pixel values. */\n    switch (bytesPerPixel) {\n    case 1:\n      for (x = 0; x < width * height; x++)\n\tclient->rcSource[x] = (uint8_t)colors[client->rcSource[x]];\n      break;\n    case 2:\n      for (x = 0; x < width * height; x++)\n\t((uint16_t *)client->rcSource)[x] = (uint16_t)colors[client->rcSource[x * 2]];\n      break;\n    case 4:\n      for (x = 0; x < width * height; x++)\n\t((uint32_t *)client->rcSource)[x] = colors[client->rcSource[x * 4]];\n      break;\n    }\n\n  } else {\t\t\t/* enc == rfbEncodingRichCursor */\n\n    if (!ReadFromRFBServer(client, (char *)client->rcSource, width * height * bytesPerPixel)) {\n      free(client->rcSource);\n      client->rcSource = NULL;\n      free(buf);\n      return FALSE;\n    }\n\n  }\n\n  /* Read and decode mask data. */\n\n  if (!ReadFromRFBServer(client, buf, bytesMaskData)) {\n    free(client->rcSource);\n    client->rcSource = NULL;\n    free(buf);\n    return FALSE;\n  }\n\n  client->rcMask = malloc(width * height);\n  if (client->rcMask == NULL) {\n    free(client->rcSource);\n    client->rcSource = NULL;\n    free(buf);\n    return FALSE;\n  }\n\n  ptr = client->rcMask;\n  for (y = 0; y < height; y++) {\n    for (x = 0; x < width / 8; x++) {\n      for (b = 7; b >= 0; b--) {\n\t*ptr++ = buf[y * bytesPerRow + x] >> b & 1;\n      }\n    }\n    for (b = 7; b > 7 - width % 8; b--) {\n      *ptr++ = buf[y * bytesPerRow + x] >> b & 1;\n    }\n  }\n\n  if (client->GotCursorShape != NULL) {\n     client->GotCursorShape(client, xhot, yhot, width, height, bytesPerPixel);\n  }\n\n  free(buf);\n\n  return TRUE;\n}\n\n\n", "patch": "@@ -28,6 +28,8 @@\n #define OPER_SAVE     0\n #define OPER_RESTORE  1\n \n+#define MAX_CURSOR_SIZE 1024\n+\n #define RGB24_TO_PIXEL(bpp,r,g,b)                                       \\\n    ((((uint##bpp##_t)(r) & 0xFF) * client->format.redMax + 127) / 255             \\\n     << client->format.redShift |                                              \\\n@@ -54,6 +56,9 @@ rfbBool HandleCursorShape(rfbClient* client,int xhot, int yhot, int width, int h\n   if (width * height == 0)\n     return TRUE;\n \n+  if (width >= MAX_CURSOR_SIZE || height >= MAX_CURSOR_SIZE)\n+    return FALSE;\n+\n   /* Allocate memory for pixel data and temporary mask data. */\n   if(client->rcSource)\n     free(client->rcSource);"}
{"patches_id": 3, "files_id": 11, "language": "js", "raw_url": "https://github.com/nodejs/node/raw/662722240928668e4b16822be2f660fc6d957340/benchmark%2F_http-benchmarkers.js", "raw_code": "'use strict';\n\nconst child_process = require('child_process');\nconst path = require('path');\nconst fs = require('fs');\n\nconst requirementsURL =\n  'https://github.com/nodejs/node/blob/HEAD/doc/contributing/writing-and-running-benchmarks.md#http-benchmark-requirements';\n\n// The port used by servers and wrk\nexports.PORT = Number(process.env.PORT) || 12346;\n\nclass AutocannonBenchmarker {\n  constructor() {\n    const shell = (process.platform === 'win32');\n    this.name = 'autocannon';\n    this.opts = { shell };\n    this.executable = shell ? 'autocannon.cmd' : 'autocannon';\n    const result = child_process.spawnSync(this.executable, ['-h'], this.opts);\n    if (shell) {\n      this.present = (result.status === 0);\n    } else {\n      this.present = !(result.error && result.error.code === 'ENOENT');\n    }\n  }\n\n  create(options) {\n    const args = [\n      '-d', options.duration,\n      '-c', options.connections,\n      '-j',\n      '-n',\n    ];\n    for (const field in options.headers) {\n      if (this.opts.shell) {\n        args.push('-H', `'${field}=${options.headers[field]}'`);\n      } else {\n        args.push('-H', `${field}=${options.headers[field]}`);\n      }\n    }\n    const scheme = options.scheme || 'http';\n    args.push(`${scheme}://127.0.0.1:${options.port}${options.path}`);\n    const child = child_process.spawn(this.executable, args, this.opts);\n    return child;\n  }\n\n  processResults(output) {\n    let result;\n    try {\n      result = JSON.parse(output);\n    } catch {\n      return undefined;\n    }\n    if (!result || !result.requests || !result.requests.average) {\n      return undefined;\n    }\n    return result.requests.average;\n  }\n}\n\nclass WrkBenchmarker {\n  constructor() {\n    this.name = 'wrk';\n    this.executable = 'wrk';\n    const result = child_process.spawnSync(this.executable, ['-h']);\n    this.present = !(result.error && result.error.code === 'ENOENT');\n  }\n\n  create(options) {\n    const duration = typeof options.duration === 'number' ?\n      Math.max(options.duration, 1) :\n      options.duration;\n    const scheme = options.scheme || 'http';\n    const args = [\n      '-d', duration,\n      '-c', options.connections,\n      '-t', Math.min(options.connections, require('os').availableParallelism() || 8),\n      `${scheme}://127.0.0.1:${options.port}${options.path}`,\n    ];\n    for (const field in options.headers) {\n      args.push('-H', `${field}: ${options.headers[field]}`);\n    }\n    const child = child_process.spawn(this.executable, args);\n    return child;\n  }\n\n  processResults(output) {\n    const throughputRe = /Requests\\/sec:[ \\t]+([0-9.]+)/;\n    const match = output.match(throughputRe);\n    const throughput = match && +match[1];\n    if (!isFinite(throughput)) {\n      return undefined;\n    }\n    return throughput;\n  }\n}\n\n/**\n * Simple, single-threaded benchmarker for testing if the benchmark\n * works\n */\nclass TestDoubleBenchmarker {\n  constructor(type) {\n    // `type` is the type of benchmarker. Possible values are 'http', 'https',\n    // and 'http2'.\n    this.name = `test-double-${type}`;\n    this.executable = path.resolve(__dirname, '_test-double-benchmarker.js');\n    this.present = fs.existsSync(this.executable);\n    this.type = type;\n  }\n\n  create(options) {\n    process.env.duration = process.env.duration || options.duration || 5;\n\n    const scheme = options.scheme || 'http';\n    const env = {\n      test_url: `${scheme}://127.0.0.1:${options.port}${options.path}`,\n      ...process.env,\n    };\n\n    const child = child_process.fork(this.executable,\n                                     [this.type],\n                                     { silent: true, env });\n    return child;\n  }\n\n  processResults(output) {\n    let result;\n    try {\n      result = JSON.parse(output);\n    } catch {\n      return undefined;\n    }\n    return result.throughput;\n  }\n}\n\n/**\n * HTTP/2 Benchmarker\n */\nclass H2LoadBenchmarker {\n  constructor() {\n    this.name = 'h2load';\n    this.executable = 'h2load';\n    const result = child_process.spawnSync(this.executable, ['-h']);\n    this.present = !(result.error && result.error.code === 'ENOENT');\n  }\n\n  create(options) {\n    const args = [];\n    if (typeof options.requests === 'number')\n      args.push('-n', options.requests);\n    if (typeof options.clients === 'number')\n      args.push('-c', options.clients);\n    if (typeof options.threads === 'number')\n      args.push('-t', options.threads);\n    if (typeof options.maxConcurrentStreams === 'number')\n      args.push('-m', options.maxConcurrentStreams);\n    if (typeof options.initialWindowSize === 'number')\n      args.push('-w', options.initialWindowSize);\n    if (typeof options.sessionInitialWindowSize === 'number')\n      args.push('-W', options.sessionInitialWindowSize);\n    if (typeof options.rate === 'number')\n      args.push('-r', options.rate);\n    if (typeof options.ratePeriod === 'number')\n      args.push(`--rate-period=${options.ratePeriod}`);\n    if (typeof options.duration === 'number')\n      args.push('-T', options.duration);\n    if (typeof options.timeout === 'number')\n      args.push('-N', options.timeout);\n    if (typeof options.headerTableSize === 'number')\n      args.push(`--header-table-size=${options.headerTableSize}`);\n    if (typeof options.encoderHeaderTableSize === 'number') {\n      args.push(\n        `--encoder-header-table-size=${options.encoderHeaderTableSize}`);\n    }\n    const scheme = options.scheme || 'http';\n    const host = options.host || '127.0.0.1';\n    args.push(`${scheme}://${host}:${options.port}${options.path}`);\n    const child = child_process.spawn(this.executable, args);\n    return child;\n  }\n\n  processResults(output) {\n    const rex = /(\\d+\\.\\d+) req\\/s/;\n    return rex.exec(output)[1];\n  }\n}\n\nconst http_benchmarkers = [\n  new WrkBenchmarker(),\n  new AutocannonBenchmarker(),\n  new TestDoubleBenchmarker('http'),\n  new TestDoubleBenchmarker('https'),\n  new TestDoubleBenchmarker('http2'),\n  new H2LoadBenchmarker(),\n];\n\nconst benchmarkers = {};\n\nhttp_benchmarkers.forEach((benchmarker) => {\n  benchmarkers[benchmarker.name] = benchmarker;\n  if (!exports.default_http_benchmarker && benchmarker.present) {\n    exports.default_http_benchmarker = benchmarker.name;\n  }\n});\n\nexports.run = function(options, callback) {\n  options = {\n    port: exports.PORT,\n    path: '/',\n    connections: 100,\n    duration: 5,\n    benchmarker: exports.default_http_benchmarker,\n    ...options,\n  };\n  if (!options.benchmarker) {\n    callback(new Error('Could not locate required http benchmarker. See ' +\n                       `${requirementsURL} for further instructions.`));\n    return;\n  }\n  const benchmarker = benchmarkers[options.benchmarker];\n  if (!benchmarker) {\n    callback(new Error(`Requested benchmarker '${options.benchmarker}' ` +\n                       'is  not supported'));\n    return;\n  }\n  if (!benchmarker.present) {\n    callback(new Error(`Requested benchmarker '${options.benchmarker}' ` +\n                       'is  not installed'));\n    return;\n  }\n\n  const benchmarker_start = process.hrtime.bigint();\n\n  const child = benchmarker.create(options);\n\n  child.stderr.pipe(process.stderr);\n\n  let stdout = '';\n  child.stdout.setEncoding('utf8');\n  child.stdout.on('data', (chunk) => stdout += chunk);\n\n  child.once('close', (code) => {\n    const benchmark_end = process.hrtime.bigint();\n    if (code) {\n      let error_message = `${options.benchmarker} failed with ${code}.`;\n      if (stdout !== '') {\n        error_message += ` Output: ${stdout}`;\n      }\n      callback(new Error(error_message), code);\n      return;\n    }\n\n    const result = benchmarker.processResults(stdout);\n    if (result === undefined) {\n      callback(new Error(\n        `${options.benchmarker} produced strange output: ${stdout}`), code);\n      return;\n    }\n\n    const elapsed = benchmark_end - benchmarker_start;\n    callback(null, code, options.benchmarker, result, elapsed);\n  });\n\n};\n", "patch": "@@ -12,11 +12,16 @@ exports.PORT = Number(process.env.PORT) || 12346;\n \n class AutocannonBenchmarker {\n   constructor() {\n+    const shell = (process.platform === 'win32');\n     this.name = 'autocannon';\n-    this.executable =\n-      process.platform === 'win32' ? 'autocannon.cmd' : 'autocannon';\n-    const result = child_process.spawnSync(this.executable, ['-h']);\n-    this.present = !(result.error && result.error.code === 'ENOENT');\n+    this.opts = { shell };\n+    this.executable = shell ? 'autocannon.cmd' : 'autocannon';\n+    const result = child_process.spawnSync(this.executable, ['-h'], this.opts);\n+    if (shell) {\n+      this.present = (result.status === 0);\n+    } else {\n+      this.present = !(result.error && result.error.code === 'ENOENT');\n+    }\n   }\n \n   create(options) {\n@@ -27,11 +32,15 @@ class AutocannonBenchmarker {\n       '-n',\n     ];\n     for (const field in options.headers) {\n-      args.push('-H', `${field}=${options.headers[field]}`);\n+      if (this.opts.shell) {\n+        args.push('-H', `'${field}=${options.headers[field]}'`);\n+      } else {\n+        args.push('-H', `${field}=${options.headers[field]}`);\n+      }\n     }\n     const scheme = options.scheme || 'http';\n     args.push(`${scheme}://127.0.0.1:${options.port}${options.path}`);\n-    const child = child_process.spawn(this.executable, args);\n+    const child = child_process.spawn(this.executable, args, this.opts);\n     return child;\n   }\n "}
{"patches_id": 3, "files_id": 12, "language": "h", "raw_url": "https://github.com/nodejs/node/raw/662722240928668e4b16822be2f660fc6d957340/src%2Fnode_revert.h", "raw_code": "#ifndef SRC_NODE_REVERT_H_\n#define SRC_NODE_REVERT_H_\n\n#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n\n#include \"node.h\"\n\n/**\n * Note that it is expected for this list to vary across specific LTS and\n * Stable versions! Only CVE's whose fixes require *breaking* changes within\n * a given LTS or Stable may be added to this list, and only with TSC\n * consensus.\n *\n * For *master* this list should always be empty!\n **/\nnamespace node {\n\n#define SECURITY_REVERSIONS(XX)                                                \\\n  XX(CVE_2023_46809, \"CVE-2023-46809\", \"Marvin attack on PKCS#1 padding\")      \\\n  XX(CVE_2024_27980, \"CVE-2024-27980\", \"Unsafe Windows batch file execution\")\n\nenum reversion {\n#define V(code, ...) SECURITY_REVERT_##code,\n  SECURITY_REVERSIONS(V)\n#undef V\n};\n\nnamespace per_process {\nextern unsigned int reverted_cve;\n}\n\n#ifdef _MSC_VER\n#pragma warning(push)\n// MSVC C4065: switch statement contains 'default' but no 'case' labels\n#pragma warning(disable : 4065)\n#endif\n\ninline const char* RevertMessage(const reversion cve) {\n#define V(code, label, msg) case SECURITY_REVERT_##code: return label \": \" msg;\n  switch (cve) {\n    SECURITY_REVERSIONS(V)\n    default:\n      return \"Unknown\";\n  }\n#undef V\n}\n\n#ifdef _MSC_VER\n#pragma warning(pop)\n#endif\n\ninline void Revert(const reversion cve) {\n  per_process::reverted_cve |= 1 << cve;\n  printf(\"SECURITY WARNING: Reverting %s\\n\", RevertMessage(cve));\n}\n\ninline void Revert(const char* cve, std::string* error) {\n#define V(code, label, _)                                                     \\\n  if (strcmp(cve, label) == 0) return Revert(SECURITY_REVERT_##code);\n  SECURITY_REVERSIONS(V)\n#undef V\n  *error = \"Error: Attempt to revert an unknown CVE [\";\n  *error += cve;\n  *error += ']';\n}\n\ninline bool IsReverted(const reversion cve) {\n  return per_process::reverted_cve & (1 << cve);\n}\n\ninline bool IsReverted(const char* cve) {\n#define V(code, label, _)                                                     \\\n  if (strcmp(cve, label) == 0) return IsReverted(SECURITY_REVERT_##code);\n  SECURITY_REVERSIONS(V)\n  return false;\n#undef V\n}\n\n}  // namespace node\n\n#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n\n#endif  // SRC_NODE_REVERT_H_\n", "patch": "@@ -16,7 +16,8 @@\n namespace node {\n \n #define SECURITY_REVERSIONS(XX)                                                \\\n-  XX(CVE_2023_46809, \"CVE-2023-46809\", \"Marvin attack on PKCS#1 padding\")\n+  XX(CVE_2023_46809, \"CVE-2023-46809\", \"Marvin attack on PKCS#1 padding\")      \\\n+  XX(CVE_2024_27980, \"CVE-2024-27980\", \"Unsafe Windows batch file execution\")\n \n enum reversion {\n #define V(code, ...) SECURITY_REVERT_##code,"}
{"patches_id": 3, "files_id": 13, "language": "cc", "raw_url": "https://github.com/nodejs/node/raw/662722240928668e4b16822be2f660fc6d957340/src%2Fprocess_wrap.cc", "raw_code": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n#include \"env-inl.h\"\n#include \"stream_base-inl.h\"\n#include \"stream_wrap.h\"\n#include \"util-inl.h\"\n\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n\nnamespace node {\n\nusing v8::Array;\nusing v8::Context;\nusing v8::FunctionCallbackInfo;\nusing v8::FunctionTemplate;\nusing v8::HandleScope;\nusing v8::Int32;\nusing v8::Integer;\nusing v8::Isolate;\nusing v8::Local;\nusing v8::Number;\nusing v8::Object;\nusing v8::String;\nusing v8::Value;\n\nnamespace {\n\nclass ProcessWrap : public HandleWrap {\n public:\n  static void Initialize(Local<Object> target,\n                         Local<Value> unused,\n                         Local<Context> context,\n                         void* priv) {\n    Environment* env = Environment::GetCurrent(context);\n    Isolate* isolate = env->isolate();\n    Local<FunctionTemplate> constructor = NewFunctionTemplate(isolate, New);\n    constructor->InstanceTemplate()->SetInternalFieldCount(\n        ProcessWrap::kInternalFieldCount);\n\n    constructor->Inherit(HandleWrap::GetConstructorTemplate(env));\n\n    SetProtoMethod(isolate, constructor, \"spawn\", Spawn);\n    SetProtoMethod(isolate, constructor, \"kill\", Kill);\n\n    SetConstructorFunction(context, target, \"Process\", constructor);\n  }\n\n  SET_NO_MEMORY_INFO()\n  SET_MEMORY_INFO_NAME(ProcessWrap)\n  SET_SELF_SIZE(ProcessWrap)\n\n private:\n  static void New(const FunctionCallbackInfo<Value>& args) {\n    // This constructor should not be exposed to public javascript.\n    // Therefore we assert that we are not trying to call this as a\n    // normal function.\n    CHECK(args.IsConstructCall());\n    Environment* env = Environment::GetCurrent(args);\n    new ProcessWrap(env, args.This());\n  }\n\n  ProcessWrap(Environment* env, Local<Object> object)\n      : HandleWrap(env,\n                   object,\n                   reinterpret_cast<uv_handle_t*>(&process_),\n                   AsyncWrap::PROVIDER_PROCESSWRAP) {\n    MarkAsUninitialized();\n  }\n\n  static uv_stream_t* StreamForWrap(Environment* env, Local<Object> stdio) {\n    Local<String> handle_key = env->handle_string();\n    // This property has always been set by JS land if we are in this code path.\n    Local<Object> handle =\n        stdio->Get(env->context(), handle_key).ToLocalChecked().As<Object>();\n\n    uv_stream_t* stream = LibuvStreamWrap::From(env, handle)->stream();\n    CHECK_NOT_NULL(stream);\n    return stream;\n  }\n\n  static void ParseStdioOptions(Environment* env,\n                                Local<Object> js_options,\n                                uv_process_options_t* options) {\n    Local<Context> context = env->context();\n    Local<String> stdio_key = env->stdio_string();\n    Local<Array> stdios =\n        js_options->Get(context, stdio_key).ToLocalChecked().As<Array>();\n\n    uint32_t len = stdios->Length();\n    options->stdio = new uv_stdio_container_t[len];\n    options->stdio_count = len;\n\n    for (uint32_t i = 0; i < len; i++) {\n      Local<Object> stdio =\n          stdios->Get(context, i).ToLocalChecked().As<Object>();\n      Local<Value> type =\n          stdio->Get(context, env->type_string()).ToLocalChecked();\n\n      if (type->StrictEquals(env->ignore_string())) {\n        options->stdio[i].flags = UV_IGNORE;\n      } else if (type->StrictEquals(env->pipe_string())) {\n        options->stdio[i].flags = static_cast<uv_stdio_flags>(\n            UV_CREATE_PIPE | UV_READABLE_PIPE | UV_WRITABLE_PIPE);\n        options->stdio[i].data.stream = StreamForWrap(env, stdio);\n      } else if (type->StrictEquals(env->overlapped_string())) {\n        options->stdio[i].flags = static_cast<uv_stdio_flags>(\n            UV_CREATE_PIPE | UV_READABLE_PIPE | UV_WRITABLE_PIPE |\n            UV_OVERLAPPED_PIPE);\n        options->stdio[i].data.stream = StreamForWrap(env, stdio);\n      } else if (type->StrictEquals(env->wrap_string())) {\n        options->stdio[i].flags = UV_INHERIT_STREAM;\n        options->stdio[i].data.stream = StreamForWrap(env, stdio);\n      } else {\n        Local<String> fd_key = env->fd_string();\n        Local<Value> fd_value = stdio->Get(context, fd_key).ToLocalChecked();\n        CHECK(fd_value->IsNumber());\n        int fd = static_cast<int>(fd_value.As<Integer>()->Value());\n        options->stdio[i].flags = UV_INHERIT_FD;\n        options->stdio[i].data.fd = fd;\n      }\n    }\n  }\n\n  static void Spawn(const FunctionCallbackInfo<Value>& args) {\n    Environment* env = Environment::GetCurrent(args);\n    Local<Context> context = env->context();\n    ProcessWrap* wrap;\n    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());\n    int err = 0;\n\n    Local<Object> js_options =\n        args[0]->ToObject(env->context()).ToLocalChecked();\n\n    uv_process_options_t options;\n    memset(&options, 0, sizeof(uv_process_options_t));\n\n    options.exit_cb = OnExit;\n\n    // options.uid\n    Local<Value> uid_v =\n        js_options->Get(context, env->uid_string()).ToLocalChecked();\n    if (!uid_v->IsUndefined() && !uid_v->IsNull()) {\n      CHECK(uid_v->IsInt32());\n      const int32_t uid = uid_v.As<Int32>()->Value();\n      options.flags |= UV_PROCESS_SETUID;\n      options.uid = static_cast<uv_uid_t>(uid);\n    }\n\n    // options.gid\n    Local<Value> gid_v =\n        js_options->Get(context, env->gid_string()).ToLocalChecked();\n    if (!gid_v->IsUndefined() && !gid_v->IsNull()) {\n      CHECK(gid_v->IsInt32());\n      const int32_t gid = gid_v.As<Int32>()->Value();\n      options.flags |= UV_PROCESS_SETGID;\n      options.gid = static_cast<uv_gid_t>(gid);\n    }\n\n    // TODO(bnoordhuis) is this possible to do without mallocing ?\n\n    // options.file\n    Local<Value> file_v =\n        js_options->Get(context, env->file_string()).ToLocalChecked();\n    CHECK(file_v->IsString());\n    node::Utf8Value file(env->isolate(), file_v);\n    options.file = *file;\n\n    // Undocumented feature of Win32 CreateProcess API allows spawning\n    // batch files directly but is potentially insecure because arguments\n    // are not escaped (and sometimes cannot be unambiguously escaped),\n    // hence why they are rejected here.\n    if (IsWindowsBatchFile(options.file))\n      err = UV_EINVAL;\n\n    // options.args\n    Local<Value> argv_v =\n        js_options->Get(context, env->args_string()).ToLocalChecked();\n    if (!argv_v.IsEmpty() && argv_v->IsArray()) {\n      Local<Array> js_argv = argv_v.As<Array>();\n      int argc = js_argv->Length();\n      CHECK_LT(argc, INT_MAX);  // Check for overflow.\n\n      // Heap allocate to detect errors. +1 is for nullptr.\n      options.args = new char*[argc + 1];\n      for (int i = 0; i < argc; i++) {\n        node::Utf8Value arg(env->isolate(),\n                            js_argv->Get(context, i).ToLocalChecked());\n        options.args[i] = strdup(*arg);\n        CHECK_NOT_NULL(options.args[i]);\n      }\n      options.args[argc] = nullptr;\n    }\n\n    // options.cwd\n    Local<Value> cwd_v =\n        js_options->Get(context, env->cwd_string()).ToLocalChecked();\n    node::Utf8Value cwd(env->isolate(),\n                        cwd_v->IsString() ? cwd_v : Local<Value>());\n    if (cwd.length() > 0) {\n      options.cwd = *cwd;\n    }\n\n    // options.env\n    Local<Value> env_v =\n        js_options->Get(context, env->env_pairs_string()).ToLocalChecked();\n    if (!env_v.IsEmpty() && env_v->IsArray()) {\n      Local<Array> env_opt = env_v.As<Array>();\n      int envc = env_opt->Length();\n      CHECK_LT(envc, INT_MAX);            // Check for overflow.\n      options.env = new char*[envc + 1];  // Heap allocated to detect errors.\n      for (int i = 0; i < envc; i++) {\n        node::Utf8Value pair(env->isolate(),\n                             env_opt->Get(context, i).ToLocalChecked());\n        options.env[i] = strdup(*pair);\n        CHECK_NOT_NULL(options.env[i]);\n      }\n      options.env[envc] = nullptr;\n    }\n\n    // options.stdio\n    ParseStdioOptions(env, js_options, &options);\n\n    // options.windowsHide\n    Local<Value> hide_v =\n        js_options->Get(context, env->windows_hide_string()).ToLocalChecked();\n\n    if (hide_v->IsTrue()) {\n      options.flags |= UV_PROCESS_WINDOWS_HIDE;\n    }\n\n    if (env->hide_console_windows()) {\n      options.flags |= UV_PROCESS_WINDOWS_HIDE_CONSOLE;\n    }\n\n    // options.windows_verbatim_arguments\n    Local<Value> wva_v =\n        js_options->Get(context, env->windows_verbatim_arguments_string())\n            .ToLocalChecked();\n\n    if (wva_v->IsTrue()) {\n      options.flags |= UV_PROCESS_WINDOWS_VERBATIM_ARGUMENTS;\n    }\n\n    // options.detached\n    Local<Value> detached_v =\n        js_options->Get(context, env->detached_string()).ToLocalChecked();\n\n    if (detached_v->IsTrue()) {\n      options.flags |= UV_PROCESS_DETACHED;\n    }\n\n    if (err == 0) {\n      err = uv_spawn(env->event_loop(), &wrap->process_, &options);\n      wrap->MarkAsInitialized();\n    }\n\n    if (err == 0) {\n      CHECK_EQ(wrap->process_.data, wrap);\n      wrap->object()->Set(context, env->pid_string(),\n                          Integer::New(env->isolate(),\n                                       wrap->process_.pid)).Check();\n    }\n\n    if (options.args) {\n      for (int i = 0; options.args[i]; i++) free(options.args[i]);\n      delete [] options.args;\n    }\n\n    if (options.env) {\n      for (int i = 0; options.env[i]; i++) free(options.env[i]);\n      delete [] options.env;\n    }\n\n    delete[] options.stdio;\n\n    args.GetReturnValue().Set(err);\n  }\n\n  static void Kill(const FunctionCallbackInfo<Value>& args) {\n    Environment* env = Environment::GetCurrent(args);\n    ProcessWrap* wrap;\n    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());\n    int signal = args[0]->Int32Value(env->context()).FromJust();\n    int err = uv_process_kill(&wrap->process_, signal);\n    args.GetReturnValue().Set(err);\n  }\n\n  static void OnExit(uv_process_t* handle,\n                     int64_t exit_status,\n                     int term_signal) {\n    ProcessWrap* wrap = ContainerOf(&ProcessWrap::process_, handle);\n    CHECK_EQ(&wrap->process_, handle);\n\n    Environment* env = wrap->env();\n    HandleScope handle_scope(env->isolate());\n    Context::Scope context_scope(env->context());\n\n    Local<Value> argv[] = {\n      Number::New(env->isolate(), static_cast<double>(exit_status)),\n      OneByteString(env->isolate(), signo_string(term_signal))\n    };\n\n    wrap->MakeCallback(env->onexit_string(), arraysize(argv), argv);\n  }\n\n  uv_process_t process_;\n};\n\n\n}  // anonymous namespace\n}  // namespace node\n\nNODE_BINDING_CONTEXT_AWARE_INTERNAL(process_wrap, node::ProcessWrap::Initialize)\n", "patch": "@@ -147,6 +147,7 @@ class ProcessWrap : public HandleWrap {\n     Local<Context> context = env->context();\n     ProcessWrap* wrap;\n     ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());\n+    int err = 0;\n \n     Local<Object> js_options =\n         args[0]->ToObject(env->context()).ToLocalChecked();\n@@ -185,6 +186,13 @@ class ProcessWrap : public HandleWrap {\n     node::Utf8Value file(env->isolate(), file_v);\n     options.file = *file;\n \n+    // Undocumented feature of Win32 CreateProcess API allows spawning\n+    // batch files directly but is potentially insecure because arguments\n+    // are not escaped (and sometimes cannot be unambiguously escaped),\n+    // hence why they are rejected here.\n+    if (IsWindowsBatchFile(options.file))\n+      err = UV_EINVAL;\n+\n     // options.args\n     Local<Value> argv_v =\n         js_options->Get(context, env->args_string()).ToLocalChecked();\n@@ -262,8 +270,10 @@ class ProcessWrap : public HandleWrap {\n       options.flags |= UV_PROCESS_DETACHED;\n     }\n \n-    int err = uv_spawn(env->event_loop(), &wrap->process_, &options);\n-    wrap->MarkAsInitialized();\n+    if (err == 0) {\n+      err = uv_spawn(env->event_loop(), &wrap->process_, &options);\n+      wrap->MarkAsInitialized();\n+    }\n \n     if (err == 0) {\n       CHECK_EQ(wrap->process_.data, wrap);"}
{"patches_id": 3, "files_id": 14, "language": "cc", "raw_url": "https://github.com/nodejs/node/raw/662722240928668e4b16822be2f660fc6d957340/src%2Fspawn_sync.cc", "raw_code": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n#include \"spawn_sync.h\"\n#include \"debug_utils-inl.h\"\n#include \"env-inl.h\"\n#include \"node_internals.h\"\n#include \"string_bytes.h\"\n#include \"util-inl.h\"\n\n#include <cstring>\n\n\nnamespace node {\n\nusing v8::Array;\nusing v8::Context;\nusing v8::EscapableHandleScope;\nusing v8::FunctionCallbackInfo;\nusing v8::HandleScope;\nusing v8::Int32;\nusing v8::Integer;\nusing v8::Isolate;\nusing v8::Just;\nusing v8::Local;\nusing v8::Maybe;\nusing v8::MaybeLocal;\nusing v8::Nothing;\nusing v8::Null;\nusing v8::Number;\nusing v8::Object;\nusing v8::String;\nusing v8::Value;\n\nvoid SyncProcessOutputBuffer::OnAlloc(size_t suggested_size,\n                                      uv_buf_t* buf) const {\n  if (used() == kBufferSize)\n    *buf = uv_buf_init(nullptr, 0);\n  else\n    *buf = uv_buf_init(data_ + used(), available());\n}\n\n\nvoid SyncProcessOutputBuffer::OnRead(const uv_buf_t* buf, size_t nread) {\n  // If we hand out the same chunk twice, this should catch it.\n  CHECK_EQ(buf->base, data_ + used());\n  used_ += static_cast<unsigned int>(nread);\n}\n\n\nsize_t SyncProcessOutputBuffer::Copy(char* dest) const {\n  memcpy(dest, data_, used());\n  return used();\n}\n\n\nunsigned int SyncProcessOutputBuffer::available() const {\n  return sizeof data_ - used();\n}\n\n\nunsigned int SyncProcessOutputBuffer::used() const {\n  return used_;\n}\n\n\nSyncProcessOutputBuffer* SyncProcessOutputBuffer::next() const {\n  return next_;\n}\n\n\nvoid SyncProcessOutputBuffer::set_next(SyncProcessOutputBuffer* next) {\n  next_ = next;\n}\n\n\nSyncProcessStdioPipe::SyncProcessStdioPipe(SyncProcessRunner* process_handler,\n                                           bool readable,\n                                           bool writable,\n                                           uv_buf_t input_buffer)\n    : process_handler_(process_handler),\n      readable_(readable),\n      writable_(writable),\n      input_buffer_(input_buffer),\n\n      first_output_buffer_(nullptr),\n      last_output_buffer_(nullptr),\n\n      uv_pipe_(),\n      write_req_(),\n      shutdown_req_(),\n\n      lifecycle_(kUninitialized) {\n  CHECK(readable || writable);\n}\n\n\nSyncProcessStdioPipe::~SyncProcessStdioPipe() {\n  CHECK(lifecycle_ == kUninitialized || lifecycle_ == kClosed);\n\n  SyncProcessOutputBuffer* buf;\n  SyncProcessOutputBuffer* next;\n\n  for (buf = first_output_buffer_; buf != nullptr; buf = next) {\n    next = buf->next();\n    delete buf;\n  }\n}\n\n\nint SyncProcessStdioPipe::Initialize(uv_loop_t* loop) {\n  CHECK_EQ(lifecycle_, kUninitialized);\n\n  int r = uv_pipe_init(loop, uv_pipe(), 0);\n  if (r < 0)\n    return r;\n\n  uv_pipe()->data = this;\n\n  lifecycle_ = kInitialized;\n  return 0;\n}\n\n\nint SyncProcessStdioPipe::Start() {\n  CHECK_EQ(lifecycle_, kInitialized);\n\n  // Set the busy flag already. If this function fails no recovery is\n  // possible.\n  lifecycle_ = kStarted;\n\n  if (readable()) {\n    if (input_buffer_.len > 0) {\n      CHECK_NOT_NULL(input_buffer_.base);\n\n      int r = uv_write(&write_req_,\n                       uv_stream(),\n                       &input_buffer_,\n                       1,\n                       WriteCallback);\n      if (r < 0)\n        return r;\n    }\n\n    int r = uv_shutdown(&shutdown_req_, uv_stream(), ShutdownCallback);\n    if (r < 0)\n      return r;\n  }\n\n  if (writable()) {\n    int r = uv_read_start(uv_stream(), AllocCallback, ReadCallback);\n    if (r < 0)\n      return r;\n  }\n\n  return 0;\n}\n\n\nvoid SyncProcessStdioPipe::Close() {\n  CHECK(lifecycle_ == kInitialized || lifecycle_ == kStarted);\n\n  uv_close(uv_handle(), CloseCallback);\n\n  lifecycle_ = kClosing;\n}\n\n\nLocal<Object> SyncProcessStdioPipe::GetOutputAsBuffer(Environment* env) const {\n  size_t length = OutputLength();\n  Local<Object> js_buffer = Buffer::New(env, length).ToLocalChecked();\n  CopyOutput(Buffer::Data(js_buffer));\n  return js_buffer;\n}\n\n\nbool SyncProcessStdioPipe::readable() const {\n  return readable_;\n}\n\n\nbool SyncProcessStdioPipe::writable() const {\n  return writable_;\n}\n\n\nuv_stdio_flags SyncProcessStdioPipe::uv_flags() const {\n  unsigned int flags;\n\n  flags = UV_CREATE_PIPE;\n  if (readable())\n    flags |= UV_READABLE_PIPE;\n  if (writable())\n    flags |= UV_WRITABLE_PIPE;\n\n  return static_cast<uv_stdio_flags>(flags);\n}\n\n\nuv_pipe_t* SyncProcessStdioPipe::uv_pipe() const {\n  CHECK_LT(lifecycle_, kClosing);\n  return &uv_pipe_;\n}\n\n\nuv_stream_t* SyncProcessStdioPipe::uv_stream() const {\n  return reinterpret_cast<uv_stream_t*>(uv_pipe());\n}\n\n\nuv_handle_t* SyncProcessStdioPipe::uv_handle() const {\n  return reinterpret_cast<uv_handle_t*>(uv_pipe());\n}\n\n\nsize_t SyncProcessStdioPipe::OutputLength() const {\n  SyncProcessOutputBuffer* buf;\n  size_t size = 0;\n\n  for (buf = first_output_buffer_; buf != nullptr; buf = buf->next())\n    size += buf->used();\n\n  return size;\n}\n\n\nvoid SyncProcessStdioPipe::CopyOutput(char* dest) const {\n  SyncProcessOutputBuffer* buf;\n  size_t offset = 0;\n\n  for (buf = first_output_buffer_; buf != nullptr; buf = buf->next())\n    offset += buf->Copy(dest + offset);\n}\n\n\nvoid SyncProcessStdioPipe::OnAlloc(size_t suggested_size, uv_buf_t* buf) {\n  // This function assumes that libuv will never allocate two buffers for the\n  // same stream at the same time. There's an assert in\n  // SyncProcessOutputBuffer::OnRead that would fail if this assumption was\n  // ever violated.\n\n  if (last_output_buffer_ == nullptr) {\n    // Allocate the first capture buffer.\n    first_output_buffer_ = new SyncProcessOutputBuffer();\n    last_output_buffer_ = first_output_buffer_;\n\n  } else if (last_output_buffer_->available() == 0) {\n    // The current capture buffer is full so get us a new one.\n    SyncProcessOutputBuffer* buf = new SyncProcessOutputBuffer();\n    last_output_buffer_->set_next(buf);\n    last_output_buffer_ = buf;\n  }\n\n  last_output_buffer_->OnAlloc(suggested_size, buf);\n}\n\n\nvoid SyncProcessStdioPipe::OnRead(const uv_buf_t* buf, ssize_t nread) {\n  if (nread == UV_EOF) {\n    // Libuv implicitly stops reading on EOF.\n\n  } else if (nread < 0) {\n    SetError(static_cast<int>(nread));\n    // At some point libuv should really implicitly stop reading on error.\n    uv_read_stop(uv_stream());\n\n  } else {\n    last_output_buffer_->OnRead(buf, nread);\n    process_handler_->IncrementBufferSizeAndCheckOverflow(nread);\n  }\n}\n\n\nvoid SyncProcessStdioPipe::OnWriteDone(int result) {\n  if (result < 0)\n    SetError(result);\n}\n\n\nvoid SyncProcessStdioPipe::OnShutdownDone(int result) {\n  if (result < 0)\n    SetError(result);\n}\n\n\nvoid SyncProcessStdioPipe::OnClose() {\n  lifecycle_ = kClosed;\n}\n\n\nvoid SyncProcessStdioPipe::SetError(int error) {\n  CHECK_NE(error, 0);\n  process_handler_->SetPipeError(error);\n}\n\n\nvoid SyncProcessStdioPipe::AllocCallback(uv_handle_t* handle,\n                                         size_t suggested_size,\n                                         uv_buf_t* buf) {\n  SyncProcessStdioPipe* self =\n      reinterpret_cast<SyncProcessStdioPipe*>(handle->data);\n  self->OnAlloc(suggested_size, buf);\n}\n\n\nvoid SyncProcessStdioPipe::ReadCallback(uv_stream_t* stream,\n                                        ssize_t nread,\n                                        const uv_buf_t* buf) {\n  SyncProcessStdioPipe* self =\n        reinterpret_cast<SyncProcessStdioPipe*>(stream->data);\n  self->OnRead(buf, nread);\n}\n\n\nvoid SyncProcessStdioPipe::WriteCallback(uv_write_t* req, int result) {\n  SyncProcessStdioPipe* self =\n      reinterpret_cast<SyncProcessStdioPipe*>(req->handle->data);\n  self->OnWriteDone(result);\n}\n\n\nvoid SyncProcessStdioPipe::ShutdownCallback(uv_shutdown_t* req, int result) {\n  SyncProcessStdioPipe* self =\n      reinterpret_cast<SyncProcessStdioPipe*>(req->handle->data);\n\n  // On AIX, OS X and the BSDs, calling shutdown() on one end of a pipe\n  // when the other end has closed the connection fails with ENOTCONN.\n  // Libuv is not the right place to handle that because it can't tell\n  // if the error is genuine but we here can.\n  if (result == UV_ENOTCONN)\n    result = 0;\n\n  self->OnShutdownDone(result);\n}\n\n\nvoid SyncProcessStdioPipe::CloseCallback(uv_handle_t* handle) {\n  SyncProcessStdioPipe* self =\n      reinterpret_cast<SyncProcessStdioPipe*>(handle->data);\n  self->OnClose();\n}\n\n\nvoid SyncProcessRunner::Initialize(Local<Object> target,\n                                   Local<Value> unused,\n                                   Local<Context> context,\n                                   void* priv) {\n  SetMethod(context, target, \"spawn\", Spawn);\n}\n\n\nvoid SyncProcessRunner::Spawn(const FunctionCallbackInfo<Value>& args) {\n  Environment* env = Environment::GetCurrent(args);\n  env->PrintSyncTrace();\n  SyncProcessRunner p(env);\n  Local<Value> result;\n  if (!p.Run(args[0]).ToLocal(&result)) return;\n  args.GetReturnValue().Set(result);\n}\n\n\nSyncProcessRunner::SyncProcessRunner(Environment* env)\n    : max_buffer_(0),\n      timeout_(0),\n      kill_signal_(SIGTERM),\n\n      uv_loop_(nullptr),\n\n      stdio_count_(0),\n      uv_stdio_containers_(nullptr),\n      stdio_pipes_initialized_(false),\n\n      uv_process_options_(),\n      file_buffer_(nullptr),\n      args_buffer_(nullptr),\n      env_buffer_(nullptr),\n      cwd_buffer_(nullptr),\n\n      uv_process_(),\n      killed_(false),\n\n      buffered_output_size_(0),\n      exit_status_(-1),\n      term_signal_(-1),\n\n      uv_timer_(),\n      kill_timer_initialized_(false),\n\n      error_(0),\n      pipe_error_(0),\n\n      lifecycle_(kUninitialized),\n\n      env_(env) {\n}\n\n\nSyncProcessRunner::~SyncProcessRunner() {\n  CHECK_EQ(lifecycle_, kHandlesClosed);\n\n  stdio_pipes_.clear();\n  delete[] file_buffer_;\n  delete[] args_buffer_;\n  delete[] cwd_buffer_;\n  delete[] env_buffer_;\n  delete[] uv_stdio_containers_;\n}\n\n\nEnvironment* SyncProcessRunner::env() const {\n  return env_;\n}\n\nMaybeLocal<Object> SyncProcessRunner::Run(Local<Value> options) {\n  EscapableHandleScope scope(env()->isolate());\n\n  CHECK_EQ(lifecycle_, kUninitialized);\n\n  Maybe<bool> r = TryInitializeAndRunLoop(options);\n  CloseHandlesAndDeleteLoop();\n  if (r.IsNothing()) return MaybeLocal<Object>();\n\n  Local<Object> result = BuildResultObject();\n\n  return scope.Escape(result);\n}\n\nMaybe<bool> SyncProcessRunner::TryInitializeAndRunLoop(Local<Value> options) {\n  int r;\n\n  // There is no recovery from failure inside TryInitializeAndRunLoop - the\n  // only option we'd have is to close all handles and destroy the loop.\n  CHECK_EQ(lifecycle_, kUninitialized);\n  lifecycle_ = kInitialized;\n\n  uv_loop_ = new uv_loop_t;\n  if (uv_loop_ == nullptr) {\n    SetError(UV_ENOMEM);\n    return Just(false);\n  }\n\n  r = uv_loop_init(uv_loop_);\n  if (r < 0) {\n    delete uv_loop_;\n    uv_loop_ = nullptr;\n    SetError(r);\n    return Just(false);\n  }\n\n  if (!ParseOptions(options).To(&r)) return Nothing<bool>();\n\n  if (r < 0) {\n    SetError(r);\n    return Just(false);\n  }\n\n  if (timeout_ > 0) {\n    r = uv_timer_init(uv_loop_, &uv_timer_);\n    if (r < 0) {\n      SetError(r);\n      return Just(false);\n    }\n\n    uv_unref(reinterpret_cast<uv_handle_t*>(&uv_timer_));\n\n    uv_timer_.data = this;\n    kill_timer_initialized_ = true;\n\n    // Start the timer immediately. If uv_spawn fails then\n    // CloseHandlesAndDeleteLoop() will immediately close the timer handle\n    // which implicitly stops it, so there is no risk that the timeout callback\n    // runs when the process didn't start.\n    r = uv_timer_start(&uv_timer_, KillTimerCallback, timeout_, 0);\n    if (r < 0) {\n      SetError(r);\n      return Just(false);\n    }\n  }\n\n  uv_process_options_.exit_cb = ExitCallback;\n  r = uv_spawn(uv_loop_, &uv_process_, &uv_process_options_);\n  if (r < 0) {\n    SetError(r);\n    return Just(false);\n  }\n  uv_process_.data = this;\n\n  for (const auto& pipe : stdio_pipes_) {\n    if (pipe != nullptr) {\n      r = pipe->Start();\n      if (r < 0) {\n        SetPipeError(r);\n        return Just(false);\n      }\n    }\n  }\n\n  r = uv_run(uv_loop_, UV_RUN_DEFAULT);\n  if (r < 0)\n    // We can't handle uv_run failure.\n    ABORT();\n\n  // If we get here the process should have exited.\n  CHECK_GE(exit_status_, 0);\n  return Just(true);\n}\n\n\nvoid SyncProcessRunner::CloseHandlesAndDeleteLoop() {\n  CHECK_LT(lifecycle_, kHandlesClosed);\n\n  if (uv_loop_ != nullptr) {\n    CloseStdioPipes();\n    CloseKillTimer();\n    // Close the process handle when ExitCallback was not called.\n    uv_handle_t* uv_process_handle =\n        reinterpret_cast<uv_handle_t*>(&uv_process_);\n\n    // Close the process handle if it is still open. The handle type also\n    // needs to be checked because TryInitializeAndRunLoop() won't spawn a\n    // process if input validation fails.\n    if (uv_process_handle->type == UV_PROCESS &&\n        !uv_is_closing(uv_process_handle))\n      uv_close(uv_process_handle, nullptr);\n\n    // Give closing watchers a chance to finish closing and get their close\n    // callbacks called.\n    int r = uv_run(uv_loop_, UV_RUN_DEFAULT);\n    if (r < 0)\n      ABORT();\n\n    CheckedUvLoopClose(uv_loop_);\n    delete uv_loop_;\n    uv_loop_ = nullptr;\n\n  } else {\n    // If the loop doesn't exist, neither should any pipes or timers.\n    CHECK_EQ(false, stdio_pipes_initialized_);\n    CHECK_EQ(false, kill_timer_initialized_);\n  }\n\n  lifecycle_ = kHandlesClosed;\n}\n\n\nvoid SyncProcessRunner::CloseStdioPipes() {\n  CHECK_LT(lifecycle_, kHandlesClosed);\n\n  if (stdio_pipes_initialized_) {\n    CHECK(!stdio_pipes_.empty());\n    CHECK_NOT_NULL(uv_loop_);\n\n    for (const auto& pipe : stdio_pipes_) {\n      if (pipe)\n        pipe->Close();\n    }\n\n    stdio_pipes_initialized_ = false;\n  }\n}\n\n\nvoid SyncProcessRunner::CloseKillTimer() {\n  CHECK_LT(lifecycle_, kHandlesClosed);\n\n  if (kill_timer_initialized_) {\n    CHECK_GT(timeout_, 0);\n    CHECK_NOT_NULL(uv_loop_);\n\n    uv_handle_t* uv_timer_handle = reinterpret_cast<uv_handle_t*>(&uv_timer_);\n    uv_ref(uv_timer_handle);\n    uv_close(uv_timer_handle, KillTimerCloseCallback);\n\n    kill_timer_initialized_ = false;\n  }\n}\n\n\nvoid SyncProcessRunner::Kill() {\n  // Only attempt to kill once.\n  if (killed_)\n    return;\n  killed_ = true;\n\n  // We might get here even if the process we spawned has already exited. This\n  // could happen when our child process spawned another process which\n  // inherited (one of) the stdio pipes. In this case we won't attempt to send\n  // a signal to the process, however we will still close our end of the stdio\n  // pipes so this situation won't make us hang.\n  if (exit_status_ < 0) {\n    int r = uv_process_kill(&uv_process_, kill_signal_);\n\n    // If uv_kill failed with an error that isn't ESRCH, the user probably\n    // specified an invalid or unsupported signal. Signal this to the user as\n    // and error and kill the process with SIGKILL instead.\n    if (r < 0 && r != UV_ESRCH) {\n      SetError(r);\n\n      // Deliberately ignore the return value, we might not have\n      // sufficient privileges to signal the child process.\n      USE(uv_process_kill(&uv_process_, SIGKILL));\n    }\n  }\n\n  // Close all stdio pipes.\n  CloseStdioPipes();\n\n  // Stop the timeout timer immediately.\n  CloseKillTimer();\n}\n\n\nvoid SyncProcessRunner::IncrementBufferSizeAndCheckOverflow(ssize_t length) {\n  buffered_output_size_ += length;\n\n  if (max_buffer_ > 0 && buffered_output_size_ > max_buffer_) {\n    SetError(UV_ENOBUFS);\n    Kill();\n  }\n}\n\n\nvoid SyncProcessRunner::OnExit(int64_t exit_status, int term_signal) {\n  if (exit_status < 0)\n    return SetError(static_cast<int>(exit_status));\n\n  exit_status_ = exit_status;\n  term_signal_ = term_signal;\n}\n\n\nvoid SyncProcessRunner::OnKillTimerTimeout() {\n  SetError(UV_ETIMEDOUT);\n  Kill();\n}\n\n\nint SyncProcessRunner::GetError() {\n  if (error_ != 0)\n    return error_;\n  else\n    return pipe_error_;\n}\n\n\nvoid SyncProcessRunner::SetError(int error) {\n  if (error_ == 0)\n    error_ = error;\n}\n\n\nvoid SyncProcessRunner::SetPipeError(int pipe_error) {\n  if (pipe_error_ == 0)\n    pipe_error_ = pipe_error;\n}\n\n\nLocal<Object> SyncProcessRunner::BuildResultObject() {\n  EscapableHandleScope scope(env()->isolate());\n  Local<Context> context = env()->context();\n\n  Local<Object> js_result = Object::New(env()->isolate());\n\n  if (GetError() != 0) {\n    js_result->Set(context, env()->error_string(),\n                   Integer::New(env()->isolate(), GetError())).Check();\n  }\n\n  if (exit_status_ >= 0) {\n    if (term_signal_ > 0) {\n      js_result->Set(context, env()->status_string(),\n                     Null(env()->isolate())).Check();\n    } else {\n      js_result->Set(context, env()->status_string(),\n                     Number::New(env()->isolate(),\n                                 static_cast<double>(exit_status_))).Check();\n    }\n  } else {\n    // If exit_status_ < 0 the process was never started because of some error.\n    js_result->Set(context, env()->status_string(),\n                   Null(env()->isolate())).Check();\n  }\n\n  if (term_signal_ > 0)\n    js_result->Set(context, env()->signal_string(),\n                   String::NewFromUtf8(env()->isolate(),\n                                       signo_string(term_signal_))\n                       .ToLocalChecked())\n        .Check();\n  else\n    js_result->Set(context, env()->signal_string(),\n                   Null(env()->isolate())).Check();\n\n  if (exit_status_ >= 0)\n    js_result->Set(context, env()->output_string(),\n                   BuildOutputArray()).Check();\n  else\n    js_result->Set(context, env()->output_string(),\n                   Null(env()->isolate())).Check();\n\n  js_result->Set(context, env()->pid_string(),\n                 Number::New(env()->isolate(), uv_process_.pid)).Check();\n\n  return scope.Escape(js_result);\n}\n\n\nLocal<Array> SyncProcessRunner::BuildOutputArray() {\n  CHECK_GE(lifecycle_, kInitialized);\n  CHECK(!stdio_pipes_.empty());\n\n  EscapableHandleScope scope(env()->isolate());\n  MaybeStackBuffer<Local<Value>, 8> js_output(stdio_pipes_.size());\n\n  for (uint32_t i = 0; i < stdio_pipes_.size(); i++) {\n    SyncProcessStdioPipe* h = stdio_pipes_[i].get();\n    if (h != nullptr && h->writable())\n      js_output[i] = h->GetOutputAsBuffer(env());\n    else\n      js_output[i] = Null(env()->isolate());\n  }\n\n  return scope.Escape(\n      Array::New(env()->isolate(), js_output.out(), js_output.length()));\n}\n\nMaybe<int> SyncProcessRunner::ParseOptions(Local<Value> js_value) {\n  Isolate* isolate = env()->isolate();\n  HandleScope scope(isolate);\n  int r;\n\n  if (!js_value->IsObject()) return Just<int>(UV_EINVAL);\n\n  Local<Context> context = env()->context();\n  Local<Object> js_options = js_value.As<Object>();\n\n  Local<Value> js_file =\n      js_options->Get(context, env()->file_string()).ToLocalChecked();\n  if (!CopyJsString(js_file, &file_buffer_).To(&r)) return Nothing<int>();\n  if (r < 0) return Just(r);\n  uv_process_options_.file = file_buffer_;\n\n  // Undocumented feature of Win32 CreateProcess API allows spawning\n  // batch files directly but is potentially insecure because arguments\n  // are not escaped (and sometimes cannot be unambiguously escaped),\n  // hence why they are rejected here.\n  if (IsWindowsBatchFile(uv_process_options_.file))\n    return Just<int>(UV_EINVAL);\n\n  Local<Value> js_args =\n      js_options->Get(context, env()->args_string()).ToLocalChecked();\n  if (!CopyJsStringArray(js_args, &args_buffer_).To(&r)) return Nothing<int>();\n  if (r < 0) return Just(r);\n  uv_process_options_.args = reinterpret_cast<char**>(args_buffer_);\n\n  Local<Value> js_cwd =\n      js_options->Get(context, env()->cwd_string()).ToLocalChecked();\n  if (IsSet(js_cwd)) {\n    if (!CopyJsString(js_cwd, &cwd_buffer_).To(&r)) return Nothing<int>();\n    if (r < 0) return Just(r);\n    uv_process_options_.cwd = cwd_buffer_;\n  }\n\n  Local<Value> js_env_pairs =\n      js_options->Get(context, env()->env_pairs_string()).ToLocalChecked();\n  if (IsSet(js_env_pairs)) {\n    if (!CopyJsStringArray(js_env_pairs, &env_buffer_).To(&r))\n      return Nothing<int>();\n    if (r < 0) return Just(r);\n\n    uv_process_options_.env = reinterpret_cast<char**>(env_buffer_);\n  }\n  Local<Value> js_uid =\n      js_options->Get(context, env()->uid_string()).ToLocalChecked();\n  if (IsSet(js_uid)) {\n    CHECK(js_uid->IsInt32());\n    const int32_t uid = js_uid.As<Int32>()->Value();\n    uv_process_options_.uid = static_cast<uv_uid_t>(uid);\n    uv_process_options_.flags |= UV_PROCESS_SETUID;\n  }\n\n  Local<Value> js_gid =\n      js_options->Get(context, env()->gid_string()).ToLocalChecked();\n  if (IsSet(js_gid)) {\n    CHECK(js_gid->IsInt32());\n    const int32_t gid = js_gid.As<Int32>()->Value();\n    uv_process_options_.gid = static_cast<uv_gid_t>(gid);\n    uv_process_options_.flags |= UV_PROCESS_SETGID;\n  }\n\n  Local<Value> js_detached =\n      js_options->Get(context, env()->detached_string()).ToLocalChecked();\n  if (js_detached->BooleanValue(isolate))\n    uv_process_options_.flags |= UV_PROCESS_DETACHED;\n\n  Local<Value> js_win_hide =\n      js_options->Get(context, env()->windows_hide_string()).ToLocalChecked();\n  if (js_win_hide->BooleanValue(isolate))\n    uv_process_options_.flags |= UV_PROCESS_WINDOWS_HIDE;\n\n  if (env()->hide_console_windows())\n    uv_process_options_.flags |= UV_PROCESS_WINDOWS_HIDE_CONSOLE;\n\n  Local<Value> js_wva =\n      js_options->Get(context, env()->windows_verbatim_arguments_string())\n          .ToLocalChecked();\n\n  if (js_wva->BooleanValue(isolate))\n    uv_process_options_.flags |= UV_PROCESS_WINDOWS_VERBATIM_ARGUMENTS;\n\n  Local<Value> js_timeout =\n      js_options->Get(context, env()->timeout_string()).ToLocalChecked();\n  if (IsSet(js_timeout)) {\n    CHECK(js_timeout->IsNumber());\n    int64_t timeout = js_timeout->IntegerValue(context).FromJust();\n    timeout_ = static_cast<uint64_t>(timeout);\n  }\n\n  Local<Value> js_max_buffer =\n      js_options->Get(context, env()->max_buffer_string()).ToLocalChecked();\n  if (IsSet(js_max_buffer)) {\n    CHECK(js_max_buffer->IsNumber());\n    max_buffer_ = js_max_buffer->NumberValue(context).FromJust();\n  }\n\n  Local<Value> js_kill_signal =\n      js_options->Get(context, env()->kill_signal_string()).ToLocalChecked();\n  if (IsSet(js_kill_signal)) {\n    CHECK(js_kill_signal->IsInt32());\n    kill_signal_ = js_kill_signal.As<Int32>()->Value();\n  }\n\n  Local<Value> js_stdio =\n      js_options->Get(context, env()->stdio_string()).ToLocalChecked();\n  r = ParseStdioOptions(js_stdio);\n  if (r < 0) return Just(r);\n\n  return Just(0);\n}\n\n\nint SyncProcessRunner::ParseStdioOptions(Local<Value> js_value) {\n  HandleScope scope(env()->isolate());\n  Local<Array> js_stdio_options;\n\n  if (!js_value->IsArray())\n    return UV_EINVAL;\n\n  Local<Context> context = env()->context();\n  js_stdio_options = js_value.As<Array>();\n\n  stdio_count_ = js_stdio_options->Length();\n  uv_stdio_containers_ = new uv_stdio_container_t[stdio_count_];\n\n  stdio_pipes_.clear();\n  stdio_pipes_.resize(stdio_count_);\n  stdio_pipes_initialized_ = true;\n\n  for (uint32_t i = 0; i < stdio_count_; i++) {\n    Local<Value> js_stdio_option =\n        js_stdio_options->Get(context, i).ToLocalChecked();\n\n    if (!js_stdio_option->IsObject())\n      return UV_EINVAL;\n\n    int r = ParseStdioOption(i, js_stdio_option.As<Object>());\n    if (r < 0)\n      return r;\n  }\n\n  uv_process_options_.stdio = uv_stdio_containers_;\n  uv_process_options_.stdio_count = stdio_count_;\n\n  return 0;\n}\n\n\nint SyncProcessRunner::ParseStdioOption(int child_fd,\n                                        Local<Object> js_stdio_option) {\n  Local<Context> context = env()->context();\n  Local<Value> js_type =\n      js_stdio_option->Get(context, env()->type_string()).ToLocalChecked();\n\n  if (js_type->StrictEquals(env()->ignore_string())) {\n    return AddStdioIgnore(child_fd);\n\n  } else if (js_type->StrictEquals(env()->pipe_string())) {\n    Isolate* isolate = env()->isolate();\n    Local<String> rs = env()->readable_string();\n    Local<String> ws = env()->writable_string();\n\n    bool readable = js_stdio_option->Get(context, rs)\n        .ToLocalChecked()->BooleanValue(isolate);\n    bool writable =\n        js_stdio_option->Get(context, ws)\n        .ToLocalChecked()->BooleanValue(isolate);\n\n    uv_buf_t buf = uv_buf_init(nullptr, 0);\n\n    if (readable) {\n      Local<Value> input =\n          js_stdio_option->Get(context, env()->input_string()).ToLocalChecked();\n      if (Buffer::HasInstance(input)) {\n        buf = uv_buf_init(Buffer::Data(input),\n                          static_cast<unsigned int>(Buffer::Length(input)));\n      } else if (!input->IsUndefined() && !input->IsNull()) {\n        // Strings, numbers etc. are currently unsupported. It's not possible\n        // to create a buffer for them here because there is no way to free\n        // them afterwards.\n        return UV_EINVAL;\n      }\n    }\n\n    return AddStdioPipe(child_fd, readable, writable, buf);\n\n  } else if (js_type->StrictEquals(env()->inherit_string()) ||\n             js_type->StrictEquals(env()->fd_string())) {\n    int inherit_fd = js_stdio_option->Get(context, env()->fd_string())\n        .ToLocalChecked()->Int32Value(context).FromJust();\n    return AddStdioInheritFD(child_fd, inherit_fd);\n\n  } else {\n    UNREACHABLE(\"invalid child stdio type\");\n  }\n}\n\n\nint SyncProcessRunner::AddStdioIgnore(uint32_t child_fd) {\n  CHECK_LT(child_fd, stdio_count_);\n  CHECK(!stdio_pipes_[child_fd]);\n\n  uv_stdio_containers_[child_fd].flags = UV_IGNORE;\n\n  return 0;\n}\n\n\nint SyncProcessRunner::AddStdioPipe(uint32_t child_fd,\n                                    bool readable,\n                                    bool writable,\n                                    uv_buf_t input_buffer) {\n  CHECK_LT(child_fd, stdio_count_);\n  CHECK(!stdio_pipes_[child_fd]);\n\n  std::unique_ptr<SyncProcessStdioPipe> h(\n      new SyncProcessStdioPipe(this, readable, writable, input_buffer));\n\n  int r = h->Initialize(uv_loop_);\n  if (r < 0) {\n    h.reset();\n    return r;\n  }\n\n  uv_stdio_containers_[child_fd].flags = h->uv_flags();\n  uv_stdio_containers_[child_fd].data.stream = h->uv_stream();\n\n  stdio_pipes_[child_fd] = std::move(h);\n\n  return 0;\n}\n\n\nint SyncProcessRunner::AddStdioInheritFD(uint32_t child_fd, int inherit_fd) {\n  CHECK_LT(child_fd, stdio_count_);\n  CHECK(!stdio_pipes_[child_fd]);\n\n  uv_stdio_containers_[child_fd].flags = UV_INHERIT_FD;\n  uv_stdio_containers_[child_fd].data.fd = inherit_fd;\n\n  return 0;\n}\n\n\nbool SyncProcessRunner::IsSet(Local<Value> value) {\n  return !value->IsUndefined() && !value->IsNull();\n}\n\nMaybe<int> SyncProcessRunner::CopyJsString(Local<Value> js_value,\n                                           const char** target) {\n  Isolate* isolate = env()->isolate();\n  Local<String> js_string;\n  size_t size, written;\n  char* buffer;\n\n  if (js_value->IsString())\n    js_string = js_value.As<String>();\n  else if (!js_value->ToString(env()->isolate()->GetCurrentContext())\n                .ToLocal(&js_string))\n    return Nothing<int>();\n\n  // Include space for null terminator byte.\n  if (!StringBytes::StorageSize(isolate, js_string, UTF8).To(&size))\n    return Nothing<int>();\n  size += 1;\n\n  buffer = new char[size];\n\n  written = StringBytes::Write(isolate, buffer, -1, js_string, UTF8);\n  buffer[written] = '\\0';\n\n  *target = buffer;\n  return Just(0);\n}\n\nMaybe<int> SyncProcessRunner::CopyJsStringArray(Local<Value> js_value,\n                                                char** target) {\n  Isolate* isolate = env()->isolate();\n  Local<Array> js_array;\n  uint32_t length;\n  size_t list_size, data_size, data_offset;\n  char** list;\n  char* buffer;\n\n  if (!js_value->IsArray()) return Just<int>(UV_EINVAL);\n\n  Local<Context> context = env()->context();\n  js_array = js_value.As<Array>()->Clone().As<Array>();\n  length = js_array->Length();\n  data_size = 0;\n\n  // Index has a pointer to every string element, plus one more for a final\n  // null pointer.\n  list_size = (length + 1) * sizeof *list;\n\n  // Convert all array elements to string. Modify the js object itself if\n  // needed - it's okay since we cloned the original object. Also compute the\n  // length of all strings, including room for a null terminator after every\n  // string. Align strings to cache lines.\n  for (uint32_t i = 0; i < length; i++) {\n    auto value = js_array->Get(context, i).ToLocalChecked();\n\n    if (!value->IsString()) {\n      Local<String> string;\n      if (!value->ToString(env()->isolate()->GetCurrentContext())\n               .ToLocal(&string))\n        return Nothing<int>();\n      js_array\n          ->Set(context,\n                i,\n                string)\n          .Check();\n    }\n\n    Maybe<size_t> maybe_size = StringBytes::StorageSize(isolate, value, UTF8);\n    if (maybe_size.IsNothing()) return Nothing<int>();\n    data_size += maybe_size.FromJust() + 1;\n    data_size = RoundUp(data_size, sizeof(void*));\n  }\n\n  buffer = new char[list_size + data_size];\n\n  list = reinterpret_cast<char**>(buffer);\n  data_offset = list_size;\n\n  for (uint32_t i = 0; i < length; i++) {\n    list[i] = buffer + data_offset;\n    auto value = js_array->Get(context, i).ToLocalChecked();\n    data_offset += StringBytes::Write(isolate,\n                                      buffer + data_offset,\n                                      -1,\n                                      value,\n                                      UTF8);\n    buffer[data_offset++] = '\\0';\n    data_offset = RoundUp(data_offset, sizeof(void*));\n  }\n\n  list[length] = nullptr;\n\n  *target = buffer;\n  return Just(0);\n}\n\n\nvoid SyncProcessRunner::ExitCallback(uv_process_t* handle,\n                                     int64_t exit_status,\n                                     int term_signal) {\n  SyncProcessRunner* self = reinterpret_cast<SyncProcessRunner*>(handle->data);\n  uv_close(reinterpret_cast<uv_handle_t*>(handle), nullptr);\n  self->OnExit(exit_status, term_signal);\n}\n\n\nvoid SyncProcessRunner::KillTimerCallback(uv_timer_t* handle) {\n  SyncProcessRunner* self = reinterpret_cast<SyncProcessRunner*>(handle->data);\n  self->OnKillTimerTimeout();\n}\n\n\nvoid SyncProcessRunner::KillTimerCloseCallback(uv_handle_t* handle) {\n  // No-op.\n}\n\n}  // namespace node\n\nNODE_BINDING_CONTEXT_AWARE_INTERNAL(spawn_sync,\n                                    node::SyncProcessRunner::Initialize)\n", "patch": "@@ -758,6 +758,13 @@ Maybe<int> SyncProcessRunner::ParseOptions(Local<Value> js_value) {\n   if (r < 0) return Just(r);\n   uv_process_options_.file = file_buffer_;\n \n+  // Undocumented feature of Win32 CreateProcess API allows spawning\n+  // batch files directly but is potentially insecure because arguments\n+  // are not escaped (and sometimes cannot be unambiguously escaped),\n+  // hence why they are rejected here.\n+  if (IsWindowsBatchFile(uv_process_options_.file))\n+    return Just<int>(UV_EINVAL);\n+\n   Local<Value> js_args =\n       js_options->Get(context, env()->args_string()).ToLocalChecked();\n   if (!CopyJsStringArray(js_args, &args_buffer_).To(&r)) return Nothing<int>();"}
{"patches_id": 3, "files_id": 15, "language": "h", "raw_url": "https://github.com/nodejs/node/raw/662722240928668e4b16822be2f660fc6d957340/src%2Futil-inl.h", "raw_code": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n#ifndef SRC_UTIL_INL_H_\n#define SRC_UTIL_INL_H_\n\n#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n\n#include <cmath>\n#include <cstring>\n#include <locale>\n#include \"node_revert.h\"\n#include \"util.h\"\n\n// These are defined by <sys/byteorder.h> or <netinet/in.h> on some systems.\n// To avoid warnings, undefine them before redefining them.\n#ifdef BSWAP_2\n# undef BSWAP_2\n#endif\n#ifdef BSWAP_4\n# undef BSWAP_4\n#endif\n#ifdef BSWAP_8\n# undef BSWAP_8\n#endif\n\n#if defined(_MSC_VER)\n#include <intrin.h>\n#define BSWAP_2(x) _byteswap_ushort(x)\n#define BSWAP_4(x) _byteswap_ulong(x)\n#define BSWAP_8(x) _byteswap_uint64(x)\n#else\n#define BSWAP_2(x) ((x) << 8) | ((x) >> 8)\n#define BSWAP_4(x)                                                            \\\n  (((x) & 0xFF) << 24) |                                                      \\\n  (((x) & 0xFF00) << 8) |                                                     \\\n  (((x) >> 8) & 0xFF00) |                                                     \\\n  (((x) >> 24) & 0xFF)\n#define BSWAP_8(x)                                                            \\\n  (((x) & 0xFF00000000000000ull) >> 56) |                                     \\\n  (((x) & 0x00FF000000000000ull) >> 40) |                                     \\\n  (((x) & 0x0000FF0000000000ull) >> 24) |                                     \\\n  (((x) & 0x000000FF00000000ull) >> 8) |                                      \\\n  (((x) & 0x00000000FF000000ull) << 8) |                                      \\\n  (((x) & 0x0000000000FF0000ull) << 24) |                                     \\\n  (((x) & 0x000000000000FF00ull) << 40) |                                     \\\n  (((x) & 0x00000000000000FFull) << 56)\n#endif\n\n#define CHAR_TEST(bits, name, expr)                                           \\\n  template <typename T>                                                       \\\n  bool name(const T ch) {                                                     \\\n    static_assert(sizeof(ch) >= (bits) / 8,                                   \\\n                  \"Character must be wider than \" #bits \" bits\");             \\\n    return (expr);                                                            \\\n  }\n\nnamespace node {\n\ntemplate <typename T>\nListNode<T>::ListNode() : prev_(this), next_(this) {}\n\ntemplate <typename T>\nListNode<T>::~ListNode() {\n  Remove();\n}\n\ntemplate <typename T>\nvoid ListNode<T>::Remove() {\n  prev_->next_ = next_;\n  next_->prev_ = prev_;\n  prev_ = this;\n  next_ = this;\n}\n\ntemplate <typename T>\nbool ListNode<T>::IsEmpty() const {\n  return prev_ == this;\n}\n\ntemplate <typename T, ListNode<T> (T::*M)>\nListHead<T, M>::Iterator::Iterator(ListNode<T>* node) : node_(node) {}\n\ntemplate <typename T, ListNode<T> (T::*M)>\nT* ListHead<T, M>::Iterator::operator*() const {\n  return ContainerOf(M, node_);\n}\n\ntemplate <typename T, ListNode<T> (T::*M)>\nconst typename ListHead<T, M>::Iterator&\nListHead<T, M>::Iterator::operator++() {\n  node_ = node_->next_;\n  return *this;\n}\n\ntemplate <typename T, ListNode<T> (T::*M)>\nbool ListHead<T, M>::Iterator::operator!=(const Iterator& that) const {\n  return node_ != that.node_;\n}\n\ntemplate <typename T, ListNode<T> (T::*M)>\nListHead<T, M>::~ListHead() {\n  while (IsEmpty() == false)\n    head_.next_->Remove();\n}\n\ntemplate <typename T, ListNode<T> (T::*M)>\nvoid ListHead<T, M>::PushBack(T* element) {\n  ListNode<T>* that = &(element->*M);\n  head_.prev_->next_ = that;\n  that->prev_ = head_.prev_;\n  that->next_ = &head_;\n  head_.prev_ = that;\n}\n\ntemplate <typename T, ListNode<T> (T::*M)>\nvoid ListHead<T, M>::PushFront(T* element) {\n  ListNode<T>* that = &(element->*M);\n  head_.next_->prev_ = that;\n  that->prev_ = &head_;\n  that->next_ = head_.next_;\n  head_.next_ = that;\n}\n\ntemplate <typename T, ListNode<T> (T::*M)>\nbool ListHead<T, M>::IsEmpty() const {\n  return head_.IsEmpty();\n}\n\ntemplate <typename T, ListNode<T> (T::*M)>\nT* ListHead<T, M>::PopFront() {\n  if (IsEmpty())\n    return nullptr;\n  ListNode<T>* node = head_.next_;\n  node->Remove();\n  return ContainerOf(M, node);\n}\n\ntemplate <typename T, ListNode<T> (T::*M)>\ntypename ListHead<T, M>::Iterator ListHead<T, M>::begin() const {\n  return Iterator(head_.next_);\n}\n\ntemplate <typename T, ListNode<T> (T::*M)>\ntypename ListHead<T, M>::Iterator ListHead<T, M>::end() const {\n  return Iterator(const_cast<ListNode<T>*>(&head_));\n}\n\ntemplate <typename Inner, typename Outer>\nconstexpr uintptr_t OffsetOf(Inner Outer::*field) {\n  return reinterpret_cast<uintptr_t>(&(static_cast<Outer*>(nullptr)->*field));\n}\n\ntemplate <typename Inner, typename Outer>\nContainerOfHelper<Inner, Outer>::ContainerOfHelper(Inner Outer::*field,\n                                                   Inner* pointer)\n    : pointer_(\n        reinterpret_cast<Outer*>(\n            reinterpret_cast<uintptr_t>(pointer) - OffsetOf(field))) {}\n\ntemplate <typename Inner, typename Outer>\ntemplate <typename TypeName>\nContainerOfHelper<Inner, Outer>::operator TypeName*() const {\n  return static_cast<TypeName*>(pointer_);\n}\n\ntemplate <typename Inner, typename Outer>\nconstexpr ContainerOfHelper<Inner, Outer> ContainerOf(Inner Outer::*field,\n                                                      Inner* pointer) {\n  return ContainerOfHelper<Inner, Outer>(field, pointer);\n}\n\ninline v8::Local<v8::String> OneByteString(v8::Isolate* isolate,\n                                           const char* data,\n                                           int length) {\n  return v8::String::NewFromOneByte(isolate,\n                                    reinterpret_cast<const uint8_t*>(data),\n                                    v8::NewStringType::kNormal,\n                                    length).ToLocalChecked();\n}\n\ninline v8::Local<v8::String> OneByteString(v8::Isolate* isolate,\n                                           const signed char* data,\n                                           int length) {\n  return v8::String::NewFromOneByte(isolate,\n                                    reinterpret_cast<const uint8_t*>(data),\n                                    v8::NewStringType::kNormal,\n                                    length).ToLocalChecked();\n}\n\ninline v8::Local<v8::String> OneByteString(v8::Isolate* isolate,\n                                           const unsigned char* data,\n                                           int length) {\n  return v8::String::NewFromOneByte(\n             isolate, data, v8::NewStringType::kNormal, length)\n      .ToLocalChecked();\n}\n\nvoid SwapBytes16(char* data, size_t nbytes) {\n  CHECK_EQ(nbytes % 2, 0);\n\n#if defined(_MSC_VER)\n  if (AlignUp(data, sizeof(uint16_t)) == data) {\n    // MSVC has no strict aliasing, and is able to highly optimize this case.\n    uint16_t* data16 = reinterpret_cast<uint16_t*>(data);\n    size_t len16 = nbytes / sizeof(*data16);\n    for (size_t i = 0; i < len16; i++) {\n      data16[i] = BSWAP_2(data16[i]);\n    }\n    return;\n  }\n#endif\n\n  uint16_t temp;\n  for (size_t i = 0; i < nbytes; i += sizeof(temp)) {\n    memcpy(&temp, &data[i], sizeof(temp));\n    temp = BSWAP_2(temp);\n    memcpy(&data[i], &temp, sizeof(temp));\n  }\n}\n\nvoid SwapBytes32(char* data, size_t nbytes) {\n  CHECK_EQ(nbytes % 4, 0);\n\n#if defined(_MSC_VER)\n  // MSVC has no strict aliasing, and is able to highly optimize this case.\n  if (AlignUp(data, sizeof(uint32_t)) == data) {\n    uint32_t* data32 = reinterpret_cast<uint32_t*>(data);\n    size_t len32 = nbytes / sizeof(*data32);\n    for (size_t i = 0; i < len32; i++) {\n      data32[i] = BSWAP_4(data32[i]);\n    }\n    return;\n  }\n#endif\n\n  uint32_t temp;\n  for (size_t i = 0; i < nbytes; i += sizeof(temp)) {\n    memcpy(&temp, &data[i], sizeof(temp));\n    temp = BSWAP_4(temp);\n    memcpy(&data[i], &temp, sizeof(temp));\n  }\n}\n\nvoid SwapBytes64(char* data, size_t nbytes) {\n  CHECK_EQ(nbytes % 8, 0);\n\n#if defined(_MSC_VER)\n  if (AlignUp(data, sizeof(uint64_t)) == data) {\n    // MSVC has no strict aliasing, and is able to highly optimize this case.\n    uint64_t* data64 = reinterpret_cast<uint64_t*>(data);\n    size_t len64 = nbytes / sizeof(*data64);\n    for (size_t i = 0; i < len64; i++) {\n      data64[i] = BSWAP_8(data64[i]);\n    }\n    return;\n  }\n#endif\n\n  uint64_t temp;\n  for (size_t i = 0; i < nbytes; i += sizeof(temp)) {\n    memcpy(&temp, &data[i], sizeof(temp));\n    temp = BSWAP_8(temp);\n    memcpy(&data[i], &temp, sizeof(temp));\n  }\n}\n\nchar ToLower(char c) {\n  return std::tolower(c, std::locale::classic());\n}\n\nstd::string ToLower(const std::string& in) {\n  std::string out(in.size(), 0);\n  for (size_t i = 0; i < in.size(); ++i)\n    out[i] = ToLower(in[i]);\n  return out;\n}\n\nchar ToUpper(char c) {\n  return std::toupper(c, std::locale::classic());\n}\n\nstd::string ToUpper(const std::string& in) {\n  std::string out(in.size(), 0);\n  for (size_t i = 0; i < in.size(); ++i)\n    out[i] = ToUpper(in[i]);\n  return out;\n}\n\nbool StringEqualNoCase(const char* a, const char* b) {\n  while (ToLower(*a) == ToLower(*b++)) {\n    if (*a++ == '\\0')\n      return true;\n  }\n  return false;\n}\n\nbool StringEqualNoCaseN(const char* a, const char* b, size_t length) {\n  for (size_t i = 0; i < length; i++) {\n    if (ToLower(a[i]) != ToLower(b[i]))\n      return false;\n    if (a[i] == '\\0')\n      return true;\n  }\n  return true;\n}\n\ntemplate <typename T>\ninline T MultiplyWithOverflowCheck(T a, T b) {\n  auto ret = a * b;\n  if (a != 0)\n    CHECK_EQ(b, ret / a);\n\n  return ret;\n}\n\n// These should be used in our code as opposed to the native\n// versions as they abstract out some platform and or\n// compiler version specific functionality.\n// malloc(0) and realloc(ptr, 0) have implementation-defined behavior in\n// that the standard allows them to either return a unique pointer or a\n// nullptr for zero-sized allocation requests.  Normalize by always using\n// a nullptr.\ntemplate <typename T>\nT* UncheckedRealloc(T* pointer, size_t n) {\n  size_t full_size = MultiplyWithOverflowCheck(sizeof(T), n);\n\n  if (full_size == 0) {\n    free(pointer);\n    return nullptr;\n  }\n\n  void* allocated = realloc(pointer, full_size);\n\n  if (UNLIKELY(allocated == nullptr)) {\n    // Tell V8 that memory is low and retry.\n    LowMemoryNotification();\n    allocated = realloc(pointer, full_size);\n  }\n\n  return static_cast<T*>(allocated);\n}\n\n// As per spec realloc behaves like malloc if passed nullptr.\ntemplate <typename T>\ninline T* UncheckedMalloc(size_t n) {\n  return UncheckedRealloc<T>(nullptr, n);\n}\n\ntemplate <typename T>\ninline T* UncheckedCalloc(size_t n) {\n  if (MultiplyWithOverflowCheck(sizeof(T), n) == 0) return nullptr;\n  return static_cast<T*>(calloc(n, sizeof(T)));\n}\n\ntemplate <typename T>\ninline T* Realloc(T* pointer, size_t n) {\n  T* ret = UncheckedRealloc(pointer, n);\n  CHECK_IMPLIES(n > 0, ret != nullptr);\n  return ret;\n}\n\ntemplate <typename T>\ninline T* Malloc(size_t n) {\n  T* ret = UncheckedMalloc<T>(n);\n  CHECK_IMPLIES(n > 0, ret != nullptr);\n  return ret;\n}\n\ntemplate <typename T>\ninline T* Calloc(size_t n) {\n  T* ret = UncheckedCalloc<T>(n);\n  CHECK_IMPLIES(n > 0, ret != nullptr);\n  return ret;\n}\n\n// Shortcuts for char*.\ninline char* Malloc(size_t n) { return Malloc<char>(n); }\ninline char* Calloc(size_t n) { return Calloc<char>(n); }\ninline char* UncheckedMalloc(size_t n) { return UncheckedMalloc<char>(n); }\ninline char* UncheckedCalloc(size_t n) { return UncheckedCalloc<char>(n); }\n\n// This is a helper in the .cc file so including util-inl.h doesn't include more\n// headers than we really need to.\nvoid ThrowErrStringTooLong(v8::Isolate* isolate);\n\nv8::MaybeLocal<v8::Value> ToV8Value(v8::Local<v8::Context> context,\n                                    std::string_view str,\n                                    v8::Isolate* isolate) {\n  if (isolate == nullptr) isolate = context->GetIsolate();\n  if (UNLIKELY(str.size() >= static_cast<size_t>(v8::String::kMaxLength))) {\n    // V8 only has a TODO comment about adding an exception when the maximum\n    // string size is exceeded.\n    ThrowErrStringTooLong(isolate);\n    return v8::MaybeLocal<v8::Value>();\n  }\n\n  return v8::String::NewFromUtf8(\n             isolate, str.data(), v8::NewStringType::kNormal, str.size())\n      .FromMaybe(v8::Local<v8::String>());\n}\n\ntemplate <typename T>\nv8::MaybeLocal<v8::Value> ToV8Value(v8::Local<v8::Context> context,\n                                    const std::vector<T>& vec,\n                                    v8::Isolate* isolate) {\n  if (isolate == nullptr) isolate = context->GetIsolate();\n  v8::EscapableHandleScope handle_scope(isolate);\n\n  MaybeStackBuffer<v8::Local<v8::Value>, 128> arr(vec.size());\n  arr.SetLength(vec.size());\n  for (size_t i = 0; i < vec.size(); ++i) {\n    if (!ToV8Value(context, vec[i], isolate).ToLocal(&arr[i]))\n      return v8::MaybeLocal<v8::Value>();\n  }\n\n  return handle_scope.Escape(v8::Array::New(isolate, arr.out(), arr.length()));\n}\n\ntemplate <typename T>\nv8::MaybeLocal<v8::Value> ToV8Value(v8::Local<v8::Context> context,\n                                    const std::set<T>& set,\n                                    v8::Isolate* isolate) {\n  if (isolate == nullptr) isolate = context->GetIsolate();\n  v8::Local<v8::Set> set_js = v8::Set::New(isolate);\n  v8::HandleScope handle_scope(isolate);\n\n  for (const T& entry : set) {\n    v8::Local<v8::Value> value;\n    if (!ToV8Value(context, entry, isolate).ToLocal(&value))\n      return {};\n    if (set_js->Add(context, value).IsEmpty())\n      return {};\n  }\n\n  return set_js;\n}\n\ntemplate <typename T, typename U>\nv8::MaybeLocal<v8::Value> ToV8Value(v8::Local<v8::Context> context,\n                                    const std::unordered_map<T, U>& map,\n                                    v8::Isolate* isolate) {\n  if (isolate == nullptr) isolate = context->GetIsolate();\n  v8::EscapableHandleScope handle_scope(isolate);\n\n  v8::Local<v8::Map> ret = v8::Map::New(isolate);\n  for (const auto& item : map) {\n    v8::Local<v8::Value> first, second;\n    if (!ToV8Value(context, item.first, isolate).ToLocal(&first) ||\n        !ToV8Value(context, item.second, isolate).ToLocal(&second) ||\n        ret->Set(context, first, second).IsEmpty()) {\n      return v8::MaybeLocal<v8::Value>();\n    }\n  }\n\n  return handle_scope.Escape(ret);\n}\n\ntemplate <typename T, typename >\nv8::MaybeLocal<v8::Value> ToV8Value(v8::Local<v8::Context> context,\n                                    const T& number,\n                                    v8::Isolate* isolate) {\n  if (isolate == nullptr) isolate = context->GetIsolate();\n\n  using Limits = std::numeric_limits<T>;\n  // Choose Uint32, Int32, or Double depending on range checks.\n  // These checks should all collapse at compile time.\n  if (static_cast<uint32_t>(Limits::max()) <=\n          std::numeric_limits<uint32_t>::max() &&\n      static_cast<uint32_t>(Limits::min()) >=\n          std::numeric_limits<uint32_t>::min() && Limits::is_exact) {\n    return v8::Integer::NewFromUnsigned(isolate, static_cast<uint32_t>(number));\n  }\n\n  if (static_cast<int32_t>(Limits::max()) <=\n          std::numeric_limits<int32_t>::max() &&\n      static_cast<int32_t>(Limits::min()) >=\n          std::numeric_limits<int32_t>::min() && Limits::is_exact) {\n    return v8::Integer::New(isolate, static_cast<int32_t>(number));\n  }\n\n  return v8::Number::New(isolate, static_cast<double>(number));\n}\n\nSlicedArguments::SlicedArguments(\n    const v8::FunctionCallbackInfo<v8::Value>& args, size_t start) {\n  const size_t length = static_cast<size_t>(args.Length());\n  if (start >= length) return;\n  const size_t size = length - start;\n\n  AllocateSufficientStorage(size);\n  for (size_t i = 0; i < size; ++i)\n    (*this)[i] = args[i + start];\n}\n\ntemplate <typename T, size_t kStackStorageSize>\nvoid MaybeStackBuffer<T, kStackStorageSize>::AllocateSufficientStorage(\n    size_t storage) {\n  CHECK(!IsInvalidated());\n  if (storage > capacity()) {\n    bool was_allocated = IsAllocated();\n    T* allocated_ptr = was_allocated ? buf_ : nullptr;\n    buf_ = Realloc(allocated_ptr, storage);\n    capacity_ = storage;\n    if (!was_allocated && length_ > 0)\n      memcpy(buf_, buf_st_, length_ * sizeof(buf_[0]));\n  }\n\n  length_ = storage;\n}\n\ntemplate <typename T, size_t S>\nArrayBufferViewContents<T, S>::ArrayBufferViewContents(\n    v8::Local<v8::Value> value) {\n  DCHECK(value->IsArrayBufferView() || value->IsSharedArrayBuffer() ||\n         value->IsArrayBuffer());\n  ReadValue(value);\n}\n\ntemplate <typename T, size_t S>\nArrayBufferViewContents<T, S>::ArrayBufferViewContents(\n    v8::Local<v8::Object> value) {\n  CHECK(value->IsArrayBufferView());\n  Read(value.As<v8::ArrayBufferView>());\n}\n\ntemplate <typename T, size_t S>\nArrayBufferViewContents<T, S>::ArrayBufferViewContents(\n    v8::Local<v8::ArrayBufferView> abv) {\n  Read(abv);\n}\n\ntemplate <typename T, size_t S>\nvoid ArrayBufferViewContents<T, S>::Read(v8::Local<v8::ArrayBufferView> abv) {\n  static_assert(sizeof(T) == 1, \"Only supports one-byte data at the moment\");\n  length_ = abv->ByteLength();\n  if (length_ > sizeof(stack_storage_) || abv->HasBuffer()) {\n    data_ = static_cast<T*>(abv->Buffer()->Data()) + abv->ByteOffset();\n  } else {\n    abv->CopyContents(stack_storage_, sizeof(stack_storage_));\n    data_ = stack_storage_;\n  }\n}\n\ntemplate <typename T, size_t S>\nvoid ArrayBufferViewContents<T, S>::ReadValue(v8::Local<v8::Value> buf) {\n  static_assert(sizeof(T) == 1, \"Only supports one-byte data at the moment\");\n  DCHECK(buf->IsArrayBufferView() || buf->IsSharedArrayBuffer() ||\n         buf->IsArrayBuffer());\n\n  if (buf->IsArrayBufferView()) {\n    Read(buf.As<v8::ArrayBufferView>());\n  } else if (buf->IsArrayBuffer()) {\n    auto ab = buf.As<v8::ArrayBuffer>();\n    length_ = ab->ByteLength();\n    data_ = static_cast<T*>(ab->Data());\n    was_detached_ = ab->WasDetached();\n  } else {\n    CHECK(buf->IsSharedArrayBuffer());\n    auto sab = buf.As<v8::SharedArrayBuffer>();\n    length_ = sab->ByteLength();\n    data_ = static_cast<T*>(sab->Data());\n  }\n}\n\n// ECMA262 20.1.2.5\ninline bool IsSafeJsInt(v8::Local<v8::Value> v) {\n  if (!v->IsNumber()) return false;\n  double v_d = v.As<v8::Number>()->Value();\n  if (std::isnan(v_d)) return false;\n  if (std::isinf(v_d)) return false;\n  if (std::trunc(v_d) != v_d) return false;  // not int\n  if (std::abs(v_d) <= static_cast<double>(kMaxSafeJsInteger)) return true;\n  return false;\n}\n\nconstexpr size_t FastStringKey::HashImpl(std::string_view str) {\n  // Low-quality hash (djb2), but just fine for current use cases.\n  size_t h = 5381;\n  for (const char c : str) {\n    h = h * 33 + c;\n  }\n  return h;\n}\n\nconstexpr size_t FastStringKey::Hash::operator()(\n    const FastStringKey& key) const {\n  return key.cached_hash_;\n}\n\nconstexpr bool FastStringKey::operator==(const FastStringKey& other) const {\n  return name_ == other.name_;\n}\n\nconstexpr FastStringKey::FastStringKey(std::string_view name)\n    : name_(name), cached_hash_(HashImpl(name)) {}\n\nconstexpr std::string_view FastStringKey::as_string_view() const {\n  return name_;\n}\n\n// Inline so the compiler can fully optimize it away on Unix platforms.\nbool IsWindowsBatchFile(const char* filename) {\n#ifdef _WIN32\n  static constexpr bool kIsWindows = true;\n#else\n  static constexpr bool kIsWindows = false;\n#endif  // _WIN32\n  if (kIsWindows)\n    if (!IsReverted(SECURITY_REVERT_CVE_2024_27980))\n      if (const char* p = strrchr(filename, '.'))\n        return StringEqualNoCase(p, \".bat\") || StringEqualNoCase(p, \".cmd\");\n  return false;\n}\n\n}  // namespace node\n\n#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n\n#endif  // SRC_UTIL_INL_H_\n", "patch": "@@ -27,6 +27,7 @@\n #include <cmath>\n #include <cstring>\n #include <locale>\n+#include \"node_revert.h\"\n #include \"util.h\"\n \n // These are defined by <sys/byteorder.h> or <netinet/in.h> on some systems.\n@@ -616,6 +617,20 @@ constexpr std::string_view FastStringKey::as_string_view() const {\n   return name_;\n }\n \n+// Inline so the compiler can fully optimize it away on Unix platforms.\n+bool IsWindowsBatchFile(const char* filename) {\n+#ifdef _WIN32\n+  static constexpr bool kIsWindows = true;\n+#else\n+  static constexpr bool kIsWindows = false;\n+#endif  // _WIN32\n+  if (kIsWindows)\n+    if (!IsReverted(SECURITY_REVERT_CVE_2024_27980))\n+      if (const char* p = strrchr(filename, '.'))\n+        return StringEqualNoCase(p, \".bat\") || StringEqualNoCase(p, \".cmd\");\n+  return false;\n+}\n+\n }  // namespace node\n \n #endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS"}
{"patches_id": 3, "files_id": 16, "language": "h", "raw_url": "https://github.com/nodejs/node/raw/662722240928668e4b16822be2f660fc6d957340/src%2Futil.h", "raw_code": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n#ifndef SRC_UTIL_H_\n#define SRC_UTIL_H_\n\n#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n\n#include \"v8.h\"\n\n#include \"node.h\"\n\n#include <climits>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#include <array>\n#include <limits>\n#include <memory>\n#include <set>\n#include <string>\n#include <string_view>\n#include <type_traits>\n#include <unordered_map>\n#include <utility>\n#include <vector>\n\n#ifdef __GNUC__\n#define MUST_USE_RESULT __attribute__((warn_unused_result))\n#else\n#define MUST_USE_RESULT\n#endif\n\nnamespace node {\n\n// Maybe remove kPathSeparator when cpp17 is ready\n#ifdef _WIN32\n    constexpr char kPathSeparator = '\\\\';\n/* MAX_PATH is in characters, not bytes. Make sure we have enough headroom. */\n#define PATH_MAX_BYTES (MAX_PATH * 4)\n#else\n    constexpr char kPathSeparator = '/';\n#define PATH_MAX_BYTES (PATH_MAX)\n#endif\n\n// These should be used in our code as opposed to the native\n// versions as they abstract out some platform and or\n// compiler version specific functionality\n// malloc(0) and realloc(ptr, 0) have implementation-defined behavior in\n// that the standard allows them to either return a unique pointer or a\n// nullptr for zero-sized allocation requests.  Normalize by always using\n// a nullptr.\ntemplate <typename T>\ninline T* UncheckedRealloc(T* pointer, size_t n);\ntemplate <typename T>\ninline T* UncheckedMalloc(size_t n);\ntemplate <typename T>\ninline T* UncheckedCalloc(size_t n);\n\n// Same things, but aborts immediately instead of returning nullptr when\n// no memory is available.\ntemplate <typename T>\ninline T* Realloc(T* pointer, size_t n);\ntemplate <typename T>\ninline T* Malloc(size_t n);\ntemplate <typename T>\ninline T* Calloc(size_t n);\n\ninline char* Malloc(size_t n);\ninline char* Calloc(size_t n);\ninline char* UncheckedMalloc(size_t n);\ninline char* UncheckedCalloc(size_t n);\n\ntemplate <typename T>\ninline T MultiplyWithOverflowCheck(T a, T b);\n\nnamespace per_process {\n// Tells whether the per-process V8::Initialize() is called and\n// if it is safe to call v8::Isolate::TryGetCurrent().\nextern bool v8_initialized;\n}  // namespace per_process\n\n// Used by the allocation functions when allocation fails.\n// Thin wrapper around v8::Isolate::LowMemoryNotification() that checks\n// whether V8 is initialized.\nvoid LowMemoryNotification();\n\n// The reason that Assert() takes a struct argument instead of individual\n// const char*s is to ease instruction cache pressure in calls from CHECK.\nstruct AssertionInfo {\n  const char* file_line;  // filename:line\n  const char* message;\n  const char* function;\n};\n[[noreturn]] void NODE_EXTERN_PRIVATE Assert(const AssertionInfo& info);\n[[noreturn]] void NODE_EXTERN_PRIVATE Abort();\nvoid DumpBacktrace(FILE* fp);\n\n// Windows 8+ does not like abort() in Release mode\n#ifdef _WIN32\n#define ABORT_NO_BACKTRACE() _exit(134)\n#else\n#define ABORT_NO_BACKTRACE() abort()\n#endif\n\n#define ABORT() node::Abort()\n\n#define ERROR_AND_ABORT(expr)                                                 \\\n  do {                                                                        \\\n    /* Make sure that this struct does not end up in inline code, but      */ \\\n    /* rather in a read-only data section when modifying this code.        */ \\\n    static const node::AssertionInfo args = {                                 \\\n      __FILE__ \":\" STRINGIFY(__LINE__), #expr, PRETTY_FUNCTION_NAME           \\\n    };                                                                        \\\n    node::Assert(args);                                                       \\\n  } while (0)\n\n#ifdef __GNUC__\n#define LIKELY(expr) __builtin_expect(!!(expr), 1)\n#define UNLIKELY(expr) __builtin_expect(!!(expr), 0)\n#define PRETTY_FUNCTION_NAME __PRETTY_FUNCTION__\n#else\n#define LIKELY(expr) expr\n#define UNLIKELY(expr) expr\n#define PRETTY_FUNCTION_NAME \"\"\n#endif\n\n#define STRINGIFY_(x) #x\n#define STRINGIFY(x) STRINGIFY_(x)\n\n#define CHECK(expr)                                                           \\\n  do {                                                                        \\\n    if (UNLIKELY(!(expr))) {                                                  \\\n      ERROR_AND_ABORT(expr);                                                  \\\n    }                                                                         \\\n  } while (0)\n\n#define CHECK_EQ(a, b) CHECK((a) == (b))\n#define CHECK_GE(a, b) CHECK((a) >= (b))\n#define CHECK_GT(a, b) CHECK((a) > (b))\n#define CHECK_LE(a, b) CHECK((a) <= (b))\n#define CHECK_LT(a, b) CHECK((a) < (b))\n#define CHECK_NE(a, b) CHECK((a) != (b))\n#define CHECK_NULL(val) CHECK((val) == nullptr)\n#define CHECK_NOT_NULL(val) CHECK((val) != nullptr)\n#define CHECK_IMPLIES(a, b) CHECK(!(a) || (b))\n\n#ifdef DEBUG\n  #define DCHECK(expr) CHECK(expr)\n  #define DCHECK_EQ(a, b) CHECK((a) == (b))\n  #define DCHECK_GE(a, b) CHECK((a) >= (b))\n  #define DCHECK_GT(a, b) CHECK((a) > (b))\n  #define DCHECK_LE(a, b) CHECK((a) <= (b))\n  #define DCHECK_LT(a, b) CHECK((a) < (b))\n  #define DCHECK_NE(a, b) CHECK((a) != (b))\n  #define DCHECK_NULL(val) CHECK((val) == nullptr)\n  #define DCHECK_NOT_NULL(val) CHECK((val) != nullptr)\n  #define DCHECK_IMPLIES(a, b) CHECK(!(a) || (b))\n#else\n  #define DCHECK(expr)\n  #define DCHECK_EQ(a, b)\n  #define DCHECK_GE(a, b)\n  #define DCHECK_GT(a, b)\n  #define DCHECK_LE(a, b)\n  #define DCHECK_LT(a, b)\n  #define DCHECK_NE(a, b)\n  #define DCHECK_NULL(val)\n  #define DCHECK_NOT_NULL(val)\n  #define DCHECK_IMPLIES(a, b)\n#endif\n\n\n#define UNREACHABLE(...)                                                      \\\n  ERROR_AND_ABORT(\"Unreachable code reached\" __VA_OPT__(\": \") __VA_ARGS__)\n\n// ECMA262 20.1.2.6 Number.MAX_SAFE_INTEGER (2^53-1)\nconstexpr int64_t kMaxSafeJsInteger = 9007199254740991;\n\ninline bool IsSafeJsInt(v8::Local<v8::Value> v);\n\n// TAILQ-style intrusive list node.\ntemplate <typename T>\nclass ListNode;\n\n// TAILQ-style intrusive list head.\ntemplate <typename T, ListNode<T> (T::*M)>\nclass ListHead;\n\ntemplate <typename T>\nclass ListNode {\n public:\n  inline ListNode();\n  inline ~ListNode();\n  inline void Remove();\n  inline bool IsEmpty() const;\n\n  ListNode(const ListNode&) = delete;\n  ListNode& operator=(const ListNode&) = delete;\n\n private:\n  template <typename U, ListNode<U> (U::*M)> friend class ListHead;\n  friend int GenDebugSymbols();\n  ListNode* prev_;\n  ListNode* next_;\n};\n\ntemplate <typename T, ListNode<T> (T::*M)>\nclass ListHead {\n public:\n  class Iterator {\n   public:\n    inline T* operator*() const;\n    inline const Iterator& operator++();\n    inline bool operator!=(const Iterator& that) const;\n\n   private:\n    friend class ListHead;\n    inline explicit Iterator(ListNode<T>* node);\n    ListNode<T>* node_;\n  };\n\n  inline ListHead() = default;\n  inline ~ListHead();\n  inline void PushBack(T* element);\n  inline void PushFront(T* element);\n  inline bool IsEmpty() const;\n  inline T* PopFront();\n  inline Iterator begin() const;\n  inline Iterator end() const;\n\n  ListHead(const ListHead&) = delete;\n  ListHead& operator=(const ListHead&) = delete;\n\n private:\n  friend int GenDebugSymbols();\n  ListNode<T> head_;\n};\n\n// The helper is for doing safe downcasts from base types to derived types.\ntemplate <typename Inner, typename Outer>\nclass ContainerOfHelper {\n public:\n  inline ContainerOfHelper(Inner Outer::*field, Inner* pointer);\n  template <typename TypeName>\n  inline operator TypeName*() const;\n private:\n  Outer* const pointer_;\n};\n\n// Calculate the address of the outer (i.e. embedding) struct from\n// the interior pointer to a data member.\ntemplate <typename Inner, typename Outer>\nconstexpr ContainerOfHelper<Inner, Outer> ContainerOf(Inner Outer::*field,\n                                                      Inner* pointer);\n\nclass KVStore {\n public:\n  KVStore() = default;\n  virtual ~KVStore() = default;\n  KVStore(const KVStore&) = delete;\n  KVStore& operator=(const KVStore&) = delete;\n  KVStore(KVStore&&) = delete;\n  KVStore& operator=(KVStore&&) = delete;\n\n  virtual v8::MaybeLocal<v8::String> Get(v8::Isolate* isolate,\n                                         v8::Local<v8::String> key) const = 0;\n  virtual v8::Maybe<std::string> Get(const char* key) const = 0;\n  virtual void Set(v8::Isolate* isolate,\n                   v8::Local<v8::String> key,\n                   v8::Local<v8::String> value) = 0;\n  virtual int32_t Query(v8::Isolate* isolate,\n                        v8::Local<v8::String> key) const = 0;\n  virtual int32_t Query(const char* key) const = 0;\n  virtual void Delete(v8::Isolate* isolate, v8::Local<v8::String> key) = 0;\n  virtual v8::Local<v8::Array> Enumerate(v8::Isolate* isolate) const = 0;\n\n  virtual std::shared_ptr<KVStore> Clone(v8::Isolate* isolate) const;\n  virtual v8::Maybe<bool> AssignFromObject(v8::Local<v8::Context> context,\n                                           v8::Local<v8::Object> entries);\n  v8::Maybe<bool> AssignToObject(v8::Isolate* isolate,\n                                 v8::Local<v8::Context> context,\n                                 v8::Local<v8::Object> object);\n\n  static std::shared_ptr<KVStore> CreateMapKVStore();\n};\n\n// Convenience wrapper around v8::String::NewFromOneByte().\ninline v8::Local<v8::String> OneByteString(v8::Isolate* isolate,\n                                           const char* data,\n                                           int length = -1);\n\n// For the people that compile with -funsigned-char.\ninline v8::Local<v8::String> OneByteString(v8::Isolate* isolate,\n                                           const signed char* data,\n                                           int length = -1);\n\ninline v8::Local<v8::String> OneByteString(v8::Isolate* isolate,\n                                           const unsigned char* data,\n                                           int length = -1);\n\n// Used to be a macro, hence the uppercase name.\ntemplate <int N>\ninline v8::Local<v8::String> FIXED_ONE_BYTE_STRING(\n    v8::Isolate* isolate,\n    const char(&data)[N]) {\n  return OneByteString(isolate, data, N - 1);\n}\n\ntemplate <std::size_t N>\ninline v8::Local<v8::String> FIXED_ONE_BYTE_STRING(\n    v8::Isolate* isolate,\n    const std::array<char, N>& arr) {\n  return OneByteString(isolate, arr.data(), N - 1);\n}\n\n\n\n// Swaps bytes in place. nbytes is the number of bytes to swap and must be a\n// multiple of the word size (checked by function).\ninline void SwapBytes16(char* data, size_t nbytes);\ninline void SwapBytes32(char* data, size_t nbytes);\ninline void SwapBytes64(char* data, size_t nbytes);\n\n// tolower() is locale-sensitive.  Use ToLower() instead.\ninline char ToLower(char c);\ninline std::string ToLower(const std::string& in);\n\n// toupper() is locale-sensitive.  Use ToUpper() instead.\ninline char ToUpper(char c);\ninline std::string ToUpper(const std::string& in);\n\n// strcasecmp() is locale-sensitive.  Use StringEqualNoCase() instead.\ninline bool StringEqualNoCase(const char* a, const char* b);\n\n// strncasecmp() is locale-sensitive.  Use StringEqualNoCaseN() instead.\ninline bool StringEqualNoCaseN(const char* a, const char* b, size_t length);\n\ntemplate <typename T, size_t N>\nconstexpr size_t arraysize(const T (&)[N]) {\n  return N;\n}\n\ntemplate <typename T, size_t N>\nconstexpr size_t strsize(const T (&)[N]) {\n  return N - 1;\n}\n\n// Allocates an array of member type T. For up to kStackStorageSize items,\n// the stack is used, otherwise malloc().\ntemplate <typename T, size_t kStackStorageSize = 1024>\nclass MaybeStackBuffer {\n public:\n  const T* out() const {\n    return buf_;\n  }\n\n  T* out() {\n    return buf_;\n  }\n\n  // operator* for compatibility with `v8::String::(Utf8)Value`\n  T* operator*() {\n    return buf_;\n  }\n\n  const T* operator*() const {\n    return buf_;\n  }\n\n  T& operator[](size_t index) {\n    CHECK_LT(index, length());\n    return buf_[index];\n  }\n\n  const T& operator[](size_t index) const {\n    CHECK_LT(index, length());\n    return buf_[index];\n  }\n\n  size_t length() const {\n    return length_;\n  }\n\n  // Current maximum capacity of the buffer with which SetLength() can be used\n  // without first calling AllocateSufficientStorage().\n  size_t capacity() const {\n    return capacity_;\n  }\n\n  // Make sure enough space for `storage` entries is available.\n  // This method can be called multiple times throughout the lifetime of the\n  // buffer, but once this has been called Invalidate() cannot be used.\n  // Content of the buffer in the range [0, length()) is preserved.\n  void AllocateSufficientStorage(size_t storage);\n\n  void SetLength(size_t length) {\n    // capacity() returns how much memory is actually available.\n    CHECK_LE(length, capacity());\n    length_ = length;\n  }\n\n  void SetLengthAndZeroTerminate(size_t length) {\n    // capacity() returns how much memory is actually available.\n    CHECK_LE(length + 1, capacity());\n    SetLength(length);\n\n    // T() is 0 for integer types, nullptr for pointers, etc.\n    buf_[length] = T();\n  }\n\n  // Make dereferencing this object return nullptr.\n  // This method can be called multiple times throughout the lifetime of the\n  // buffer, but once this has been called AllocateSufficientStorage() cannot\n  // be used.\n  void Invalidate() {\n    CHECK(!IsAllocated());\n    capacity_ = 0;\n    length_ = 0;\n    buf_ = nullptr;\n  }\n\n  // If the buffer is stored in the heap rather than on the stack.\n  bool IsAllocated() const {\n    return !IsInvalidated() && buf_ != buf_st_;\n  }\n\n  // If Invalidate() has been called.\n  bool IsInvalidated() const {\n    return buf_ == nullptr;\n  }\n\n  // Release ownership of the malloc'd buffer.\n  // Note: This does not free the buffer.\n  void Release() {\n    CHECK(IsAllocated());\n    buf_ = buf_st_;\n    length_ = 0;\n    capacity_ = arraysize(buf_st_);\n  }\n\n  MaybeStackBuffer()\n      : length_(0), capacity_(arraysize(buf_st_)), buf_(buf_st_) {\n    // Default to a zero-length, null-terminated buffer.\n    buf_[0] = T();\n  }\n\n  explicit MaybeStackBuffer(size_t storage) : MaybeStackBuffer() {\n    AllocateSufficientStorage(storage);\n  }\n\n  ~MaybeStackBuffer() {\n    if (IsAllocated())\n      free(buf_);\n  }\n\n  inline std::basic_string<T> ToString() const { return {out(), length()}; }\n  inline std::basic_string_view<T> ToStringView() const {\n    return {out(), length()};\n  }\n\n private:\n  size_t length_;\n  // capacity of the malloc'ed buf_\n  size_t capacity_;\n  T* buf_;\n  T buf_st_[kStackStorageSize];\n};\n\n// Provides access to an ArrayBufferView's storage, either the original,\n// or for small data, a copy of it. This object's lifetime is bound to the\n// original ArrayBufferView's lifetime.\ntemplate <typename T, size_t kStackStorageSize = 64>\nclass ArrayBufferViewContents {\n public:\n  ArrayBufferViewContents() = default;\n\n  ArrayBufferViewContents(const ArrayBufferViewContents&) = delete;\n  void operator=(const ArrayBufferViewContents&) = delete;\n\n  explicit inline ArrayBufferViewContents(v8::Local<v8::Value> value);\n  explicit inline ArrayBufferViewContents(v8::Local<v8::Object> value);\n  explicit inline ArrayBufferViewContents(v8::Local<v8::ArrayBufferView> abv);\n  inline void Read(v8::Local<v8::ArrayBufferView> abv);\n  inline void ReadValue(v8::Local<v8::Value> buf);\n\n  inline bool WasDetached() const { return was_detached_; }\n  inline const T* data() const { return data_; }\n  inline size_t length() const { return length_; }\n\n private:\n  // Declaring operator new and delete as deleted is not spec compliant.\n  // Therefore, declare them private instead to disable dynamic alloc.\n  void* operator new(size_t size);\n  void* operator new[](size_t size);\n  void operator delete(void*, size_t);\n  void operator delete[](void*, size_t);\n\n  T stack_storage_[kStackStorageSize];\n  T* data_ = nullptr;\n  size_t length_ = 0;\n  bool was_detached_ = false;\n};\n\nclass Utf8Value : public MaybeStackBuffer<char> {\n public:\n  explicit Utf8Value(v8::Isolate* isolate, v8::Local<v8::Value> value);\n\n  inline bool operator==(const char* a) const { return strcmp(out(), a) == 0; }\n  inline bool operator!=(const char* a) const { return !(*this == a); }\n};\n\nclass TwoByteValue : public MaybeStackBuffer<uint16_t> {\n public:\n  explicit TwoByteValue(v8::Isolate* isolate, v8::Local<v8::Value> value);\n};\n\nclass BufferValue : public MaybeStackBuffer<char> {\n public:\n  explicit BufferValue(v8::Isolate* isolate, v8::Local<v8::Value> value);\n\n  inline std::string ToString() const { return std::string(out(), length()); }\n};\n\n#define SPREAD_BUFFER_ARG(val, name)                                           \\\n  CHECK((val)->IsArrayBufferView());                                           \\\n  v8::Local<v8::ArrayBufferView> name = (val).As<v8::ArrayBufferView>();       \\\n  const size_t name##_offset = name->ByteOffset();                             \\\n  const size_t name##_length = name->ByteLength();                             \\\n  char* const name##_data =                                                    \\\n      static_cast<char*>(name->Buffer()->Data()) + name##_offset;              \\\n  if (name##_length > 0) CHECK_NE(name##_data, nullptr);\n\n// Use this when a variable or parameter is unused in order to explicitly\n// silence a compiler warning about that.\ntemplate <typename T> inline void USE(T&&) {}\n\ntemplate <typename Fn>\nstruct OnScopeLeaveImpl {\n  Fn fn_;\n  bool active_;\n\n  explicit OnScopeLeaveImpl(Fn&& fn) : fn_(std::move(fn)), active_(true) {}\n  ~OnScopeLeaveImpl() { if (active_) fn_(); }\n\n  OnScopeLeaveImpl(const OnScopeLeaveImpl& other) = delete;\n  OnScopeLeaveImpl& operator=(const OnScopeLeaveImpl& other) = delete;\n  OnScopeLeaveImpl(OnScopeLeaveImpl&& other)\n    : fn_(std::move(other.fn_)), active_(other.active_) {\n    other.active_ = false;\n  }\n};\n\n// Run a function when exiting the current scope. Used like this:\n// auto on_scope_leave = OnScopeLeave([&] {\n//   // ... run some code ...\n// });\ntemplate <typename Fn>\ninline MUST_USE_RESULT OnScopeLeaveImpl<Fn> OnScopeLeave(Fn&& fn) {\n  return OnScopeLeaveImpl<Fn>{std::move(fn)};\n}\n\n// Simple RAII wrapper for contiguous data that uses malloc()/free().\ntemplate <typename T>\nstruct MallocedBuffer {\n  T* data;\n  size_t size;\n\n  T* release() {\n    T* ret = data;\n    data = nullptr;\n    return ret;\n  }\n\n  void Truncate(size_t new_size) {\n    CHECK_LE(new_size, size);\n    size = new_size;\n  }\n\n  void Realloc(size_t new_size) {\n    Truncate(new_size);\n    data = UncheckedRealloc(data, new_size);\n  }\n\n  bool is_empty() const { return data == nullptr; }\n\n  MallocedBuffer() : data(nullptr), size(0) {}\n  explicit MallocedBuffer(size_t size) : data(Malloc<T>(size)), size(size) {}\n  MallocedBuffer(T* data, size_t size) : data(data), size(size) {}\n  MallocedBuffer(MallocedBuffer&& other) : data(other.data), size(other.size) {\n    other.data = nullptr;\n  }\n  MallocedBuffer& operator=(MallocedBuffer&& other) {\n    this->~MallocedBuffer();\n    return *new(this) MallocedBuffer(std::move(other));\n  }\n  ~MallocedBuffer() {\n    free(data);\n  }\n  MallocedBuffer(const MallocedBuffer&) = delete;\n  MallocedBuffer& operator=(const MallocedBuffer&) = delete;\n};\n\ntemplate <typename T>\nclass NonCopyableMaybe {\n public:\n  NonCopyableMaybe() : empty_(true) {}\n  explicit NonCopyableMaybe(T&& value)\n      : empty_(false),\n        value_(std::move(value)) {}\n\n  bool IsEmpty() const {\n    return empty_;\n  }\n\n  const T* get() const {\n    return empty_ ? nullptr : &value_;\n  }\n\n  const T* operator->() const {\n    CHECK(!empty_);\n    return &value_;\n  }\n\n  T&& Release() {\n    CHECK_EQ(empty_, false);\n    empty_ = true;\n    return std::move(value_);\n  }\n\n private:\n  bool empty_;\n  T value_;\n};\n\n// Test whether some value can be called with ().\ntemplate <typename T, typename = void>\nstruct is_callable : std::is_function<T> { };\n\ntemplate <typename T>\nstruct is_callable<T, typename std::enable_if<\n    std::is_same<decltype(void(&T::operator())), void>::value\n    >::type> : std::true_type { };\n\ntemplate <typename T, void (*function)(T*)>\nstruct FunctionDeleter {\n  void operator()(T* pointer) const { function(pointer); }\n  typedef std::unique_ptr<T, FunctionDeleter> Pointer;\n};\n\ntemplate <typename T, void (*function)(T*)>\nusing DeleteFnPtr = typename FunctionDeleter<T, function>::Pointer;\n\nstd::vector<std::string_view> SplitString(const std::string_view in,\n                                          const std::string_view delim);\n\ninline v8::MaybeLocal<v8::Value> ToV8Value(v8::Local<v8::Context> context,\n                                           std::string_view str,\n                                           v8::Isolate* isolate = nullptr);\ntemplate <typename T, typename test_for_number =\n    typename std::enable_if<std::numeric_limits<T>::is_specialized, bool>::type>\ninline v8::MaybeLocal<v8::Value> ToV8Value(v8::Local<v8::Context> context,\n                                           const T& number,\n                                           v8::Isolate* isolate = nullptr);\ntemplate <typename T>\ninline v8::MaybeLocal<v8::Value> ToV8Value(v8::Local<v8::Context> context,\n                                           const std::vector<T>& vec,\n                                           v8::Isolate* isolate = nullptr);\ntemplate <typename T>\ninline v8::MaybeLocal<v8::Value> ToV8Value(v8::Local<v8::Context> context,\n                                           const std::set<T>& set,\n                                           v8::Isolate* isolate = nullptr);\ntemplate <typename T, typename U>\ninline v8::MaybeLocal<v8::Value> ToV8Value(v8::Local<v8::Context> context,\n                                           const std::unordered_map<T, U>& map,\n                                           v8::Isolate* isolate = nullptr);\n\n// These macros expects a `Isolate* isolate` and a `Local<Context> context`\n// to be in the scope.\n#define READONLY_PROPERTY(obj, name, value)                                    \\\n  do {                                                                         \\\n    obj->DefineOwnProperty(                                                    \\\n           context, FIXED_ONE_BYTE_STRING(isolate, name), value, v8::ReadOnly) \\\n        .Check();                                                              \\\n  } while (0)\n\n#define READONLY_DONT_ENUM_PROPERTY(obj, name, var)                            \\\n  do {                                                                         \\\n    obj->DefineOwnProperty(                                                    \\\n           context,                                                            \\\n           OneByteString(isolate, name),                                       \\\n           var,                                                                \\\n           static_cast<v8::PropertyAttribute>(v8::ReadOnly | v8::DontEnum))    \\\n        .Check();                                                              \\\n  } while (0)\n\n#define READONLY_FALSE_PROPERTY(obj, name)                                     \\\n  READONLY_PROPERTY(obj, name, v8::False(isolate))\n\n#define READONLY_TRUE_PROPERTY(obj, name)                                      \\\n  READONLY_PROPERTY(obj, name, v8::True(isolate))\n\n#define READONLY_STRING_PROPERTY(obj, name, str)                               \\\n  READONLY_PROPERTY(obj, name, ToV8Value(context, str).ToLocalChecked())\n\n// Variation on NODE_DEFINE_CONSTANT that sets a String value.\n#define NODE_DEFINE_STRING_CONSTANT(target, name, constant)                    \\\n  do {                                                                         \\\n    v8::Isolate* isolate = target->GetIsolate();                               \\\n    v8::Local<v8::String> constant_name =                                      \\\n        v8::String::NewFromUtf8(isolate, name).ToLocalChecked();               \\\n    v8::Local<v8::String> constant_value =                                     \\\n        v8::String::NewFromUtf8(isolate, constant).ToLocalChecked();           \\\n    v8::PropertyAttribute constant_attributes =                                \\\n        static_cast<v8::PropertyAttribute>(v8::ReadOnly | v8::DontDelete);     \\\n    target                                                                     \\\n        ->DefineOwnProperty(isolate->GetCurrentContext(),                      \\\n                            constant_name,                                     \\\n                            constant_value,                                    \\\n                            constant_attributes)                               \\\n        .Check();                                                              \\\n  } while (0)\n\nenum class Endianness { LITTLE, BIG };\n\ninline Endianness GetEndianness() {\n  // Constant-folded by the compiler.\n  const union {\n    uint8_t u8[2];\n    uint16_t u16;\n  } u = {{1, 0}};\n  return u.u16 == 1 ? Endianness::LITTLE : Endianness::BIG;\n}\n\ninline bool IsLittleEndian() {\n  return GetEndianness() == Endianness::LITTLE;\n}\n\ninline bool IsBigEndian() {\n  return GetEndianness() == Endianness::BIG;\n}\n\n// Round up a to the next highest multiple of b.\ntemplate <typename T>\nconstexpr T RoundUp(T a, T b) {\n  return a % b != 0 ? a + b - (a % b) : a;\n}\n\n// Align ptr to an `alignment`-bytes boundary.\ntemplate <typename T, typename U>\nconstexpr T* AlignUp(T* ptr, U alignment) {\n  return reinterpret_cast<T*>(\n      RoundUp(reinterpret_cast<uintptr_t>(ptr), alignment));\n}\n\nclass SlicedArguments : public MaybeStackBuffer<v8::Local<v8::Value>> {\n public:\n  inline explicit SlicedArguments(\n      const v8::FunctionCallbackInfo<v8::Value>& args, size_t start = 0);\n};\n\n// Convert a v8::PersistentBase, e.g. v8::Global, to a Local, with an extra\n// optimization for strong persistent handles.\nclass PersistentToLocal {\n public:\n  // If persistent.IsWeak() == false, then do not call persistent.Reset()\n  // while the returned Local<T> is still in scope, it will destroy the\n  // reference to the object.\n  template <class TypeName>\n  static inline v8::Local<TypeName> Default(\n      v8::Isolate* isolate,\n      const v8::PersistentBase<TypeName>& persistent) {\n    if (persistent.IsWeak()) {\n      return PersistentToLocal::Weak(isolate, persistent);\n    } else {\n      return PersistentToLocal::Strong(persistent);\n    }\n  }\n\n  // Unchecked conversion from a non-weak Persistent<T> to Local<T>,\n  // use with care!\n  //\n  // Do not call persistent.Reset() while the returned Local<T> is still in\n  // scope, it will destroy the reference to the object.\n  template <class TypeName>\n  static inline v8::Local<TypeName> Strong(\n      const v8::PersistentBase<TypeName>& persistent) {\n    DCHECK(!persistent.IsWeak());\n    return *reinterpret_cast<v8::Local<TypeName>*>(\n        const_cast<v8::PersistentBase<TypeName>*>(&persistent));\n  }\n\n  template <class TypeName>\n  static inline v8::Local<TypeName> Weak(\n      v8::Isolate* isolate,\n      const v8::PersistentBase<TypeName>& persistent) {\n    return v8::Local<TypeName>::New(isolate, persistent);\n  }\n};\n\n// Can be used as a key for std::unordered_map when lookup performance is more\n// important than size and the keys are statically used to avoid redundant hash\n// computations.\nclass FastStringKey {\n public:\n  constexpr explicit FastStringKey(std::string_view name);\n\n  struct Hash {\n    constexpr size_t operator()(const FastStringKey& key) const;\n  };\n  constexpr bool operator==(const FastStringKey& other) const;\n\n  constexpr std::string_view as_string_view() const;\n\n private:\n  static constexpr size_t HashImpl(std::string_view str);\n\n  const std::string_view name_;\n  const size_t cached_hash_;\n};\n\n// Like std::static_pointer_cast but for unique_ptr with the default deleter.\ntemplate <typename T, typename U>\nstd::unique_ptr<T> static_unique_pointer_cast(std::unique_ptr<U>&& ptr) {\n  return std::unique_ptr<T>(static_cast<T*>(ptr.release()));\n}\n\n#define MAYBE_FIELD_PTR(ptr, field) ptr == nullptr ? nullptr : &(ptr->field)\n\n// Returns a non-zero code if it fails to open or read the file,\n// aborts if it fails to close the file.\nint ReadFileSync(std::string* result, const char* path);\n\nv8::Local<v8::FunctionTemplate> NewFunctionTemplate(\n    v8::Isolate* isolate,\n    v8::FunctionCallback callback,\n    v8::Local<v8::Signature> signature = v8::Local<v8::Signature>(),\n    v8::ConstructorBehavior behavior = v8::ConstructorBehavior::kAllow,\n    v8::SideEffectType side_effect = v8::SideEffectType::kHasSideEffect,\n    const v8::CFunction* c_function = nullptr);\n\n// Convenience methods for NewFunctionTemplate().\nvoid SetMethod(v8::Local<v8::Context> context,\n               v8::Local<v8::Object> that,\n               const char* name,\n               v8::FunctionCallback callback);\n// Similar to SetProtoMethod but without receiver signature checks.\nvoid SetMethod(v8::Isolate* isolate,\n               v8::Local<v8::Template> that,\n               const char* name,\n               v8::FunctionCallback callback);\n\nvoid SetFastMethod(v8::Local<v8::Context> context,\n                   v8::Local<v8::Object> that,\n                   const char* name,\n                   v8::FunctionCallback slow_callback,\n                   const v8::CFunction* c_function);\nvoid SetFastMethodNoSideEffect(v8::Local<v8::Context> context,\n                               v8::Local<v8::Object> that,\n                               const char* name,\n                               v8::FunctionCallback slow_callback,\n                               const v8::CFunction* c_function);\n\nvoid SetProtoMethod(v8::Isolate* isolate,\n                    v8::Local<v8::FunctionTemplate> that,\n                    const char* name,\n                    v8::FunctionCallback callback);\n\nvoid SetInstanceMethod(v8::Isolate* isolate,\n                       v8::Local<v8::FunctionTemplate> that,\n                       const char* name,\n                       v8::FunctionCallback callback);\n\n// Safe variants denote the function has no side effects.\nvoid SetMethodNoSideEffect(v8::Local<v8::Context> context,\n                           v8::Local<v8::Object> that,\n                           const char* name,\n                           v8::FunctionCallback callback);\nvoid SetProtoMethodNoSideEffect(v8::Isolate* isolate,\n                                v8::Local<v8::FunctionTemplate> that,\n                                const char* name,\n                                v8::FunctionCallback callback);\n\nenum class SetConstructorFunctionFlag {\n  NONE,\n  SET_CLASS_NAME,\n};\n\nvoid SetConstructorFunction(v8::Local<v8::Context> context,\n                            v8::Local<v8::Object> that,\n                            const char* name,\n                            v8::Local<v8::FunctionTemplate> tmpl,\n                            SetConstructorFunctionFlag flag =\n                                SetConstructorFunctionFlag::SET_CLASS_NAME);\n\nvoid SetConstructorFunction(v8::Local<v8::Context> context,\n                            v8::Local<v8::Object> that,\n                            v8::Local<v8::String> name,\n                            v8::Local<v8::FunctionTemplate> tmpl,\n                            SetConstructorFunctionFlag flag =\n                                SetConstructorFunctionFlag::SET_CLASS_NAME);\n\n// Returns true if OS==Windows and filename ends in .bat or .cmd,\n// case insensitive.\ninline bool IsWindowsBatchFile(const char* filename);\n\n}  // namespace node\n\n#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n\n#endif  // SRC_UTIL_H_\n", "patch": "@@ -919,6 +919,10 @@ void SetConstructorFunction(v8::Local<v8::Context> context,\n                             SetConstructorFunctionFlag flag =\n                                 SetConstructorFunctionFlag::SET_CLASS_NAME);\n \n+// Returns true if OS==Windows and filename ends in .bat or .cmd,\n+// case insensitive.\n+inline bool IsWindowsBatchFile(const char* filename);\n+\n }  // namespace node\n \n #endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS"}
{"patches_id": 3, "files_id": 17, "language": "js", "raw_url": "https://github.com/nodejs/node/raw/662722240928668e4b16822be2f660fc6d957340/test%2Fparallel%2Ftest-child-process-spawn-windows-batch-file.js", "raw_code": "'use strict';\n\n// Node.js on Windows should not be able to spawn batch files directly,\n// only when the 'shell' option is set. An undocumented feature of the\n// Win32 CreateProcess API allows spawning .bat and .cmd files directly\n// but it does not sanitize arguments. We cannot do that automatically\n// because it's sometimes impossible to escape arguments unambiguously.\n//\n// Expectation: spawn() and spawnSync() raise EINVAL if and only if:\n//\n// 1. 'shell' option is unset\n// 2. Platform is Windows\n// 3. Filename ends in .bat or .cmd, case-insensitive\n//\n// exec() and execSync() are unchanged.\n\nconst common = require('../common');\nconst cp = require('child_process');\nconst assert = require('assert');\nconst { isWindows } = common;\n\nconst arg = '--security-revert=CVE-2024-27980';\nconst isRevert = process.execArgv.includes(arg);\n\nconst expectedCode = isWindows && !isRevert ? 'EINVAL' : 'ENOENT';\nconst expectedStatus = isWindows ? 1 : 127;\n\nconst suffixes =\n    'BAT bAT BaT baT BAt bAt Bat bat CMD cMD CmD cmD CMd cMd Cmd cmd'\n    .split(' ');\n\nif (process.argv[2] === undefined) {\n  const a = cp.spawnSync(process.execPath, [__filename, 'child']);\n  const b = cp.spawnSync(process.execPath, [arg, __filename, 'child']);\n  assert.strictEqual(a.status, 0);\n  assert.strictEqual(b.status, 0);\n  return;\n}\n\nfunction testExec(filename) {\n  return new Promise((resolve) => {\n    cp.exec(filename).once('exit', common.mustCall(function(status) {\n      assert.strictEqual(status, expectedStatus);\n      resolve();\n    }));\n  });\n}\n\nfunction testExecSync(filename) {\n  let e;\n  try {\n    cp.execSync(filename);\n  } catch (_e) {\n    e = _e;\n  }\n  if (!e) throw new Error(`Exception expected for ${filename}`);\n  assert.strictEqual(e.status, expectedStatus);\n}\n\nfunction testSpawn(filename, code) {\n  // Batch file case is a synchronous error, file-not-found is asynchronous.\n  if (code === 'EINVAL') {\n    let e;\n    try {\n      cp.spawn(filename);\n    } catch (_e) {\n      e = _e;\n    }\n    if (!e) throw new Error(`Exception expected for ${filename}`);\n    assert.strictEqual(e.code, code);\n  } else {\n    return new Promise((resolve) => {\n      cp.spawn(filename).once('error', common.mustCall(function(e) {\n        assert.strictEqual(e.code, code);\n        resolve();\n      }));\n    });\n  }\n}\n\nfunction testSpawnSync(filename, code) {\n  {\n    const r = cp.spawnSync(filename);\n    assert.strictEqual(r.error.code, code);\n  }\n  {\n    const r = cp.spawnSync(filename, { shell: true });\n    assert.strictEqual(r.status, expectedStatus);\n  }\n}\n\ntestExecSync('./nosuchdir/nosuchfile');\ntestSpawnSync('./nosuchdir/nosuchfile', 'ENOENT');\nfor (const suffix of suffixes) {\n  testExecSync(`./nosuchdir/nosuchfile.${suffix}`);\n  testSpawnSync(`./nosuchdir/nosuchfile.${suffix}`, expectedCode);\n}\n\ngo().catch((ex) => { throw ex; });\n\nasync function go() {\n  await testExec('./nosuchdir/nosuchfile');\n  await testSpawn('./nosuchdir/nosuchfile', 'ENOENT');\n  for (const suffix of suffixes) {\n    await testExec(`./nosuchdir/nosuchfile.${suffix}`);\n    await testSpawn(`./nosuchdir/nosuchfile.${suffix}`, expectedCode);\n  }\n}\n", "patch": "@@ -0,0 +1,108 @@\n+'use strict';\n+\n+// Node.js on Windows should not be able to spawn batch files directly,\n+// only when the 'shell' option is set. An undocumented feature of the\n+// Win32 CreateProcess API allows spawning .bat and .cmd files directly\n+// but it does not sanitize arguments. We cannot do that automatically\n+// because it's sometimes impossible to escape arguments unambiguously.\n+//\n+// Expectation: spawn() and spawnSync() raise EINVAL if and only if:\n+//\n+// 1. 'shell' option is unset\n+// 2. Platform is Windows\n+// 3. Filename ends in .bat or .cmd, case-insensitive\n+//\n+// exec() and execSync() are unchanged.\n+\n+const common = require('../common');\n+const cp = require('child_process');\n+const assert = require('assert');\n+const { isWindows } = common;\n+\n+const arg = '--security-revert=CVE-2024-27980';\n+const isRevert = process.execArgv.includes(arg);\n+\n+const expectedCode = isWindows && !isRevert ? 'EINVAL' : 'ENOENT';\n+const expectedStatus = isWindows ? 1 : 127;\n+\n+const suffixes =\n+    'BAT bAT BaT baT BAt bAt Bat bat CMD cMD CmD cmD CMd cMd Cmd cmd'\n+    .split(' ');\n+\n+if (process.argv[2] === undefined) {\n+  const a = cp.spawnSync(process.execPath, [__filename, 'child']);\n+  const b = cp.spawnSync(process.execPath, [arg, __filename, 'child']);\n+  assert.strictEqual(a.status, 0);\n+  assert.strictEqual(b.status, 0);\n+  return;\n+}\n+\n+function testExec(filename) {\n+  return new Promise((resolve) => {\n+    cp.exec(filename).once('exit', common.mustCall(function(status) {\n+      assert.strictEqual(status, expectedStatus);\n+      resolve();\n+    }));\n+  });\n+}\n+\n+function testExecSync(filename) {\n+  let e;\n+  try {\n+    cp.execSync(filename);\n+  } catch (_e) {\n+    e = _e;\n+  }\n+  if (!e) throw new Error(`Exception expected for ${filename}`);\n+  assert.strictEqual(e.status, expectedStatus);\n+}\n+\n+function testSpawn(filename, code) {\n+  // Batch file case is a synchronous error, file-not-found is asynchronous.\n+  if (code === 'EINVAL') {\n+    let e;\n+    try {\n+      cp.spawn(filename);\n+    } catch (_e) {\n+      e = _e;\n+    }\n+    if (!e) throw new Error(`Exception expected for ${filename}`);\n+    assert.strictEqual(e.code, code);\n+  } else {\n+    return new Promise((resolve) => {\n+      cp.spawn(filename).once('error', common.mustCall(function(e) {\n+        assert.strictEqual(e.code, code);\n+        resolve();\n+      }));\n+    });\n+  }\n+}\n+\n+function testSpawnSync(filename, code) {\n+  {\n+    const r = cp.spawnSync(filename);\n+    assert.strictEqual(r.error.code, code);\n+  }\n+  {\n+    const r = cp.spawnSync(filename, { shell: true });\n+    assert.strictEqual(r.status, expectedStatus);\n+  }\n+}\n+\n+testExecSync('./nosuchdir/nosuchfile');\n+testSpawnSync('./nosuchdir/nosuchfile', 'ENOENT');\n+for (const suffix of suffixes) {\n+  testExecSync(`./nosuchdir/nosuchfile.${suffix}`);\n+  testSpawnSync(`./nosuchdir/nosuchfile.${suffix}`, expectedCode);\n+}\n+\n+go().catch((ex) => { throw ex; });\n+\n+async function go() {\n+  await testExec('./nosuchdir/nosuchfile');\n+  await testSpawn('./nosuchdir/nosuchfile', 'ENOENT');\n+  for (const suffix of suffixes) {\n+    await testExec(`./nosuchdir/nosuchfile.${suffix}`);\n+    await testSpawn(`./nosuchdir/nosuchfile.${suffix}`, expectedCode);\n+  }\n+}"}
{"patches_id": 4, "files_id": 18, "language": "rb", "raw_url": "https://github.com/rails/rails/raw/a21d6edf35a60383dfa6c4da49e4b1aef5f00731/activesupport%2Flib%2Factive_support%2Fencrypted_file.rb", "raw_code": "# frozen_string_literal: true\n\nrequire \"pathname\"\nrequire \"tempfile\"\nrequire \"active_support/message_encryptor\"\n\nmodule ActiveSupport\n  class EncryptedFile\n    class MissingContentError < RuntimeError\n      def initialize(content_path)\n        super \"Missing encrypted content file in #{content_path}.\"\n      end\n    end\n\n    class MissingKeyError < RuntimeError\n      def initialize(key_path:, env_key:)\n        super \\\n          \"Missing encryption key to decrypt file with. \" +\n          \"Ask your team for your master key and write it to #{key_path} or put it in the ENV['#{env_key}'].\"\n      end\n    end\n\n    class InvalidKeyLengthError < RuntimeError\n      def initialize\n        super \"Encryption key must be exactly #{EncryptedFile.expected_key_length} characters.\"\n      end\n    end\n\n    CIPHER = \"aes-128-gcm\"\n\n    def self.generate_key\n      SecureRandom.hex(ActiveSupport::MessageEncryptor.key_len(CIPHER))\n    end\n\n    def self.expected_key_length # :nodoc:\n      @expected_key_length ||= generate_key.length\n    end\n\n\n    attr_reader :content_path, :key_path, :env_key, :raise_if_missing_key\n\n    def initialize(content_path:, key_path:, env_key:, raise_if_missing_key:)\n      @content_path = Pathname.new(content_path).yield_self { |path| path.symlink? ? path.realpath : path }\n      @key_path = Pathname.new(key_path)\n      @env_key, @raise_if_missing_key = env_key, raise_if_missing_key\n    end\n\n    # Returns the encryption key, first trying the environment variable\n    # specified by +env_key+, then trying the key file specified by +key_path+.\n    # If +raise_if_missing_key+ is true, raises MissingKeyError if the\n    # environment variable is not set and the key file does not exist.\n    def key\n      read_env_key || read_key_file || handle_missing_key\n    end\n\n    # Reads the file and returns the decrypted content.\n    #\n    # Raises:\n    # - MissingKeyError if the key is missing and +raise_if_missing_key+ is true.\n    # - MissingContentError if the encrypted file does not exist or otherwise\n    #   if the key is missing.\n    # - ActiveSupport::MessageEncryptor::InvalidMessage if the content cannot be\n    #   decrypted or verified.\n    def read\n      if !key.nil? && content_path.exist?\n        decrypt content_path.binread\n      else\n        raise MissingContentError, content_path\n      end\n    end\n\n    def write(contents)\n      IO.binwrite \"#{content_path}.tmp\", encrypt(contents)\n      FileUtils.mv \"#{content_path}.tmp\", content_path\n    end\n\n    def change(&block)\n      writing read, &block\n    end\n\n\n    private\n      def writing(contents)\n        Tempfile.create([\"\", \"-\" + content_path.basename.to_s.chomp(\".enc\")]) do |tmp_file|\n          tmp_path = Pathname.new(tmp_file)\n          tmp_path.binwrite contents\n\n          yield tmp_path\n\n          updated_contents = tmp_path.binread\n\n          write(updated_contents) if updated_contents != contents\n        end\n      end\n\n\n      def encrypt(contents)\n        check_key_length\n        encryptor.encrypt_and_sign contents\n      end\n\n      def decrypt(contents)\n        encryptor.decrypt_and_verify contents\n      end\n\n      def encryptor\n        @encryptor ||= ActiveSupport::MessageEncryptor.new([ key ].pack(\"H*\"), cipher: CIPHER)\n      end\n\n\n      def read_env_key\n        ENV[env_key].presence\n      end\n\n      def read_key_file\n        return @key_file_contents if defined?(@key_file_contents)\n        @key_file_contents = (key_path.binread.strip if key_path.exist?)\n      end\n\n      def handle_missing_key\n        raise MissingKeyError.new(key_path: key_path, env_key: env_key) if raise_if_missing_key\n      end\n\n      def check_key_length\n        raise InvalidKeyLengthError if key&.length != self.class.expected_key_length\n      end\n  end\nend\n", "patch": "@@ -1,7 +1,7 @@\n # frozen_string_literal: true\n \n require \"pathname\"\n-require \"tmpdir\"\n+require \"tempfile\"\n require \"active_support/message_encryptor\"\n \n module ActiveSupport\n@@ -81,17 +81,16 @@ def change(&block)\n \n     private\n       def writing(contents)\n-        tmp_file = \"#{Process.pid}.#{content_path.basename.to_s.chomp('.enc')}\"\n-        tmp_path = Pathname.new File.join(Dir.tmpdir, tmp_file)\n-        tmp_path.binwrite contents\n+        Tempfile.create([\"\", \"-\" + content_path.basename.to_s.chomp(\".enc\")]) do |tmp_file|\n+          tmp_path = Pathname.new(tmp_file)\n+          tmp_path.binwrite contents\n \n-        yield tmp_path\n+          yield tmp_path\n \n-        updated_contents = tmp_path.binread\n+          updated_contents = tmp_path.binread\n \n-        write(updated_contents) if updated_contents != contents\n-      ensure\n-        FileUtils.rm(tmp_path) if tmp_path&.exist?\n+          write(updated_contents) if updated_contents != contents\n+        end\n       end\n \n "}
{"patches_id": 4, "files_id": 19, "language": "rb", "raw_url": "https://github.com/rails/rails/raw/a21d6edf35a60383dfa6c4da49e4b1aef5f00731/activesupport%2Ftest%2Fencrypted_file_test.rb", "raw_code": "# frozen_string_literal: true\n\nrequire_relative \"abstract_unit\"\nrequire \"active_support/encrypted_file\"\n\nclass EncryptedFileTest < ActiveSupport::TestCase\n  setup do\n    @content = \"One little fox jumped over the hedge\"\n\n    @tmpdir = Dir.mktmpdir(\"encrypted-file-test-\")\n    @content_path = File.join(@tmpdir, \"content.txt.enc\")\n\n    @key_path = File.join(@tmpdir, \"content.txt.key\")\n    File.write(@key_path, ActiveSupport::EncryptedFile.generate_key)\n\n    @encrypted_file = encrypted_file(@content_path)\n  end\n\n  teardown do\n    FileUtils.rm_rf @content_path\n    FileUtils.rm_rf @key_path\n    FileUtils.rm_rf @tmpdir\n  end\n\n  test \"reading content by env key\" do\n    FileUtils.rm_rf @key_path\n\n    begin\n      ENV[\"CONTENT_KEY\"] = ActiveSupport::EncryptedFile.generate_key\n      @encrypted_file.write @content\n\n      assert_equal @content, @encrypted_file.read\n    ensure\n      ENV[\"CONTENT_KEY\"] = nil\n    end\n  end\n\n  test \"reading content by key file\" do\n    @encrypted_file.write(@content)\n    assert_equal @content, @encrypted_file.read\n  end\n\n  test \"change content by key file\" do\n    @encrypted_file.write(@content)\n    @encrypted_file.change do |file|\n      file.write(file.read + \" and went by the lake\")\n    end\n\n    assert_equal \"#{@content} and went by the lake\", @encrypted_file.read\n  end\n\n  test \"change sets restricted permissions\" do\n    @encrypted_file.write(@content)\n    @encrypted_file.change do |file|\n      assert_predicate file, :owned?\n      assert_equal \"100600\", file.stat.mode.to_s(8), \"Incorrect mode for #{file}\"\n    end\n  end\n\n  test \"raise MissingKeyError when key is missing\" do\n    assert_raise ActiveSupport::EncryptedFile::MissingKeyError do\n      encrypted_file(@content_path, key_path: \"\", env_key: \"\").read\n    end\n  end\n\n  test \"raise MissingKeyError when env key is blank\" do\n    FileUtils.rm_rf @key_path\n\n    begin\n      ENV[\"CONTENT_KEY\"] = \"\"\n      raised = assert_raise ActiveSupport::EncryptedFile::MissingKeyError do\n        @encrypted_file.write @content\n        @encrypted_file.read\n      end\n\n      assert_match(/Missing encryption key to decrypt file/, raised.message)\n    ensure\n      ENV[\"CONTENT_KEY\"] = nil\n    end\n  end\n\n  test \"raise InvalidKeyLengthError when key is too short\" do\n    File.write(@key_path, ActiveSupport::EncryptedFile.generate_key[0..-2])\n\n    assert_raise ActiveSupport::EncryptedFile::InvalidKeyLengthError do\n      @encrypted_file.write(@content)\n    end\n  end\n\n  test \"raise InvalidKeyLengthError when key is too long\" do\n    File.write(@key_path, ActiveSupport::EncryptedFile.generate_key + \"0\")\n\n    assert_raise ActiveSupport::EncryptedFile::InvalidKeyLengthError do\n      @encrypted_file.write(@content)\n    end\n  end\n\n  test \"respects existing content_path symlink\" do\n    @encrypted_file.write(@content)\n\n    symlink_path = File.join(@tmpdir, \"content_symlink.txt.enc\")\n    File.symlink(@encrypted_file.content_path, symlink_path)\n\n    encrypted_file(symlink_path).write(@content)\n\n    assert File.symlink?(symlink_path)\n    assert_equal @content, @encrypted_file.read\n  ensure\n    FileUtils.rm_rf symlink_path\n  end\n\n  test \"creates new content_path symlink if it's dead\" do\n    symlink_path = File.join(@tmpdir, \"content_symlink.txt.enc\")\n    File.symlink(@content_path, symlink_path)\n\n    encrypted_file(symlink_path).write(@content)\n\n    assert File.exist?(@content_path)\n    assert_equal @content, @encrypted_file.read\n  ensure\n    FileUtils.rm_rf symlink_path\n  end\n\n  private\n    def encrypted_file(content_path, key_path: @key_path, env_key: \"CONTENT_KEY\")\n      ActiveSupport::EncryptedFile.new(content_path: @content_path, key_path: key_path,\n        env_key: env_key, raise_if_missing_key: true)\n    end\nend\n", "patch": "@@ -49,6 +49,14 @@ class EncryptedFileTest < ActiveSupport::TestCase\n     assert_equal \"#{@content} and went by the lake\", @encrypted_file.read\n   end\n \n+  test \"change sets restricted permissions\" do\n+    @encrypted_file.write(@content)\n+    @encrypted_file.change do |file|\n+      assert_predicate file, :owned?\n+      assert_equal \"100600\", file.stat.mode.to_s(8), \"Incorrect mode for #{file}\"\n+    end\n+  end\n+\n   test \"raise MissingKeyError when key is missing\" do\n     assert_raise ActiveSupport::EncryptedFile::MissingKeyError do\n       encrypted_file(@content_path, key_path: \"\", env_key: \"\").read"}
{"patches_id": 4, "files_id": 20, "language": "rb", "raw_url": "https://github.com/rails/rails/raw/a21d6edf35a60383dfa6c4da49e4b1aef5f00731/railties%2Flib%2Frails%2Fsecrets.rb", "raw_code": "# frozen_string_literal: true\n\nrequire \"yaml\"\nrequire \"tempfile\"\nrequire \"active_support/message_encryptor\"\n\nmodule Rails\n  # Greatly inspired by Ara T. Howard's magnificent sekrets gem. \n  class Secrets # :nodoc:\n    class MissingKeyError < RuntimeError\n      def initialize\n        super(<<-end_of_message.squish)\n          Missing encryption key to decrypt secrets with.\n          Ask your team for your master key and put it in ENV[\"RAILS_MASTER_KEY\"]\n        end_of_message\n      end\n    end\n\n    @cipher = \"aes-128-gcm\"\n    @root = File # Wonky, but ensures `join` uses the current directory.\n\n    class << self\n      attr_writer :root\n\n      def parse(paths, env:)\n        paths.each_with_object(Hash.new) do |path, all_secrets|\n          require \"erb\"\n\n          source = ERB.new(preprocess(path)).result\n          secrets = YAML.respond_to?(:unsafe_load) ? YAML.unsafe_load(source) : YAML.load(source)\n          secrets ||= {}\n\n          all_secrets.merge!(secrets[\"shared\"].deep_symbolize_keys) if secrets[\"shared\"]\n          all_secrets.merge!(secrets[env].deep_symbolize_keys) if secrets[env]\n        end\n      end\n\n      def key\n        ENV[\"RAILS_MASTER_KEY\"] || read_key_file || handle_missing_key\n      end\n\n      def encrypt(data)\n        encryptor.encrypt_and_sign(data)\n      end\n\n      def decrypt(data)\n        encryptor.decrypt_and_verify(data)\n      end\n\n      def read\n        decrypt(IO.binread(path))\n      end\n\n      def write(contents)\n        IO.binwrite(\"#{path}.tmp\", encrypt(contents))\n        FileUtils.mv(\"#{path}.tmp\", path)\n      end\n\n      def read_for_editing(&block)\n        writing(read, &block)\n      end\n\n      private\n        def handle_missing_key\n          raise MissingKeyError\n        end\n\n        def read_key_file\n          if File.exist?(key_path)\n            IO.binread(key_path).strip\n          end\n        end\n\n        def key_path\n          @root.join(\"config\", \"secrets.yml.key\")\n        end\n\n        def path\n          @root.join(\"config\", \"secrets.yml.enc\").to_s\n        end\n\n        def preprocess(path)\n          if path.end_with?(\".enc\")\n            decrypt(IO.binread(path))\n          else\n            IO.read(path)\n          end\n        end\n\n        def writing(contents)\n          file_name = \"#{File.basename(path)}.#{Process.pid}\"\n\n          Tempfile.create([\"\", \"-\" + file_name]) do |tmp_file|\n            tmp_path = Pathname.new(tmp_file)\n            tmp_path.binwrite contents\n\n            yield tmp_path\n\n            updated_contents = tmp_path.binread\n\n            write(updated_contents) if updated_contents != contents\n          end\n        end\n\n        def encryptor\n          @encryptor ||= ActiveSupport::MessageEncryptor.new([ key ].pack(\"H*\"), cipher: @cipher)\n        end\n    end\n  end\nend\n", "patch": "@@ -1,6 +1,7 @@\n # frozen_string_literal: true\n \n require \"yaml\"\n+require \"tempfile\"\n require \"active_support/message_encryptor\"\n \n module Rails\n@@ -87,17 +88,18 @@ def preprocess(path)\n         end\n \n         def writing(contents)\n-          tmp_file = \"#{File.basename(path)}.#{Process.pid}\"\n-          tmp_path = File.join(Dir.tmpdir, tmp_file)\n-          IO.binwrite(tmp_path, contents)\n+          file_name = \"#{File.basename(path)}.#{Process.pid}\"\n \n-          yield tmp_path\n+          Tempfile.create([\"\", \"-\" + file_name]) do |tmp_file|\n+            tmp_path = Pathname.new(tmp_file)\n+            tmp_path.binwrite contents\n \n-          updated_contents = IO.binread(tmp_path)\n+            yield tmp_path\n \n-          write(updated_contents) if updated_contents != contents\n-        ensure\n-          FileUtils.rm(tmp_path) if File.exist?(tmp_path)\n+            updated_contents = tmp_path.binread\n+\n+            write(updated_contents) if updated_contents != contents\n+          end\n         end\n \n         def encryptor"}
{"patches_id": 5, "files_id": 21, "language": "coffee", "raw_url": "https://github.com/rails/rails/raw/5037a13614d71727af8a175063bcf6ba1a74bdbd/actionview%2Fapp%2Fassets%2Fjavascripts%2Frails-ujs%2Ffeatures%2Fdisable.coffee", "raw_code": "#= require_tree ../utils\n\n{ matches, getData, setData, stopEverything, formElements, isContentEditable } = Rails\n\nRails.handleDisabledElement = (e) ->\n  element = this\n  stopEverything(e) if element.disabled\n\n# Unified function to enable an element (link, button and form)\nRails.enableElement = (e) ->\n  if e instanceof Event\n    return if isXhrRedirect(e)\n    element = e.target\n  else\n    element = e\n\n  if isContentEditable(element)\n    return\n\n  if matches(element, Rails.linkDisableSelector)\n    enableLinkElement(element)\n  else if matches(element, Rails.buttonDisableSelector) or matches(element, Rails.formEnableSelector)\n    enableFormElement(element)\n  else if matches(element, Rails.formSubmitSelector)\n    enableFormElements(element)\n\n# Unified function to disable an element (link, button and form)\nRails.disableElement = (e) ->\n  element = if e instanceof Event then e.target else e\n\n  if isContentEditable(element)\n    return\n\n  if matches(element, Rails.linkDisableSelector)\n    disableLinkElement(element)\n  else if matches(element, Rails.buttonDisableSelector) or matches(element, Rails.formDisableSelector)\n    disableFormElement(element)\n  else if matches(element, Rails.formSubmitSelector)\n    disableFormElements(element)\n\n#  Replace element's html with the 'data-disable-with' after storing original html\n#  and prevent clicking on it\ndisableLinkElement = (element) ->\n  return if getData(element, 'ujs:disabled')\n  replacement = element.getAttribute('data-disable-with')\n  if replacement?\n    setData(element, 'ujs:enable-with', element.innerHTML) # store enabled state\n    element.innerHTML = replacement\n  element.addEventListener('click', stopEverything) # prevent further clicking\n  setData(element, 'ujs:disabled', true)\n\n# Restore element to its original state which was disabled by 'disableLinkElement' above\nenableLinkElement = (element) ->\n  originalText = getData(element, 'ujs:enable-with')\n  if originalText?\n    element.innerHTML = originalText # set to old enabled state\n    setData(element, 'ujs:enable-with', null) # clean up cache\n  element.removeEventListener('click', stopEverything) # enable element\n  setData(element, 'ujs:disabled', null)\n\n# Disables form elements:\n#  - Caches element value in 'ujs:enable-with' data store\n#  - Replaces element text with value of 'data-disable-with' attribute\n#  - Sets disabled property to true\ndisableFormElements = (form) ->\n  formElements(form, Rails.formDisableSelector).forEach(disableFormElement)\n\ndisableFormElement = (element) ->\n  return if getData(element, 'ujs:disabled')\n  replacement = element.getAttribute('data-disable-with')\n  if replacement?\n    if matches(element, 'button')\n      setData(element, 'ujs:enable-with', element.innerHTML)\n      element.innerHTML = replacement\n    else\n      setData(element, 'ujs:enable-with', element.value)\n      element.value = replacement\n  element.disabled = true\n  setData(element, 'ujs:disabled', true)\n\n# Re-enables disabled form elements:\n#  - Replaces element text with cached value from 'ujs:enable-with' data store (created in `disableFormElements`)\n#  - Sets disabled property to false\nenableFormElements = (form) ->\n  formElements(form, Rails.formEnableSelector).forEach(enableFormElement)\n\nenableFormElement = (element) ->\n  originalText = getData(element, 'ujs:enable-with')\n  if originalText?\n    if matches(element, 'button')\n      element.innerHTML = originalText\n    else\n      element.value = originalText\n    setData(element, 'ujs:enable-with', null) # clean up cache\n  element.disabled = false\n  setData(element, 'ujs:disabled', null)\n\nisXhrRedirect = (event) ->\n  xhr = event.detail?[0]\n  xhr?.getResponseHeader(\"X-Xhr-Redirect\")?\n", "patch": "@@ -1,6 +1,6 @@\n #= require_tree ../utils\n \n-{ matches, getData, setData, stopEverything, formElements } = Rails\n+{ matches, getData, setData, stopEverything, formElements, isContentEditable } = Rails\n \n Rails.handleDisabledElement = (e) ->\n   element = this\n@@ -14,6 +14,9 @@ Rails.enableElement = (e) ->\n   else\n     element = e\n \n+  if isContentEditable(element)\n+    return\n+\n   if matches(element, Rails.linkDisableSelector)\n     enableLinkElement(element)\n   else if matches(element, Rails.buttonDisableSelector) or matches(element, Rails.formEnableSelector)\n@@ -24,6 +27,10 @@ Rails.enableElement = (e) ->\n # Unified function to disable an element (link, button and form)\n Rails.disableElement = (e) ->\n   element = if e instanceof Event then e.target else e\n+\n+  if isContentEditable(element)\n+    return\n+\n   if matches(element, Rails.linkDisableSelector)\n     disableLinkElement(element)\n   else if matches(element, Rails.buttonDisableSelector) or matches(element, Rails.formDisableSelector)"}
{"patches_id": 5, "files_id": 22, "language": "coffee", "raw_url": "https://github.com/rails/rails/raw/5037a13614d71727af8a175063bcf6ba1a74bdbd/actionview%2Fapp%2Fassets%2Fjavascripts%2Frails-ujs%2Ffeatures%2Fmethod.coffee", "raw_code": "#= require_tree ../utils\n\n{ stopEverything } = Rails\n{ isContentEditable } = Rails\n\n# Handles \"data-method\" on links such as:\n# <a href=\"/users/5\" data-method=\"delete\" rel=\"nofollow\" data-confirm=\"Are you sure?\">Delete</a>\nRails.handleMethod = (e) ->\n  link = this\n  method = link.getAttribute('data-method')\n  return unless method\n\n  if isContentEditable(this)\n    return\n\n  href = Rails.href(link)\n  csrfToken = Rails.csrfToken()\n  csrfParam = Rails.csrfParam()\n  form = document.createElement('form')\n  formContent = \"<input name='_method' value='#{method}' type='hidden' />\"\n\n  if csrfParam? and csrfToken? and not Rails.isCrossDomain(href)\n    formContent += \"<input name='#{csrfParam}' value='#{csrfToken}' type='hidden' />\"\n\n  # Must trigger submit by click on a button, else \"submit\" event handler won't work!\n  # https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement/submit\n  formContent += '<input type=\"submit\" />'\n\n  form.method = 'post'\n  form.action = href\n  form.target = link.target\n  form.innerHTML = formContent\n  form.style.display = 'none'\n\n  document.body.appendChild(form)\n  form.querySelector('[type=\"submit\"]').click()\n\n  stopEverything(e)\n", "patch": "@@ -1,6 +1,7 @@\n #= require_tree ../utils\n \n { stopEverything } = Rails\n+{ isContentEditable } = Rails\n \n # Handles \"data-method\" on links such as:\n # <a href=\"/users/5\" data-method=\"delete\" rel=\"nofollow\" data-confirm=\"Are you sure?\">Delete</a>\n@@ -9,6 +10,9 @@ Rails.handleMethod = (e) ->\n   method = link.getAttribute('data-method')\n   return unless method\n \n+  if isContentEditable(this)\n+    return\n+\n   href = Rails.href(link)\n   csrfToken = Rails.csrfToken()\n   csrfParam = Rails.csrfParam()"}
{"patches_id": 5, "files_id": 23, "language": "coffee", "raw_url": "https://github.com/rails/rails/raw/5037a13614d71727af8a175063bcf6ba1a74bdbd/actionview%2Fapp%2Fassets%2Fjavascripts%2Frails-ujs%2Ffeatures%2Fremote.coffee", "raw_code": "#= require_tree ../utils\n\n{\n  matches, getData, setData\n  fire, stopEverything\n  ajax, isCrossDomain\n  serializeElement,\n  isContentEditable\n} = Rails\n\n# Checks \"data-remote\" if true to handle the request through a XHR request.\nisRemote = (element) ->\n  value = element.getAttribute('data-remote')\n  value? and value isnt 'false'\n\n# Submits \"remote\" forms and links with ajax\nRails.handleRemote = (e) ->\n  element = this\n\n  return true unless isRemote(element)\n  unless fire(element, 'ajax:before')\n    fire(element, 'ajax:stopped')\n    return false\n\n  if isContentEditable(element)\n    fire(element, 'ajax:stopped')\n    return false\n\n  withCredentials = element.getAttribute('data-with-credentials')\n  dataType = element.getAttribute('data-type') or 'script'\n\n  if matches(element, Rails.formSubmitSelector)\n    # memoized value from clicked submit button\n    button = getData(element, 'ujs:submit-button')\n    method = getData(element, 'ujs:submit-button-formmethod') or element.method\n    url = getData(element, 'ujs:submit-button-formaction') or element.getAttribute('action') or location.href\n\n    # strip query string if it's a GET request\n    url = url.replace(/\\?.*$/, '') if method.toUpperCase() is 'GET'\n\n    if element.enctype is 'multipart/form-data'\n      data = new FormData(element)\n      data.append(button.name, button.value) if button?\n    else\n      data = serializeElement(element, button)\n\n    setData(element, 'ujs:submit-button', null)\n    setData(element, 'ujs:submit-button-formmethod', null)\n    setData(element, 'ujs:submit-button-formaction', null)\n  else if matches(element, Rails.buttonClickSelector) or matches(element, Rails.inputChangeSelector)\n    method = element.getAttribute('data-method')\n    url = element.getAttribute('data-url')\n    data = serializeElement(element, element.getAttribute('data-params'))\n  else\n    method = element.getAttribute('data-method')\n    url = Rails.href(element)\n    data = element.getAttribute('data-params')\n\n  ajax(\n    type: method or 'GET'\n    url: url\n    data: data\n    dataType: dataType\n    # stopping the \"ajax:beforeSend\" event will cancel the ajax request\n    beforeSend: (xhr, options) ->\n      if fire(element, 'ajax:beforeSend', [xhr, options])\n        fire(element, 'ajax:send', [xhr])\n      else\n        fire(element, 'ajax:stopped')\n        return false\n    success: (args...) -> fire(element, 'ajax:success', args)\n    error: (args...) -> fire(element, 'ajax:error', args)\n    complete: (args...) -> fire(element, 'ajax:complete', args)\n    crossDomain: isCrossDomain(url)\n    withCredentials: withCredentials? and withCredentials isnt 'false'\n  )\n  stopEverything(e)\n\nRails.formSubmitButtonClick = (e) ->\n  button = this\n  form = button.form\n  return unless form\n  # Register the pressed submit button\n  setData(form, 'ujs:submit-button', name: button.name, value: button.value) if button.name\n  # Save attributes from button\n  setData(form, 'ujs:formnovalidate-button', button.formNoValidate)\n  setData(form, 'ujs:submit-button-formaction', button.getAttribute('formaction'))\n  setData(form, 'ujs:submit-button-formmethod', button.getAttribute('formmethod'))\n\nRails.preventInsignificantClick = (e) ->\n  link = this\n  method = (link.getAttribute('data-method') or 'GET').toUpperCase()\n  data = link.getAttribute('data-params')\n  metaClick = e.metaKey or e.ctrlKey\n  insignificantMetaClick = metaClick and method is 'GET' and not data\n  nonPrimaryMouseClick = e.button? and e.button isnt 0\n  e.stopImmediatePropagation() if nonPrimaryMouseClick or insignificantMetaClick\n\n", "patch": "@@ -4,7 +4,8 @@\n   matches, getData, setData\n   fire, stopEverything\n   ajax, isCrossDomain\n-  serializeElement\n+  serializeElement,\n+  isContentEditable\n } = Rails\n \n # Checks \"data-remote\" if true to handle the request through a XHR request.\n@@ -21,6 +22,10 @@ Rails.handleRemote = (e) ->\n     fire(element, 'ajax:stopped')\n     return false\n \n+  if isContentEditable(element)\n+    fire(element, 'ajax:stopped')\n+    return false\n+\n   withCredentials = element.getAttribute('data-with-credentials')\n   dataType = element.getAttribute('data-type') or 'script'\n "}
{"patches_id": 5, "files_id": 24, "language": "coffee", "raw_url": "https://github.com/rails/rails/raw/5037a13614d71727af8a175063bcf6ba1a74bdbd/actionview%2Fapp%2Fassets%2Fjavascripts%2Frails-ujs%2Futils%2Fdom.coffee", "raw_code": "m = Element.prototype.matches or\n    Element.prototype.matchesSelector or\n    Element.prototype.mozMatchesSelector or\n    Element.prototype.msMatchesSelector or\n    Element.prototype.oMatchesSelector or\n    Element.prototype.webkitMatchesSelector\n\n# Checks if the given native dom element matches the selector\n# element::\n#   native DOM element\n# selector::\n#   css selector string or\n#   a javascript object with `selector` and `exclude` properties\n#   Examples: \"form\", { selector: \"form\", exclude: \"form[data-remote='true']\"}\nRails.matches = (element, selector) ->\n  if selector.exclude?\n    m.call(element, selector.selector) and not m.call(element, selector.exclude)\n  else\n    m.call(element, selector)\n\n# get and set data on a given element using \"expando properties\"\n# See: https://developer.mozilla.org/en-US/docs/Glossary/Expando\nexpando = '_ujsData'\n\nRails.getData = (element, key) ->\n  element[expando]?[key]\n\nRails.setData = (element, key, value) ->\n  element[expando] ?= {}\n  element[expando][key] = value\n\nRails.isContentEditable = (element) ->\n  isEditable = false\n  loop\n    if(element.isContentEditable)\n      isEditable = true\n      break\n\n    element = element.parentElement\n    break unless(element)\n\n  return isEditable\n\n# a wrapper for document.querySelectorAll\n# returns an Array\nRails.$ = (selector) ->\n  Array.prototype.slice.call(document.querySelectorAll(selector))\n", "patch": "@@ -29,6 +29,18 @@ Rails.setData = (element, key, value) ->\n   element[expando] ?= {}\n   element[expando][key] = value\n \n+Rails.isContentEditable = (element) ->\n+  isEditable = false\n+  loop\n+    if(element.isContentEditable)\n+      isEditable = true\n+      break\n+\n+    element = element.parentElement\n+    break unless(element)\n+\n+  return isEditable\n+\n # a wrapper for document.querySelectorAll\n # returns an Array\n Rails.$ = (selector) ->"}
{"patches_id": 5, "files_id": 25, "language": "js", "raw_url": "https://github.com/rails/rails/raw/5037a13614d71727af8a175063bcf6ba1a74bdbd/actionview%2Ftest%2Fujs%2Fpublic%2Ftest%2Fdata-disable-with.js", "raw_code": "module('data-disable-with', {\n  setup: function() {\n    $('#qunit-fixture').append($('<form />', {\n      action: '/echo',\n      'data-remote': 'true',\n      method: 'post'\n    }))\n      .find('form')\n      .append($('<input type=\"text\" data-disable-with=\"processing ...\" name=\"user_name\" value=\"john\" />'))\n\n    $('#qunit-fixture').append($('<form />', {\n      action: '/echo',\n      method: 'post',\n      id: 'not_remote'\n    }))\n      .find('form:last')\n      // WEEIRDD: the form won't submit to an iframe if the button is name=\"submit\" (??!)\n      .append($('<input type=\"submit\" data-disable-with=\"submitting ...\" name=\"submit2\" value=\"Submit\" />'))\n\n    $('#qunit-fixture').append($('<a />', {\n      text: 'Click me',\n      href: '/echo',\n      'data-disable-with': 'clicking...'\n    }))\n\n    $('#qunit-fixture').append($('<input />', {\n      type: 'submit',\n      form: 'not_remote',\n      'data-disable-with': 'form attr submitting',\n      name: 'submit3',\n      value: 'Form Attr Submit'\n    }))\n\n    $('#qunit-fixture').append($('<button />', {\n      text: 'Click me',\n      'data-remote': true,\n      'data-url': '/echo',\n      'data-disable-with': 'clicking...'\n    }))\n\n    $('#qunit-fixture').append($('<div />', {\n      id: 'edit-div', 'contenteditable': 'true'\n    }))\n  },\n  teardown: function() {\n    $(document).unbind('iframe:loaded')\n  }\n})\n\nasyncTest('form input field with \"data-disable-with\" attribute', 7, function() {\n  var form = $('form[data-remote]'), input = form.find('input[type=text]')\n\n  App.checkEnabledState(input, 'john')\n\n  form.bindNative('ajax:success', function(e, data) {\n    setTimeout(function() {\n      App.checkEnabledState(input, 'john')\n      equal(data.params.user_name, 'john')\n      start()\n    }, 13)\n  })\n  form.triggerNative('submit')\n\n  App.checkDisabledState(input, 'processing ...')\n})\n\nasyncTest('blank form input field with \"data-disable-with\" attribute', 7, function() {\n  var form = $('form[data-remote]'), input = form.find('input[type=text]')\n\n  input.val('')\n  App.checkEnabledState(input, '')\n\n  form.bindNative('ajax:success', function(e, data) {\n    setTimeout(function() {\n      App.checkEnabledState(input, '')\n      equal(data.params.user_name, '')\n      start()\n    }, 13)\n  })\n  form.triggerNative('submit')\n\n  App.checkDisabledState(input, 'processing ...')\n})\n\nasyncTest('form button with \"data-disable-with\" attribute', 6, function() {\n  var form = $('form[data-remote]'), button = $('<button data-disable-with=\"submitting ...\" name=\"submit2\">Submit</button>')\n  form.append(button)\n\n  App.checkEnabledState(button, 'Submit')\n\n  form.bindNative('ajax:success', function(e, data) {\n    setTimeout(function() {\n      App.checkEnabledState(button, 'Submit')\n      start()\n    }, 13)\n  })\n  form.triggerNative('submit')\n\n  App.checkDisabledState(button, 'submitting ...')\n})\n\nasyncTest('a[data-remote][data-disable-with] within a form disables and re-enables', 6, function() {\n  var form = $('form:not([data-remote])'),\n      link = $('<a data-remote=\"true\" data-disable-with=\"clicking...\">Click me</a>')\n  form.append(link)\n\n  App.checkEnabledState(link, 'Click me')\n\n  link\n    .bindNative('ajax:beforeSend', function() {\n      App.checkDisabledState(link, 'clicking...')\n    })\n    .bindNative('ajax:complete', function() {\n      setTimeout( function() {\n        App.checkEnabledState(link, 'Click me')\n        link.remove()\n        start()\n      }, 15)\n    })\n    .triggerNative('click')\n})\n\nasyncTest('form input[type=submit][data-disable-with] disables', 6, function() {\n  var form = $('form:not([data-remote])'), input = form.find('input[type=submit]')\n\n  App.checkEnabledState(input, 'Submit')\n\n  $(document).bind('iframe:loaded', function(e, data) {\n    setTimeout(function() {\n      App.checkDisabledState(input, 'submitting ...')\n      start()\n    }, 30)\n  })\n  form.triggerNative('submit')\n\n  setTimeout(function() {\n    App.checkDisabledState(input, 'submitting ...')\n  }, 30)\n})\n\ntest('form input[type=submit][data-disable-with] re-enables when `pageshow` event is triggered', function() {\n  var form = $('form:not([data-remote])'), input = form.find('input[type=submit]')\n\n  App.checkEnabledState(input, 'Submit')\n\n  // Emulate the disabled state without submitting the form at all, what is the\n  // state after going back on firefox after submitting a form.\n  //\n  // See https://github.com/rails/jquery-ujs/issues/357\n  $.rails.disableElement(form[0])\n\n  App.checkDisabledState(input, 'submitting ...')\n\n  $(window).triggerNative('pageshow')\n\n  App.checkEnabledState(input, 'Submit')\n})\n\nasyncTest('form[data-remote] input[type=submit][data-disable-with] is replaced in ajax callback', 2, function() {\n  var form = $('#qunit-fixture form:not([data-remote])').attr('data-remote', 'true'),\n      origFormContents = form.html()\n\n  form.bindNative('ajax:success', function() {\n    form.html(origFormContents)\n\n    setTimeout(function() {\n      var input = form.find('input[type=submit]')\n      App.checkEnabledState(input, 'Submit')\n      start()\n    }, 30)\n  }).triggerNative('submit')\n})\n\nasyncTest('form[data-remote] input[data-disable-with] is replaced with disabled field in ajax callback', 2, function() {\n  var form = $('#qunit-fixture form:not([data-remote])').attr('data-remote', 'true'),\n      input = form.find('input[type=submit]'),\n      newDisabledInput = input.clone().attr('disabled', 'disabled')\n\n  form.bindNative('ajax:success', function() {\n    input.replaceWith(newDisabledInput)\n\n    setTimeout(function() {\n      App.checkEnabledState(newDisabledInput, 'Submit')\n      start()\n    }, 30)\n  }).triggerNative('submit')\n})\n\nasyncTest('form input[type=submit][data-disable-with] using \"form\" attribute disables', 6, function() {\n  var form = $('#not_remote'), input = $('input[form=not_remote]')\n  App.checkEnabledState(input, 'Form Attr Submit')\n\n  $(document).bind('iframe:loaded', function(e, data) {\n    setTimeout(function() {\n      App.checkDisabledState(input, 'form attr submitting')\n      start()\n    }, 30)\n  })\n  form.triggerNative('submit')\n\n  setTimeout(function() {\n    App.checkDisabledState(input, 'form attr submitting')\n  }, 30)\n\n})\n\nasyncTest('form[data-remote] textarea[data-disable-with] attribute', 3, function() {\n  var form = $('form[data-remote]'),\n      textarea = $('<textarea data-disable-with=\"processing ...\" name=\"user_bio\">born, lived, died.</textarea>').appendTo(form)\n\n  form.bindNative('ajax:success', function(e, data) {\n    setTimeout(function() {\n      equal(data.params.user_bio, 'born, lived, died.')\n      start()\n    }, 13)\n  })\n  form.triggerNative('submit')\n\n  App.checkDisabledState(textarea, 'processing ...')\n})\n\nasyncTest('a[data-disable-with] disables', 4, function() {\n  var link = $('a[data-disable-with]')\n\n  App.checkEnabledState(link, 'Click me')\n\n  link.triggerNative('click')\n  App.checkDisabledState(link, 'clicking...')\n  start()\n})\n\ntest('a[data-disable-with] re-enables when `pageshow` event is triggered', function() {\n  var link = $('a[data-disable-with]')\n\n  App.checkEnabledState(link, 'Click me')\n\n  link.triggerNative('click')\n  App.checkDisabledState(link, 'clicking...')\n\n  $(window).triggerNative('pageshow')\n  App.checkEnabledState(link, 'Click me')\n})\n\nasyncTest('a[data-remote][data-disable-with] disables and re-enables', 6, function() {\n  var link = $('a[data-disable-with]').attr('data-remote', true)\n\n  App.checkEnabledState(link, 'Click me')\n\n  link\n    .bindNative('ajax:beforeSend', function() {\n      App.checkDisabledState(link, 'clicking...')\n    })\n    .bindNative('ajax:complete', function() {\n      setTimeout( function() {\n        App.checkEnabledState(link, 'Click me')\n        start()\n      }, 15)\n    })\n    .triggerNative('click')\n})\n\nasyncTest('a[data-remote][data-disable-with] re-enables when `ajax:before` event is cancelled', 6, function() {\n  var link = $('a[data-disable-with]').attr('data-remote', true)\n\n  App.checkEnabledState(link, 'Click me')\n\n  link\n    .bindNative('ajax:before', function(e) {\n      App.checkDisabledState(link, 'clicking...')\n      e.preventDefault()\n    })\n    .triggerNative('click')\n\n  setTimeout(function() {\n    App.checkEnabledState(link, 'Click me')\n    start()\n  }, 30)\n})\n\nasyncTest('a[data-remote][data-disable-with] re-enables when `ajax:beforeSend` event is cancelled', 6, function() {\n  var link = $('a[data-disable-with]').attr('data-remote', true)\n\n  App.checkEnabledState(link, 'Click me')\n\n  link\n    .bindNative('ajax:beforeSend', function(e) {\n      App.checkDisabledState(link, 'clicking...')\n      e.preventDefault()\n    })\n    .triggerNative('click')\n\n  setTimeout(function() {\n    App.checkEnabledState(link, 'Click me')\n    start()\n  }, 30)\n})\n\nasyncTest('a[data-remote][data-disable-with] re-enables when `ajax:error` event is triggered', 6, function() {\n  var link = $('a[data-disable-with]').attr('data-remote', true).attr('href', '/error')\n\n  App.checkEnabledState(link, 'Click me')\n\n  link\n    .bindNative('ajax:beforeSend', function() {\n      App.checkDisabledState(link, 'clicking...')\n    })\n    .triggerNative('click')\n\n  setTimeout(function() {\n    App.checkEnabledState(link, 'Click me')\n    start()\n  }, 30)\n})\n\nasyncTest('form[data-remote] input|button|textarea[data-disable-with] does not disable when `ajax:beforeSend` event is cancelled', 8, function() {\n  var form = $('form[data-remote]'),\n      input = form.find('input:text'),\n      button = $('<button data-disable-with=\"submitting ...\" name=\"submit2\">Submit</button>').appendTo(form),\n      textarea = $('<textarea data-disable-with=\"processing ...\" name=\"user_bio\">born, lived, died.</textarea>').appendTo(form),\n      submit = $('<input type=\"submit\" data-disable-with=\"submitting ...\" name=\"submit2\" value=\"Submit\" />').appendTo(form)\n\n  form\n    .bindNative('ajax:beforeSend', function(e) {\n      e.preventDefault()\n      e.stopPropagation()\n    })\n    .triggerNative('submit')\n\n  App.checkEnabledState(input, 'john')\n  App.checkEnabledState(button, 'Submit')\n  App.checkEnabledState(textarea, 'born, lived, died.')\n  App.checkEnabledState(submit, 'Submit')\n\n  start()\n})\n\nasyncTest('ctrl-clicking on a link does not disable the link', 6, function() {\n  var link = $('a[data-disable-with]')\n\n  App.checkEnabledState(link, 'Click me')\n\n  link.triggerNative('click', { metaKey: true })\n  App.checkEnabledState(link, 'Click me')\n\n  link.triggerNative('click', { metaKey: true })\n  App.checkEnabledState(link, 'Click me')\n  start()\n})\n\nasyncTest('right/mouse-wheel-clicking on a link does not disable the link', 10, function() {\n  var link = $('a[data-disable-with]')\n\n  App.checkEnabledState(link, 'Click me')\n\n  link.triggerNative('click', { button: 1 })\n  App.checkEnabledState(link, 'Click me')\n\n  link.triggerNative('click', { button: 1 })\n  App.checkEnabledState(link, 'Click me')\n\n  link.triggerNative('click', { button: 2 })\n  App.checkEnabledState(link, 'Click me')\n\n  link.triggerNative('click', { button: 2 })\n  App.checkEnabledState(link, 'Click me')\n  start()\n})\n\nasyncTest('button[data-remote][data-disable-with] disables and re-enables', 6, function() {\n  var button = $('button[data-remote][data-disable-with]')\n\n  App.checkEnabledState(button, 'Click me')\n\n  button\n    .bindNative('ajax:send', function() {\n      App.checkDisabledState(button, 'clicking...')\n    })\n    .bindNative('ajax:complete', function() {\n      setTimeout( function() {\n        App.checkEnabledState(button, 'Click me')\n        start()\n      }, 15)\n    })\n    .triggerNative('click')\n})\n\nasyncTest('button[data-remote][data-disable-with] re-enables when `ajax:before` event is cancelled', 6, function() {\n  var button = $('button[data-remote][data-disable-with]')\n\n  App.checkEnabledState(button, 'Click me')\n\n  button\n    .bindNative('ajax:before', function(e) {\n      App.checkDisabledState(button, 'clicking...')\n      e.preventDefault()\n    })\n    .triggerNative('click')\n\n  setTimeout(function() {\n    App.checkEnabledState(button, 'Click me')\n    start()\n  }, 30)\n})\n\nasyncTest('button[data-remote][data-disable-with] re-enables when `ajax:beforeSend` event is cancelled', 6, function() {\n  var button = $('button[data-remote][data-disable-with]')\n\n  App.checkEnabledState(button, 'Click me')\n\n  button\n    .bindNative('ajax:beforeSend', function(e) {\n      App.checkDisabledState(button, 'clicking...')\n      e.preventDefault()\n    })\n    .triggerNative('click')\n\n  setTimeout(function() {\n    App.checkEnabledState(button, 'Click me')\n    start()\n  }, 30)\n})\n\nasyncTest('button[data-remote][data-disable-with] re-enables when `ajax:error` event is triggered', 6, function() {\n  var button = $('a[data-disable-with]').attr('data-remote', true).attr('href', '/error')\n\n  App.checkEnabledState(button, 'Click me')\n\n  button\n    .bindNative('ajax:send', function() {\n      App.checkDisabledState(button, 'clicking...')\n    })\n    .triggerNative('click')\n\n  setTimeout(function() {\n    App.checkEnabledState(button, 'Click me')\n    start()\n  }, 30)\n})\n\nasyncTest('form button with \"data-disable-with\" attribute and contenteditable is not modified', 6, function() {\n  var form = $('form[data-remote]'), button = $('<button data-disable-with=\"submitting ...\" name=\"submit2\">Submit</button>')\n\n  var contenteditable_div = $('#qunit-fixture').find('div')\n  form.append(button)\n  contenteditable_div.append(form)\n\n  App.checkEnabledState(button, 'Submit')\n\n  setTimeout(function() {\n    App.checkEnabledState(button, 'Submit')\n    start()\n  }, 13)\n  form.triggerNative('submit')\n\n  App.checkEnabledState(button, 'Submit')\n})\n", "patch": "@@ -37,6 +37,10 @@ module('data-disable-with', {\n       'data-url': '/echo',\n       'data-disable-with': 'clicking...'\n     }))\n+\n+    $('#qunit-fixture').append($('<div />', {\n+      id: 'edit-div', 'contenteditable': 'true'\n+    }))\n   },\n   teardown: function() {\n     $(document).unbind('iframe:loaded')\n@@ -432,3 +436,21 @@ asyncTest('button[data-remote][data-disable-with] re-enables when `ajax:error` e\n     start()\n   }, 30)\n })\n+\n+asyncTest('form button with \"data-disable-with\" attribute and contenteditable is not modified', 6, function() {\n+  var form = $('form[data-remote]'), button = $('<button data-disable-with=\"submitting ...\" name=\"submit2\">Submit</button>')\n+\n+  var contenteditable_div = $('#qunit-fixture').find('div')\n+  form.append(button)\n+  contenteditable_div.append(form)\n+\n+  App.checkEnabledState(button, 'Submit')\n+\n+  setTimeout(function() {\n+    App.checkEnabledState(button, 'Submit')\n+    start()\n+  }, 13)\n+  form.triggerNative('submit')\n+\n+  App.checkEnabledState(button, 'Submit')\n+})"}
{"patches_id": 5, "files_id": 26, "language": "js", "raw_url": "https://github.com/rails/rails/raw/5037a13614d71727af8a175063bcf6ba1a74bdbd/actionview%2Ftest%2Fujs%2Fpublic%2Ftest%2Fdata-method.js", "raw_code": "(function() {\n\nmodule('data-method', {\n  setup: function() {\n    $('#qunit-fixture').append($('<a />', {\n      href: '/echo', 'data-method': 'delete', text: 'destroy!'\n    }))\n\n    $('#qunit-fixture').append($('<div />', {\n      id: 'edit-div', 'contenteditable': 'true'\n    }))\n  },\n  teardown: function() {\n    $(document).unbind('iframe:loaded')\n  }\n})\n\nfunction submit(fn, options) {\n  $(document).bind('iframe:loaded', function(e, data) {\n    fn(data)\n    start()\n  })\n\n  $('#qunit-fixture').find('a')\n    .triggerNative('click')\n}\n\nasyncTest('link with \"data-method\" set to \"delete\"', 3, function() {\n  submit(function(data) {\n    equal(data.REQUEST_METHOD, 'DELETE')\n    strictEqual(data.params.authenticity_token, undefined)\n    strictEqual(data.HTTP_X_CSRF_TOKEN, undefined)\n  })\n})\n\nasyncTest('click on the child of link with \"data-method\"', 3, function() {\n  $(document).bind('iframe:loaded', function(e, data) {\n    equal(data.REQUEST_METHOD, 'DELETE')\n    strictEqual(data.params.authenticity_token, undefined)\n    strictEqual(data.HTTP_X_CSRF_TOKEN, undefined)\n    start()\n  })\n  $('#qunit-fixture a').html('<strong>destroy!</strong>').find('strong').triggerNative('click')\n})\n\nasyncTest('link with \"data-method\" and CSRF', 1, function() {\n  $('#qunit-fixture')\n    .append('<meta name=\"csrf-param\" content=\"authenticity_token\"/>')\n    .append('<meta name=\"csrf-token\" content=\"cf50faa3fe97702ca1ae\"/>')\n\n  submit(function(data) {\n    equal(data.params.authenticity_token, 'cf50faa3fe97702ca1ae')\n  })\n})\n\nasyncTest('link \"target\" should be carried over to generated form', 1, function() {\n  $('a[data-method]').attr('target', 'super-special-frame')\n  submit(function(data) {\n    equal(data.params._target, 'super-special-frame')\n  })\n})\n\nasyncTest('link with \"data-method\" and cross origin', 1, function() {\n  var data = {}\n\n  $('#qunit-fixture')\n    .append('<meta name=\"csrf-param\" content=\"authenticity_token\"/>')\n    .append('<meta name=\"csrf-token\" content=\"cf50faa3fe97702ca1ae\"/>')\n\n  $(document).on('submit', 'form', function(e) {\n    $(e.currentTarget).serializeArray().map(function(item) {\n      data[item.name] = item.value\n    })\n\n    return false\n  })\n\n  var link = $('#qunit-fixture').find('a')\n\n  link.attr('href', 'http://www.alfajango.com')\n\n  link.triggerNative('click')\n\n  start()\n\n  notEqual(data.authenticity_token, 'cf50faa3fe97702ca1ae')\n})\n\nasyncTest('do not interact with contenteditable elements', 6, function() {\n  var contenteditable_div = $('#qunit-fixture').find('div')\n  contenteditable_div.append('<a href=\"http://www.shouldnevershowindocument.com\" data-method=\"delete\">')\n\n  var link = $('#edit-div').find('a')\n  link.triggerNative('click')\n\n  start()\n\n  collection = document.getElementsByTagName('form')\n  for (const item of collection) {\n    notEqual(item.action, \"http://www.shouldnevershowindocument.com/\")\n  }\n})\n\n})()\n", "patch": "@@ -5,6 +5,10 @@ module('data-method', {\n     $('#qunit-fixture').append($('<a />', {\n       href: '/echo', 'data-method': 'delete', text: 'destroy!'\n     }))\n+\n+    $('#qunit-fixture').append($('<div />', {\n+      id: 'edit-div', 'contenteditable': 'true'\n+    }))\n   },\n   teardown: function() {\n     $(document).unbind('iframe:loaded')\n@@ -82,4 +86,19 @@ asyncTest('link with \"data-method\" and cross origin', 1, function() {\n   notEqual(data.authenticity_token, 'cf50faa3fe97702ca1ae')\n })\n \n+asyncTest('do not interact with contenteditable elements', 6, function() {\n+  var contenteditable_div = $('#qunit-fixture').find('div')\n+  contenteditable_div.append('<a href=\"http://www.shouldnevershowindocument.com\" data-method=\"delete\">')\n+\n+  var link = $('#edit-div').find('a')\n+  link.triggerNative('click')\n+\n+  start()\n+\n+  collection = document.getElementsByTagName('form')\n+  for (const item of collection) {\n+    notEqual(item.action, \"http://www.shouldnevershowindocument.com/\")\n+  }\n+})\n+\n })()"}
{"patches_id": 5, "files_id": 27, "language": "js", "raw_url": "https://github.com/rails/rails/raw/5037a13614d71727af8a175063bcf6ba1a74bdbd/actionview%2Ftest%2Fujs%2Fpublic%2Ftest%2Fdata-remote.js", "raw_code": "(function() {\n\nfunction buildSelect(attrs) {\n  attrs = $.extend({\n    'name': 'user_data', 'data-remote': 'true', 'data-url': '/echo', 'data-params': 'data1=value1'\n  }, attrs)\n\n  $('#qunit-fixture').append(\n    $('<select />', attrs)\n      .append($('<option />', {value: 'optionValue1', text: 'option1'}))\n      .append($('<option />', {value: 'optionValue2', text: 'option2'}))\n  )\n}\n\nmodule('data-remote', {\n  setup: function() {\n    $('#qunit-fixture')\n      .append($('<a />', {\n        href: '/echo',\n        'data-remote': 'true',\n        'data-params': 'data1=value1&data2=value2',\n        text: 'my address'\n      }))\n      .append($('<button />', {\n        'data-url': '/echo',\n        'data-remote': 'true',\n        'data-params': 'data1=value1&data2=value2',\n        text: 'my button'\n      }))\n      .append($('<form />', {\n        action: '/echo',\n        'data-remote': 'true',\n        method: 'post',\n        id: 'my-remote-form'\n      }))\n      .append($('<a />', {\n        href: '/echo',\n        'data-remote': 'true',\n        disabled: 'disabled',\n        text: 'Disabled link'\n      }))\n      .find('form').append($('<input type=\"text\" name=\"user_name\" value=\"john\">'))\n\n    $('#qunit-fixture').append($('<div />', {\n      id: 'edit-div', 'contenteditable': 'true'\n    }))\n  }\n})\n\nasyncTest('ctrl-clicking on a link does not fire ajaxyness', 0, function() {\n  var link = $('a[data-remote]')\n\n  // Ideally, we'd set up an iframe to intercept normal link clicks\n  // and add a test to make sure the iframe:loaded event is triggered.\n  // However, jquery doesn't actually cause a native `click` event and\n  // follow links using `trigger('click')`, it only fires bindings.\n  link\n    .removeAttr('data-params')\n    .bindNative('ajax:beforeSend', function() {\n      ok(false, 'ajax should not be triggered')\n    })\n\n  link.triggerNative('click', { metaKey: true })\n  link.triggerNative('click', { ctrlKey: true })\n\n  setTimeout(function() { start() }, 13)\n})\n\nasyncTest('right/mouse-wheel-clicking on a link does not fire ajaxyness', 0, function() {\n  var link = $('a[data-remote]')\n\n  // Ideally, we'd set up an iframe to intercept normal link clicks\n  // and add a test to make sure the iframe:loaded event is triggered.\n  // However, jquery doesn't actually cause a native `click` event and\n  // follow links using `trigger('click')`, it only fires bindings.\n  link\n    .removeAttr('data-params')\n    .bindNative('ajax:beforeSend', function() {\n      ok(false, 'ajax should not be triggered')\n    })\n\n  link.triggerNative('click', { button: 1 })\n  link.triggerNative('click', { button: 2 })\n\n  setTimeout(function() { start() }, 13)\n})\n\nasyncTest('clicking on a link via a non-mouse Event (such as from js) works', 1, function() {\n  var link = $('a[data-remote]')\n\n  link\n    .removeAttr('data-params')\n    .bindNative('ajax:beforeSend', function() {\n      ok(true, 'ajax should be triggered')\n    })\n\n  Rails.fire(link[0], 'click')\n\n  setTimeout(function() { start() }, 13)\n})\n\nasyncTest('ctrl-clicking on a link still fires ajax for non-GET links and for links with \"data-params\"', 2, function() {\n  var link = $('a[data-remote]')\n\n  link\n    .removeAttr('data-params')\n    .attr('data-method', 'POST')\n    .bindNative('ajax:beforeSend', function() {\n      ok(true, 'ajax should be triggered')\n    })\n    .triggerNative('click', { metaKey: true })\n\n  link\n    .removeAttr('data-method')\n    .attr('data-params', 'name=steve')\n    .triggerNative('click', { metaKey: true })\n\n  setTimeout(function() { start() }, 13)\n})\n\nasyncTest('clicking on a link with data-remote attribute', 5, function() {\n  $('a[data-remote]')\n    .bindNative('ajax:success', function(e, data, status, xhr) {\n      App.assertCallbackInvoked('ajax:success')\n      App.assertRequestPath(data, '/echo')\n      equal(data.params.data1, 'value1', 'ajax arguments should have key data1 with right value')\n      equal(data.params.data2, 'value2', 'ajax arguments should have key data2 with right value')\n      App.assertGetRequest(data)\n    })\n    .bindNative('ajax:complete', function() { start() })\n    .triggerNative('click')\n})\n\nasyncTest('clicking on a link with both query string in href and data-params', 4, function() {\n  $('a[data-remote]')\n    .attr('href', '/echo?data3=value3')\n    .bindNative('ajax:success', function(e, data, status, xhr) {\n      App.assertGetRequest(data)\n      equal(data.params.data1, 'value1', 'ajax arguments should have key data1 with right value')\n      equal(data.params.data2, 'value2', 'ajax arguments should have key data2 with right value')\n      equal(data.params.data3, 'value3', 'query string in URL should be passed to server with right value')\n    })\n    .bindNative('ajax:complete', function() { start() })\n    .triggerNative('click')\n})\n\nasyncTest('clicking on a link with both query string in href and data-params with POST method', 4, function() {\n  $('a[data-remote]')\n    .attr('href', '/echo?data3=value3')\n    .attr('data-method', 'post')\n    .bindNative('ajax:success', function(e, data, status, xhr) {\n      App.assertPostRequest(data)\n      equal(data.params.data1, 'value1', 'ajax arguments should have key data1 with right value')\n      equal(data.params.data2, 'value2', 'ajax arguments should have key data2 with right value')\n      equal(data.params.data3, 'value3', 'query string in URL should be passed to server with right value')\n    })\n    .bindNative('ajax:complete', function() { start() })\n    .triggerNative('click')\n})\n\nasyncTest('clicking on a link with disabled attribute', 0, function() {\n  $('a[disabled]')\n  .bindNative('ajax:before', function(e, data, status, xhr) {\n    App.assertCallbackNotInvoked('ajax:success')\n  })\n  .bindNative('ajax:complete', function() { start() })\n  .triggerNative('click')\n\n  setTimeout(function() {\n    start()\n  }, 13)\n})\n\nasyncTest('clicking on a button with data-remote attribute', 5, function() {\n  $('button[data-remote]')\n    .bindNative('ajax:success', function(e, data, status, xhr) {\n      App.assertCallbackInvoked('ajax:success')\n      App.assertRequestPath(data, '/echo')\n      equal(data.params.data1, 'value1', 'ajax arguments should have key data1 with right value')\n      equal(data.params.data2, 'value2', 'ajax arguments should have key data2 with right value')\n      App.assertGetRequest(data)\n    })\n    .bindNative('ajax:complete', function() { start() })\n    .triggerNative('click')\n})\n\nasyncTest('right/mouse-wheel-clicking on a button with data-remote attribute does not fire ajaxyness', 0, function() {\n  var button = $('button[data-remote]')\n\n  // Ideally, we'd set up an iframe to intercept normal link clicks\n  // and add a test to make sure the iframe:loaded event is triggered.\n  // However, jquery doesn't actually cause a native `click` event and\n  // follow links using `trigger('click')`, it only fires bindings.\n  button\n    .removeAttr('data-params')\n    .bindNative('ajax:beforeSend', function() {\n      ok(false, 'ajax should not be triggered')\n    })\n\n  button.triggerNative('click', { button: 1 })\n  button.triggerNative('click', { button: 2 })\n\n  setTimeout(function() { start() }, 13)\n})\n\nasyncTest('changing a select option with data-remote attribute', 5, function() {\n  buildSelect()\n\n  $('select[data-remote]')\n    .bindNative('ajax:success', function(e, data, status, xhr) {\n      App.assertCallbackInvoked('ajax:success')\n      App.assertRequestPath(data, '/echo')\n      equal(data.params.user_data, 'optionValue2', 'ajax arguments should have key term with right value')\n      equal(data.params.data1, 'value1', 'ajax arguments should have key data1 with right value')\n      App.assertGetRequest(data)\n    })\n    .bindNative('ajax:complete', function() { start() })\n    .val('optionValue2')\n    .triggerNative('change')\n})\n\nasyncTest('submitting form with data-remote attribute', 4, function() {\n  $('form[data-remote]')\n    .bindNative('ajax:success', function(e, data, status, xhr) {\n      App.assertCallbackInvoked('ajax:success')\n      App.assertRequestPath(data, '/echo')\n      equal(data.params.user_name, 'john', 'ajax arguments should have key user_name with right value')\n      App.assertPostRequest(data)\n    })\n    .bindNative('ajax:complete', function() { start() })\n    .triggerNative('submit')\n})\n\nasyncTest('submitting form with data-remote attribute should include inputs in a fieldset only once', 3, function() {\n  $('form[data-remote]')\n    .append('<fieldset><input name=\"items[]\" value=\"Item\" /></fieldset>')\n    .bindNative('ajax:success', function(e, data, status, xhr) {\n      App.assertCallbackInvoked('ajax:success')\n      equal(data.params.items.length, 1, 'ajax arguments should only have the item once')\n      App.assertPostRequest(data)\n    })\n    .bindNative('ajax:complete', function() {\n      $('form[data-remote], fieldset').remove()\n      start()\n    })\n    .triggerNative('submit')\n})\n\nasyncTest('submitting form with data-remote attribute submits input with matching [form] attribute', 6, function() {\n  $('#qunit-fixture')\n    .append($('<input type=\"text\" name=\"user_data\" value=\"value1\" form=\"my-remote-form\">'))\n    .append($('<input type=\"text\" name=\"user_email\" value=\"from@example.com\" disabled=\"disabled\" form=\"my-remote-form\">'))\n\n  $('form[data-remote]')\n    .bindNative('ajax:success', function(e, data, status, xhr) {\n      App.assertCallbackInvoked('ajax:success')\n      App.assertRequestPath(data, '/echo')\n      equal(data.params.user_name, 'john', 'ajax arguments should have key user_name with right value')\n      equal(data.params.user_data, 'value1', 'ajax arguments should have key user_data with right value')\n      equal(data.params.user_email, undefined, 'ajax arguments should not have disabled field')\n      App.assertPostRequest(data)\n    })\n    .bindNative('ajax:complete', function() { start() })\n    .triggerNative('submit')\n})\n\nasyncTest('submitting form with data-remote attribute by clicking button with matching [form] attribute', 5, function() {\n  $('form[data-remote]')\n    .bindNative('ajax:success', function(e, data, status, xhr) {\n      App.assertCallbackInvoked('ajax:success')\n      App.assertRequestPath(data, '/echo')\n      equal(data.params.user_name, 'john', 'ajax arguments should have key user_name with right value')\n      equal(data.params.user_data, 'value2', 'ajax arguments should have key user_data with right value')\n      App.assertPostRequest(data)\n    })\n    .bindNative('ajax:complete', function() { start() })\n\n  $('<button />', {\n        type: 'submit',\n        name: 'user_data',\n        value: 'value1',\n        form: 'my-remote-form'\n      })\n    .appendTo($('#qunit-fixture'))\n\n  $('<button />', {\n      type: 'submit',\n      name: 'user_data',\n      value: 'value2',\n      form: 'my-remote-form'\n    })\n    .appendTo($('#qunit-fixture'))\n    .triggerNative('click')\n})\n\nasyncTest('form\\'s submit bindings in browsers that don\\'t support submit bubbling', 5, function() {\n  var form = $('form[data-remote]'), directBindingCalled = false\n\n  ok(!directBindingCalled, 'nothing is called')\n\n  form\n    .append($('<input type=\"submit\" />'))\n    .bindNative('submit', function(event) {\n      ok(event.type == 'submit', 'submit event handlers are called with submit event')\n      ok(true, 'binding handler is called')\n      directBindingCalled = true\n    })\n    .bindNative('ajax:beforeSend', function() {\n      ok(true, 'form being submitted via ajax')\n      ok(directBindingCalled, 'binding handler already called')\n    })\n    .bindNative('ajax:complete', function() {\n      start()\n    })\n\n    if(!$.support.submitBubbles) {\n      // Must indrectly submit form via click to trigger jQuery's manual submit bubbling in IE\n      form.find('input[type=submit]')\n      .triggerNative('click')\n    } else {\n      form.triggerNative('submit')\n    }\n})\n\nasyncTest('returning false in form\\'s submit bindings in non-submit-bubbling browsers', 1, function() {\n  var form = $('form[data-remote]')\n\n  form\n    .append($('<input type=\"submit\" />'))\n    .bindNative('submit', function(e) {\n      ok(true, 'binding handler is called')\n      e.preventDefault()\n      e.stopPropagation()\n    })\n    .bindNative('ajax:beforeSend', function() {\n      ok(false, 'form should not be submitted')\n    })\n\n    if (!$.support.submitBubbles) {\n      // Must indrectly submit form via click to trigger jQuery's manual submit bubbling in IE\n      form.find('input[type=submit]').triggerNative('click')\n    } else {\n      form.triggerNative('submit')\n    }\n\n    setTimeout(function() { start() }, 13)\n})\n\nasyncTest('clicking on a link with falsy \"data-remote\" attribute does not fire ajaxyness', 0, function() {\n  $('a[data-remote]')\n    .attr('data-remote', 'false')\n    .bindNative('ajax:beforeSend', function() {\n      ok(false, 'ajax should not be triggered')\n    })\n    .bindNative('click', function(e) {\n      e.preventDefault()\n    })\n    .triggerNative('click')\n\n  setTimeout(function() { start() }, 20)\n})\n\nasyncTest('ctrl-clicking on a link with falsy \"data-remote\" attribute does not fire ajaxyness even if \"data-params\" present', 0, function() {\n  var link = $('a[data-remote]')\n\n  link\n    .removeAttr('data-params')\n    .attr('data-remote', 'false')\n    .attr('data-method', 'POST')\n    .bindNative('ajax:beforeSend', function() {\n      ok(false, 'ajax should not be triggered')\n    })\n    .bindNative('click', function(e) {\n      e.preventDefault()\n    })\n    .triggerNative('click', { metaKey: true })\n\n  link\n    .removeAttr('data-method')\n    .attr('data-params', 'name=steve')\n    .triggerNative('click', { metaKey: true })\n\n  setTimeout(function() { start() }, 20)\n})\n\nasyncTest('clicking on a button with falsy \"data-remote\" attribute', 0, function() {\n  $('button[data-remote]:first')\n    .attr('data-remote', 'false')\n    .bindNative('ajax:beforeSend', function() {\n      ok(false, 'ajax should not be triggered')\n    })\n    .bindNative('click', function(e) {\n      e.preventDefault()\n    })\n    .triggerNative('click')\n\n  setTimeout(function() { start() }, 20)\n})\n\nasyncTest('submitting a form with falsy \"data-remote\" attribute', 0, function() {\n  $('form[data-remote]:first')\n    .attr('data-remote', 'false')\n    .bindNative('ajax:beforeSend', function() {\n      ok(false, 'ajax should not be triggered')\n    })\n    .bindNative('submit', function(e) {\n      e.preventDefault()\n    })\n    .triggerNative('submit')\n\n  setTimeout(function() { start() }, 20)\n})\n\nasyncTest('changing a select option with falsy \"data-remote\" attribute', 0, function() {\n  buildSelect({'data-remote': 'false'})\n\n  $('select[data-remote=false]:first')\n    .bindNative('ajax:beforeSend', function() {\n      ok(false, 'ajax should not be triggered')\n    })\n    .val('optionValue2')\n    .triggerNative('change')\n\n  setTimeout(function() { start() }, 20)\n})\n\nasyncTest('form should be serialized correctly', 6, function() {\n  $('form')\n    .append('<textarea name=\"textarea\">textarea</textarea>')\n    .append('<input type=\"checkbox\" name=\"checkbox[]\" value=\"0\" />')\n    .append('<input type=\"checkbox\" checked=\"checked\" name=\"checkbox[]\" value=\"1\" />')\n    .append('<input type=\"radio\" checked=\"checked\" name=\"radio\" value=\"0\" />')\n    .append('<input type=\"radio\" name=\"radio\" value=\"1\" />')\n    .append('<select multiple=\"multiple\" name=\"select[]\">\\\n      <option value=\"1\" selected>1</option>\\\n      <option value=\"2\" selected>2</option>\\\n      <option value=\"3\">3</option>\\\n      <option selected>4</option>\\\n    </select>')\n    .bindNative('ajax:success', function(e, data, status, xhr) {\n      equal(data.params.checkbox.length, 1)\n      equal(data.params.checkbox[0], '1')\n      equal(data.params.radio, '0')\n      equal(data.params.select.length, 3)\n      equal(data.params.select[2], '4')\n      equal(data.params.textarea, 'textarea')\n\n      start()\n    })\n    .triggerNative('submit')\n})\n\nasyncTest('form buttons should only be serialized when clicked', 4, function() {\n  $('form')\n    .append('<input type=\"submit\" name=\"submit1\" value=\"submit1\" />')\n    .append('<button name=\"submit2\" value=\"submit2\" />')\n    .append('<button name=\"submit3\" value=\"submit3\" />')\n    .bindNative('ajax:success', function(e, data, status, xhr) {\n      equal(data.params.submit1, undefined)\n      equal(data.params.submit2, 'submit2')\n      equal(data.params.submit3, undefined)\n      equal(data['rack.request.form_vars'], 'user_name=john&submit2=submit2')\n\n      start()\n    })\n    .find('[name=submit2]').triggerNative('click')\n})\n\nasyncTest('changing a select option without \"data-url\" attribute still fires ajax request to current location', 1, function() {\n  var currentLocation, ajaxLocation\n\n  buildSelect({'data-url': ''})\n\n  $('select[data-remote]')\n    .bindNative('ajax:beforeSend', function(e, xhr, settings) {\n      // Get current location (the same way jQuery does)\n      try {\n        currentLocation = location.href\n      } catch(err) {\n        currentLocation = document.createElement( 'a' )\n        currentLocation.href = ''\n        currentLocation = currentLocation.href\n      }\n\n      ajaxLocation = settings.url.replace(settings.data, '').replace(/&$/, '').replace(/\\?$/, '')\n      equal(ajaxLocation, currentLocation, 'URL should be current page by default')\n\n      e.preventDefault()\n    })\n    .val('optionValue2')\n    .triggerNative('change')\n\n  setTimeout(function() { start() }, 20)\n})\n\nasyncTest('inputs inside disabled fieldset are not submitted on remote forms', 3, function() {\n  $('form')\n    .append('<fieldset>\\\n      <input name=\"description\" value=\"A wise man\" />\\\n    </fieldset>')\n    .append('<fieldset disabled=\"disabled\">\\\n      <input name=\"age\" />\\\n    </fieldset>')\n    .bindNative('ajax:success', function(e, data, status, xhr) {\n      equal(data.params.user_name, 'john')\n      equal(data.params.description, 'A wise man')\n      equal(data.params.age, undefined)\n\n      start()\n    })\n    .triggerNative('submit')\n})\n\nasyncTest('clicking on a link with contenteditable attribute does not fire ajaxyness', 0, function() {\n  var contenteditable_div = $('#qunit-fixture').find('div')\n  var link = $('a[data-remote]')\n  contenteditable_div.append(link)\n\n  link\n    .bindNative('ajax:beforeSend', function() {\n      ok(false, 'ajax should not be triggered')\n    })\n    .bindNative('click', function(e) {\n      e.preventDefault()\n    })\n    .triggerNative('click')\n\n  setTimeout(function() { start() }, 20)\n})\n\n})()\n", "patch": "@@ -41,6 +41,9 @@ module('data-remote', {\n       }))\n       .find('form').append($('<input type=\"text\" name=\"user_name\" value=\"john\">'))\n \n+    $('#qunit-fixture').append($('<div />', {\n+      id: 'edit-div', 'contenteditable': 'true'\n+    }))\n   }\n })\n \n@@ -508,4 +511,21 @@ asyncTest('inputs inside disabled fieldset are not submitted on remote forms', 3\n     .triggerNative('submit')\n })\n \n+asyncTest('clicking on a link with contenteditable attribute does not fire ajaxyness', 0, function() {\n+  var contenteditable_div = $('#qunit-fixture').find('div')\n+  var link = $('a[data-remote]')\n+  contenteditable_div.append(link)\n+\n+  link\n+    .bindNative('ajax:beforeSend', function() {\n+      ok(false, 'ajax should not be triggered')\n+    })\n+    .bindNative('click', function(e) {\n+      e.preventDefault()\n+    })\n+    .triggerNative('click')\n+\n+  setTimeout(function() { start() }, 20)\n+})\n+\n })()"}
{"patches_id": 6, "files_id": 28, "language": "coffee", "raw_url": "https://github.com/rails/rails/raw/73009ea59a811b28e8ec2a9c9bc24635aa891214/actionview%2Fapp%2Fassets%2Fjavascripts%2Frails-ujs%2Ffeatures%2Fdisable.coffee", "raw_code": "#= require_tree ../utils\n\n{ matches, getData, setData, stopEverything, formElements, isContentEditable } = Rails\n\nRails.handleDisabledElement = (e) ->\n  element = this\n  stopEverything(e) if element.disabled\n\n# Unified function to enable an element (link, button and form)\nRails.enableElement = (e) ->\n  if e instanceof Event\n    return if isXhrRedirect(e)\n    element = e.target\n  else\n    element = e\n\n  if isContentEditable(element)\n    return\n\n  if matches(element, Rails.linkDisableSelector)\n    enableLinkElement(element)\n  else if matches(element, Rails.buttonDisableSelector) or matches(element, Rails.formEnableSelector)\n    enableFormElement(element)\n  else if matches(element, Rails.formSubmitSelector)\n    enableFormElements(element)\n\n# Unified function to disable an element (link, button and form)\nRails.disableElement = (e) ->\n  element = if e instanceof Event then e.target else e\n\n  if isContentEditable(element)\n    return\n\n  if matches(element, Rails.linkDisableSelector)\n    disableLinkElement(element)\n  else if matches(element, Rails.buttonDisableSelector) or matches(element, Rails.formDisableSelector)\n    disableFormElement(element)\n  else if matches(element, Rails.formSubmitSelector)\n    disableFormElements(element)\n\n#  Replace element's html with the 'data-disable-with' after storing original html\n#  and prevent clicking on it\ndisableLinkElement = (element) ->\n  return if getData(element, 'ujs:disabled')\n  replacement = element.getAttribute('data-disable-with')\n  if replacement?\n    setData(element, 'ujs:enable-with', element.innerHTML) # store enabled state\n    element.innerHTML = replacement\n  element.addEventListener('click', stopEverything) # prevent further clicking\n  setData(element, 'ujs:disabled', true)\n\n# Restore element to its original state which was disabled by 'disableLinkElement' above\nenableLinkElement = (element) ->\n  originalText = getData(element, 'ujs:enable-with')\n  if originalText?\n    element.innerHTML = originalText # set to old enabled state\n    setData(element, 'ujs:enable-with', null) # clean up cache\n  element.removeEventListener('click', stopEverything) # enable element\n  setData(element, 'ujs:disabled', null)\n\n# Disables form elements:\n#  - Caches element value in 'ujs:enable-with' data store\n#  - Replaces element text with value of 'data-disable-with' attribute\n#  - Sets disabled property to true\ndisableFormElements = (form) ->\n  formElements(form, Rails.formDisableSelector).forEach(disableFormElement)\n\ndisableFormElement = (element) ->\n  return if getData(element, 'ujs:disabled')\n  replacement = element.getAttribute('data-disable-with')\n  if replacement?\n    if matches(element, 'button')\n      setData(element, 'ujs:enable-with', element.innerHTML)\n      element.innerHTML = replacement\n    else\n      setData(element, 'ujs:enable-with', element.value)\n      element.value = replacement\n  element.disabled = true\n  setData(element, 'ujs:disabled', true)\n\n# Re-enables disabled form elements:\n#  - Replaces element text with cached value from 'ujs:enable-with' data store (created in `disableFormElements`)\n#  - Sets disabled property to false\nenableFormElements = (form) ->\n  formElements(form, Rails.formEnableSelector).forEach(enableFormElement)\n\nenableFormElement = (element) ->\n  originalText = getData(element, 'ujs:enable-with')\n  if originalText?\n    if matches(element, 'button')\n      element.innerHTML = originalText\n    else\n      element.value = originalText\n    setData(element, 'ujs:enable-with', null) # clean up cache\n  element.disabled = false\n  setData(element, 'ujs:disabled', null)\n\nisXhrRedirect = (event) ->\n  xhr = event.detail?[0]\n  xhr?.getResponseHeader(\"X-Xhr-Redirect\")?\n", "patch": "@@ -1,6 +1,6 @@\n #= require_tree ../utils\n \n-{ matches, getData, setData, stopEverything, formElements } = Rails\n+{ matches, getData, setData, stopEverything, formElements, isContentEditable } = Rails\n \n Rails.handleDisabledElement = (e) ->\n   element = this\n@@ -14,6 +14,9 @@ Rails.enableElement = (e) ->\n   else\n     element = e\n \n+  if isContentEditable(element)\n+    return\n+\n   if matches(element, Rails.linkDisableSelector)\n     enableLinkElement(element)\n   else if matches(element, Rails.buttonDisableSelector) or matches(element, Rails.formEnableSelector)\n@@ -24,6 +27,10 @@ Rails.enableElement = (e) ->\n # Unified function to disable an element (link, button and form)\n Rails.disableElement = (e) ->\n   element = if e instanceof Event then e.target else e\n+\n+  if isContentEditable(element)\n+    return\n+\n   if matches(element, Rails.linkDisableSelector)\n     disableLinkElement(element)\n   else if matches(element, Rails.buttonDisableSelector) or matches(element, Rails.formDisableSelector)"}
{"patches_id": 6, "files_id": 29, "language": "coffee", "raw_url": "https://github.com/rails/rails/raw/73009ea59a811b28e8ec2a9c9bc24635aa891214/actionview%2Fapp%2Fassets%2Fjavascripts%2Frails-ujs%2Ffeatures%2Fmethod.coffee", "raw_code": "#= require_tree ../utils\n\n{ stopEverything } = Rails\n{ isContentEditable } = Rails\n\n# Handles \"data-method\" on links such as:\n# <a href=\"/users/5\" data-method=\"delete\" rel=\"nofollow\" data-confirm=\"Are you sure?\">Delete</a>\nRails.handleMethod = (e) ->\n  link = this\n  method = link.getAttribute('data-method')\n  return unless method\n\n  if isContentEditable(this)\n    return\n\n  href = Rails.href(link)\n  csrfToken = Rails.csrfToken()\n  csrfParam = Rails.csrfParam()\n  form = document.createElement('form')\n  formContent = \"<input name='_method' value='#{method}' type='hidden' />\"\n\n  if csrfParam? and csrfToken? and not Rails.isCrossDomain(href)\n    formContent += \"<input name='#{csrfParam}' value='#{csrfToken}' type='hidden' />\"\n\n  # Must trigger submit by click on a button, else \"submit\" event handler won't work!\n  # https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement/submit\n  formContent += '<input type=\"submit\" />'\n\n  form.method = 'post'\n  form.action = href\n  form.target = link.target\n  form.innerHTML = formContent\n  form.style.display = 'none'\n\n  document.body.appendChild(form)\n  form.querySelector('[type=\"submit\"]').click()\n\n  stopEverything(e)\n", "patch": "@@ -1,6 +1,7 @@\n #= require_tree ../utils\n \n { stopEverything } = Rails\n+{ isContentEditable } = Rails\n \n # Handles \"data-method\" on links such as:\n # <a href=\"/users/5\" data-method=\"delete\" rel=\"nofollow\" data-confirm=\"Are you sure?\">Delete</a>\n@@ -9,6 +10,9 @@ Rails.handleMethod = (e) ->\n   method = link.getAttribute('data-method')\n   return unless method\n \n+  if isContentEditable(this)\n+    return\n+\n   href = Rails.href(link)\n   csrfToken = Rails.csrfToken()\n   csrfParam = Rails.csrfParam()"}
{"patches_id": 6, "files_id": 30, "language": "coffee", "raw_url": "https://github.com/rails/rails/raw/73009ea59a811b28e8ec2a9c9bc24635aa891214/actionview%2Fapp%2Fassets%2Fjavascripts%2Frails-ujs%2Ffeatures%2Fremote.coffee", "raw_code": "#= require_tree ../utils\n\n{\n  matches, getData, setData\n  fire, stopEverything\n  ajax, isCrossDomain\n  serializeElement,\n  isContentEditable\n} = Rails\n\n# Checks \"data-remote\" if true to handle the request through a XHR request.\nisRemote = (element) ->\n  value = element.getAttribute('data-remote')\n  value? and value isnt 'false'\n\n# Submits \"remote\" forms and links with ajax\nRails.handleRemote = (e) ->\n  element = this\n\n  return true unless isRemote(element)\n  unless fire(element, 'ajax:before')\n    fire(element, 'ajax:stopped')\n    return false\n\n  if isContentEditable(element)\n    fire(element, 'ajax:stopped')\n    return false\n\n  withCredentials = element.getAttribute('data-with-credentials')\n  dataType = element.getAttribute('data-type') or 'script'\n\n  if matches(element, Rails.formSubmitSelector)\n    # memoized value from clicked submit button\n    button = getData(element, 'ujs:submit-button')\n    method = getData(element, 'ujs:submit-button-formmethod') or element.method\n    url = getData(element, 'ujs:submit-button-formaction') or element.getAttribute('action') or location.href\n\n    # strip query string if it's a GET request\n    url = url.replace(/\\?.*$/, '') if method.toUpperCase() is 'GET'\n\n    if element.enctype is 'multipart/form-data'\n      data = new FormData(element)\n      data.append(button.name, button.value) if button?\n    else\n      data = serializeElement(element, button)\n\n    setData(element, 'ujs:submit-button', null)\n    setData(element, 'ujs:submit-button-formmethod', null)\n    setData(element, 'ujs:submit-button-formaction', null)\n  else if matches(element, Rails.buttonClickSelector) or matches(element, Rails.inputChangeSelector)\n    method = element.getAttribute('data-method')\n    url = element.getAttribute('data-url')\n    data = serializeElement(element, element.getAttribute('data-params'))\n  else\n    method = element.getAttribute('data-method')\n    url = Rails.href(element)\n    data = element.getAttribute('data-params')\n\n  ajax(\n    type: method or 'GET'\n    url: url\n    data: data\n    dataType: dataType\n    # stopping the \"ajax:beforeSend\" event will cancel the ajax request\n    beforeSend: (xhr, options) ->\n      if fire(element, 'ajax:beforeSend', [xhr, options])\n        fire(element, 'ajax:send', [xhr])\n      else\n        fire(element, 'ajax:stopped')\n        return false\n    success: (args...) -> fire(element, 'ajax:success', args)\n    error: (args...) -> fire(element, 'ajax:error', args)\n    complete: (args...) -> fire(element, 'ajax:complete', args)\n    crossDomain: isCrossDomain(url)\n    withCredentials: withCredentials? and withCredentials isnt 'false'\n  )\n  stopEverything(e)\n\nRails.formSubmitButtonClick = (e) ->\n  button = this\n  form = button.form\n  return unless form\n  # Register the pressed submit button\n  setData(form, 'ujs:submit-button', name: button.name, value: button.value) if button.name\n  # Save attributes from button\n  setData(form, 'ujs:formnovalidate-button', button.formNoValidate)\n  setData(form, 'ujs:submit-button-formaction', button.getAttribute('formaction'))\n  setData(form, 'ujs:submit-button-formmethod', button.getAttribute('formmethod'))\n\nRails.preventInsignificantClick = (e) ->\n  link = this\n  method = (link.getAttribute('data-method') or 'GET').toUpperCase()\n  data = link.getAttribute('data-params')\n  metaClick = e.metaKey or e.ctrlKey\n  insignificantMetaClick = metaClick and method is 'GET' and not data\n  nonPrimaryMouseClick = e.button? and e.button isnt 0\n  e.stopImmediatePropagation() if nonPrimaryMouseClick or insignificantMetaClick\n\n", "patch": "@@ -4,7 +4,8 @@\n   matches, getData, setData\n   fire, stopEverything\n   ajax, isCrossDomain\n-  serializeElement\n+  serializeElement,\n+  isContentEditable\n } = Rails\n \n # Checks \"data-remote\" if true to handle the request through a XHR request.\n@@ -21,6 +22,10 @@ Rails.handleRemote = (e) ->\n     fire(element, 'ajax:stopped')\n     return false\n \n+  if isContentEditable(element)\n+    fire(element, 'ajax:stopped')\n+    return false\n+\n   withCredentials = element.getAttribute('data-with-credentials')\n   dataType = element.getAttribute('data-type') or 'script'\n "}
{"patches_id": 6, "files_id": 31, "language": "coffee", "raw_url": "https://github.com/rails/rails/raw/73009ea59a811b28e8ec2a9c9bc24635aa891214/actionview%2Fapp%2Fassets%2Fjavascripts%2Frails-ujs%2Futils%2Fdom.coffee", "raw_code": "m = Element.prototype.matches or\n    Element.prototype.matchesSelector or\n    Element.prototype.mozMatchesSelector or\n    Element.prototype.msMatchesSelector or\n    Element.prototype.oMatchesSelector or\n    Element.prototype.webkitMatchesSelector\n\n# Checks if the given native dom element matches the selector\n# element::\n#   native DOM element\n# selector::\n#   CSS selector string or\n#   a JavaScript object with `selector` and `exclude` properties\n#   Examples: \"form\", { selector: \"form\", exclude: \"form[data-remote='true']\"}\nRails.matches = (element, selector) ->\n  if selector.exclude?\n    m.call(element, selector.selector) and not m.call(element, selector.exclude)\n  else\n    m.call(element, selector)\n\n# get and set data on a given element using \"expando properties\"\n# See: https://developer.mozilla.org/en-US/docs/Glossary/Expando\nexpando = '_ujsData'\n\nRails.getData = (element, key) ->\n  element[expando]?[key]\n\nRails.setData = (element, key, value) ->\n  element[expando] ?= {}\n  element[expando][key] = value\n\nRails.isContentEditable = (element) ->\n  isEditable = false\n  loop\n    if(element.isContentEditable)\n      isEditable = true\n      break\n\n    element = element.parentElement\n    break unless(element)\n\n  return isEditable\n\n# a wrapper for document.querySelectorAll\n# returns an Array\nRails.$ = (selector) ->\n  Array.prototype.slice.call(document.querySelectorAll(selector))\n", "patch": "@@ -29,6 +29,18 @@ Rails.setData = (element, key, value) ->\n   element[expando] ?= {}\n   element[expando][key] = value\n \n+Rails.isContentEditable = (element) ->\n+  isEditable = false\n+  loop\n+    if(element.isContentEditable)\n+      isEditable = true\n+      break\n+\n+    element = element.parentElement\n+    break unless(element)\n+\n+  return isEditable\n+\n # a wrapper for document.querySelectorAll\n # returns an Array\n Rails.$ = (selector) ->"}
{"patches_id": 6, "files_id": 32, "language": "js", "raw_url": "https://github.com/rails/rails/raw/73009ea59a811b28e8ec2a9c9bc24635aa891214/actionview%2Ftest%2Fujs%2Fpublic%2Ftest%2Fdata-disable-with.js", "raw_code": "module('data-disable-with', {\n  setup: function() {\n    $('#qunit-fixture').append($('<form />', {\n      action: '/echo',\n      'data-remote': 'true',\n      method: 'post'\n    }))\n      .find('form')\n      .append($('<input type=\"text\" data-disable-with=\"processing ...\" name=\"user_name\" value=\"john\" />'))\n\n    $('#qunit-fixture').append($('<form />', {\n      action: '/echo',\n      method: 'post',\n      id: 'not_remote'\n    }))\n      .find('form:last')\n      // WEEIRDD: the form won't submit to an iframe if the button is name=\"submit\" (??!)\n      .append($('<input type=\"submit\" data-disable-with=\"submitting ...\" name=\"submit2\" value=\"Submit\" />'))\n\n    $('#qunit-fixture').append($('<a />', {\n      text: 'Click me',\n      href: '/echo',\n      'data-disable-with': 'clicking...'\n    }))\n\n    $('#qunit-fixture').append($('<input />', {\n      type: 'submit',\n      form: 'not_remote',\n      'data-disable-with': 'form attr submitting',\n      name: 'submit3',\n      value: 'Form Attr Submit'\n    }))\n\n    $('#qunit-fixture').append($('<button />', {\n      text: 'Click me',\n      'data-remote': true,\n      'data-url': '/echo',\n      'data-disable-with': 'clicking...'\n    }))\n\n    $('#qunit-fixture').append($('<div />', {\n      id: 'edit-div', 'contenteditable': 'true'\n    }))\n  },\n  teardown: function() {\n    $(document).unbind('iframe:loaded')\n  }\n})\n\nasyncTest('form input field with \"data-disable-with\" attribute', 7, function() {\n  var form = $('form[data-remote]'), input = form.find('input[type=text]')\n\n  App.checkEnabledState(input, 'john')\n\n  form.bindNative('ajax:success', function(e, data) {\n    setTimeout(function() {\n      App.checkEnabledState(input, 'john')\n      equal(data.params.user_name, 'john')\n      start()\n    }, 13)\n  })\n  form.triggerNative('submit')\n\n  App.checkDisabledState(input, 'processing ...')\n})\n\nasyncTest('blank form input field with \"data-disable-with\" attribute', 7, function() {\n  var form = $('form[data-remote]'), input = form.find('input[type=text]')\n\n  input.val('')\n  App.checkEnabledState(input, '')\n\n  form.bindNative('ajax:success', function(e, data) {\n    setTimeout(function() {\n      App.checkEnabledState(input, '')\n      equal(data.params.user_name, '')\n      start()\n    }, 13)\n  })\n  form.triggerNative('submit')\n\n  App.checkDisabledState(input, 'processing ...')\n})\n\nasyncTest('form button with \"data-disable-with\" attribute', 6, function() {\n  var form = $('form[data-remote]'), button = $('<button data-disable-with=\"submitting ...\" name=\"submit2\">Submit</button>')\n  form.append(button)\n\n  App.checkEnabledState(button, 'Submit')\n\n  form.bindNative('ajax:success', function(e, data) {\n    setTimeout(function() {\n      App.checkEnabledState(button, 'Submit')\n      start()\n    }, 13)\n  })\n  form.triggerNative('submit')\n\n  App.checkDisabledState(button, 'submitting ...')\n})\n\nasyncTest('a[data-remote][data-disable-with] within a form disables and re-enables', 6, function() {\n  var form = $('form:not([data-remote])'),\n      link = $('<a data-remote=\"true\" data-disable-with=\"clicking...\">Click me</a>')\n  form.append(link)\n\n  App.checkEnabledState(link, 'Click me')\n\n  link\n    .bindNative('ajax:beforeSend', function() {\n      App.checkDisabledState(link, 'clicking...')\n    })\n    .bindNative('ajax:complete', function() {\n      setTimeout( function() {\n        App.checkEnabledState(link, 'Click me')\n        link.remove()\n        start()\n      }, 15)\n    })\n    .triggerNative('click')\n})\n\nasyncTest('form input[type=submit][data-disable-with] disables', 6, function() {\n  var form = $('form:not([data-remote])'), input = form.find('input[type=submit]')\n\n  App.checkEnabledState(input, 'Submit')\n\n  $(document).bind('iframe:loaded', function(e, data) {\n    setTimeout(function() {\n      App.checkDisabledState(input, 'submitting ...')\n      start()\n    }, 30)\n  })\n  form.triggerNative('submit')\n\n  setTimeout(function() {\n    App.checkDisabledState(input, 'submitting ...')\n  }, 30)\n})\n\ntest('form input[type=submit][data-disable-with] re-enables when `pageshow` event is triggered', function() {\n  var form = $('form:not([data-remote])'), input = form.find('input[type=submit]')\n\n  App.checkEnabledState(input, 'Submit')\n\n  // Emulate the disabled state without submitting the form at all, what is the\n  // state after going back on firefox after submitting a form.\n  //\n  // See https://github.com/rails/jquery-ujs/issues/357\n  $.rails.disableElement(form[0])\n\n  App.checkDisabledState(input, 'submitting ...')\n\n  $(window).triggerNative('pageshow')\n\n  App.checkEnabledState(input, 'Submit')\n})\n\nasyncTest('form[data-remote] input[type=submit][data-disable-with] is replaced in ajax callback', 2, function() {\n  var form = $('#qunit-fixture form:not([data-remote])').attr('data-remote', 'true'),\n      origFormContents = form.html()\n\n  form.bindNative('ajax:success', function() {\n    form.html(origFormContents)\n\n    setTimeout(function() {\n      var input = form.find('input[type=submit]')\n      App.checkEnabledState(input, 'Submit')\n      start()\n    }, 30)\n  }).triggerNative('submit')\n})\n\nasyncTest('form[data-remote] input[data-disable-with] is replaced with disabled field in ajax callback', 2, function() {\n  var form = $('#qunit-fixture form:not([data-remote])').attr('data-remote', 'true'),\n      input = form.find('input[type=submit]'),\n      newDisabledInput = input.clone().attr('disabled', 'disabled')\n\n  form.bindNative('ajax:success', function() {\n    input.replaceWith(newDisabledInput)\n\n    setTimeout(function() {\n      App.checkEnabledState(newDisabledInput, 'Submit')\n      start()\n    }, 30)\n  }).triggerNative('submit')\n})\n\nasyncTest('form input[type=submit][data-disable-with] using \"form\" attribute disables', 6, function() {\n  var form = $('#not_remote'), input = $('input[form=not_remote]')\n  App.checkEnabledState(input, 'Form Attr Submit')\n\n  $(document).bind('iframe:loaded', function(e, data) {\n    setTimeout(function() {\n      App.checkDisabledState(input, 'form attr submitting')\n      start()\n    }, 30)\n  })\n  form.triggerNative('submit')\n\n  setTimeout(function() {\n    App.checkDisabledState(input, 'form attr submitting')\n  }, 30)\n\n})\n\nasyncTest('form[data-remote] textarea[data-disable-with] attribute', 3, function() {\n  var form = $('form[data-remote]'),\n      textarea = $('<textarea data-disable-with=\"processing ...\" name=\"user_bio\">born, lived, died.</textarea>').appendTo(form)\n\n  form.bindNative('ajax:success', function(e, data) {\n    setTimeout(function() {\n      equal(data.params.user_bio, 'born, lived, died.')\n      start()\n    }, 13)\n  })\n  form.triggerNative('submit')\n\n  App.checkDisabledState(textarea, 'processing ...')\n})\n\nasyncTest('a[data-disable-with] disables', 4, function() {\n  var link = $('a[data-disable-with]')\n\n  App.checkEnabledState(link, 'Click me')\n\n  link.triggerNative('click')\n  App.checkDisabledState(link, 'clicking...')\n  start()\n})\n\ntest('a[data-disable-with] re-enables when `pageshow` event is triggered', function() {\n  var link = $('a[data-disable-with]')\n\n  App.checkEnabledState(link, 'Click me')\n\n  link.triggerNative('click')\n  App.checkDisabledState(link, 'clicking...')\n\n  $(window).triggerNative('pageshow')\n  App.checkEnabledState(link, 'Click me')\n})\n\nasyncTest('a[data-remote][data-disable-with] disables and re-enables', 6, function() {\n  var link = $('a[data-disable-with]').attr('data-remote', true)\n\n  App.checkEnabledState(link, 'Click me')\n\n  link\n    .bindNative('ajax:beforeSend', function() {\n      App.checkDisabledState(link, 'clicking...')\n    })\n    .bindNative('ajax:complete', function() {\n      setTimeout( function() {\n        App.checkEnabledState(link, 'Click me')\n        start()\n      }, 15)\n    })\n    .triggerNative('click')\n})\n\nasyncTest('a[data-remote][data-disable-with] re-enables when `ajax:before` event is cancelled', 6, function() {\n  var link = $('a[data-disable-with]').attr('data-remote', true)\n\n  App.checkEnabledState(link, 'Click me')\n\n  link\n    .bindNative('ajax:before', function(e) {\n      App.checkDisabledState(link, 'clicking...')\n      e.preventDefault()\n    })\n    .triggerNative('click')\n\n  setTimeout(function() {\n    App.checkEnabledState(link, 'Click me')\n    start()\n  }, 30)\n})\n\nasyncTest('a[data-remote][data-disable-with] re-enables when `ajax:beforeSend` event is cancelled', 6, function() {\n  var link = $('a[data-disable-with]').attr('data-remote', true)\n\n  App.checkEnabledState(link, 'Click me')\n\n  link\n    .bindNative('ajax:beforeSend', function(e) {\n      App.checkDisabledState(link, 'clicking...')\n      e.preventDefault()\n    })\n    .triggerNative('click')\n\n  setTimeout(function() {\n    App.checkEnabledState(link, 'Click me')\n    start()\n  }, 30)\n})\n\nasyncTest('a[data-remote][data-disable-with] re-enables when `ajax:error` event is triggered', 6, function() {\n  var link = $('a[data-disable-with]').attr('data-remote', true).attr('href', '/error')\n\n  App.checkEnabledState(link, 'Click me')\n\n  link\n    .bindNative('ajax:beforeSend', function() {\n      App.checkDisabledState(link, 'clicking...')\n    })\n    .triggerNative('click')\n\n  setTimeout(function() {\n    App.checkEnabledState(link, 'Click me')\n    start()\n  }, 30)\n})\n\nasyncTest('form[data-remote] input|button|textarea[data-disable-with] does not disable when `ajax:beforeSend` event is cancelled', 8, function() {\n  var form = $('form[data-remote]'),\n      input = form.find('input:text'),\n      button = $('<button data-disable-with=\"submitting ...\" name=\"submit2\">Submit</button>').appendTo(form),\n      textarea = $('<textarea data-disable-with=\"processing ...\" name=\"user_bio\">born, lived, died.</textarea>').appendTo(form),\n      submit = $('<input type=\"submit\" data-disable-with=\"submitting ...\" name=\"submit2\" value=\"Submit\" />').appendTo(form)\n\n  form\n    .bindNative('ajax:beforeSend', function(e) {\n      e.preventDefault()\n      e.stopPropagation()\n    })\n    .triggerNative('submit')\n\n  App.checkEnabledState(input, 'john')\n  App.checkEnabledState(button, 'Submit')\n  App.checkEnabledState(textarea, 'born, lived, died.')\n  App.checkEnabledState(submit, 'Submit')\n\n  start()\n})\n\nasyncTest('ctrl-clicking on a link does not disable the link', 6, function() {\n  var link = $('a[data-disable-with]')\n\n  App.checkEnabledState(link, 'Click me')\n\n  link.triggerNative('click', { metaKey: true })\n  App.checkEnabledState(link, 'Click me')\n\n  link.triggerNative('click', { metaKey: true })\n  App.checkEnabledState(link, 'Click me')\n  start()\n})\n\nasyncTest('right/mouse-wheel-clicking on a link does not disable the link', 10, function() {\n  var link = $('a[data-disable-with]')\n\n  App.checkEnabledState(link, 'Click me')\n\n  link.triggerNative('click', { button: 1 })\n  App.checkEnabledState(link, 'Click me')\n\n  link.triggerNative('click', { button: 1 })\n  App.checkEnabledState(link, 'Click me')\n\n  link.triggerNative('click', { button: 2 })\n  App.checkEnabledState(link, 'Click me')\n\n  link.triggerNative('click', { button: 2 })\n  App.checkEnabledState(link, 'Click me')\n  start()\n})\n\nasyncTest('button[data-remote][data-disable-with] disables and re-enables', 6, function() {\n  var button = $('button[data-remote][data-disable-with]')\n\n  App.checkEnabledState(button, 'Click me')\n\n  button\n    .bindNative('ajax:send', function() {\n      App.checkDisabledState(button, 'clicking...')\n    })\n    .bindNative('ajax:complete', function() {\n      setTimeout( function() {\n        App.checkEnabledState(button, 'Click me')\n        start()\n      }, 15)\n    })\n    .triggerNative('click')\n})\n\nasyncTest('button[data-remote][data-disable-with] re-enables when `ajax:before` event is cancelled', 6, function() {\n  var button = $('button[data-remote][data-disable-with]')\n\n  App.checkEnabledState(button, 'Click me')\n\n  button\n    .bindNative('ajax:before', function(e) {\n      App.checkDisabledState(button, 'clicking...')\n      e.preventDefault()\n    })\n    .triggerNative('click')\n\n  setTimeout(function() {\n    App.checkEnabledState(button, 'Click me')\n    start()\n  }, 30)\n})\n\nasyncTest('button[data-remote][data-disable-with] re-enables when `ajax:beforeSend` event is cancelled', 6, function() {\n  var button = $('button[data-remote][data-disable-with]')\n\n  App.checkEnabledState(button, 'Click me')\n\n  button\n    .bindNative('ajax:beforeSend', function(e) {\n      App.checkDisabledState(button, 'clicking...')\n      e.preventDefault()\n    })\n    .triggerNative('click')\n\n  setTimeout(function() {\n    App.checkEnabledState(button, 'Click me')\n    start()\n  }, 30)\n})\n\nasyncTest('button[data-remote][data-disable-with] re-enables when `ajax:error` event is triggered', 6, function() {\n  var button = $('a[data-disable-with]').attr('data-remote', true).attr('href', '/error')\n\n  App.checkEnabledState(button, 'Click me')\n\n  button\n    .bindNative('ajax:send', function() {\n      App.checkDisabledState(button, 'clicking...')\n    })\n    .triggerNative('click')\n\n  setTimeout(function() {\n    App.checkEnabledState(button, 'Click me')\n    start()\n  }, 30)\n})\n\nasyncTest('form button with \"data-disable-with\" attribute and contenteditable is not modified', 6, function() {\n  var form = $('form[data-remote]'), button = $('<button data-disable-with=\"submitting ...\" name=\"submit2\">Submit</button>')\n\n  var contenteditable_div = $('#qunit-fixture').find('div')\n  form.append(button)\n  contenteditable_div.append(form)\n\n  App.checkEnabledState(button, 'Submit')\n\n  setTimeout(function() {\n    App.checkEnabledState(button, 'Submit')\n    start()\n  }, 13)\n  form.triggerNative('submit')\n\n  App.checkEnabledState(button, 'Submit')\n})\n", "patch": "@@ -37,6 +37,10 @@ module('data-disable-with', {\n       'data-url': '/echo',\n       'data-disable-with': 'clicking...'\n     }))\n+\n+    $('#qunit-fixture').append($('<div />', {\n+      id: 'edit-div', 'contenteditable': 'true'\n+    }))\n   },\n   teardown: function() {\n     $(document).unbind('iframe:loaded')\n@@ -432,3 +436,21 @@ asyncTest('button[data-remote][data-disable-with] re-enables when `ajax:error` e\n     start()\n   }, 30)\n })\n+\n+asyncTest('form button with \"data-disable-with\" attribute and contenteditable is not modified', 6, function() {\n+  var form = $('form[data-remote]'), button = $('<button data-disable-with=\"submitting ...\" name=\"submit2\">Submit</button>')\n+\n+  var contenteditable_div = $('#qunit-fixture').find('div')\n+  form.append(button)\n+  contenteditable_div.append(form)\n+\n+  App.checkEnabledState(button, 'Submit')\n+\n+  setTimeout(function() {\n+    App.checkEnabledState(button, 'Submit')\n+    start()\n+  }, 13)\n+  form.triggerNative('submit')\n+\n+  App.checkEnabledState(button, 'Submit')\n+})"}
{"patches_id": 6, "files_id": 33, "language": "js", "raw_url": "https://github.com/rails/rails/raw/73009ea59a811b28e8ec2a9c9bc24635aa891214/actionview%2Ftest%2Fujs%2Fpublic%2Ftest%2Fdata-method.js", "raw_code": "(function() {\n\nmodule('data-method', {\n  setup: function() {\n    $('#qunit-fixture').append($('<a />', {\n      href: '/echo', 'data-method': 'delete', text: 'destroy!'\n    }))\n\n    $('#qunit-fixture').append($('<div />', {\n      id: 'edit-div', 'contenteditable': 'true'\n    }))\n  },\n  teardown: function() {\n    $(document).unbind('iframe:loaded')\n  }\n})\n\nfunction submit(fn, options) {\n  $(document).bind('iframe:loaded', function(e, data) {\n    fn(data)\n    start()\n  })\n\n  $('#qunit-fixture').find('a')\n    .triggerNative('click')\n}\n\nasyncTest('link with \"data-method\" set to \"delete\"', 3, function() {\n  submit(function(data) {\n    equal(data.REQUEST_METHOD, 'DELETE')\n    strictEqual(data.params.authenticity_token, undefined)\n    strictEqual(data.HTTP_X_CSRF_TOKEN, undefined)\n  })\n})\n\nasyncTest('click on the child of link with \"data-method\"', 3, function() {\n  $(document).bind('iframe:loaded', function(e, data) {\n    equal(data.REQUEST_METHOD, 'DELETE')\n    strictEqual(data.params.authenticity_token, undefined)\n    strictEqual(data.HTTP_X_CSRF_TOKEN, undefined)\n    start()\n  })\n  $('#qunit-fixture a').html('<strong>destroy!</strong>').find('strong').triggerNative('click')\n})\n\nasyncTest('link with \"data-method\" and CSRF', 1, function() {\n  $('#qunit-fixture')\n    .append('<meta name=\"csrf-param\" content=\"authenticity_token\"/>')\n    .append('<meta name=\"csrf-token\" content=\"cf50faa3fe97702ca1ae\"/>')\n\n  submit(function(data) {\n    equal(data.params.authenticity_token, 'cf50faa3fe97702ca1ae')\n  })\n})\n\nasyncTest('link \"target\" should be carried over to generated form', 1, function() {\n  $('a[data-method]').attr('target', 'super-special-frame')\n  submit(function(data) {\n    equal(data.params._target, 'super-special-frame')\n  })\n})\n\nasyncTest('link with \"data-method\" and cross origin', 1, function() {\n  var data = {}\n\n  $('#qunit-fixture')\n    .append('<meta name=\"csrf-param\" content=\"authenticity_token\"/>')\n    .append('<meta name=\"csrf-token\" content=\"cf50faa3fe97702ca1ae\"/>')\n\n  $(document).on('submit', 'form', function(e) {\n    $(e.currentTarget).serializeArray().map(function(item) {\n      data[item.name] = item.value\n    })\n\n    return false\n  })\n\n  var link = $('#qunit-fixture').find('a')\n\n  link.attr('href', 'http://www.alfajango.com')\n\n  link.triggerNative('click')\n\n  start()\n\n  notEqual(data.authenticity_token, 'cf50faa3fe97702ca1ae')\n})\n\nasyncTest('do not interact with contenteditable elements', 6, function() {\n  var contenteditable_div = $('#qunit-fixture').find('div')\n  contenteditable_div.append('<a href=\"http://www.shouldnevershowindocument.com\" data-method=\"delete\">')\n\n  var link = $('#edit-div').find('a')\n  link.triggerNative('click')\n\n  start()\n\n  collection = document.getElementsByTagName('form')\n  for (const item of collection) {\n    notEqual(item.action, \"http://www.shouldnevershowindocument.com/\")\n  }\n})\n\n})()\n", "patch": "@@ -5,6 +5,10 @@ module('data-method', {\n     $('#qunit-fixture').append($('<a />', {\n       href: '/echo', 'data-method': 'delete', text: 'destroy!'\n     }))\n+\n+    $('#qunit-fixture').append($('<div />', {\n+      id: 'edit-div', 'contenteditable': 'true'\n+    }))\n   },\n   teardown: function() {\n     $(document).unbind('iframe:loaded')\n@@ -82,4 +86,19 @@ asyncTest('link with \"data-method\" and cross origin', 1, function() {\n   notEqual(data.authenticity_token, 'cf50faa3fe97702ca1ae')\n })\n \n+asyncTest('do not interact with contenteditable elements', 6, function() {\n+  var contenteditable_div = $('#qunit-fixture').find('div')\n+  contenteditable_div.append('<a href=\"http://www.shouldnevershowindocument.com\" data-method=\"delete\">')\n+\n+  var link = $('#edit-div').find('a')\n+  link.triggerNative('click')\n+\n+  start()\n+\n+  collection = document.getElementsByTagName('form')\n+  for (const item of collection) {\n+    notEqual(item.action, \"http://www.shouldnevershowindocument.com/\")\n+  }\n+})\n+\n })()"}
{"patches_id": 6, "files_id": 34, "language": "js", "raw_url": "https://github.com/rails/rails/raw/73009ea59a811b28e8ec2a9c9bc24635aa891214/actionview%2Ftest%2Fujs%2Fpublic%2Ftest%2Fdata-remote.js", "raw_code": "(function() {\n\nfunction buildSelect(attrs) {\n  attrs = $.extend({\n    'name': 'user_data', 'data-remote': 'true', 'data-url': '/echo', 'data-params': 'data1=value1'\n  }, attrs)\n\n  $('#qunit-fixture').append(\n    $('<select />', attrs)\n      .append($('<option />', {value: 'optionValue1', text: 'option1'}))\n      .append($('<option />', {value: 'optionValue2', text: 'option2'}))\n  )\n}\n\nmodule('data-remote', {\n  setup: function() {\n    $('#qunit-fixture')\n      .append($('<a />', {\n        href: '/echo',\n        'data-remote': 'true',\n        'data-params': 'data1=value1&data2=value2',\n        text: 'my address'\n      }))\n      .append($('<button />', {\n        'data-url': '/echo',\n        'data-remote': 'true',\n        'data-params': 'data1=value1&data2=value2',\n        text: 'my button'\n      }))\n      .append($('<form />', {\n        action: '/echo',\n        'data-remote': 'true',\n        method: 'post',\n        id: 'my-remote-form'\n      }))\n      .append($('<a />', {\n        href: '/echo',\n        'data-remote': 'true',\n        disabled: 'disabled',\n        text: 'Disabled link'\n      }))\n      .find('form').append($('<input type=\"text\" name=\"user_name\" value=\"john\">'))\n\n    $('#qunit-fixture').append($('<div />', {\n      id: 'edit-div', 'contenteditable': 'true'\n    }))\n  }\n})\n\nasyncTest('ctrl-clicking on a link does not fire ajaxyness', 0, function() {\n  var link = $('a[data-remote]')\n\n  // Ideally, we'd set up an iframe to intercept normal link clicks\n  // and add a test to make sure the iframe:loaded event is triggered.\n  // However, jquery doesn't actually cause a native `click` event and\n  // follow links using `trigger('click')`, it only fires bindings.\n  link\n    .removeAttr('data-params')\n    .bindNative('ajax:beforeSend', function() {\n      ok(false, 'ajax should not be triggered')\n    })\n\n  link.triggerNative('click', { metaKey: true })\n  link.triggerNative('click', { ctrlKey: true })\n\n  setTimeout(function() { start() }, 13)\n})\n\nasyncTest('right/mouse-wheel-clicking on a link does not fire ajaxyness', 0, function() {\n  var link = $('a[data-remote]')\n\n  // Ideally, we'd set up an iframe to intercept normal link clicks\n  // and add a test to make sure the iframe:loaded event is triggered.\n  // However, jquery doesn't actually cause a native `click` event and\n  // follow links using `trigger('click')`, it only fires bindings.\n  link\n    .removeAttr('data-params')\n    .bindNative('ajax:beforeSend', function() {\n      ok(false, 'ajax should not be triggered')\n    })\n\n  link.triggerNative('click', { button: 1 })\n  link.triggerNative('click', { button: 2 })\n\n  setTimeout(function() { start() }, 13)\n})\n\nasyncTest('clicking on a link via a non-mouse Event (such as from js) works', 1, function() {\n  var link = $('a[data-remote]')\n\n  link\n    .removeAttr('data-params')\n    .bindNative('ajax:beforeSend', function() {\n      ok(true, 'ajax should be triggered')\n    })\n\n  Rails.fire(link[0], 'click')\n\n  setTimeout(function() { start() }, 13)\n})\n\nasyncTest('ctrl-clicking on a link still fires ajax for non-GET links and for links with \"data-params\"', 2, function() {\n  var link = $('a[data-remote]')\n\n  link\n    .removeAttr('data-params')\n    .attr('data-method', 'POST')\n    .bindNative('ajax:beforeSend', function() {\n      ok(true, 'ajax should be triggered')\n    })\n    .triggerNative('click', { metaKey: true })\n\n  link\n    .removeAttr('data-method')\n    .attr('data-params', 'name=steve')\n    .triggerNative('click', { metaKey: true })\n\n  setTimeout(function() { start() }, 13)\n})\n\nasyncTest('clicking on a link with data-remote attribute', 5, function() {\n  $('a[data-remote]')\n    .bindNative('ajax:success', function(e, data, status, xhr) {\n      App.assertCallbackInvoked('ajax:success')\n      App.assertRequestPath(data, '/echo')\n      equal(data.params.data1, 'value1', 'ajax arguments should have key data1 with right value')\n      equal(data.params.data2, 'value2', 'ajax arguments should have key data2 with right value')\n      App.assertGetRequest(data)\n    })\n    .bindNative('ajax:complete', function() { start() })\n    .triggerNative('click')\n})\n\nasyncTest('clicking on a link with both query string in href and data-params', 4, function() {\n  $('a[data-remote]')\n    .attr('href', '/echo?data3=value3')\n    .bindNative('ajax:success', function(e, data, status, xhr) {\n      App.assertGetRequest(data)\n      equal(data.params.data1, 'value1', 'ajax arguments should have key data1 with right value')\n      equal(data.params.data2, 'value2', 'ajax arguments should have key data2 with right value')\n      equal(data.params.data3, 'value3', 'query string in URL should be passed to server with right value')\n    })\n    .bindNative('ajax:complete', function() { start() })\n    .triggerNative('click')\n})\n\nasyncTest('clicking on a link with both query string in href and data-params with POST method', 4, function() {\n  $('a[data-remote]')\n    .attr('href', '/echo?data3=value3')\n    .attr('data-method', 'post')\n    .bindNative('ajax:success', function(e, data, status, xhr) {\n      App.assertPostRequest(data)\n      equal(data.params.data1, 'value1', 'ajax arguments should have key data1 with right value')\n      equal(data.params.data2, 'value2', 'ajax arguments should have key data2 with right value')\n      equal(data.params.data3, 'value3', 'query string in URL should be passed to server with right value')\n    })\n    .bindNative('ajax:complete', function() { start() })\n    .triggerNative('click')\n})\n\nasyncTest('clicking on a link with disabled attribute', 0, function() {\n  $('a[disabled]')\n  .bindNative('ajax:before', function(e, data, status, xhr) {\n    App.assertCallbackNotInvoked('ajax:success')\n  })\n  .bindNative('ajax:complete', function() { start() })\n  .triggerNative('click')\n\n  setTimeout(function() {\n    start()\n  }, 13)\n})\n\nasyncTest('clicking on a button with data-remote attribute', 5, function() {\n  $('button[data-remote]')\n    .bindNative('ajax:success', function(e, data, status, xhr) {\n      App.assertCallbackInvoked('ajax:success')\n      App.assertRequestPath(data, '/echo')\n      equal(data.params.data1, 'value1', 'ajax arguments should have key data1 with right value')\n      equal(data.params.data2, 'value2', 'ajax arguments should have key data2 with right value')\n      App.assertGetRequest(data)\n    })\n    .bindNative('ajax:complete', function() { start() })\n    .triggerNative('click')\n})\n\nasyncTest('right/mouse-wheel-clicking on a button with data-remote attribute does not fire ajaxyness', 0, function() {\n  var button = $('button[data-remote]')\n\n  // Ideally, we'd set up an iframe to intercept normal link clicks\n  // and add a test to make sure the iframe:loaded event is triggered.\n  // However, jquery doesn't actually cause a native `click` event and\n  // follow links using `trigger('click')`, it only fires bindings.\n  button\n    .removeAttr('data-params')\n    .bindNative('ajax:beforeSend', function() {\n      ok(false, 'ajax should not be triggered')\n    })\n\n  button.triggerNative('click', { button: 1 })\n  button.triggerNative('click', { button: 2 })\n\n  setTimeout(function() { start() }, 13)\n})\n\nasyncTest('changing a select option with data-remote attribute', 5, function() {\n  buildSelect()\n\n  $('select[data-remote]')\n    .bindNative('ajax:success', function(e, data, status, xhr) {\n      App.assertCallbackInvoked('ajax:success')\n      App.assertRequestPath(data, '/echo')\n      equal(data.params.user_data, 'optionValue2', 'ajax arguments should have key term with right value')\n      equal(data.params.data1, 'value1', 'ajax arguments should have key data1 with right value')\n      App.assertGetRequest(data)\n    })\n    .bindNative('ajax:complete', function() { start() })\n    .val('optionValue2')\n    .triggerNative('change')\n})\n\nasyncTest('submitting form with data-remote attribute', 4, function() {\n  $('form[data-remote]')\n    .bindNative('ajax:success', function(e, data, status, xhr) {\n      App.assertCallbackInvoked('ajax:success')\n      App.assertRequestPath(data, '/echo')\n      equal(data.params.user_name, 'john', 'ajax arguments should have key user_name with right value')\n      App.assertPostRequest(data)\n    })\n    .bindNative('ajax:complete', function() { start() })\n    .triggerNative('submit')\n})\n\nasyncTest('submitting form with data-remote attribute should include inputs in a fieldset only once', 3, function() {\n  $('form[data-remote]')\n    .append('<fieldset><input name=\"items[]\" value=\"Item\" /></fieldset>')\n    .bindNative('ajax:success', function(e, data, status, xhr) {\n      App.assertCallbackInvoked('ajax:success')\n      equal(data.params.items.length, 1, 'ajax arguments should only have the item once')\n      App.assertPostRequest(data)\n    })\n    .bindNative('ajax:complete', function() {\n      $('form[data-remote], fieldset').remove()\n      start()\n    })\n    .triggerNative('submit')\n})\n\nasyncTest('submitting form with data-remote attribute submits input with matching [form] attribute', 6, function() {\n  $('#qunit-fixture')\n    .append($('<input type=\"text\" name=\"user_data\" value=\"value1\" form=\"my-remote-form\">'))\n    .append($('<input type=\"text\" name=\"user_email\" value=\"from@example.com\" disabled=\"disabled\" form=\"my-remote-form\">'))\n\n  $('form[data-remote]')\n    .bindNative('ajax:success', function(e, data, status, xhr) {\n      App.assertCallbackInvoked('ajax:success')\n      App.assertRequestPath(data, '/echo')\n      equal(data.params.user_name, 'john', 'ajax arguments should have key user_name with right value')\n      equal(data.params.user_data, 'value1', 'ajax arguments should have key user_data with right value')\n      equal(data.params.user_email, undefined, 'ajax arguments should not have disabled field')\n      App.assertPostRequest(data)\n    })\n    .bindNative('ajax:complete', function() { start() })\n    .triggerNative('submit')\n})\n\nasyncTest('submitting form with data-remote attribute by clicking button with matching [form] attribute', 5, function() {\n  $('form[data-remote]')\n    .bindNative('ajax:success', function(e, data, status, xhr) {\n      App.assertCallbackInvoked('ajax:success')\n      App.assertRequestPath(data, '/echo')\n      equal(data.params.user_name, 'john', 'ajax arguments should have key user_name with right value')\n      equal(data.params.user_data, 'value2', 'ajax arguments should have key user_data with right value')\n      App.assertPostRequest(data)\n    })\n    .bindNative('ajax:complete', function() { start() })\n\n  $('<button />', {\n        type: 'submit',\n        name: 'user_data',\n        value: 'value1',\n        form: 'my-remote-form'\n      })\n    .appendTo($('#qunit-fixture'))\n\n  $('<button />', {\n      type: 'submit',\n      name: 'user_data',\n      value: 'value2',\n      form: 'my-remote-form'\n    })\n    .appendTo($('#qunit-fixture'))\n    .triggerNative('click')\n})\n\nasyncTest('form\\'s submit bindings in browsers that don\\'t support submit bubbling', 5, function() {\n  var form = $('form[data-remote]'), directBindingCalled = false\n\n  ok(!directBindingCalled, 'nothing is called')\n\n  form\n    .append($('<input type=\"submit\" />'))\n    .bindNative('submit', function(event) {\n      ok(event.type == 'submit', 'submit event handlers are called with submit event')\n      ok(true, 'binding handler is called')\n      directBindingCalled = true\n    })\n    .bindNative('ajax:beforeSend', function() {\n      ok(true, 'form being submitted via ajax')\n      ok(directBindingCalled, 'binding handler already called')\n    })\n    .bindNative('ajax:complete', function() {\n      start()\n    })\n\n    if(!$.support.submitBubbles) {\n      // Must indirectly submit form via click to trigger jQuery's manual submit bubbling in IE\n      form.find('input[type=submit]')\n      .triggerNative('click')\n    } else {\n      form.triggerNative('submit')\n    }\n})\n\nasyncTest('returning false in form\\'s submit bindings in non-submit-bubbling browsers', 1, function() {\n  var form = $('form[data-remote]')\n\n  form\n    .append($('<input type=\"submit\" />'))\n    .bindNative('submit', function(e) {\n      ok(true, 'binding handler is called')\n      e.preventDefault()\n      e.stopPropagation()\n    })\n    .bindNative('ajax:beforeSend', function() {\n      ok(false, 'form should not be submitted')\n    })\n\n    if (!$.support.submitBubbles) {\n      // Must indirectly submit form via click to trigger jQuery's manual submit bubbling in IE\n      form.find('input[type=submit]').triggerNative('click')\n    } else {\n      form.triggerNative('submit')\n    }\n\n    setTimeout(function() { start() }, 13)\n})\n\nasyncTest('clicking on a link with falsy \"data-remote\" attribute does not fire ajaxyness', 0, function() {\n  $('a[data-remote]')\n    .attr('data-remote', 'false')\n    .bindNative('ajax:beforeSend', function() {\n      ok(false, 'ajax should not be triggered')\n    })\n    .bindNative('click', function(e) {\n      e.preventDefault()\n    })\n    .triggerNative('click')\n\n  setTimeout(function() { start() }, 20)\n})\n\nasyncTest('ctrl-clicking on a link with falsy \"data-remote\" attribute does not fire ajaxyness even if \"data-params\" present', 0, function() {\n  var link = $('a[data-remote]')\n\n  link\n    .removeAttr('data-params')\n    .attr('data-remote', 'false')\n    .attr('data-method', 'POST')\n    .bindNative('ajax:beforeSend', function() {\n      ok(false, 'ajax should not be triggered')\n    })\n    .bindNative('click', function(e) {\n      e.preventDefault()\n    })\n    .triggerNative('click', { metaKey: true })\n\n  link\n    .removeAttr('data-method')\n    .attr('data-params', 'name=steve')\n    .triggerNative('click', { metaKey: true })\n\n  setTimeout(function() { start() }, 20)\n})\n\nasyncTest('clicking on a button with falsy \"data-remote\" attribute', 0, function() {\n  $('button[data-remote]:first')\n    .attr('data-remote', 'false')\n    .bindNative('ajax:beforeSend', function() {\n      ok(false, 'ajax should not be triggered')\n    })\n    .bindNative('click', function(e) {\n      e.preventDefault()\n    })\n    .triggerNative('click')\n\n  setTimeout(function() { start() }, 20)\n})\n\nasyncTest('submitting a form with falsy \"data-remote\" attribute', 0, function() {\n  $('form[data-remote]:first')\n    .attr('data-remote', 'false')\n    .bindNative('ajax:beforeSend', function() {\n      ok(false, 'ajax should not be triggered')\n    })\n    .bindNative('submit', function(e) {\n      e.preventDefault()\n    })\n    .triggerNative('submit')\n\n  setTimeout(function() { start() }, 20)\n})\n\nasyncTest('changing a select option with falsy \"data-remote\" attribute', 0, function() {\n  buildSelect({'data-remote': 'false'})\n\n  $('select[data-remote=false]:first')\n    .bindNative('ajax:beforeSend', function() {\n      ok(false, 'ajax should not be triggered')\n    })\n    .val('optionValue2')\n    .triggerNative('change')\n\n  setTimeout(function() { start() }, 20)\n})\n\nasyncTest('form should be serialized correctly', 6, function() {\n  $('form')\n    .append('<textarea name=\"textarea\">textarea</textarea>')\n    .append('<input type=\"checkbox\" name=\"checkbox[]\" value=\"0\" />')\n    .append('<input type=\"checkbox\" checked=\"checked\" name=\"checkbox[]\" value=\"1\" />')\n    .append('<input type=\"radio\" checked=\"checked\" name=\"radio\" value=\"0\" />')\n    .append('<input type=\"radio\" name=\"radio\" value=\"1\" />')\n    .append('<select multiple=\"multiple\" name=\"select[]\">\\\n      <option value=\"1\" selected>1</option>\\\n      <option value=\"2\" selected>2</option>\\\n      <option value=\"3\">3</option>\\\n      <option selected>4</option>\\\n    </select>')\n    .bindNative('ajax:success', function(e, data, status, xhr) {\n      equal(data.params.checkbox.length, 1)\n      equal(data.params.checkbox[0], '1')\n      equal(data.params.radio, '0')\n      equal(data.params.select.length, 3)\n      equal(data.params.select[2], '4')\n      equal(data.params.textarea, 'textarea')\n\n      start()\n    })\n    .triggerNative('submit')\n})\n\nasyncTest('form buttons should only be serialized when clicked', 4, function() {\n  $('form')\n    .append('<input type=\"submit\" name=\"submit1\" value=\"submit1\" />')\n    .append('<button name=\"submit2\" value=\"submit2\" />')\n    .append('<button name=\"submit3\" value=\"submit3\" />')\n    .bindNative('ajax:success', function(e, data, status, xhr) {\n      equal(data.params.submit1, undefined)\n      equal(data.params.submit2, 'submit2')\n      equal(data.params.submit3, undefined)\n      equal(data['rack.request.form_vars'], 'user_name=john&submit2=submit2')\n\n      start()\n    })\n    .find('[name=submit2]').triggerNative('click')\n})\n\nasyncTest('changing a select option without \"data-url\" attribute still fires ajax request to current location', 1, function() {\n  var currentLocation, ajaxLocation\n\n  buildSelect({'data-url': ''})\n\n  $('select[data-remote]')\n    .bindNative('ajax:beforeSend', function(e, xhr, settings) {\n      // Get current location (the same way jQuery does)\n      try {\n        currentLocation = location.href\n      } catch(err) {\n        currentLocation = document.createElement( 'a' )\n        currentLocation.href = ''\n        currentLocation = currentLocation.href\n      }\n\n      ajaxLocation = settings.url.replace(settings.data, '').replace(/&$/, '').replace(/\\?$/, '')\n      equal(ajaxLocation, currentLocation, 'URL should be current page by default')\n\n      e.preventDefault()\n    })\n    .val('optionValue2')\n    .triggerNative('change')\n\n  setTimeout(function() { start() }, 20)\n})\n\nasyncTest('inputs inside disabled fieldset are not submitted on remote forms', 3, function() {\n  $('form')\n    .append('<fieldset>\\\n      <input name=\"description\" value=\"A wise man\" />\\\n    </fieldset>')\n    .append('<fieldset disabled=\"disabled\">\\\n      <input name=\"age\" />\\\n    </fieldset>')\n    .bindNative('ajax:success', function(e, data, status, xhr) {\n      equal(data.params.user_name, 'john')\n      equal(data.params.description, 'A wise man')\n      equal(data.params.age, undefined)\n\n      start()\n    })\n    .triggerNative('submit')\n})\n\nasyncTest('clicking on a link with contenteditable attribute does not fire ajaxyness', 0, function() {\n  var contenteditable_div = $('#qunit-fixture').find('div')\n  var link = $('a[data-remote]')\n  contenteditable_div.append(link)\n\n  link\n    .bindNative('ajax:beforeSend', function() {\n      ok(false, 'ajax should not be triggered')\n    })\n    .bindNative('click', function(e) {\n      e.preventDefault()\n    })\n    .triggerNative('click')\n\n  setTimeout(function() { start() }, 20)\n})\n\n})()\n", "patch": "@@ -41,6 +41,9 @@ module('data-remote', {\n       }))\n       .find('form').append($('<input type=\"text\" name=\"user_name\" value=\"john\">'))\n \n+    $('#qunit-fixture').append($('<div />', {\n+      id: 'edit-div', 'contenteditable': 'true'\n+    }))\n   }\n })\n \n@@ -508,4 +511,21 @@ asyncTest('inputs inside disabled fieldset are not submitted on remote forms', 3\n     .triggerNative('submit')\n })\n \n+asyncTest('clicking on a link with contenteditable attribute does not fire ajaxyness', 0, function() {\n+  var contenteditable_div = $('#qunit-fixture').find('div')\n+  var link = $('a[data-remote]')\n+  contenteditable_div.append(link)\n+\n+  link\n+    .bindNative('ajax:beforeSend', function() {\n+      ok(false, 'ajax should not be triggered')\n+    })\n+    .bindNative('click', function(e) {\n+      e.preventDefault()\n+    })\n+    .triggerNative('click')\n+\n+  setTimeout(function() { start() }, 20)\n+})\n+\n })()"}
{"patches_id": 7, "files_id": 35, "language": "cc", "raw_url": "https://github.com/nodejs/node/raw/d39e993903e27bb5761dd98b0a93964dcaabac65/src%2Fpermission%2Ffs_permission.cc", "raw_code": "#include \"fs_permission.h\"\n#include \"base_object-inl.h\"\n#include \"debug_utils-inl.h\"\n#include \"env.h\"\n#include \"path.h\"\n#include \"v8.h\"\n\n#include <fcntl.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <algorithm>\n#include <filesystem>\n#include <string>\n#include <string_view>\n#include <vector>\n\nnamespace {\n\nstd::string WildcardIfDir(const std::string& res) noexcept {\n  auto path = std::filesystem::path(res);\n  auto file_status = std::filesystem::status(path);\n  if (file_status.type() == std::filesystem::file_type::directory) {\n    path /= \"*\";\n  }\n  return path.string();\n}\n\nvoid FreeRecursivelyNode(\n    node::permission::FSPermission::RadixTree::Node* node) {\n  if (node == nullptr) {\n    return;\n  }\n\n  if (node->children.size()) {\n    for (auto& c : node->children) {\n      FreeRecursivelyNode(c.second);\n    }\n  }\n\n  if (node->wildcard_child != nullptr) {\n    delete node->wildcard_child;\n  }\n  delete node;\n}\n\nbool is_tree_granted(\n    node::Environment* env,\n    const node::permission::FSPermission::RadixTree* granted_tree,\n    const std::string_view& param) {\n  std::string resolved_param = node::PathResolve(env, {param});\n#ifdef _WIN32\n  // Remove leading \"\\\\?\\\" from UNC path\n  if (resolved_param.substr(0, 4) == \"\\\\\\\\?\\\\\") {\n    resolved_param.erase(0, 4);\n  }\n\n  // Remove leading \"UNC\\\" from UNC path\n  if (resolved_param.substr(0, 4) == \"UNC\\\\\") {\n    resolved_param.erase(0, 4);\n  }\n  // Remove leading \"//\" from UNC path\n  if (resolved_param.substr(0, 2) == \"//\") {\n    resolved_param.erase(0, 2);\n  }\n#endif\n  return granted_tree->Lookup(resolved_param, true);\n}\n\nvoid PrintTree(const node::permission::FSPermission::RadixTree::Node* node,\n               size_t spaces = 0) {\n  std::string whitespace(spaces, ' ');\n\n  if (node == nullptr) {\n    return;\n  }\n  if (node->wildcard_child != nullptr) {\n    node::per_process::Debug(node::DebugCategory::PERMISSION_MODEL,\n                             \"%s Wildcard: %s\\n\",\n                             whitespace,\n                             node->prefix);\n  } else {\n    node::per_process::Debug(node::DebugCategory::PERMISSION_MODEL,\n                             \"%s Prefix: %s\\n\",\n                             whitespace,\n                             node->prefix);\n    if (node->children.size()) {\n      size_t child = 0;\n      for (const auto& pair : node->children) {\n        ++child;\n        node::per_process::Debug(node::DebugCategory::PERMISSION_MODEL,\n                                 \"%s Child(%s): %s\\n\",\n                                 whitespace,\n                                 child,\n                                 std::string(1, pair.first));\n        PrintTree(pair.second, spaces + 2);\n      }\n      node::per_process::Debug(node::DebugCategory::PERMISSION_MODEL,\n                               \"%s End of tree - child(%s)\\n\",\n                               whitespace,\n                               child);\n    } else {\n      node::per_process::Debug(node::DebugCategory::PERMISSION_MODEL,\n                               \"%s End of tree: %s\\n\",\n                               whitespace,\n                               node->prefix);\n    }\n  }\n}\n\n}  // namespace\n\nnamespace node {\n\nnamespace permission {\n\n// allow = '*'\n// allow = '/tmp/,/home/example.js'\nvoid FSPermission::Apply(Environment* env,\n                         const std::vector<std::string>& allow,\n                         PermissionScope scope) {\n  for (const std::string& res : allow) {\n    if (res == \"*\") {\n      if (scope == PermissionScope::kFileSystemRead) {\n        deny_all_in_ = false;\n        allow_all_in_ = true;\n      } else {\n        deny_all_out_ = false;\n        allow_all_out_ = true;\n      }\n      return;\n    }\n    GrantAccess(scope, PathResolve(env, {res}));\n  }\n}\n\nvoid FSPermission::GrantAccess(PermissionScope perm, const std::string& res) {\n  const std::string path = WildcardIfDir(res);\n  if (perm == PermissionScope::kFileSystemRead) {\n    granted_in_fs_.Insert(path);\n    deny_all_in_ = false;\n  } else if (perm == PermissionScope::kFileSystemWrite) {\n    granted_out_fs_.Insert(path);\n    deny_all_out_ = false;\n  }\n}\n\nbool FSPermission::is_granted(Environment* env,\n                              PermissionScope perm,\n                              const std::string_view& param = \"\") const {\n  switch (perm) {\n    case PermissionScope::kFileSystem:\n      return allow_all_in_ && allow_all_out_;\n    case PermissionScope::kFileSystemRead:\n      return !deny_all_in_ &&\n             ((param.empty() && allow_all_in_) || allow_all_in_ ||\n              is_tree_granted(env, &granted_in_fs_, param));\n    case PermissionScope::kFileSystemWrite:\n      return !deny_all_out_ &&\n             ((param.empty() && allow_all_out_) || allow_all_out_ ||\n              is_tree_granted(env, &granted_out_fs_, param));\n    default:\n      return false;\n  }\n}\n\nFSPermission::RadixTree::RadixTree() : root_node_(new Node(\"\")) {}\n\nFSPermission::RadixTree::~RadixTree() {\n  FreeRecursivelyNode(root_node_);\n}\n\nbool FSPermission::RadixTree::Lookup(const std::string_view& s,\n                                     bool when_empty_return) const {\n  FSPermission::RadixTree::Node* current_node = root_node_;\n  if (current_node->children.empty()) {\n    return when_empty_return;\n  }\n  size_t parent_node_prefix_len = current_node->prefix.length();\n  const std::string path(s);\n  auto path_len = path.length();\n\n  while (true) {\n    if (parent_node_prefix_len == path_len && current_node->IsEndNode()) {\n      return true;\n    }\n\n    auto node = current_node->NextNode(path, parent_node_prefix_len);\n    if (node == nullptr) {\n      return false;\n    }\n\n    current_node = node;\n    parent_node_prefix_len += current_node->prefix.length();\n    if (current_node->wildcard_child != nullptr &&\n        path_len >= (parent_node_prefix_len - 2 /* slash* */)) {\n      return true;\n    }\n  }\n}\n\nvoid FSPermission::RadixTree::Insert(const std::string& path) {\n  FSPermission::RadixTree::Node* current_node = root_node_;\n\n  size_t parent_node_prefix_len = current_node->prefix.length();\n  size_t path_len = path.length();\n\n  for (size_t i = 1; i <= path_len; ++i) {\n    bool is_wildcard_node = path[i - 1] == '*';\n    bool is_last_char = i == path_len;\n\n    if (is_wildcard_node || is_last_char) {\n      std::string node_path = path.substr(parent_node_prefix_len, i);\n      current_node = current_node->CreateChild(node_path);\n    }\n\n    if (is_wildcard_node) {\n      current_node = current_node->CreateWildcardChild();\n      parent_node_prefix_len = i;\n    }\n  }\n\n  if (UNLIKELY(per_process::enabled_debug_list.enabled(\n          DebugCategory::PERMISSION_MODEL))) {\n    per_process::Debug(DebugCategory::PERMISSION_MODEL, \"Inserting %s\\n\", path);\n    PrintTree(root_node_);\n  }\n}\n\n}  // namespace permission\n}  // namespace node\n", "patch": "@@ -49,15 +49,18 @@ bool is_tree_granted(\n     const std::string_view& param) {\n   std::string resolved_param = node::PathResolve(env, {param});\n #ifdef _WIN32\n-  // is UNC file path\n-  if (resolved_param.rfind(\"\\\\\\\\\", 0) == 0) {\n-    // return lookup with normalized param\n-    size_t starting_pos = 4;  // \"\\\\?\\\"\n-    if (resolved_param.rfind(\"\\\\\\\\?\\\\UNC\\\\\") == 0) {\n-      starting_pos += 4;  // \"UNC\\\"\n-    }\n-    auto normalized = param.substr(starting_pos);\n-    return granted_tree->Lookup(normalized, true);\n+  // Remove leading \"\\\\?\\\" from UNC path\n+  if (resolved_param.substr(0, 4) == \"\\\\\\\\?\\\\\") {\n+    resolved_param.erase(0, 4);\n+  }\n+\n+  // Remove leading \"UNC\\\" from UNC path\n+  if (resolved_param.substr(0, 4) == \"UNC\\\\\") {\n+    resolved_param.erase(0, 4);\n+  }\n+  // Remove leading \"//\" from UNC path\n+  if (resolved_param.substr(0, 2) == \"//\") {\n+    resolved_param.erase(0, 2);\n   }\n #endif\n   return granted_tree->Lookup(resolved_param, true);"}
{"patches_id": 7, "files_id": 36, "language": "js", "raw_url": "https://github.com/nodejs/node/raw/d39e993903e27bb5761dd98b0a93964dcaabac65/test%2Fparallel%2Ftest-permission-fs-windows-path.js", "raw_code": "// Flags: --experimental-permission --allow-fs-read=* --allow-child-process\n'use strict';\n\nconst common = require('../common');\ncommon.skipIfWorker();\n\nconst assert = require('assert');\nconst { spawnSync } = require('child_process');\n\nif (!common.isWindows) {\n  common.skip('windows UNC path test');\n}\n\n{\n  const { stdout, status } = spawnSync(process.execPath, [\n    '--experimental-permission', '--allow-fs-write', 'C:\\\\\\\\', '-e',\n    'console.log(process.permission.has(\"fs.write\", \"C:\\\\\\\\\"))',\n  ]);\n  assert.strictEqual(stdout.toString(), 'true\\n');\n  assert.strictEqual(status, 0);\n}\n\n{\n  const { stdout, status, stderr } = spawnSync(process.execPath, [\n    '--experimental-permission', '--allow-fs-write=\"\\\\\\\\?\\\\C:\\\\\"', '-e',\n    'console.log(process.permission.has(\"fs.write\", \"C:\\\\\\\\\"))',\n  ]);\n  assert.strictEqual(stdout.toString(), 'false\\n', stderr.toString());\n  assert.strictEqual(status, 0);\n}\n\n{\n  const { stdout, status, stderr } = spawnSync(process.execPath, [\n    '--experimental-permission', '--allow-fs-write', 'C:\\\\', '-e',\n    `const path = require('path');\n     console.log(process.permission.has('fs.write', path.toNamespacedPath('C:\\\\\\\\')))`,\n  ]);\n  assert.strictEqual(stdout.toString(), 'true\\n', stderr.toString());\n  assert.strictEqual(status, 0);\n}\n\n{\n  const { stdout, status, stderr } = spawnSync(process.execPath, [\n    '--experimental-permission', '--allow-fs-write', 'C:\\\\*', '-e',\n    \"console.log(process.permission.has('fs.write', '\\\\\\\\\\\\\\\\A\\\\\\\\C:\\\\Users'))\",\n  ]);\n  assert.strictEqual(stdout.toString(), 'false\\n', stderr.toString());\n  assert.strictEqual(status, 0);\n}\n", "patch": "@@ -38,3 +38,12 @@ if (!common.isWindows) {\n   assert.strictEqual(stdout.toString(), 'true\\n', stderr.toString());\n   assert.strictEqual(status, 0);\n }\n+\n+{\n+  const { stdout, status, stderr } = spawnSync(process.execPath, [\n+    '--experimental-permission', '--allow-fs-write', 'C:\\\\*', '-e',\n+    \"console.log(process.permission.has('fs.write', '\\\\\\\\\\\\\\\\A\\\\\\\\C:\\\\Users'))\",\n+  ]);\n+  assert.strictEqual(stdout.toString(), 'false\\n', stderr.toString());\n+  assert.strictEqual(status, 0);\n+}"}
{"patches_id": 8, "files_id": 37, "language": "rb", "raw_url": "https://github.com/rails/kredis/raw/d576b7ae5c8d3d74eeb4bd84cad0aa64ffc299fa/lib%2Fkredis%2Ftype%2Fjson.rb", "raw_code": "# frozen_string_literal: true\n\nmodule Kredis\n  module Type\n    class Json < ActiveModel::Type::Value\n      def type\n        :json\n      end\n\n      def cast_value(value)\n        JSON.parse(value)\n      end\n\n      def serialize(value)\n        JSON.dump(value)\n      end\n    end\n  end\nend\n", "patch": "@@ -8,7 +8,7 @@ def type\n       end\n \n       def cast_value(value)\n-        JSON.load(value)\n+        JSON.parse(value)\n       end\n \n       def serialize(value)"}
{"patches_id": 8, "files_id": 38, "language": "rb", "raw_url": "https://github.com/rails/kredis/raw/d576b7ae5c8d3d74eeb4bd84cad0aa64ffc299fa/test%2Ftypes%2Fscalar_test.rb", "raw_code": "require \"test_helper\"\nrequire \"active_support/core_ext/integer\"\n\nclass ScalarTest < ActiveSupport::TestCase\n  test \"string\" do\n    string = Kredis.scalar \"myscalar\"\n    string.value = \"Something!\"\n    assert_equal \"Something!\", string.value\n  end\n\n  test \"integer\" do\n    integer = Kredis.scalar \"myscalar\", typed: :integer\n    integer.value = 5\n    assert_equal 5, integer.value\n  end\n\n  test \"decimal\" do\n    decimal = Kredis.decimal \"myscalar\"\n    decimal.value = 5.to_d\n    assert_equal 5.to_d, decimal.value\n  end\n\n  test \"float\" do\n    float = Kredis.float \"myscalar\"\n    float.value = 5.7\n    assert_equal 5.7, float.value\n  end\n\n  test \"boolean\" do\n    boolean = Kredis.boolean \"myscalar\"\n    boolean.value = true\n    assert_equal true, boolean.value\n    boolean.value = false\n    assert_equal false, boolean.value\n    boolean.value = 't'\n    assert_equal true, boolean.value\n    boolean.value = 'false'\n    assert_equal false, boolean.value\n  end\n\n  test \"datetime\" do\n    datetime = Kredis.datetime \"myscalar\"\n    datetime.value = 5.days.from_now.midnight\n    assert_equal 5.days.from_now.midnight, datetime.value\n\n    datetime.value += 0.5.seconds\n    assert_equal 5.days.from_now.midnight + 0.5.seconds, datetime.value\n\n    datetime.value = nil\n    assert_nil datetime.value\n  end\n\n  test \"datetime casting Dates\" do\n    datetime = Kredis.datetime \"myscalar\"\n    datetime.value = Date.current\n    assert_equal Date.current.to_datetime, datetime.value\n  end\n\n  test \"json\" do\n    json = Kredis.json \"myscalar\"\n    json.value = { \"one\" => 1, \"string\" => \"hello\" }\n    assert_equal({ \"one\" => 1, \"string\" => \"hello\" }, json.value)\n\n    json.value = {\"json_class\"=>\"String\", \"raw\"=>[97, 98, 99]}\n    assert_equal({\"json_class\"=>\"String\", \"raw\"=>[97, 98, 99]}, json.value)\n  end\n\n  test \"invalid type\" do\n    nothere = Kredis.scalar \"myscalar\", typed: :nothere\n    assert_raises(Kredis::TypeCasting::InvalidType) { nothere.value = true }\n\n    assert_raises(Kredis::TypeCasting::InvalidType) { nothere.value }\n  end\n\n  test \"assigned?\" do\n    string = Kredis.string \"myscalar\"\n    assert_not string.assigned?\n\n    string.value = \"Something!\"\n    assert string.assigned?\n  end\n\n  test \"clear\" do\n    string = Kredis.string \"myscalar\"\n    string.value = \"Something!\"\n    string.clear\n    assert_not string.assigned?\n  end\n\n  test \"default\" do\n    integer = Kredis.scalar \"myscalar\", typed: :integer, default: 8\n    assert_equal 8, integer.value\n\n    integer.value = 5\n    assert_equal 5, integer.value\n\n    integer.clear\n    assert_equal 8, integer.value\n\n    assert_equal \"8\", integer.value.to_s\n\n    json = Kredis.json \"myscalar\", default: { \"one\" => 1, \"string\" => \"hello\" }\n    assert_equal({ \"one\" => 1, \"string\" => \"hello\" }, json.value)\n  end\n\n  test \"returns default when failing open\" do\n    integer = Kredis.scalar \"myscalar\", typed: :integer, default: 8\n    integer.value = 42\n\n    stub_redis_down(integer) { assert_equal 8, integer.value }\n  end\n\n  test \"telling a scalar to expire in a relative amount of time\" do\n    string = Kredis.scalar \"myscalar\", default: \"unassigned\"\n    string.value = \"assigned\"\n    assert_changes \"string.value\", from: \"assigned\", to: \"unassigned\" do\n      string.expire_in 1.second\n      sleep 1.1.seconds\n    end\n  end\n\n  test \"telling a scaler to expire at a specific point in time\" do\n    string = Kredis.scalar \"myscalar\", default: \"unassigned\"\n    string.value = \"assigned\"\n    assert_changes \"string.value\", from: \"assigned\", to: \"unassigned\" do\n      string.expire_at 1.second.from_now\n      sleep 1.1.seconds\n    end\n  end\n\n  test \"configuring a scaler to always expire after assignment\" do\n    forever_string = Kredis.scalar \"forever\", default: \"unassigned\", expires_in: nil\n    ephemeral_string = Kredis.scalar \"ephemeral\", default: \"unassigned\", expires_in: 1.second\n\n    forever_string.value = \"assigned\"\n    ephemeral_string.value = \"assigned\"\n\n    assert_no_changes \"forever_string.value\" do\n      assert_changes \"ephemeral_string.value\", from: \"assigned\", to: \"unassigned\" do\n        sleep 1.1.seconds\n      end\n    end\n  end\n\n  test \"all scalar types can be configured with expires_in\" do\n    duration = 1.second\n    scalar = Kredis.scalar(\"ephemeral\", expires_in: duration)\n\n    scalar = Kredis.string(\"ephemeral\", expires_in: duration)\n    assert_equal duration, scalar.expires_in\n\n    scalar = Kredis.integer(\"ephemeral\", expires_in: duration)\n    assert_equal duration, scalar.expires_in\n\n    scalar = Kredis.decimal(\"ephemeral\", expires_in: duration)\n    assert_equal duration, scalar.expires_in\n\n    scalar = Kredis.float(\"ephemeral\", expires_in: duration)\n    assert_equal duration, scalar.expires_in\n\n    scalar = Kredis.boolean(\"ephemeral\", expires_in: duration)\n    assert_equal duration, scalar.expires_in\n\n    scalar = Kredis.datetime(\"ephemeral\", expires_in: duration)\n    assert_equal duration, scalar.expires_in\n\n    scalar = Kredis.json(\"ephemeral\", expires_in: duration)\n    assert_equal duration, scalar.expires_in\n  end\nend\n", "patch": "@@ -60,6 +60,9 @@ class ScalarTest < ActiveSupport::TestCase\n     json = Kredis.json \"myscalar\"\n     json.value = { \"one\" => 1, \"string\" => \"hello\" }\n     assert_equal({ \"one\" => 1, \"string\" => \"hello\" }, json.value)\n+\n+    json.value = {\"json_class\"=>\"String\", \"raw\"=>[97, 98, 99]}\n+    assert_equal({\"json_class\"=>\"String\", \"raw\"=>[97, 98, 99]}, json.value)\n   end\n \n   test \"invalid type\" do"}
{"patches_id": 9, "files_id": 39, "language": "rb", "raw_url": "https://github.com/rails/rails/raw/3cf23c3f891e2e81c977ea4ab83b62bc2a444b70/activesupport%2Flib%2Factive_support%2Fcore_ext%2Fstring%2Foutput_safety.rb", "raw_code": "# frozen_string_literal: true\n\nrequire \"erb\"\nrequire \"active_support/core_ext/module/redefine_method\"\nrequire \"active_support/multibyte/unicode\"\n\nclass ERB\n  module Util\n    HTML_ESCAPE = { \"&\" => \"&amp;\",  \">\" => \"&gt;\",   \"<\" => \"&lt;\", '\"' => \"&quot;\", \"'\" => \"&#39;\" }\n    JSON_ESCAPE = { \"&\" => '\\u0026', \">\" => '\\u003e', \"<\" => '\\u003c', \"\\u2028\" => '\\u2028', \"\\u2029\" => '\\u2029' }\n    HTML_ESCAPE_ONCE_REGEXP = /[\"><']|&(?!([a-zA-Z]+|(#\\d+)|(#[xX][\\dA-Fa-f]+));)/\n    JSON_ESCAPE_REGEXP = /[\\u2028\\u2029&><]/u\n\n    # Following XML requirements: https://www.w3.org/TR/REC-xml/#NT-Name\n    TAG_NAME_START_REGEXP_SET = \"@:A-Z_a-z\\u{C0}-\\u{D6}\\u{D8}-\\u{F6}\\u{F8}-\\u{2FF}\\u{370}-\\u{37D}\\u{37F}-\\u{1FFF}\" \\\n                                \"\\u{200C}-\\u{200D}\\u{2070}-\\u{218F}\\u{2C00}-\\u{2FEF}\\u{3001}-\\u{D7FF}\\u{F900}-\\u{FDCF}\" \\\n                                \"\\u{FDF0}-\\u{FFFD}\\u{10000}-\\u{EFFFF}\"\n    TAG_NAME_START_REGEXP = /[^#{TAG_NAME_START_REGEXP_SET}]/\n    TAG_NAME_FOLLOWING_REGEXP = /[^#{TAG_NAME_START_REGEXP_SET}\\-.0-9\\u{B7}\\u{0300}-\\u{036F}\\u{203F}-\\u{2040}]/\n    TAG_NAME_REPLACEMENT_CHAR = \"_\"\n\n    # A utility method for escaping HTML tag characters.\n    # This method is also aliased as <tt>h</tt>.\n    #\n    #   puts html_escape('is a > 0 & a < 10?')\n    #   # => is a &gt; 0 &amp; a &lt; 10?\n    def html_escape(s)\n      unwrapped_html_escape(s).html_safe\n    end\n\n    silence_redefinition_of_method :h\n    alias h html_escape\n\n    module_function :h\n\n    singleton_class.silence_redefinition_of_method :html_escape\n    module_function :html_escape\n\n    # HTML escapes strings but doesn't wrap them with an ActiveSupport::SafeBuffer.\n    # This method is not for public consumption! Seriously!\n    def unwrapped_html_escape(s) # :nodoc:\n      s = s.to_s\n      if s.html_safe?\n        s\n      else\n        CGI.escapeHTML(ActiveSupport::Multibyte::Unicode.tidy_bytes(s))\n      end\n    end\n    module_function :unwrapped_html_escape\n\n    # A utility method for escaping HTML without affecting existing escaped entities.\n    #\n    #   html_escape_once('1 < 2 &amp; 3')\n    #   # => \"1 &lt; 2 &amp; 3\"\n    #\n    #   html_escape_once('&lt;&lt; Accept & Checkout')\n    #   # => \"&lt;&lt; Accept &amp; Checkout\"\n    def html_escape_once(s)\n      result = ActiveSupport::Multibyte::Unicode.tidy_bytes(s.to_s).gsub(HTML_ESCAPE_ONCE_REGEXP, HTML_ESCAPE)\n      s.html_safe? ? result.html_safe : result\n    end\n\n    module_function :html_escape_once\n\n    # A utility method for escaping HTML entities in JSON strings. Specifically, the\n    # &, > and < characters are replaced with their equivalent unicode escaped form -\n    # \\u0026, \\u003e, and \\u003c. The Unicode sequences \\u2028 and \\u2029 are also\n    # escaped as they are treated as newline characters in some JavaScript engines.\n    # These sequences have identical meaning as the original characters inside the\n    # context of a JSON string, so assuming the input is a valid and well-formed\n    # JSON value, the output will have equivalent meaning when parsed:\n    #\n    #   json = JSON.generate({ name: \"</script><script>alert('PWNED!!!')</script>\"})\n    #   # => \"{\\\"name\\\":\\\"</script><script>alert('PWNED!!!')</script>\\\"}\"\n    #\n    #   json_escape(json)\n    #   # => \"{\\\"name\\\":\\\"\\\\u003C/script\\\\u003E\\\\u003Cscript\\\\u003Ealert('PWNED!!!')\\\\u003C/script\\\\u003E\\\"}\"\n    #\n    #   JSON.parse(json) == JSON.parse(json_escape(json))\n    #   # => true\n    #\n    # The intended use case for this method is to escape JSON strings before including\n    # them inside a script tag to avoid XSS vulnerability:\n    #\n    #   <script>\n    #     var currentUser = <%= raw json_escape(current_user.to_json) %>;\n    #   </script>\n    #\n    # It is necessary to +raw+ the result of +json_escape+, so that quotation marks\n    # don't get converted to <tt>&quot;</tt> entities. +json_escape+ doesn't\n    # automatically flag the result as HTML safe, since the raw value is unsafe to\n    # use inside HTML attributes.\n    #\n    # If your JSON is being used downstream for insertion into the DOM, be aware of\n    # whether or not it is being inserted via <tt>html()</tt>. Most jQuery plugins do this.\n    # If that is the case, be sure to +html_escape+ or +sanitize+ any user-generated\n    # content returned by your JSON.\n    #\n    # If you need to output JSON elsewhere in your HTML, you can just do something\n    # like this, as any unsafe characters (including quotation marks) will be\n    # automatically escaped for you:\n    #\n    #   <div data-user-info=\"<%= current_user.to_json %>\">...</div>\n    #\n    # WARNING: this helper only works with valid JSON. Using this on non-JSON values\n    # will open up serious XSS vulnerabilities. For example, if you replace the\n    # +current_user.to_json+ in the example above with user input instead, the browser\n    # will happily eval() that string as JavaScript.\n    #\n    # The escaping performed in this method is identical to those performed in the\n    # Active Support JSON encoder when +ActiveSupport.escape_html_entities_in_json+ is\n    # set to true. Because this transformation is idempotent, this helper can be\n    # applied even if +ActiveSupport.escape_html_entities_in_json+ is already true.\n    #\n    # Therefore, when you are unsure if +ActiveSupport.escape_html_entities_in_json+\n    # is enabled, or if you are unsure where your JSON string originated from, it\n    # is recommended that you always apply this helper (other libraries, such as the\n    # JSON gem, do not provide this kind of protection by default; also some gems\n    # might override +to_json+ to bypass Active Support's encoder).\n    def json_escape(s)\n      result = s.to_s.gsub(JSON_ESCAPE_REGEXP, JSON_ESCAPE)\n      s.html_safe? ? result.html_safe : result\n    end\n\n    module_function :json_escape\n\n    # A utility method for escaping XML names of tags and names of attributes.\n    #\n    #   xml_name_escape('1 < 2 & 3')\n    #   # => \"1___2___3\"\n    #\n    # It follows the requirements of the specification: https://www.w3.org/TR/REC-xml/#NT-Name\n    def xml_name_escape(name)\n      name = name.to_s\n      return \"\" if name.blank?\n\n      starting_char = name[0].gsub(TAG_NAME_START_REGEXP, TAG_NAME_REPLACEMENT_CHAR)\n\n      return starting_char if name.size == 1\n\n      following_chars = name[1..-1].gsub(TAG_NAME_FOLLOWING_REGEXP, TAG_NAME_REPLACEMENT_CHAR)\n\n      starting_char + following_chars\n    end\n    module_function :xml_name_escape\n  end\nend\n\nclass Object\n  def html_safe?\n    false\n  end\nend\n\nclass Numeric\n  def html_safe?\n    true\n  end\nend\n\nmodule ActiveSupport #:nodoc:\n  class SafeBuffer < String\n    UNSAFE_STRING_METHODS = %w(\n      capitalize chomp chop delete delete_prefix delete_suffix\n      downcase lstrip next reverse rstrip scrub slice squeeze strip\n      succ swapcase tr tr_s unicode_normalize upcase\n    )\n\n    UNSAFE_STRING_METHODS_WITH_BACKREF = %w(gsub sub)\n\n    alias_method :original_concat, :concat\n    private :original_concat\n\n    # Raised when <tt>ActiveSupport::SafeBuffer#safe_concat</tt> is called on unsafe buffers.\n    class SafeConcatError < StandardError\n      def initialize\n        super \"Could not concatenate to the buffer because it is not html safe.\"\n      end\n    end\n\n    def [](*args)\n      if html_safe?\n        new_string = super\n\n        return unless new_string\n\n        new_safe_buffer = new_string.is_a?(SafeBuffer) ? new_string : SafeBuffer.new(new_string)\n        new_safe_buffer.instance_variable_set :@html_safe, true\n        new_safe_buffer\n      else\n        to_str[*args]\n      end\n    end\n\n    def safe_concat(value)\n      raise SafeConcatError unless html_safe?\n      original_concat(value)\n    end\n\n    def initialize(str = \"\")\n      @html_safe = true\n      super\n    end\n\n    def initialize_copy(other)\n      super\n      @html_safe = other.html_safe?\n    end\n\n    def clone_empty\n      self[0, 0]\n    end\n\n    def concat(value)\n      super(html_escape_interpolated_argument(value))\n    end\n    alias << concat\n\n    def bytesplice(*args, value)\n      super(*args, implicit_html_escape_interpolated_argument(value))\n    end\n\n    def insert(index, value)\n      super(index, html_escape_interpolated_argument(value))\n    end\n\n    def prepend(value)\n      super(html_escape_interpolated_argument(value))\n    end\n\n    def replace(value)\n      super(html_escape_interpolated_argument(value))\n    end\n\n    def []=(*args)\n      if args.length == 3\n        super(args[0], args[1], html_escape_interpolated_argument(args[2]))\n      else\n        super(args[0], html_escape_interpolated_argument(args[1]))\n      end\n    end\n\n    def +(other)\n      dup.concat(other)\n    end\n\n    def *(*)\n      new_string = super\n      new_safe_buffer = new_string.is_a?(SafeBuffer) ? new_string : SafeBuffer.new(new_string)\n      new_safe_buffer.instance_variable_set(:@html_safe, @html_safe)\n      new_safe_buffer\n    end\n\n    def %(args)\n      case args\n      when Hash\n        escaped_args = args.transform_values { |arg| html_escape_interpolated_argument(arg) }\n      else\n        escaped_args = Array(args).map { |arg| html_escape_interpolated_argument(arg) }\n      end\n\n      self.class.new(super(escaped_args))\n    end\n\n    def html_safe?\n      defined?(@html_safe) && @html_safe\n    end\n\n    def to_s\n      self\n    end\n\n    def to_param\n      to_str\n    end\n\n    def encode_with(coder)\n      coder.represent_object nil, to_str\n    end\n\n    UNSAFE_STRING_METHODS.each do |unsafe_method|\n      if unsafe_method.respond_to?(unsafe_method)\n        class_eval <<-EOT, __FILE__, __LINE__ + 1\n          def #{unsafe_method}(*args, &block)       # def capitalize(*args, &block)\n            to_str.#{unsafe_method}(*args, &block)  #   to_str.capitalize(*args, &block)\n          end                                       # end\n\n          def #{unsafe_method}!(*args)              # def capitalize!(*args)\n            @html_safe = false                      #   @html_safe = false\n            super                                   #   super\n          end                                       # end\n        EOT\n      end\n    end\n\n    UNSAFE_STRING_METHODS_WITH_BACKREF.each do |unsafe_method|\n      if unsafe_method.respond_to?(unsafe_method)\n        class_eval <<-EOT, __FILE__, __LINE__ + 1\n          def #{unsafe_method}(*args, &block)             # def gsub(*args, &block)\n            if block                                      #   if block\n              to_str.#{unsafe_method}(*args) { |*params|  #     to_str.gsub(*args) { |*params|\n                set_block_back_references(block, $~)      #       set_block_back_references(block, $~)\n                block.call(*params)                       #       block.call(*params)\n              }                                           #     }\n            else                                          #   else\n              to_str.#{unsafe_method}(*args)              #     to_str.gsub(*args)\n            end                                           #   end\n          end                                             # end\n\n          def #{unsafe_method}!(*args, &block)            # def gsub!(*args, &block)\n            @html_safe = false                            #   @html_safe = false\n            if block                                      #   if block\n              super(*args) { |*params|                    #     super(*args) { |*params|\n                set_block_back_references(block, $~)      #       set_block_back_references(block, $~)\n                block.call(*params)                       #       block.call(*params)\n              }                                           #     }\n            else                                          #   else\n              super                                       #     super\n            end                                           #   end\n          end                                             # end\n        EOT\n      end\n    end\n\n    private\n      def html_escape_interpolated_argument(arg)\n        (!html_safe? || arg.html_safe?) ? arg : CGI.escapeHTML(arg.to_s)\n      end\n\n      def set_block_back_references(block, match_data)\n        block.binding.eval(\"proc { |m| $~ = m }\").call(match_data)\n      rescue ArgumentError\n        # Can't create binding from C level Proc\n      end\n  end\nend\n\nclass String\n  # Marks a string as trusted safe. It will be inserted into HTML with no\n  # additional escaping performed. It is your responsibility to ensure that the\n  # string contains no malicious content. This method is equivalent to the\n  # +raw+ helper in views. It is recommended that you use +sanitize+ instead of\n  # this method. It should never be called on user input.\n  def html_safe\n    ActiveSupport::SafeBuffer.new(self)\n  end\nend\n", "patch": "@@ -216,6 +216,10 @@ def concat(value)\n     end\n     alias << concat\n \n+    def bytesplice(*args, value)\n+      super(*args, implicit_html_escape_interpolated_argument(value))\n+    end\n+\n     def insert(index, value)\n       super(index, html_escape_interpolated_argument(value))\n     end"}
{"patches_id": 9, "files_id": 40, "language": "rb", "raw_url": "https://github.com/rails/rails/raw/3cf23c3f891e2e81c977ea4ab83b62bc2a444b70/activesupport%2Ftest%2Fcore_ext%2Fstring_ext_test.rb", "raw_code": "# frozen_string_literal: true\n\nrequire \"date\"\nrequire_relative \"../abstract_unit\"\nrequire \"timeout\"\nrequire_relative \"../inflector_test_cases\"\nrequire_relative \"../constantize_test_cases\"\n\nrequire \"active_support/inflector\"\nrequire \"active_support/core_ext/string\"\nrequire \"active_support/time\"\nrequire \"active_support/core_ext/string/output_safety\"\nrequire \"active_support/core_ext/string/indent\"\nrequire \"active_support/core_ext/string/strip\"\nrequire_relative \"../time_zone_test_helpers\"\nrequire \"yaml\"\n\nclass StringInflectionsTest < ActiveSupport::TestCase\n  include InflectorTestCases\n  include ConstantizeTestCases\n  include TimeZoneTestHelpers\n\n  def test_strip_heredoc_on_an_empty_string\n    assert_equal \"\", \"\".strip_heredoc\n  end\n\n  def test_strip_heredoc_on_a_frozen_string\n    assert \"\".strip_heredoc.frozen?\n  end\n\n  def test_strip_heredoc_on_a_string_with_no_lines\n    assert_equal \"x\", \"x\".strip_heredoc\n    assert_equal \"x\", \"    x\".strip_heredoc\n  end\n\n  def test_strip_heredoc_on_a_heredoc_with_no_margin\n    assert_equal \"foo\\nbar\", \"foo\\nbar\".strip_heredoc\n    assert_equal \"foo\\n  bar\", \"foo\\n  bar\".strip_heredoc\n  end\n\n  def test_strip_heredoc_on_a_regular_indented_heredoc\n    assert_equal \"foo\\n  bar\\nbaz\\n\", <<-EOS.strip_heredoc\n      foo\n        bar\n      baz\n    EOS\n  end\n\n  def test_strip_heredoc_on_a_regular_indented_heredoc_with_blank_lines\n    assert_equal \"foo\\n  bar\\n\\nbaz\\n\", <<-EOS.strip_heredoc\n      foo\n        bar\n\n      baz\n    EOS\n  end\n\n  def test_pluralize\n    SingularToPlural.each do |singular, plural|\n      assert_equal(plural, singular.pluralize)\n    end\n\n    assert_equal(\"plurals\", \"plurals\".pluralize)\n\n    assert_equal(\"blargles\", \"blargle\".pluralize(0))\n    assert_equal(\"blargle\", \"blargle\".pluralize(1))\n    assert_equal(\"blargles\", \"blargle\".pluralize(2))\n  end\n\n  test \"pluralize with count = 1 still returns new string\" do\n    name = \"Kuldeep\"\n    assert_not_same name.pluralize(1), name\n  end\n\n  def test_singularize\n    SingularToPlural.each do |singular, plural|\n      assert_equal(singular, plural.singularize)\n    end\n  end\n\n  def test_titleize\n    MixtureToTitleCase.each do |before, titleized|\n      assert_equal(titleized, before.titleize)\n    end\n  end\n\n  def test_titleize_with_keep_id_suffix\n    MixtureToTitleCaseWithKeepIdSuffix.each do |before, titleized|\n      assert_equal(titleized, before.titleize(keep_id_suffix: true))\n    end\n  end\n\n  def test_upcase_first\n    assert_equal \"What a Lovely Day\", \"what a Lovely Day\".upcase_first\n  end\n\n  def test_upcase_first_with_one_char\n    assert_equal \"W\", \"w\".upcase_first\n  end\n\n  def test_upcase_first_with_empty_string\n    assert_equal \"\", \"\".upcase_first\n  end\n\n  def test_camelize\n    CamelToUnderscore.each do |camel, underscore|\n      assert_equal(camel, underscore.camelize)\n    end\n  end\n\n  def test_camelize_lower\n    assert_equal(\"capital\", \"Capital\".camelize(:lower))\n  end\n\n  def test_camelize_invalid_option\n    e = assert_raise ArgumentError do\n      \"Capital\".camelize(nil)\n    end\n    assert_equal(\"Invalid option, use either :upper or :lower.\", e.message)\n  end\n\n  def test_dasherize\n    UnderscoresToDashes.each do |underscored, dasherized|\n      assert_equal(dasherized, underscored.dasherize)\n    end\n  end\n\n  def test_underscore\n    CamelToUnderscore.each do |camel, underscore|\n      assert_equal(underscore, camel.underscore)\n    end\n\n    assert_equal \"html_tidy\", \"HTMLTidy\".underscore\n    assert_equal \"html_tidy_generator\", \"HTMLTidyGenerator\".underscore\n  end\n\n  def test_underscore_to_lower_camel\n    UnderscoreToLowerCamel.each do |underscored, lower_camel|\n      assert_equal(lower_camel, underscored.camelize(:lower))\n    end\n  end\n\n  def test_demodulize\n    assert_equal \"Account\", \"MyApplication::Billing::Account\".demodulize\n  end\n\n  def test_deconstantize\n    assert_equal \"MyApplication::Billing\", \"MyApplication::Billing::Account\".deconstantize\n  end\n\n  def test_foreign_key\n    ClassNameToForeignKeyWithUnderscore.each do |klass, foreign_key|\n      assert_equal(foreign_key, klass.foreign_key)\n    end\n\n    ClassNameToForeignKeyWithoutUnderscore.each do |klass, foreign_key|\n      assert_equal(foreign_key, klass.foreign_key(false))\n    end\n  end\n\n  def test_tableize\n    ClassNameToTableName.each do |class_name, table_name|\n      assert_equal(table_name, class_name.tableize)\n    end\n  end\n\n  def test_classify\n    ClassNameToTableName.each do |class_name, table_name|\n      assert_equal(class_name, table_name.classify)\n    end\n  end\n\n  def test_string_parameterized_normal\n    StringToParameterized.each do |normal, slugged|\n      assert_equal(slugged, normal.parameterize)\n    end\n  end\n\n  def test_string_parameterized_normal_preserve_case\n    StringToParameterizedPreserveCase.each do |normal, slugged|\n      assert_equal(slugged, normal.parameterize(preserve_case: true))\n    end\n  end\n\n  def test_string_parameterized_no_separator\n    StringToParameterizeWithNoSeparator.each do |normal, slugged|\n      assert_equal(slugged, normal.parameterize(separator: \"\"))\n    end\n  end\n\n  def test_string_parameterized_no_separator_preserve_case\n    StringToParameterizePreserveCaseWithNoSeparator.each do |normal, slugged|\n      assert_equal(slugged, normal.parameterize(separator: \"\", preserve_case: true))\n    end\n  end\n\n  def test_string_parameterized_underscore\n    StringToParameterizeWithUnderscore.each do |normal, slugged|\n      assert_equal(slugged, normal.parameterize(separator: \"_\"))\n    end\n  end\n\n  def test_string_parameterized_underscore_preserve_case\n    StringToParameterizePreserveCaseWithUnderscore.each do |normal, slugged|\n      assert_equal(slugged, normal.parameterize(separator: \"_\", preserve_case: true))\n    end\n  end\n\n  def test_parameterize_with_locale\n    word = \"Fnf autos\"\n    I18n.backend.store_translations(:de, i18n: { transliterate: { rule: { \"\" => \"ue\" } } })\n    assert_equal(\"fuenf-autos\", word.parameterize(locale: :de))\n  end\n\n  def test_humanize\n    UnderscoreToHuman.each do |underscore, human|\n      assert_equal(human, underscore.humanize)\n    end\n  end\n\n  def test_humanize_without_capitalize\n    UnderscoreToHumanWithoutCapitalize.each do |underscore, human|\n      assert_equal(human, underscore.humanize(capitalize: false))\n    end\n  end\n\n  def test_humanize_with_keep_id_suffix\n    UnderscoreToHumanWithKeepIdSuffix.each do |underscore, human|\n      assert_equal(human, underscore.humanize(keep_id_suffix: true))\n    end\n  end\n\n  def test_humanize_with_html_escape\n    assert_equal \"Hello\", ERB::Util.html_escape(\"hello\").humanize\n  end\n\n  def test_ord\n    assert_equal 97, \"a\".ord\n    assert_equal 97, \"abc\".ord\n  end\n\n  def test_starts_ends_with_alias\n    s = \"hello\"\n    assert s.starts_with?(\"h\")\n    assert s.starts_with?(\"hel\")\n    assert_not s.starts_with?(\"el\")\n\n    assert s.ends_with?(\"o\")\n    assert s.ends_with?(\"lo\")\n    assert_not s.ends_with?(\"el\")\n  end\n\n  def test_string_squish\n    original = +%{\\u205f\\u3000 A string surrounded by various unicode spaces,\n      with tabs(\\t\\t), newlines(\\n\\n), unicode nextlines(\\u0085\\u0085) and many spaces(  ). \\u00a0\\u2007}\n\n    expected = \"A string surrounded by various unicode spaces, \" \\\n      \"with tabs( ), newlines( ), unicode nextlines( ) and many spaces( ).\"\n\n    # Make sure squish returns what we expect:\n    assert_equal expected, original.squish\n    # But doesn't modify the original string:\n    assert_not_equal expected, original\n\n    # Make sure squish! returns what we expect:\n    assert_equal expected, original.squish!\n    # And changes the original string:\n    assert_equal expected, original\n  end\n\n  def test_string_inquiry\n    assert_predicate \"production\".inquiry, :production?\n    assert_not_predicate \"production\".inquiry, :development?\n  end\n\n  def test_truncate\n    assert_equal \"Hello World!\", \"Hello World!\".truncate(12)\n    assert_equal \"Hello Wor...\", \"Hello World!!\".truncate(12)\n  end\n\n  def test_truncate_with_omission_and_separator\n    assert_equal \"Hello[...]\", \"Hello World!\".truncate(10, omission: \"[...]\")\n    assert_equal \"Hello[...]\", \"Hello Big World!\".truncate(13, omission: \"[...]\", separator: \" \")\n    assert_equal \"Hello Big[...]\", \"Hello Big World!\".truncate(14, omission: \"[...]\", separator: \" \")\n    assert_equal \"Hello Big[...]\", \"Hello Big World!\".truncate(15, omission: \"[...]\", separator: \" \")\n  end\n\n  def test_truncate_with_omission_and_regexp_separator\n    assert_equal \"Hello[...]\", \"Hello Big World!\".truncate(13, omission: \"[...]\", separator: /\\s/)\n    assert_equal \"Hello Big[...]\", \"Hello Big World!\".truncate(14, omission: \"[...]\", separator: /\\s/)\n    assert_equal \"Hello Big[...]\", \"Hello Big World!\".truncate(15, omission: \"[...]\", separator: /\\s/)\n  end\n\n  def test_truncate_returns_frozen_string\n    assert_not \"Hello World!\".truncate(12).frozen?\n    assert_not \"Hello World!!\".truncate(12).frozen?\n  end\n\n  def test_truncate_bytes\n    assert_equal \"\", \"\".truncate_bytes(16)\n    assert_equal \"\", \"\".truncate_bytes(16, omission: nil)\n    assert_equal \"\", \"\".truncate_bytes(16, omission: \" \")\n    assert_equal \"\", \"\".truncate_bytes(16, omission: \"\")\n\n    assert_equal \"\", \"\".truncate_bytes(15)\n    assert_equal \"\", \"\".truncate_bytes(15, omission: nil)\n    assert_equal \" \", \"\".truncate_bytes(15, omission: \" \")\n    assert_equal \"\", \"\".truncate_bytes(15, omission: \"\")\n\n    assert_equal \"\", \"\".truncate_bytes(5)\n    assert_equal \"\", \"\".truncate_bytes(5, omission: nil)\n    assert_equal \" \", \"\".truncate_bytes(5, omission: \" \")\n    assert_equal \"\", \"\".truncate_bytes(5, omission: \"\")\n\n    assert_equal \"\", \"\".truncate_bytes(4)\n    assert_equal \"\", \"\".truncate_bytes(4, omission: nil)\n    assert_equal \" \", \"\".truncate_bytes(4, omission: \" \")\n    assert_equal \"\", \"\".truncate_bytes(4, omission: \"\")\n\n    assert_raise ArgumentError do\n      \"\".truncate_bytes(3, omission: \"\")\n    end\n  end\n\n  def test_truncate_bytes_preserves_codepoints\n    assert_equal \"\", \"\".truncate_bytes(16)\n    assert_equal \"\", \"\".truncate_bytes(16, omission: nil)\n    assert_equal \"\", \"\".truncate_bytes(16, omission: \" \")\n    assert_equal \"\", \"\".truncate_bytes(16, omission: \"\")\n\n    assert_equal \"\", \"\".truncate_bytes(15)\n    assert_equal \"\", \"\".truncate_bytes(15, omission: nil)\n    assert_equal \" \", \"\".truncate_bytes(15, omission: \" \")\n    assert_equal \"\", \"\".truncate_bytes(15, omission: \"\")\n\n    assert_equal \"\", \"\".truncate_bytes(5)\n    assert_equal \"\", \"\".truncate_bytes(5, omission: nil)\n    assert_equal \" \", \"\".truncate_bytes(5, omission: \" \")\n    assert_equal \"\", \"\".truncate_bytes(5, omission: \"\")\n\n    assert_equal \"\", \"\".truncate_bytes(4)\n    assert_equal \"\", \"\".truncate_bytes(4, omission: nil)\n    assert_equal \" \", \"\".truncate_bytes(4, omission: \" \")\n    assert_equal \"\", \"\".truncate_bytes(4, omission: \"\")\n\n    assert_raise ArgumentError do\n      \"\".truncate_bytes(3, omission: \"\")\n    end\n  end\n\n  def test_truncates_bytes_preserves_grapheme_clusters\n    assert_equal \"a \", \"a  b\".truncate_bytes(2, omission: nil)\n    assert_equal \"a \", \"a  b\".truncate_bytes(3, omission: nil)\n    assert_equal \"a \", \"a  b\".truncate_bytes(7, omission: nil)\n    assert_equal \"a \", \"a  b\".truncate_bytes(8, omission: nil)\n\n    assert_equal \"a \", \"a \".truncate_bytes(13, omission: nil)\n    assert_equal \"\", \"\".truncate_bytes(13, omission: nil)\n  end\n\n  def test_truncate_words\n    assert_equal \"Hello Big World!\", \"Hello Big World!\".truncate_words(3)\n    assert_equal \"Hello Big...\", \"Hello Big World!\".truncate_words(2)\n  end\n\n  def test_truncate_words_with_omission\n    assert_equal \"Hello Big World!\", \"Hello Big World!\".truncate_words(3, omission: \"[...]\")\n    assert_equal \"Hello Big[...]\", \"Hello Big World!\".truncate_words(2, omission: \"[...]\")\n  end\n\n  def test_truncate_words_with_separator\n    assert_equal \"Hello<br>Big<br>World!...\", \"Hello<br>Big<br>World!<br>\".truncate_words(3, separator: \"<br>\")\n    assert_equal \"Hello<br>Big<br>World!\", \"Hello<br>Big<br>World!\".truncate_words(3, separator: \"<br>\")\n    assert_equal \"Hello\\n<br>Big...\", \"Hello\\n<br>Big<br>Wide<br>World!\".truncate_words(2, separator: \"<br>\")\n  end\n\n  def test_truncate_words_with_separator_and_omission\n    assert_equal \"Hello<br>Big<br>World![...]\", \"Hello<br>Big<br>World!<br>\".truncate_words(3, omission: \"[...]\", separator: \"<br>\")\n    assert_equal \"Hello<br>Big<br>World!\", \"Hello<br>Big<br>World!\".truncate_words(3, omission: \"[...]\", separator: \"<br>\")\n  end\n\n  def test_truncate_words_with_complex_string\n    Timeout.timeout(10) do\n      complex_string = \"aa aa aaa aa aaa aaa aaa aa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaaa aaaaa aaaaa aaaaaa aa aa aa aaa aa  aaa aa aa aa aa a aaa aaa \\n a aaa <<s\"\n      assert_equal complex_string, complex_string.truncate_words(80)\n    end\n  rescue Timeout::Error\n    assert false\n  end\n\n  def test_truncate_multibyte\n    assert_equal (+\"\\354\\225\\204\\353\\246\\254\\353\\236\\221 \\354\\225\\204\\353\\246\\254 ...\").force_encoding(Encoding::UTF_8),\n      (+\"\\354\\225\\204\\353\\246\\254\\353\\236\\221 \\354\\225\\204\\353\\246\\254 \\354\\225\\204\\353\\235\\274\\353\\246\\254\\354\\230\\244\").force_encoding(Encoding::UTF_8).truncate(10)\n  end\n\n  def test_truncate_should_not_be_html_safe\n    assert_not_predicate \"Hello World!\".truncate(12), :html_safe?\n  end\n\n  def test_remove\n    original = \"This is a good day to die\"\n    assert_equal \"This is a good day\", original.remove(\" to die\")\n    assert_equal \"This is a good day\", original.remove(\" to \", /die/)\n    assert_equal \"This is a good day to die\", original\n  end\n\n  def test_remove_for_multiple_occurrences\n    original = \"This is a good day to die to die\"\n    assert_equal \"This is a good day\", original.remove(\" to die\")\n    assert_equal \"This is a good day to die to die\", original\n  end\n\n  def test_remove!\n    original = +\"This is a very good day to die\"\n    assert_equal \"This is a good day to die\", original.remove!(\" very\")\n    assert_equal \"This is a good day to die\", original\n    assert_equal \"This is a good day\", original.remove!(\" to \", /die/)\n    assert_equal \"This is a good day\", original\n  end\n\n  def test_constantize\n    run_constantize_tests_on(&:constantize)\n  end\n\n  def test_safe_constantize\n    run_safe_constantize_tests_on(&:safe_constantize)\n  end\nend\n\nclass StringAccessTest < ActiveSupport::TestCase\n  test \"#at with Integer, returns a substring of one character at that position\" do\n    assert_equal \"h\", \"hello\".at(0)\n  end\n\n  test \"#at with Range, returns a substring containing characters at offsets\" do\n    assert_equal \"lo\", \"hello\".at(-2..-1)\n  end\n\n  test \"#at with Regex, returns the matching portion of the string\" do\n    assert_equal \"lo\", \"hello\".at(/lo/)\n    assert_nil \"hello\".at(/nonexisting/)\n  end\n\n  test \"#from with positive Integer, returns substring from the given position to the end\" do\n    assert_equal \"llo\", \"hello\".from(2)\n  end\n\n  test \"#from with negative Integer, position is counted from the end\" do\n    assert_equal \"lo\", \"hello\".from(-2)\n  end\n\n  test \"#to with positive Integer, substring from the beginning to the given position\" do\n    assert_equal \"hel\", \"hello\".to(2)\n  end\n\n  test \"#to with negative Integer, position is counted from the end\" do\n    assert_equal \"hell\", \"hello\".to(-2)\n    assert_equal \"h\", \"hello\".to(-5)\n    assert_equal \"\", \"hello\".to(-7)\n  end\n\n  test \"#from and #to can be combined\" do\n    assert_equal \"hello\", \"hello\".from(0).to(-1)\n    assert_equal \"ell\", \"hello\".from(1).to(-2)\n  end\n\n  test \"#first returns the first character\" do\n    assert_equal \"h\", \"hello\".first\n    assert_equal \"x\", \"x\".first\n  end\n\n  test \"#first with Integer, returns a substring from the beginning to position\" do\n    assert_equal \"he\", \"hello\".first(2)\n    assert_equal \"\", \"hello\".first(0)\n    assert_equal \"hello\", \"hello\".first(10)\n    assert_equal \"x\", \"x\".first(4)\n  end\n\n  test \"#first with Integer >= string length still returns a new string\" do\n    string = \"hello\"\n    different_string = string.first(5)\n    assert_not_same different_string, string\n  end\n\n  test \"#first with Integer returns a non-frozen string\" do\n    string = \"he\"\n    (0..string.length + 1).each do |limit|\n      assert_not string.first(limit).frozen?\n    end\n  end\n\n  test \"#first with negative Integer raises ArgumentError\" do\n    assert_raise ArgumentError do\n      \"hello\".first(-1)\n    end\n  end\n\n  test \"#last returns the last character\" do\n    assert_equal \"o\", \"hello\".last\n    assert_equal \"x\", \"x\".last\n  end\n\n  test \"#last with Integer, returns a substring from the end to position\" do\n    assert_equal \"llo\", \"hello\".last(3)\n    assert_equal \"hello\", \"hello\".last(10)\n    assert_equal \"\", \"hello\".last(0)\n    assert_equal \"x\", \"x\".last(4)\n  end\n\n  test \"#last with Integer >= string length still returns a new string\" do\n    string = \"hello\"\n    different_string = string.last(5)\n    assert_not_same different_string, string\n  end\n\n  test \"#last with Integer returns a non-frozen string\" do\n    string = \"he\"\n    (0..string.length + 1).each do |limit|\n      assert_not string.last(limit).frozen?\n    end\n  end\n\n  test \"#last with negative Integer raises ArgumentError\" do\n    assert_raise ArgumentError do\n      \"hello\".last(-1)\n    end\n  end\n\n  test \"access returns a real string\" do\n    hash = {}\n    hash[\"h\"] = true\n    hash[\"hello123\".at(0)] = true\n    assert_equal %w(h), hash.keys\n\n    hash = {}\n    hash[\"llo\"] = true\n    hash[\"hello\".from(2)] = true\n    assert_equal %w(llo), hash.keys\n\n    hash = {}\n    hash[\"hel\"] = true\n    hash[\"hello\".to(2)] = true\n    assert_equal %w(hel), hash.keys\n\n    hash = {}\n    hash[\"hello\"] = true\n    hash[\"123hello\".last(5)] = true\n    assert_equal %w(hello), hash.keys\n\n    hash = {}\n    hash[\"hello\"] = true\n    hash[\"hello123\".first(5)] = true\n    assert_equal %w(hello), hash.keys\n  end\nend\n\nclass StringConversionsTest < ActiveSupport::TestCase\n  include TimeZoneTestHelpers\n\n  def test_string_to_time\n    with_env_tz \"Europe/Moscow\" do\n      assert_equal Time.utc(2005, 2, 27, 23, 50), \"2005-02-27 23:50\".to_time(:utc)\n      assert_equal Time.local(2005, 2, 27, 23, 50), \"2005-02-27 23:50\".to_time\n      assert_equal Time.utc(2005, 2, 27, 23, 50, 19, 275038), \"2005-02-27T23:50:19.275038\".to_time(:utc)\n      assert_equal Time.local(2005, 2, 27, 23, 50, 19, 275038), \"2005-02-27T23:50:19.275038\".to_time\n      assert_equal Time.utc(2039, 2, 27, 23, 50), \"2039-02-27 23:50\".to_time(:utc)\n      assert_equal Time.local(2039, 2, 27, 23, 50), \"2039-02-27 23:50\".to_time\n      assert_equal Time.local(2011, 2, 27, 17, 50), \"2011-02-27 13:50 -0100\".to_time\n      assert_equal Time.utc(2011, 2, 27, 23, 50), \"2011-02-27 22:50 -0100\".to_time(:utc)\n      assert_equal Time.local(2005, 2, 27, 22, 50), \"2005-02-27 14:50 -0500\".to_time\n      assert_nil \"010\".to_time\n      assert_nil \"\".to_time\n    end\n  end\n\n  def test_timestamp_string_to_time\n    exception = assert_raises(ArgumentError) do\n      \"1604326192\".to_time\n    end\n\n    assert_equal \"argument out of range\", exception.message\n  end\n\n  def test_string_to_time_utc_offset\n    with_env_tz \"US/Eastern\" do\n      if ActiveSupport.to_time_preserves_timezone\n        assert_equal 0, \"2005-02-27 23:50\".to_time(:utc).utc_offset\n        assert_equal(-18000, \"2005-02-27 23:50\".to_time.utc_offset)\n        assert_equal 0, \"2005-02-27 22:50 -0100\".to_time(:utc).utc_offset\n        assert_equal(-3600, \"2005-02-27 22:50 -0100\".to_time.utc_offset)\n      else\n        assert_equal 0, \"2005-02-27 23:50\".to_time(:utc).utc_offset\n        assert_equal(-18000, \"2005-02-27 23:50\".to_time.utc_offset)\n        assert_equal 0, \"2005-02-27 22:50 -0100\".to_time(:utc).utc_offset\n        assert_equal(-18000, \"2005-02-27 22:50 -0100\".to_time.utc_offset)\n      end\n    end\n  end\n\n  def test_partial_string_to_time\n    with_env_tz \"Europe/Moscow\" do # use timezone which does not observe DST.\n      now = Time.now\n      assert_equal Time.local(now.year, now.month, now.day, 23, 50), \"23:50\".to_time\n      assert_equal Time.utc(now.year, now.month, now.day, 23, 50), \"23:50\".to_time(:utc)\n      assert_equal Time.local(now.year, now.month, now.day, 17, 50), \"13:50 -0100\".to_time\n      assert_equal Time.utc(now.year, now.month, now.day, 23, 50), \"22:50 -0100\".to_time(:utc)\n    end\n  end\n\n  def test_standard_time_string_to_time_when_current_time_is_standard_time\n    with_env_tz \"US/Eastern\" do\n      Time.stub(:now, Time.local(2012, 1, 1)) do\n        assert_equal Time.local(2012, 1, 1, 10, 0), \"2012-01-01 10:00\".to_time\n        assert_equal Time.utc(2012, 1, 1, 10, 0), \"2012-01-01 10:00\".to_time(:utc)\n        assert_equal Time.local(2012, 1, 1, 13, 0), \"2012-01-01 10:00 -0800\".to_time\n        assert_equal Time.utc(2012, 1, 1, 18, 0), \"2012-01-01 10:00 -0800\".to_time(:utc)\n        assert_equal Time.local(2012, 1, 1, 10, 0), \"2012-01-01 10:00 -0500\".to_time\n        assert_equal Time.utc(2012, 1, 1, 15, 0), \"2012-01-01 10:00 -0500\".to_time(:utc)\n        assert_equal Time.local(2012, 1, 1, 5, 0), \"2012-01-01 10:00 UTC\".to_time\n        assert_equal Time.utc(2012, 1, 1, 10, 0), \"2012-01-01 10:00 UTC\".to_time(:utc)\n        assert_equal Time.local(2012, 1, 1, 13, 0), \"2012-01-01 10:00 PST\".to_time\n        assert_equal Time.utc(2012, 1, 1, 18, 0), \"2012-01-01 10:00 PST\".to_time(:utc)\n        assert_equal Time.local(2012, 1, 1, 10, 0), \"2012-01-01 10:00 EST\".to_time\n        assert_equal Time.utc(2012, 1, 1, 15, 0), \"2012-01-01 10:00 EST\".to_time(:utc)\n      end\n    end\n  end\n\n  def test_standard_time_string_to_time_when_current_time_is_daylight_savings\n    with_env_tz \"US/Eastern\" do\n      Time.stub(:now, Time.local(2012, 7, 1)) do\n        assert_equal Time.local(2012, 1, 1, 10, 0), \"2012-01-01 10:00\".to_time\n        assert_equal Time.utc(2012, 1, 1, 10, 0), \"2012-01-01 10:00\".to_time(:utc)\n        assert_equal Time.local(2012, 1, 1, 13, 0), \"2012-01-01 10:00 -0800\".to_time\n        assert_equal Time.utc(2012, 1, 1, 18, 0), \"2012-01-01 10:00 -0800\".to_time(:utc)\n        assert_equal Time.local(2012, 1, 1, 10, 0), \"2012-01-01 10:00 -0500\".to_time\n        assert_equal Time.utc(2012, 1, 1, 15, 0), \"2012-01-01 10:00 -0500\".to_time(:utc)\n        assert_equal Time.local(2012, 1, 1, 5, 0), \"2012-01-01 10:00 UTC\".to_time\n        assert_equal Time.utc(2012, 1, 1, 10, 0), \"2012-01-01 10:00 UTC\".to_time(:utc)\n        assert_equal Time.local(2012, 1, 1, 13, 0), \"2012-01-01 10:00 PST\".to_time\n        assert_equal Time.utc(2012, 1, 1, 18, 0), \"2012-01-01 10:00 PST\".to_time(:utc)\n        assert_equal Time.local(2012, 1, 1, 10, 0), \"2012-01-01 10:00 EST\".to_time\n        assert_equal Time.utc(2012, 1, 1, 15, 0), \"2012-01-01 10:00 EST\".to_time(:utc)\n      end\n    end\n  end\n\n  def test_daylight_savings_string_to_time_when_current_time_is_standard_time\n    with_env_tz \"US/Eastern\" do\n      Time.stub(:now, Time.local(2012, 1, 1)) do\n        assert_equal Time.local(2012, 7, 1, 10, 0), \"2012-07-01 10:00\".to_time\n        assert_equal Time.utc(2012, 7, 1, 10, 0), \"2012-07-01 10:00\".to_time(:utc)\n        assert_equal Time.local(2012, 7, 1, 13, 0), \"2012-07-01 10:00 -0700\".to_time\n        assert_equal Time.utc(2012, 7, 1, 17, 0), \"2012-07-01 10:00 -0700\".to_time(:utc)\n        assert_equal Time.local(2012, 7, 1, 10, 0), \"2012-07-01 10:00 -0400\".to_time\n        assert_equal Time.utc(2012, 7, 1, 14, 0), \"2012-07-01 10:00 -0400\".to_time(:utc)\n        assert_equal Time.local(2012, 7, 1, 6, 0), \"2012-07-01 10:00 UTC\".to_time\n        assert_equal Time.utc(2012, 7, 1, 10, 0), \"2012-07-01 10:00 UTC\".to_time(:utc)\n        assert_equal Time.local(2012, 7, 1, 13, 0), \"2012-07-01 10:00 PDT\".to_time\n        assert_equal Time.utc(2012, 7, 1, 17, 0), \"2012-07-01 10:00 PDT\".to_time(:utc)\n        assert_equal Time.local(2012, 7, 1, 10, 0), \"2012-07-01 10:00 EDT\".to_time\n        assert_equal Time.utc(2012, 7, 1, 14, 0), \"2012-07-01 10:00 EDT\".to_time(:utc)\n      end\n    end\n  end\n\n  def test_daylight_savings_string_to_time_when_current_time_is_daylight_savings\n    with_env_tz \"US/Eastern\" do\n      Time.stub(:now, Time.local(2012, 7, 1)) do\n        assert_equal Time.local(2012, 7, 1, 10, 0), \"2012-07-01 10:00\".to_time\n        assert_equal Time.utc(2012, 7, 1, 10, 0), \"2012-07-01 10:00\".to_time(:utc)\n        assert_equal Time.local(2012, 7, 1, 13, 0), \"2012-07-01 10:00 -0700\".to_time\n        assert_equal Time.utc(2012, 7, 1, 17, 0), \"2012-07-01 10:00 -0700\".to_time(:utc)\n        assert_equal Time.local(2012, 7, 1, 10, 0), \"2012-07-01 10:00 -0400\".to_time\n        assert_equal Time.utc(2012, 7, 1, 14, 0), \"2012-07-01 10:00 -0400\".to_time(:utc)\n        assert_equal Time.local(2012, 7, 1, 6, 0), \"2012-07-01 10:00 UTC\".to_time\n        assert_equal Time.utc(2012, 7, 1, 10, 0), \"2012-07-01 10:00 UTC\".to_time(:utc)\n        assert_equal Time.local(2012, 7, 1, 13, 0), \"2012-07-01 10:00 PDT\".to_time\n        assert_equal Time.utc(2012, 7, 1, 17, 0), \"2012-07-01 10:00 PDT\".to_time(:utc)\n        assert_equal Time.local(2012, 7, 1, 10, 0), \"2012-07-01 10:00 EDT\".to_time\n        assert_equal Time.utc(2012, 7, 1, 14, 0), \"2012-07-01 10:00 EDT\".to_time(:utc)\n      end\n    end\n  end\n\n  def test_partial_string_to_time_when_current_time_is_standard_time\n    with_env_tz \"US/Eastern\" do\n      Time.stub(:now, Time.local(2012, 1, 1)) do\n        assert_equal Time.local(2012, 1, 1, 10, 0), \"10:00\".to_time\n        assert_equal Time.utc(2012, 1, 1, 10, 0),  \"10:00\".to_time(:utc)\n        assert_equal Time.local(2012, 1, 1, 6, 0), \"10:00 -0100\".to_time\n        assert_equal Time.utc(2012, 1, 1, 11, 0), \"10:00 -0100\".to_time(:utc)\n        assert_equal Time.local(2012, 1, 1, 10, 0), \"10:00 -0500\".to_time\n        assert_equal Time.utc(2012, 1, 1, 15, 0), \"10:00 -0500\".to_time(:utc)\n        assert_equal Time.local(2012, 1, 1, 5, 0), \"10:00 UTC\".to_time\n        assert_equal Time.utc(2012, 1, 1, 10, 0), \"10:00 UTC\".to_time(:utc)\n        assert_equal Time.local(2012, 1, 1, 13, 0), \"10:00 PST\".to_time\n        assert_equal Time.utc(2012, 1, 1, 18, 0), \"10:00 PST\".to_time(:utc)\n        assert_equal Time.local(2012, 1, 1, 12, 0), \"10:00 PDT\".to_time\n        assert_equal Time.utc(2012, 1, 1, 17, 0), \"10:00 PDT\".to_time(:utc)\n        assert_equal Time.local(2012, 1, 1, 10, 0), \"10:00 EST\".to_time\n        assert_equal Time.utc(2012, 1, 1, 15, 0), \"10:00 EST\".to_time(:utc)\n        assert_equal Time.local(2012, 1, 1, 9, 0), \"10:00 EDT\".to_time\n        assert_equal Time.utc(2012, 1, 1, 14, 0), \"10:00 EDT\".to_time(:utc)\n      end\n    end\n  end\n\n  def test_partial_string_to_time_when_current_time_is_daylight_savings\n    with_env_tz \"US/Eastern\" do\n      Time.stub(:now, Time.local(2012, 7, 1)) do\n        assert_equal Time.local(2012, 7, 1, 10, 0), \"10:00\".to_time\n        assert_equal Time.utc(2012, 7, 1, 10, 0), \"10:00\".to_time(:utc)\n        assert_equal Time.local(2012, 7, 1, 7, 0), \"10:00 -0100\".to_time\n        assert_equal Time.utc(2012, 7, 1, 11, 0), \"10:00 -0100\".to_time(:utc)\n        assert_equal Time.local(2012, 7, 1, 11, 0), \"10:00 -0500\".to_time\n        assert_equal Time.utc(2012, 7, 1, 15, 0), \"10:00 -0500\".to_time(:utc)\n        assert_equal Time.local(2012, 7, 1, 6, 0), \"10:00 UTC\".to_time\n        assert_equal Time.utc(2012, 7, 1, 10, 0), \"10:00 UTC\".to_time(:utc)\n        assert_equal Time.local(2012, 7, 1, 14, 0), \"10:00 PST\".to_time\n        assert_equal Time.utc(2012, 7, 1, 18, 0), \"10:00 PST\".to_time(:utc)\n        assert_equal Time.local(2012, 7, 1, 13, 0), \"10:00 PDT\".to_time\n        assert_equal Time.utc(2012, 7, 1, 17, 0), \"10:00 PDT\".to_time(:utc)\n        assert_equal Time.local(2012, 7, 1, 11, 0), \"10:00 EST\".to_time\n        assert_equal Time.utc(2012, 7, 1, 15, 0), \"10:00 EST\".to_time(:utc)\n        assert_equal Time.local(2012, 7, 1, 10, 0), \"10:00 EDT\".to_time\n        assert_equal Time.utc(2012, 7, 1, 14, 0), \"10:00 EDT\".to_time(:utc)\n      end\n    end\n  end\n\n  def test_string_to_datetime\n    assert_equal DateTime.civil(2039, 2, 27, 23, 50), \"2039-02-27 23:50\".to_datetime\n    assert_equal 0, \"2039-02-27 23:50\".to_datetime.offset # use UTC offset\n    assert_equal ::Date::ITALY, \"2039-02-27 23:50\".to_datetime.start # use Ruby's default start value\n    assert_equal DateTime.civil(2039, 2, 27, 23, 50, 19 + Rational(275038, 1000000), \"-04:00\"), \"2039-02-27T23:50:19.275038-04:00\".to_datetime\n    assert_nil \"\".to_datetime\n  end\n\n  def test_partial_string_to_datetime\n    now = DateTime.now\n    assert_equal DateTime.civil(now.year, now.month, now.day, 23, 50), \"23:50\".to_datetime\n    assert_equal DateTime.civil(now.year, now.month, now.day, 23, 50, 0, \"-04:00\"), \"23:50 -0400\".to_datetime\n  end\n\n  def test_string_to_date\n    assert_equal Date.new(2005, 2, 27), \"2005-02-27\".to_date\n    assert_nil \"\".to_date\n    assert_equal Date.new(Date.today.year, 2, 3), \"Feb 3rd\".to_date\n  end\nend\n\nclass StringBehaviourTest < ActiveSupport::TestCase\n  def test_acts_like_string\n    assert_predicate \"Bambi\", :acts_like_string?\n  end\nend\n\nclass CoreExtStringMultibyteTest < ActiveSupport::TestCase\n  UTF8_STRING = \"\"\n  ASCII_STRING = \"ohayo\".encode(\"US-ASCII\")\n  EUC_JP_STRING = \"\".encode(\"EUC-JP\")\n  INVALID_UTF8_STRING = \"\\270\\236\\010\\210\\245\"\n\n  def test_core_ext_adds_mb_chars\n    assert_respond_to UTF8_STRING, :mb_chars\n  end\n\n  def test_string_should_recognize_utf8_strings\n    assert_predicate UTF8_STRING, :is_utf8?\n    assert_predicate ASCII_STRING, :is_utf8?\n    assert_not_predicate EUC_JP_STRING, :is_utf8?\n    assert_not_predicate INVALID_UTF8_STRING, :is_utf8?\n  end\n\n  def test_mb_chars_returns_instance_of_proxy_class\n    assert_kind_of ActiveSupport::Multibyte.proxy_class, UTF8_STRING.mb_chars\n  end\nend\n\nclass OutputSafetyTest < ActiveSupport::TestCase\n  def setup\n    @string = +\"hello\"\n    @object = Class.new(Object) do\n      def to_s\n        \"other\"\n      end\n    end.new\n  end\n\n  test \"A string is unsafe by default\" do\n    assert_not_predicate @string, :html_safe?\n  end\n\n  test \"A string can be marked safe\" do\n    string = @string.html_safe\n    assert_predicate string, :html_safe?\n  end\n\n  test \"Marking a string safe returns the string\" do\n    assert_equal @string, @string.html_safe\n  end\n\n  test \"An integer is safe by default\" do\n    assert_predicate 5, :html_safe?\n  end\n\n  test \"a float is safe by default\" do\n    assert_predicate 5.7, :html_safe?\n  end\n\n  test \"An object is unsafe by default\" do\n    assert_not_predicate @object, :html_safe?\n  end\n\n  test \"Adding an object to a safe string returns a safe string\" do\n    string = @string.html_safe\n    string << @object\n\n    assert_equal \"helloother\", string\n    assert_predicate string, :html_safe?\n  end\n\n  test \"Adding a safe string to another safe string returns a safe string\" do\n    @other_string = \"other\".html_safe\n    string = @string.html_safe\n    @combination = @other_string + string\n\n    assert_equal \"otherhello\", @combination\n    assert_predicate @combination, :html_safe?\n  end\n\n  test \"Adding an unsafe string to a safe string escapes it and returns a safe string\" do\n    @other_string = \"other\".html_safe\n    @combination = @other_string + \"<foo>\"\n    @other_combination = @string + \"<foo>\"\n\n    assert_equal \"other&lt;foo&gt;\", @combination\n    assert_equal \"hello<foo>\", @other_combination\n\n    assert_predicate @combination, :html_safe?\n    assert_not_predicate @other_combination, :html_safe?\n  end\n\n  test \"Prepending safe onto unsafe yields unsafe\" do\n    @string.prepend \"other\".html_safe\n    assert_not_predicate @string, :html_safe?\n    assert_equal \"otherhello\", @string\n  end\n\n  test \"Prepending unsafe onto safe yields escaped safe\" do\n    other = \"other\".html_safe\n    other.prepend \"<foo>\"\n    assert_predicate other, :html_safe?\n    assert_equal \"&lt;foo&gt;other\", other\n  end\n\n  test \"Concatting safe onto unsafe yields unsafe\" do\n    @other_string = +\"other\"\n\n    string = @string.html_safe\n    @other_string.concat(string)\n    assert_not_predicate @other_string, :html_safe?\n  end\n\n  test \"Concatting unsafe onto safe yields escaped safe\" do\n    @other_string = \"other\".html_safe\n    string = @other_string.concat(\"<foo>\")\n    assert_equal \"other&lt;foo&gt;\", string\n    assert_predicate string, :html_safe?\n  end\n\n  test \"Concatting safe onto safe yields safe\" do\n    @other_string = \"other\".html_safe\n    string = @string.html_safe\n\n    @other_string.concat(string)\n    assert_predicate @other_string, :html_safe?\n  end\n\n  test \"Concatting safe onto unsafe with << yields unsafe\" do\n    @other_string = +\"other\"\n    string = @string.html_safe\n\n    @other_string << string\n    assert_not_predicate @other_string, :html_safe?\n  end\n\n  test \"Concatting unsafe onto safe with << yields escaped safe\" do\n    @other_string = \"other\".html_safe\n    string = @other_string << \"<foo>\"\n    assert_equal \"other&lt;foo&gt;\", string\n    assert_predicate string, :html_safe?\n  end\n\n  test \"Concatting safe onto safe with << yields safe\" do\n    @other_string = \"other\".html_safe\n    string = @string.html_safe\n\n    @other_string << string\n    assert_predicate @other_string, :html_safe?\n  end\n\n  test \"Concatting safe onto unsafe with % yields unsafe\" do\n    @other_string = \"other%s\"\n    string = @string.html_safe\n\n    @other_string = @other_string % string\n    assert_not_predicate @other_string, :html_safe?\n  end\n\n  test \"Concatting unsafe onto safe with % yields escaped safe\" do\n    @other_string = \"other%s\".html_safe\n    string = @other_string % \"<foo>\"\n\n    assert_equal \"other&lt;foo&gt;\", string\n    assert_predicate string, :html_safe?\n  end\n\n  test \"Concatting safe onto safe with % yields safe\" do\n    @other_string = \"other%s\".html_safe\n    string = @string.html_safe\n\n    @other_string = @other_string % string\n    assert_predicate @other_string, :html_safe?\n  end\n\n  test \"Concatting with % doesn't modify a string\" do\n    @other_string = [\"<p>\", \"<b>\", \"<h1>\"]\n    _ = \"%s %s %s\".html_safe % @other_string\n\n    assert_equal [\"<p>\", \"<b>\", \"<h1>\"], @other_string\n  end\n\n  test \"Concatting an integer to safe always yields safe\" do\n    string = @string.html_safe\n    string = string.concat(13)\n    assert_equal (+\"hello\").concat(13), string\n    assert_predicate string, :html_safe?\n  end\n\n  test \"Inserting safe into safe yields safe\" do\n    string = \"foo\".html_safe\n    string.insert(0, \"<b>\".html_safe)\n\n    assert_equal \"<b>foo\", string\n    assert_predicate string, :html_safe?\n  end\n\n  test \"Inserting unsafe into safe yields escaped safe\" do\n    string = \"foo\".html_safe\n    string.insert(0, \"<b>\")\n\n    assert_equal \"&lt;b&gt;foo\", string\n    assert_predicate string, :html_safe?\n  end\n\n  test \"Replacing safe with safe yields safe\" do\n    string = \"foo\".html_safe\n    string.replace(\"<b>\".html_safe)\n\n    assert_equal \"<b>\", string\n    assert_predicate string, :html_safe?\n  end\n\n  test \"Replacing safe with unsafe yields escaped safe\" do\n    string = \"foo\".html_safe\n    string.replace(\"<b>\")\n\n    assert_equal \"&lt;b&gt;\", string\n    assert_predicate string, :html_safe?\n  end\n\n  test \"Replacing index of safe with safe yields safe\" do\n    string = \"foo\".html_safe\n    string[0] = \"<b>\".html_safe\n\n    assert_equal \"<b>oo\", string\n    assert_predicate string, :html_safe?\n  end\n\n  test \"Replacing index of safe with unsafe yields escaped safe\" do\n    string = \"foo\".html_safe\n    string[0] = \"<b>\"\n\n    assert_equal \"&lt;b&gt;oo\", string\n    assert_predicate string, :html_safe?\n  end\n\n  if \"\".respond_to?(:bytesplice)\n    test \"Bytesplicing safe into safe yields safe\" do\n      string = \"hello\".html_safe\n      string.bytesplice(0, 0, \"<b>\".html_safe)\n\n      assert_equal \"<b>hello\", string\n      assert_predicate string, :html_safe?\n\n      string = \"hello\".html_safe\n      string.bytesplice(0..1, \"<b>\".html_safe)\n\n      assert_equal \"<b>llo\", string\n      assert_predicate string, :html_safe?\n    end\n\n    test \"Bytesplicing unsafe into safe yields escaped safe\" do\n      string = \"hello\".html_safe\n      string.bytesplice(1, 0, \"<b>\")\n\n      assert_equal \"h&lt;b&gt;ello\", string\n      assert_predicate string, :html_safe?\n\n      string = \"hello\".html_safe\n      string.bytesplice(1..2, \"<b>\")\n\n      assert_equal \"h&lt;b&gt;lo\", string\n      assert_predicate string, :html_safe?\n    end\n  end\n\n  test \"emits normal string yaml\" do\n    assert_equal \"foo\".to_yaml, \"foo\".html_safe.to_yaml(foo: 1)\n  end\n\n  test \"call to_param returns a normal string\" do\n    string = @string.html_safe\n    assert_predicate string, :html_safe?\n    assert_not_predicate string.to_param, :html_safe?\n  end\n\n  test \"ERB::Util.html_escape should escape unsafe characters\" do\n    string = '<>&\"\\''\n    expected = \"&lt;&gt;&amp;&quot;&#39;\"\n    assert_equal expected, ERB::Util.html_escape(string)\n  end\n\n  test \"ERB::Util.html_escape should correctly handle invalid UTF-8 strings\" do\n    string = \"\\251 <\"\n    expected = \" &lt;\"\n    assert_equal expected, ERB::Util.html_escape(string)\n  end\n\n  test \"ERB::Util.html_escape should not escape safe strings\" do\n    string = \"<b>hello</b>\".html_safe\n    assert_equal string, ERB::Util.html_escape(string)\n  end\n\n  test \"ERB::Util.html_escape_once only escapes once\" do\n    string = \"1 < 2 &amp; 3\"\n    escaped_string = \"1 &lt; 2 &amp; 3\"\n\n    assert_equal escaped_string, ERB::Util.html_escape_once(string)\n    assert_equal escaped_string, ERB::Util.html_escape_once(escaped_string)\n  end\n\n  test \"ERB::Util.html_escape_once should correctly handle invalid UTF-8 strings\" do\n    string = \"\\251 <\"\n    expected = \" &lt;\"\n    assert_equal expected, ERB::Util.html_escape_once(string)\n  end\n\n  test \"ERB::Util.xml_name_escape should escape unsafe characters for XML names\" do\n    unsafe_char = \">\"\n    safe_char = \"\"\n    safe_char_after_start = \"3\"\n\n    assert_equal \"_\", ERB::Util.xml_name_escape(unsafe_char)\n    assert_equal \"_#{safe_char}\", ERB::Util.xml_name_escape(unsafe_char + safe_char)\n    assert_equal \"__\", ERB::Util.xml_name_escape(unsafe_char * 2)\n\n    assert_equal \"__#{safe_char}_\",\n                 ERB::Util.xml_name_escape(\"#{unsafe_char * 2}#{safe_char}#{unsafe_char}\")\n\n    assert_equal safe_char + safe_char_after_start,\n                 ERB::Util.xml_name_escape(safe_char + safe_char_after_start)\n\n    assert_equal \"_#{safe_char}\",\n                 ERB::Util.xml_name_escape(safe_char_after_start + safe_char)\n\n    assert_equal \"img_src_nonexistent_onerror_alert_1_\",\n                 ERB::Util.xml_name_escape(\"img src=nonexistent onerror=alert(1)\")\n\n    common_dangerous_chars = \"&<>\\\"' %*+,/;=^|\"\n    assert_equal \"_\" * common_dangerous_chars.size,\n                 ERB::Util.xml_name_escape(common_dangerous_chars)\n  end\nend\n\nclass StringExcludeTest < ActiveSupport::TestCase\n  test \"inverse of #include\" do\n    assert_equal false, \"foo\".exclude?(\"o\")\n    assert_equal true, \"foo\".exclude?(\"p\")\n  end\nend\n\nclass StringIndentTest < ActiveSupport::TestCase\n  test \"does not indent strings that only contain newlines (edge cases)\" do\n    [\"\", \"\\n\", \"\\n\" * 7].each do |string|\n      str = string.dup\n      assert_nil str.indent!(8)\n      assert_equal str, str.indent(8)\n      assert_equal str, str.indent(1, \"\\t\")\n    end\n  end\n\n  test \"by default, indents with spaces if the existing indentation uses them\" do\n    assert_equal \"    foo\\n      bar\", \"foo\\n  bar\".indent(4)\n  end\n\n  test \"by default, indents with tabs if the existing indentation uses them\" do\n    assert_equal \"\\tfoo\\n\\t\\t\\bar\", \"foo\\n\\t\\bar\".indent(1)\n  end\n\n  test \"by default, indents with spaces as a fallback if there is no indentation\" do\n    assert_equal \"   foo\\n   bar\\n   baz\", \"foo\\nbar\\nbaz\".indent(3)\n  end\n\n  # Nothing is said about existing indentation that mixes spaces and tabs, so\n  # there is nothing to test.\n\n  test \"uses the indent char if passed\" do\n    assert_equal <<EXPECTED, <<ACTUAL.indent(4, \".\")\n....  def some_method(x, y)\n....    some_code\n....  end\nEXPECTED\n  def some_method(x, y)\n    some_code\n  end\nACTUAL\n\n    assert_equal <<EXPECTED, <<ACTUAL.indent(2, \"&nbsp;\")\n&nbsp;&nbsp;&nbsp;&nbsp;def some_method(x, y)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;some_code\n&nbsp;&nbsp;&nbsp;&nbsp;end\nEXPECTED\n&nbsp;&nbsp;def some_method(x, y)\n&nbsp;&nbsp;&nbsp;&nbsp;some_code\n&nbsp;&nbsp;end\nACTUAL\n  end\n\n  test \"does not indent blank lines by default\" do\n    assert_equal \" foo\\n\\n bar\", \"foo\\n\\nbar\".indent(1)\n  end\n\n  test \"indents blank lines if told so\" do\n    assert_equal \" foo\\n \\n bar\", \"foo\\n\\nbar\".indent(1, nil, true)\n  end\nend\n", "patch": "@@ -987,6 +987,36 @@ def to_s\n     assert_predicate string, :html_safe?\n   end\n \n+  if \"\".respond_to?(:bytesplice)\n+    test \"Bytesplicing safe into safe yields safe\" do\n+      string = \"hello\".html_safe\n+      string.bytesplice(0, 0, \"<b>\".html_safe)\n+\n+      assert_equal \"<b>hello\", string\n+      assert_predicate string, :html_safe?\n+\n+      string = \"hello\".html_safe\n+      string.bytesplice(0..1, \"<b>\".html_safe)\n+\n+      assert_equal \"<b>llo\", string\n+      assert_predicate string, :html_safe?\n+    end\n+\n+    test \"Bytesplicing unsafe into safe yields escaped safe\" do\n+      string = \"hello\".html_safe\n+      string.bytesplice(1, 0, \"<b>\")\n+\n+      assert_equal \"h&lt;b&gt;ello\", string\n+      assert_predicate string, :html_safe?\n+\n+      string = \"hello\".html_safe\n+      string.bytesplice(1..2, \"<b>\")\n+\n+      assert_equal \"h&lt;b&gt;lo\", string\n+      assert_predicate string, :html_safe?\n+    end\n+  end\n+\n   test \"emits normal string yaml\" do\n     assert_equal \"foo\".to_yaml, \"foo\".html_safe.to_yaml(foo: 1)\n   end"}
{"patches_id": 10, "files_id": 41, "language": "rb", "raw_url": "https://github.com/rails/rails/raw/69e37c84e3f77d75566424c7d0015172d6a6fac5/actionpack%2Flib%2Faction_controller%2Fmetal%2Fredirecting.rb", "raw_code": "# frozen_string_literal: true\n\nmodule ActionController\n  module Redirecting\n    extend ActiveSupport::Concern\n\n    include AbstractController::Logger\n    include ActionController::UrlFor\n\n    class UnsafeRedirectError < StandardError; end\n\n    ILLEGAL_HEADER_VALUE_REGEX = /[\\x00-\\x08\\x0A-\\x1F]/.freeze\n\n    included do\n      mattr_accessor :raise_on_open_redirects, default: false\n    end\n\n    # Redirects the browser to the target specified in +options+. This parameter can be any one of:\n    #\n    # * <tt>Hash</tt> - The URL will be generated by calling url_for with the +options+.\n    # * <tt>Record</tt> - The URL will be generated by calling url_for with the +options+, which will reference a named URL for that record.\n    # * <tt>String</tt> starting with <tt>protocol://</tt> (like <tt>http://</tt>) or a protocol relative reference (like <tt>//</tt>) - Is passed straight through as the target for redirection.\n    # * <tt>String</tt> not containing a protocol - The current protocol and host is prepended to the string.\n    # * <tt>Proc</tt> - A block that will be executed in the controller's context. Should return any option accepted by +redirect_to+.\n    #\n    # === Examples\n    #\n    #   redirect_to action: \"show\", id: 5\n    #   redirect_to @post\n    #   redirect_to \"http://www.rubyonrails.org\"\n    #   redirect_to \"/images/screenshot.jpg\"\n    #   redirect_to posts_url\n    #   redirect_to proc { edit_post_url(@post) }\n    #\n    # The redirection happens as a <tt>302 Found</tt> header unless otherwise specified using the <tt>:status</tt> option:\n    #\n    #   redirect_to post_url(@post), status: :found\n    #   redirect_to action: 'atom', status: :moved_permanently\n    #   redirect_to post_url(@post), status: 301\n    #   redirect_to action: 'atom', status: 302\n    #\n    # The status code can either be a standard {HTTP Status code}[https://www.iana.org/assignments/http-status-codes] as an\n    # integer, or a symbol representing the downcased, underscored and symbolized description.\n    # Note that the status code must be a 3xx HTTP code, or redirection will not occur.\n    #\n    # If you are using XHR requests other than GET or POST and redirecting after the\n    # request then some browsers will follow the redirect using the original request\n    # method. This may lead to undesirable behavior such as a double DELETE. To work\n    # around this you can return a <tt>303 See Other</tt> status code which will be\n    # followed using a GET request.\n    #\n    #   redirect_to posts_url, status: :see_other\n    #   redirect_to action: 'index', status: 303\n    #\n    # It is also possible to assign a flash message as part of the redirection. There are two special accessors for the commonly used flash names\n    # +alert+ and +notice+ as well as a general purpose +flash+ bucket.\n    #\n    #   redirect_to post_url(@post), alert: \"Watch it, mister!\"\n    #   redirect_to post_url(@post), status: :found, notice: \"Pay attention to the road\"\n    #   redirect_to post_url(@post), status: 301, flash: { updated_post_id: @post.id }\n    #   redirect_to({ action: 'atom' }, alert: \"Something serious happened\")\n    #\n    # Statements after +redirect_to+ in our controller get executed, so +redirect_to+ doesn't stop the execution of the function.\n    # To terminate the execution of the function immediately after the +redirect_to+, use return.\n    #\n    #   redirect_to post_url(@post) and return\n    #\n    # === Open Redirect protection\n    #\n    # By default, \\Rails protects against redirecting to external hosts for your app's safety, so called open redirects.\n    # Note: this was a new default in \\Rails 7.0, after upgrading opt-in by uncommenting the line with +raise_on_open_redirects+ in <tt>config/initializers/new_framework_defaults_7_0.rb</tt>\n    #\n    # Here #redirect_to automatically validates the potentially-unsafe URL:\n    #\n    #   redirect_to params[:redirect_url]\n    #\n    # Raises UnsafeRedirectError in the case of an unsafe redirect.\n    #\n    # To allow any external redirects pass <tt>allow_other_host: true</tt>, though using a user-provided param in that case is unsafe.\n    #\n    #   redirect_to \"https://rubyonrails.org\", allow_other_host: true\n    #\n    # See #url_from for more information on what an internal and safe URL is, or how to fall back to an alternate redirect URL in the unsafe case.\n    def redirect_to(options = {}, response_options = {})\n      raise ActionControllerError.new(\"Cannot redirect to nil!\") unless options\n      raise AbstractController::DoubleRenderError if response_body\n\n      allow_other_host = response_options.delete(:allow_other_host) { _allow_other_host }\n\n      self.status        = _extract_redirect_to_status(options, response_options)\n\n      redirect_to_location = _compute_redirect_to_location(request, options)\n      _ensure_url_is_http_header_safe(redirect_to_location)\n\n      self.location      = _enforce_open_redirect_protection(redirect_to_location, allow_other_host: allow_other_host)\n      self.response_body = \"\"\n    end\n\n    # Soft deprecated alias for #redirect_back_or_to where the +fallback_location+ location is supplied as a keyword argument instead\n    # of the first positional argument.\n    def redirect_back(fallback_location:, allow_other_host: _allow_other_host, **args)\n      redirect_back_or_to fallback_location, allow_other_host: allow_other_host, **args\n    end\n\n    # Redirects the browser to the page that issued the request (the referrer)\n    # if possible, otherwise redirects to the provided default fallback\n    # location.\n    #\n    # The referrer information is pulled from the HTTP +Referer+ (sic) header on\n    # the request. This is an optional header and its presence on the request is\n    # subject to browser security settings and user preferences. If the request\n    # is missing this header, the <tt>fallback_location</tt> will be used.\n    #\n    #   redirect_back_or_to({ action: \"show\", id: 5 })\n    #   redirect_back_or_to @post\n    #   redirect_back_or_to \"http://www.rubyonrails.org\"\n    #   redirect_back_or_to \"/images/screenshot.jpg\"\n    #   redirect_back_or_to posts_url\n    #   redirect_back_or_to proc { edit_post_url(@post) }\n    #   redirect_back_or_to '/', allow_other_host: false\n    #\n    # ==== Options\n    # * <tt>:allow_other_host</tt> - Allow or disallow redirection to the host that is different to the current host, defaults to true.\n    #\n    # All other options that can be passed to #redirect_to are accepted as\n    # options, and the behavior is identical.\n    def redirect_back_or_to(fallback_location, allow_other_host: _allow_other_host, **options)\n      if request.referer && (allow_other_host || _url_host_allowed?(request.referer))\n        redirect_to request.referer, allow_other_host: allow_other_host, **options\n      else\n        # The method level `allow_other_host` doesn't apply in the fallback case, omit and let the `redirect_to` handling take over.\n        redirect_to fallback_location, **options\n      end\n    end\n\n    def _compute_redirect_to_location(request, options) # :nodoc:\n      case options\n      # The scheme name consist of a letter followed by any combination of\n      # letters, digits, and the plus (\"+\"), period (\".\"), or hyphen (\"-\")\n      # characters; and is terminated by a colon (\":\").\n      # See https://tools.ietf.org/html/rfc3986#section-3.1\n      # The protocol relative scheme starts with a double slash \"//\".\n      when /\\A([a-z][a-z\\d\\-+.]*:|\\/\\/).*/i\n        options.to_str\n      when String\n        request.protocol + request.host_with_port + options\n      when Proc\n        _compute_redirect_to_location request, instance_eval(&options)\n      else\n        url_for(options)\n      end.delete(\"\\0\\r\\n\")\n    end\n    module_function :_compute_redirect_to_location\n    public :_compute_redirect_to_location\n\n    # Verifies the passed +location+ is an internal URL that's safe to redirect to and returns it, or nil if not.\n    # Useful to wrap a params provided redirect URL and fallback to an alternate URL to redirect to:\n    #\n    #   redirect_to url_from(params[:redirect_url]) || root_url\n    #\n    # The +location+ is considered internal, and safe, if it's on the same host as <tt>request.host</tt>:\n    #\n    #   # If request.host is example.com:\n    #   url_from(\"https://example.com/profile\") # => \"https://example.com/profile\"\n    #   url_from(\"http://example.com/profile\")  # => \"http://example.com/profile\"\n    #   url_from(\"http://evil.com/profile\")     # => nil\n    #\n    # Subdomains are considered part of the host:\n    #\n    #   # If request.host is on https://example.com or https://app.example.com, you'd get:\n    #   url_from(\"https://dev.example.com/profile\") # => nil\n    #\n    # NOTE: there's a similarity with {url_for}[rdoc-ref:ActionDispatch::Routing::UrlFor#url_for], which generates an internal URL from various options from within the app, e.g. <tt>url_for(@post)</tt>.\n    # However, #url_from is meant to take an external parameter to verify as in <tt>url_from(params[:redirect_url])</tt>.\n    def url_from(location)\n      location = location.presence\n      location if location && _url_host_allowed?(location)\n    end\n\n    private\n      def _allow_other_host\n        !raise_on_open_redirects\n      end\n\n      def _extract_redirect_to_status(options, response_options)\n        if options.is_a?(Hash) && options.key?(:status)\n          Rack::Utils.status_code(options.delete(:status))\n        elsif response_options.key?(:status)\n          Rack::Utils.status_code(response_options[:status])\n        else\n          302\n        end\n      end\n\n      def _enforce_open_redirect_protection(location, allow_other_host:)\n        if allow_other_host || _url_host_allowed?(location)\n          location\n        else\n          raise UnsafeRedirectError, \"Unsafe redirect to #{location.truncate(100).inspect}, pass allow_other_host: true to redirect anyway.\"\n        end\n      end\n\n      def _url_host_allowed?(url)\n        host = URI(url.to_s).host\n\n        return true if host == request.host\n        return false unless host.nil?\n        return false unless url.to_s.start_with?(\"/\")\n        !url.to_s.start_with?(\"//\")\n      rescue ArgumentError, URI::Error\n        false\n      end\n\n      def _ensure_url_is_http_header_safe(url)\n        # Attempt to comply with the set of valid token characters\n        # defined for an HTTP header value in\n        # https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.6\n        if url.match(ILLEGAL_HEADER_VALUE_REGEX)\n          msg = \"The redirect URL #{url} contains one or more illegal HTTP header field character. \" \\\n            \"Set of legal characters defined in https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.6\"\n          raise UnsafeRedirectError, msg\n        end\n      end\n  end\nend\n", "patch": "@@ -9,6 +9,8 @@ module Redirecting\n \n     class UnsafeRedirectError < StandardError; end\n \n+    ILLEGAL_HEADER_VALUE_REGEX = /[\\x00-\\x08\\x0A-\\x1F]/.freeze\n+\n     included do\n       mattr_accessor :raise_on_open_redirects, default: false\n     end\n@@ -86,7 +88,11 @@ def redirect_to(options = {}, response_options = {})\n       allow_other_host = response_options.delete(:allow_other_host) { _allow_other_host }\n \n       self.status        = _extract_redirect_to_status(options, response_options)\n-      self.location      = _enforce_open_redirect_protection(_compute_redirect_to_location(request, options), allow_other_host: allow_other_host)\n+\n+      redirect_to_location = _compute_redirect_to_location(request, options)\n+      _ensure_url_is_http_header_safe(redirect_to_location)\n+\n+      self.location      = _enforce_open_redirect_protection(redirect_to_location, allow_other_host: allow_other_host)\n       self.response_body = \"\"\n     end\n \n@@ -204,5 +210,16 @@ def _url_host_allowed?(url)\n       rescue ArgumentError, URI::Error\n         false\n       end\n+\n+      def _ensure_url_is_http_header_safe(url)\n+        # Attempt to comply with the set of valid token characters\n+        # defined for an HTTP header value in\n+        # https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.6\n+        if url.match(ILLEGAL_HEADER_VALUE_REGEX)\n+          msg = \"The redirect URL #{url} contains one or more illegal HTTP header field character. \" \\\n+            \"Set of legal characters defined in https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.6\"\n+          raise UnsafeRedirectError, msg\n+        end\n+      end\n   end\n end"}
{"patches_id": 10, "files_id": 42, "language": "rb", "raw_url": "https://github.com/rails/rails/raw/69e37c84e3f77d75566424c7d0015172d6a6fac5/actionpack%2Ftest%2Fcontroller%2Fredirect_test.rb", "raw_code": "# frozen_string_literal: true\n\nrequire \"abstract_unit\"\n\nclass Workshop\n  extend ActiveModel::Naming\n  include ActiveModel::Conversion\n\n  OUT_OF_SCOPE_BLOCK = proc do\n    raise \"Not executed in controller's context\" unless RedirectController === self\n    request.original_url\n  end\n\n  attr_accessor :id\n\n  def initialize(id)\n    @id = id\n  end\n\n  def persisted?\n    id.present?\n  end\n\n  def to_s\n    id.to_s\n  end\nend\n\nclass RedirectController < ActionController::Base\n  # empty method not used anywhere to ensure methods like\n  # `status` and `location` aren't called on `redirect_to` calls\n  def status; raise \"Should not be called!\"; end\n  def location; raise \"Should not be called!\"; end\n\n  def simple_redirect\n    redirect_to action: \"hello_world\"\n  end\n\n  def redirect_with_status\n    redirect_to(action: \"hello_world\", status: 301)\n  end\n\n  def redirect_with_status_hash\n    redirect_to({ action: \"hello_world\" }, { status: 301 })\n  end\n\n  def redirect_with_protocol\n    redirect_to action: \"hello_world\", protocol: \"https\"\n  end\n\n  def url_redirect_with_status\n    redirect_to(\"http://www.example.com\", status: :moved_permanently)\n  end\n\n  def url_redirect_with_status_hash\n    redirect_to(\"http://www.example.com\", status: 301)\n  end\n\n  def relative_url_redirect_with_status\n    redirect_to(\"/things/stuff\", status: :found)\n  end\n\n  def relative_url_redirect_with_status_hash\n    redirect_to(\"/things/stuff\", status: 301)\n  end\n\n  def redirect_back_with_status\n    redirect_back_or_to \"/things/stuff\", status: 307\n  end\n\n  def redirect_back_with_status_and_fallback_location_to_another_host\n    redirect_back_or_to \"http://www.rubyonrails.org/\", status: 307\n  end\n\n  def safe_redirect_back_with_status\n    redirect_back_or_to \"/things/stuff\", status: 307, allow_other_host: false\n  end\n\n  def safe_redirect_back_with_status_and_fallback_location_to_another_host\n    redirect_back_or_to \"http://www.rubyonrails.org/\", status: 307, allow_other_host: false\n  end\n\n  def safe_redirect_to_root\n    redirect_to url_from(\"/\")\n  end\n\n  def unsafe_redirect\n    redirect_to \"http://www.rubyonrails.org/\"\n  end\n\n  def unsafe_redirect_back\n    redirect_back_or_to \"http://www.rubyonrails.org/\"\n  end\n\n  def unsafe_redirect_malformed\n    redirect_to \"http:///www.rubyonrails.org/\"\n  end\n\n  def unsafe_redirect_protocol_relative_double_slash\n    redirect_to \"//www.rubyonrails.org/\"\n  end\n\n  def unsafe_redirect_protocol_relative_triple_slash\n    redirect_to \"///www.rubyonrails.org/\"\n  end\n\n  def unsafe_redirect_with_illegal_http_header_value_character\n    redirect_to \"javascript:alert(document.domain)\\b\", allow_other_host: true\n  end\n\n  def only_path_redirect\n    redirect_to action: \"other_host\", only_path: true\n  end\n\n  def safe_redirect_with_fallback\n    redirect_to url_from(params[:redirect_url]) || \"/fallback\"\n  end\n\n  def redirect_back_with_explicit_fallback_kwarg\n    redirect_back(fallback_location: \"/things/stuff\", status: 307)\n  end\n\n  def host_redirect\n    redirect_to action: \"other_host\", only_path: false, host: \"other.test.host\"\n  end\n\n  def module_redirect\n    redirect_to controller: \"module_test/module_redirect\", action: \"hello_world\"\n  end\n\n  def redirect_to_url\n    redirect_to \"http://www.rubyonrails.org/\"\n  end\n\n  def redirect_to_url_with_stringlike\n    stringlike = Object.new\n\n    def stringlike.to_str\n      \"http://www.rubyonrails.org/\"\n    end\n\n    redirect_to stringlike\n  end\n\n  def redirect_to_url_with_unescaped_query_string\n    redirect_to \"http://example.com/query?status=new\"\n  end\n\n  def redirect_to_url_with_complex_scheme\n    redirect_to \"x-test+scheme.complex:redirect\"\n  end\n\n  def redirect_to_url_with_network_path_reference\n    redirect_to \"//www.rubyonrails.org/\"\n  end\n\n  def redirect_to_existing_record\n    redirect_to Workshop.new(5)\n  end\n\n  def redirect_to_new_record\n    redirect_to Workshop.new(nil)\n  end\n\n  def redirect_to_nil\n    redirect_to nil\n  end\n\n  def redirect_to_polymorphic\n    redirect_to [:internal, Workshop.new(5)]\n  end\n\n  def redirect_to_polymorphic_string_args\n    redirect_to [\"internal\", Workshop.new(5)]\n  end\n\n  def redirect_to_params\n    redirect_to ActionController::Parameters.new(status: 200, protocol: \"javascript\", f: \"%0Aeval(name)\")\n  end\n\n  def redirect_to_with_block\n    redirect_to proc { \"http://www.rubyonrails.org/\" }\n  end\n\n  def redirect_to_with_block_and_assigns\n    @url = \"http://www.rubyonrails.org/\"\n    redirect_to proc { @url }\n  end\n\n  def redirect_to_with_block_and_options\n    redirect_to proc { { action: \"hello_world\" } }\n  end\n\n  def redirect_to_out_of_scope_block\n    redirect_to Workshop::OUT_OF_SCOPE_BLOCK\n  end\n\n  def redirect_with_header_break\n    redirect_to \"/lol\\r\\nwat\"\n  end\n\n  def redirect_with_null_bytes\n    redirect_to \"\\000/lol\\r\\nwat\"\n  end\n\n  def rescue_errors(e) raise e end\n\n  private\n    def dashboard_url(id, message)\n      url_for action: \"dashboard\", params: { \"id\" => id, \"message\" => message }\n    end\nend\n\nclass RedirectTest < ActionController::TestCase\n  tests RedirectController\n\n  def test_simple_redirect\n    get :simple_redirect\n    assert_response :redirect\n    assert_equal \"http://test.host/redirect/hello_world\", redirect_to_url\n  end\n\n  def test_redirect_with_header_break\n    get :redirect_with_header_break\n    assert_response :redirect\n    assert_equal \"http://test.host/lolwat\", redirect_to_url\n  end\n\n  def test_redirect_with_null_bytes\n    get :redirect_with_null_bytes\n    assert_response :redirect\n    assert_equal \"http://test.host/lolwat\", redirect_to_url\n  end\n\n  def test_redirect_with_no_status\n    get :simple_redirect\n    assert_response 302\n    assert_equal \"http://test.host/redirect/hello_world\", redirect_to_url\n  end\n\n  def test_redirect_with_status\n    get :redirect_with_status\n    assert_response 301\n    assert_equal \"http://test.host/redirect/hello_world\", redirect_to_url\n  end\n\n  def test_redirect_with_status_hash\n    get :redirect_with_status_hash\n    assert_response 301\n    assert_equal \"http://test.host/redirect/hello_world\", redirect_to_url\n  end\n\n  def test_redirect_with_protocol\n    get :redirect_with_protocol\n    assert_response 302\n    assert_equal \"https://test.host/redirect/hello_world\", redirect_to_url\n  end\n\n  def test_url_redirect_with_status\n    get :url_redirect_with_status\n    assert_response 301\n    assert_equal \"http://www.example.com\", redirect_to_url\n  end\n\n  def test_url_redirect_with_status_hash\n    get :url_redirect_with_status_hash\n    assert_response 301\n    assert_equal \"http://www.example.com\", redirect_to_url\n  end\n\n  def test_relative_url_redirect_with_status\n    get :relative_url_redirect_with_status\n    assert_response 302\n    assert_equal \"http://test.host/things/stuff\", redirect_to_url\n  end\n\n  def test_relative_url_redirect_with_status_hash\n    get :relative_url_redirect_with_status_hash\n    assert_response 301\n    assert_equal \"http://test.host/things/stuff\", redirect_to_url\n  end\n\n  def test_relative_url_redirect_host_with_port\n    request.host = \"test.host:1234\"\n    get :relative_url_redirect_with_status\n    assert_response 302\n    assert_equal \"http://test.host:1234/things/stuff\", redirect_to_url\n  end\n\n  def test_simple_redirect_using_options\n    get :host_redirect\n    assert_response :redirect\n    assert_redirected_to action: \"other_host\", only_path: false, host: \"other.test.host\"\n  end\n\n  def test_module_redirect\n    get :module_redirect\n    assert_response :redirect\n    assert_redirected_to \"http://test.host/module_test/module_redirect/hello_world\"\n  end\n\n  def test_module_redirect_using_options\n    get :module_redirect\n    assert_response :redirect\n    assert_redirected_to controller: \"module_test/module_redirect\", action: \"hello_world\"\n  end\n\n  def test_redirect_to_url\n    get :redirect_to_url\n    assert_response :redirect\n    assert_redirected_to \"http://www.rubyonrails.org/\"\n  end\n\n  def test_redirect_to_url_with_stringlike\n    get :redirect_to_url_with_stringlike\n    assert_response :redirect\n    assert_redirected_to \"http://www.rubyonrails.org/\"\n  end\n\n  def test_redirect_to_url_with_unescaped_query_string\n    get :redirect_to_url_with_unescaped_query_string\n    assert_response :redirect\n    assert_redirected_to \"http://example.com/query?status=new\"\n  end\n\n  def test_redirect_to_url_with_complex_scheme\n    get :redirect_to_url_with_complex_scheme\n    assert_response :redirect\n    assert_equal \"x-test+scheme.complex:redirect\", redirect_to_url\n  end\n\n  def test_redirect_to_url_with_network_path_reference\n    get :redirect_to_url_with_network_path_reference\n    assert_response :redirect\n    assert_equal \"//www.rubyonrails.org/\", redirect_to_url\n  end\n\n  def test_redirect_back\n    referer = \"http://www.example.com/coming/from\"\n    @request.env[\"HTTP_REFERER\"] = referer\n\n    get :redirect_back_with_status\n\n    assert_response 307\n    assert_equal referer, redirect_to_url\n  end\n\n  def test_redirect_back_with_no_referer\n    get :redirect_back_with_status\n\n    assert_response 307\n    assert_equal \"http://test.host/things/stuff\", redirect_to_url\n  end\n\n  def test_redirect_back_with_no_referer_redirects_to_another_host\n    get :redirect_back_with_status_and_fallback_location_to_another_host\n\n    assert_response 307\n    assert_equal \"http://www.rubyonrails.org/\", redirect_to_url\n  end\n\n  def test_safe_redirect_back_from_other_host\n    @request.env[\"HTTP_REFERER\"] = \"http://another.host/coming/from\"\n    get :safe_redirect_back_with_status\n\n    assert_response 307\n    assert_equal \"http://test.host/things/stuff\", redirect_to_url\n  end\n\n  def test_safe_redirect_back_from_the_same_host\n    referer = \"http://test.host/coming/from\"\n    @request.env[\"HTTP_REFERER\"] = referer\n    get :safe_redirect_back_with_status\n\n    assert_response 307\n    assert_equal referer, redirect_to_url\n  end\n\n  def test_safe_redirect_back_with_no_referer\n    get :safe_redirect_back_with_status\n\n    assert_response 307\n    assert_equal \"http://test.host/things/stuff\", redirect_to_url\n  end\n\n  def test_safe_redirect_back_with_no_referer_redirects_to_another_host\n    get :safe_redirect_back_with_status_and_fallback_location_to_another_host\n\n    assert_response 307\n    assert_equal \"http://www.rubyonrails.org/\", redirect_to_url\n  end\n\n  def test_safe_redirect_to_root\n    get :safe_redirect_to_root\n\n    assert_equal \"http://test.host/\", redirect_to_url\n  end\n\n  def test_redirect_back_with_explicit_fallback_kwarg\n    referer = \"http://www.example.com/coming/from\"\n    @request.env[\"HTTP_REFERER\"] = referer\n\n    get :redirect_back_with_explicit_fallback_kwarg\n\n    assert_response 307\n    assert_equal referer, redirect_to_url\n  end\n\n  def test_redirect_to_record\n    with_routing do |set|\n      set.draw do\n        resources :workshops\n\n        ActionDispatch.deprecator.silence do\n          get \":controller/:action\"\n        end\n      end\n\n      get :redirect_to_existing_record\n      assert_equal \"http://test.host/workshops/5\", redirect_to_url\n      assert_redirected_to Workshop.new(5)\n\n      get :redirect_to_new_record\n      assert_equal \"http://test.host/workshops\", redirect_to_url\n      assert_redirected_to Workshop.new(nil)\n    end\n  end\n\n  def test_polymorphic_redirect\n    with_routing do |set|\n      set.draw do\n        namespace :internal do\n          resources :workshops\n        end\n\n        ActionDispatch.deprecator.silence do\n          get \":controller/:action\"\n        end\n      end\n\n      get :redirect_to_polymorphic\n      assert_equal \"http://test.host/internal/workshops/5\", redirect_to_url\n      assert_redirected_to [:internal, Workshop.new(5)]\n    end\n  end\n\n  def test_polymorphic_redirect_with_string_args\n    with_routing do |set|\n      set.draw do\n        namespace :internal do\n          resources :workshops\n        end\n\n        ActionDispatch.deprecator.silence do\n          get \":controller/:action\"\n        end\n      end\n\n      error = assert_raises(ArgumentError) do\n        get :redirect_to_polymorphic_string_args\n      end\n      assert_equal(\"Please use symbols for polymorphic route arguments.\", error.message)\n    end\n  end\n\n  def test_redirect_to_nil\n    error = assert_raise(ActionController::ActionControllerError) do\n      get :redirect_to_nil\n    end\n    assert_equal \"Cannot redirect to nil!\", error.message\n  end\n\n  def test_redirect_to_params\n    error = assert_raise(ActionController::UnfilteredParameters) do\n      get :redirect_to_params\n    end\n    assert_equal \"unable to convert unpermitted parameters to hash\", error.message\n  end\n\n  def test_redirect_to_with_block\n    get :redirect_to_with_block\n    assert_response :redirect\n    assert_redirected_to \"http://www.rubyonrails.org/\"\n  end\n\n  def test_redirect_to_with_block_and_assigns\n    get :redirect_to_with_block_and_assigns\n    assert_response :redirect\n    assert_redirected_to \"http://www.rubyonrails.org/\"\n  end\n\n  def test_redirect_to_out_of_scope_block\n    get :redirect_to_out_of_scope_block\n    assert_response :redirect\n    assert_redirected_to \"http://test.host/redirect/redirect_to_out_of_scope_block\"\n  end\n\n  def test_redirect_to_with_block_and_accepted_options\n    with_routing do |set|\n      set.draw do\n        ActionDispatch.deprecator.silence do\n          get \":controller/:action\"\n        end\n      end\n\n      get :redirect_to_with_block_and_options\n\n      assert_response :redirect\n      assert_redirected_to \"http://test.host/redirect/hello_world\"\n    end\n  end\n\n  def test_unsafe_redirect\n    with_raise_on_open_redirects do\n      error = assert_raise(ActionController::Redirecting::UnsafeRedirectError) do\n        get :unsafe_redirect\n      end\n\n      assert_equal \"Unsafe redirect to \\\"http://www.rubyonrails.org/\\\", pass allow_other_host: true to redirect anyway.\", error.message\n    end\n  end\n\n  def test_unsafe_redirect_back\n    with_raise_on_open_redirects do\n      error = assert_raise(ActionController::Redirecting::UnsafeRedirectError) do\n        get :unsafe_redirect_back\n      end\n\n      assert_equal \"Unsafe redirect to \\\"http://www.rubyonrails.org/\\\", pass allow_other_host: true to redirect anyway.\", error.message\n    end\n  end\n\n  def test_unsafe_redirect_with_malformed_url\n    with_raise_on_open_redirects do\n      error = assert_raise(ActionController::Redirecting::UnsafeRedirectError) do\n        get :unsafe_redirect_malformed\n      end\n\n      assert_equal \"Unsafe redirect to \\\"http:///www.rubyonrails.org/\\\", pass allow_other_host: true to redirect anyway.\", error.message\n    end\n  end\n\n  def test_unsafe_redirect_with_protocol_relative_double_slash_url\n    with_raise_on_open_redirects do\n      error = assert_raise(ActionController::Redirecting::UnsafeRedirectError) do\n        get :unsafe_redirect_protocol_relative_double_slash\n      end\n\n      assert_equal \"Unsafe redirect to \\\"//www.rubyonrails.org/\\\", pass allow_other_host: true to redirect anyway.\", error.message\n    end\n  end\n\n  def test_unsafe_redirect_with_protocol_relative_triple_slash_url\n    with_raise_on_open_redirects do\n      error = assert_raise(ActionController::Redirecting::UnsafeRedirectError) do\n        get :unsafe_redirect_protocol_relative_triple_slash\n      end\n\n      assert_equal \"Unsafe redirect to \\\"///www.rubyonrails.org/\\\", pass allow_other_host: true to redirect anyway.\", error.message\n    end\n  end\n\n  def test_unsafe_redirect_with_illegal_http_header_value_character\n    with_raise_on_open_redirects do\n      error = assert_raise(ActionController::Redirecting::UnsafeRedirectError) do\n        get :unsafe_redirect_with_illegal_http_header_value_character\n      end\n\n      msg = \"The redirect URL javascript:alert(document.domain)\\b contains one or more illegal HTTP header field character. \" \\\n        \"Set of legal characters defined in https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.6\"\n\n      assert_equal msg, error.message\n    end\n  end\n\n\n  def test_only_path_redirect\n    with_raise_on_open_redirects do\n      get :only_path_redirect\n      assert_response :redirect\n      assert_redirected_to \"/redirect/other_host\"\n    end\n  end\n\n  def test_url_from\n    with_raise_on_open_redirects do\n      get :safe_redirect_with_fallback, params: { redirect_url: \"http://test.host/app\" }\n      assert_response :redirect\n      assert_redirected_to \"http://test.host/app\"\n    end\n  end\n\n  def test_url_from_fallback\n    with_raise_on_open_redirects do\n      get :safe_redirect_with_fallback, params: { redirect_url: \"http://www.rubyonrails.org/\" }\n      assert_response :redirect\n      assert_redirected_to \"http://test.host/fallback\"\n\n      get :safe_redirect_with_fallback, params: { redirect_url: \"\" }\n      assert_response :redirect\n      assert_redirected_to \"http://test.host/fallback\"\n    end\n  end\n\n  private\n    def with_raise_on_open_redirects\n      old_raise_on_open_redirects = ActionController::Base.raise_on_open_redirects\n      ActionController::Base.raise_on_open_redirects = true\n      yield\n    ensure\n      ActionController::Base.raise_on_open_redirects = old_raise_on_open_redirects\n    end\nend\n\nmodule ModuleTest\n  class ModuleRedirectController < ::RedirectController\n    def module_redirect\n      redirect_to controller: \"/redirect\", action: \"hello_world\"\n    end\n  end\n\n  class ModuleRedirectTest < ActionController::TestCase\n    tests ModuleRedirectController\n\n    def test_simple_redirect\n      get :simple_redirect\n      assert_response :redirect\n      assert_equal \"http://test.host/module_test/module_redirect/hello_world\", redirect_to_url\n    end\n\n    def test_simple_redirect_using_options\n      get :host_redirect\n      assert_response :redirect\n      assert_redirected_to action: \"other_host\", only_path: false, host: \"other.test.host\"\n    end\n\n    def test_module_redirect\n      get :module_redirect\n      assert_response :redirect\n      assert_equal \"http://test.host/redirect/hello_world\", redirect_to_url\n    end\n\n    def test_module_redirect_using_options\n      get :module_redirect\n      assert_response :redirect\n      assert_redirected_to controller: \"/redirect\", action: \"hello_world\"\n    end\n  end\nend\n", "patch": "@@ -104,6 +104,10 @@ def unsafe_redirect_protocol_relative_triple_slash\n     redirect_to \"///www.rubyonrails.org/\"\n   end\n \n+  def unsafe_redirect_with_illegal_http_header_value_character\n+    redirect_to \"javascript:alert(document.domain)\\b\", allow_other_host: true\n+  end\n+\n   def only_path_redirect\n     redirect_to action: \"other_host\", only_path: true\n   end\n@@ -556,6 +560,20 @@ def test_unsafe_redirect_with_protocol_relative_triple_slash_url\n     end\n   end\n \n+  def test_unsafe_redirect_with_illegal_http_header_value_character\n+    with_raise_on_open_redirects do\n+      error = assert_raise(ActionController::Redirecting::UnsafeRedirectError) do\n+        get :unsafe_redirect_with_illegal_http_header_value_character\n+      end\n+\n+      msg = \"The redirect URL javascript:alert(document.domain)\\b contains one or more illegal HTTP header field character. \" \\\n+        \"Set of legal characters defined in https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.6\"\n+\n+      assert_equal msg, error.message\n+    end\n+  end\n+\n+\n   def test_only_path_redirect\n     with_raise_on_open_redirects do\n       get :only_path_redirect"}
{"patches_id": 11, "files_id": 43, "language": "rb", "raw_url": "https://github.com/rails/rails/raw/1c3f93d1e90a3475f9ae2377ead25ccf11f71441/actionpack%2Flib%2Faction_controller%2Fmetal%2Fredirecting.rb", "raw_code": "# frozen_string_literal: true\n\nmodule ActionController\n  module Redirecting\n    extend ActiveSupport::Concern\n\n    include AbstractController::Logger\n    include ActionController::UrlFor\n\n    ILLEGAL_HEADER_VALUE_REGEX = /[\\x00-\\x08\\x0A-\\x1F]/.freeze\n\n    class UnsafeRedirectError < StandardError; end\n\n    # Redirects the browser to the target specified in +options+. This parameter can be any one of:\n    #\n    # * <tt>Hash</tt> - The URL will be generated by calling url_for with the +options+.\n    # * <tt>Record</tt> - The URL will be generated by calling url_for with the +options+, which will reference a named URL for that record.\n    # * <tt>String</tt> starting with <tt>protocol://</tt> (like <tt>http://</tt>) or a protocol relative reference (like <tt>//</tt>) - Is passed straight through as the target for redirection.\n    # * <tt>String</tt> not containing a protocol - The current protocol and host is prepended to the string.\n    # * <tt>Proc</tt> - A block that will be executed in the controller's context. Should return any option accepted by +redirect_to+.\n    #\n    # === Examples:\n    #\n    #   redirect_to action: \"show\", id: 5\n    #   redirect_to @post\n    #   redirect_to \"http://www.rubyonrails.org\"\n    #   redirect_to \"/images/screenshot.jpg\"\n    #   redirect_to posts_url\n    #   redirect_to proc { edit_post_url(@post) }\n    #\n    # The redirection happens as a <tt>302 Found</tt> header unless otherwise specified using the <tt>:status</tt> option:\n    #\n    #   redirect_to post_url(@post), status: :found\n    #   redirect_to action: 'atom', status: :moved_permanently\n    #   redirect_to post_url(@post), status: 301\n    #   redirect_to action: 'atom', status: 302\n    #\n    # The status code can either be a standard {HTTP Status code}[https://www.iana.org/assignments/http-status-codes] as an\n    # integer, or a symbol representing the downcased, underscored and symbolized description.\n    # Note that the status code must be a 3xx HTTP code, or redirection will not occur.\n    #\n    # If you are using XHR requests other than GET or POST and redirecting after the\n    # request then some browsers will follow the redirect using the original request\n    # method. This may lead to undesirable behavior such as a double DELETE. To work\n    # around this you can return a <tt>303 See Other</tt> status code which will be\n    # followed using a GET request.\n    #\n    #   redirect_to posts_url, status: :see_other\n    #   redirect_to action: 'index', status: 303\n    #\n    # It is also possible to assign a flash message as part of the redirection. There are two special accessors for the commonly used flash names\n    # +alert+ and +notice+ as well as a general purpose +flash+ bucket.\n    #\n    #   redirect_to post_url(@post), alert: \"Watch it, mister!\"\n    #   redirect_to post_url(@post), status: :found, notice: \"Pay attention to the road\"\n    #   redirect_to post_url(@post), status: 301, flash: { updated_post_id: @post.id }\n    #   redirect_to({ action: 'atom' }, alert: \"Something serious happened\")\n    #\n    # Statements after +redirect_to+ in our controller get executed, so +redirect_to+ doesn't stop the execution of the function.\n    # To terminate the execution of the function immediately after the +redirect_to+, use return.\n    #   redirect_to post_url(@post) and return\n    def redirect_to(options = {}, response_options = {})\n      raise ActionControllerError.new(\"Cannot redirect to nil!\") unless options\n      raise AbstractController::DoubleRenderError if response_body\n\n      self.status        = _extract_redirect_to_status(options, response_options)\n\n      redirect_to_location = _compute_redirect_to_location(request, options)\n      _ensure_url_is_http_header_safe(redirect_to_location)\n\n      self.location      = redirect_to_location\n      self.response_body = \"<html><body>You are being <a href=\\\"#{ERB::Util.unwrapped_html_escape(response.location)}\\\">redirected</a>.</body></html>\"\n    end\n\n    # Redirects the browser to the page that issued the request (the referrer)\n    # if possible, otherwise redirects to the provided default fallback\n    # location.\n    #\n    # The referrer information is pulled from the HTTP +Referer+ (sic) header on\n    # the request. This is an optional header and its presence on the request is\n    # subject to browser security settings and user preferences. If the request\n    # is missing this header, the <tt>fallback_location</tt> will be used.\n    #\n    #   redirect_back fallback_location: { action: \"show\", id: 5 }\n    #   redirect_back fallback_location: @post\n    #   redirect_back fallback_location: \"http://www.rubyonrails.org\"\n    #   redirect_back fallback_location: \"/images/screenshot.jpg\"\n    #   redirect_back fallback_location: posts_url\n    #   redirect_back fallback_location: proc { edit_post_url(@post) }\n    #   redirect_back fallback_location: '/', allow_other_host: false\n    #\n    # ==== Options\n    # * <tt>:fallback_location</tt> - The default fallback location that will be used on missing +Referer+ header.\n    # * <tt>:allow_other_host</tt> - Allow or disallow redirection to the host that is different to the current host, defaults to true.\n    #\n    # All other options that can be passed to #redirect_to are accepted as\n    # options and the behavior is identical.\n    def redirect_back(fallback_location:, allow_other_host: true, **args)\n      referer = request.headers[\"Referer\"]\n      redirect_to_referer = referer && (allow_other_host || _url_host_allowed?(referer))\n      redirect_to redirect_to_referer ? referer : fallback_location, **args\n    end\n\n    def _compute_redirect_to_location(request, options) #:nodoc:\n      case options\n      # The scheme name consist of a letter followed by any combination of\n      # letters, digits, and the plus (\"+\"), period (\".\"), or hyphen (\"-\")\n      # characters; and is terminated by a colon (\":\").\n      # See https://tools.ietf.org/html/rfc3986#section-3.1\n      # The protocol relative scheme starts with a double slash \"//\".\n      when /\\A([a-z][a-z\\d\\-+\\.]*:|\\/\\/).*/i\n        options\n      when String\n        request.protocol + request.host_with_port + options\n      when Proc\n        _compute_redirect_to_location request, instance_eval(&options)\n      else\n        url_for(options)\n      end.delete(\"\\0\\r\\n\")\n    end\n    module_function :_compute_redirect_to_location\n    public :_compute_redirect_to_location\n\n    private\n      def _extract_redirect_to_status(options, response_options)\n        if options.is_a?(Hash) && options.key?(:status)\n          Rack::Utils.status_code(options.delete(:status))\n        elsif response_options.key?(:status)\n          Rack::Utils.status_code(response_options[:status])\n        else\n          302\n        end\n      end\n\n      def _url_host_allowed?(url)\n        URI(url.to_s).host == request.host\n      rescue ArgumentError, URI::Error\n        false\n      end\n\n      def _ensure_url_is_http_header_safe(url)\n        # Attempt to comply with the set of valid token characters\n        # defined for an HTTP header value in\n        # https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.6\n        if url.match(ILLEGAL_HEADER_VALUE_REGEX)\n          msg = \"The redirect URL #{url} contains one or more illegal HTTP header field character. \" \\\n            \"Set of legal characters defined in https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.6\"\n          raise UnsafeRedirectError, msg\n        end\n      end\n  end\nend\n", "patch": "@@ -7,6 +7,10 @@ module Redirecting\n     include AbstractController::Logger\n     include ActionController::UrlFor\n \n+    ILLEGAL_HEADER_VALUE_REGEX = /[\\x00-\\x08\\x0A-\\x1F]/.freeze\n+\n+    class UnsafeRedirectError < StandardError; end\n+\n     # Redirects the browser to the target specified in +options+. This parameter can be any one of:\n     #\n     # * <tt>Hash</tt> - The URL will be generated by calling url_for with the +options+.\n@@ -60,7 +64,11 @@ def redirect_to(options = {}, response_options = {})\n       raise AbstractController::DoubleRenderError if response_body\n \n       self.status        = _extract_redirect_to_status(options, response_options)\n-      self.location      = _compute_redirect_to_location(request, options)\n+\n+      redirect_to_location = _compute_redirect_to_location(request, options)\n+      _ensure_url_is_http_header_safe(redirect_to_location)\n+\n+      self.location      = redirect_to_location\n       self.response_body = \"<html><body>You are being <a href=\\\"#{ERB::Util.unwrapped_html_escape(response.location)}\\\">redirected</a>.</body></html>\"\n     end\n \n@@ -129,5 +137,16 @@ def _url_host_allowed?(url)\n       rescue ArgumentError, URI::Error\n         false\n       end\n+\n+      def _ensure_url_is_http_header_safe(url)\n+        # Attempt to comply with the set of valid token characters\n+        # defined for an HTTP header value in\n+        # https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.6\n+        if url.match(ILLEGAL_HEADER_VALUE_REGEX)\n+          msg = \"The redirect URL #{url} contains one or more illegal HTTP header field character. \" \\\n+            \"Set of legal characters defined in https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.6\"\n+          raise UnsafeRedirectError, msg\n+        end\n+      end\n   end\n end"}
{"patches_id": 11, "files_id": 44, "language": "rb", "raw_url": "https://github.com/rails/rails/raw/1c3f93d1e90a3475f9ae2377ead25ccf11f71441/actionpack%2Ftest%2Fcontroller%2Fredirect_test.rb", "raw_code": "# frozen_string_literal: true\n\nrequire \"abstract_unit\"\n\nclass Workshop\n  extend ActiveModel::Naming\n  include ActiveModel::Conversion\n\n  OUT_OF_SCOPE_BLOCK = proc do\n    raise \"Not executed in controller's context\" unless RedirectController === self\n    request.original_url\n  end\n\n  attr_accessor :id\n\n  def initialize(id)\n    @id = id\n  end\n\n  def persisted?\n    id.present?\n  end\n\n  def to_s\n    id.to_s\n  end\nend\n\nclass RedirectController < ActionController::Base\n  # empty method not used anywhere to ensure methods like\n  # `status` and `location` aren't called on `redirect_to` calls\n  def status; raise \"Should not be called!\"; end\n  def location; raise \"Should not be called!\"; end\n\n  def simple_redirect\n    redirect_to action: \"hello_world\"\n  end\n\n  def redirect_with_status\n    redirect_to(action: \"hello_world\", status: 301)\n  end\n\n  def redirect_with_status_hash\n    redirect_to({ action: \"hello_world\" }, { status: 301 })\n  end\n\n  def redirect_with_protocol\n    redirect_to action: \"hello_world\", protocol: \"https\"\n  end\n\n  def url_redirect_with_status\n    redirect_to(\"http://www.example.com\", status: :moved_permanently)\n  end\n\n  def url_redirect_with_status_hash\n    redirect_to(\"http://www.example.com\", status: 301)\n  end\n\n  def relative_url_redirect_with_status\n    redirect_to(\"/things/stuff\", status: :found)\n  end\n\n  def relative_url_redirect_with_status_hash\n    redirect_to(\"/things/stuff\", status: 301)\n  end\n\n  def redirect_back_with_status\n    redirect_back(fallback_location: \"/things/stuff\", status: 307)\n  end\n\n  def redirect_back_with_status_and_fallback_location_to_another_host\n    redirect_back(fallback_location: \"http://www.rubyonrails.org/\", status: 307)\n  end\n\n  def safe_redirect_back_with_status\n    redirect_back(fallback_location: \"/things/stuff\", status: 307, allow_other_host: false)\n  end\n\n  def safe_redirect_back_with_status_and_fallback_location_to_another_host\n    redirect_back(fallback_location: \"http://www.rubyonrails.org/\", status: 307, allow_other_host: false)\n  end\n\n  def host_redirect\n    redirect_to action: \"other_host\", only_path: false, host: \"other.test.host\"\n  end\n\n  def module_redirect\n    redirect_to controller: \"module_test/module_redirect\", action: \"hello_world\"\n  end\n\n  def redirect_to_url\n    redirect_to \"http://www.rubyonrails.org/\"\n  end\n\n  def redirect_to_url_with_unescaped_query_string\n    redirect_to \"http://example.com/query?status=new\"\n  end\n\n  def redirect_to_url_with_complex_scheme\n    redirect_to \"x-test+scheme.complex:redirect\"\n  end\n\n  def redirect_to_url_with_network_path_reference\n    redirect_to \"//www.rubyonrails.org/\"\n  end\n\n  def redirect_to_existing_record\n    redirect_to Workshop.new(5)\n  end\n\n  def redirect_to_new_record\n    redirect_to Workshop.new(nil)\n  end\n\n  def redirect_to_nil\n    redirect_to nil\n  end\n\n  def redirect_to_polymorphic\n    redirect_to [:internal, Workshop.new(5)]\n  end\n\n  def redirect_to_polymorphic_string_args\n    redirect_to [\"internal\", Workshop.new(5)]\n  end\n\n  def redirect_to_params\n    redirect_to ActionController::Parameters.new(status: 200, protocol: \"javascript\", f: \"%0Aeval(name)\")\n  end\n\n  def redirect_to_with_block\n    redirect_to proc { \"http://www.rubyonrails.org/\" }\n  end\n\n  def redirect_to_with_block_and_assigns\n    @url = \"http://www.rubyonrails.org/\"\n    redirect_to proc { @url }\n  end\n\n  def redirect_to_with_block_and_options\n    redirect_to proc { { action: \"hello_world\" } }\n  end\n\n  def redirect_to_out_of_scope_block\n    redirect_to Workshop::OUT_OF_SCOPE_BLOCK\n  end\n\n  def redirect_with_header_break\n    redirect_to \"/lol\\r\\nwat\"\n  end\n\n  def redirect_with_null_bytes\n    redirect_to \"\\000/lol\\r\\nwat\"\n  end\n\n  def unsafe_redirect_with_illegal_http_header_value_character\n    redirect_to \"javascript:alert(document.domain)\\b\"\n  end\n\n\n  def rescue_errors(e) raise e end\n\n  private\n    def dashbord_url(id, message)\n      url_for action: \"dashboard\", params: { \"id\" => id, \"message\" => message }\n    end\nend\n\nclass RedirectTest < ActionController::TestCase\n  tests RedirectController\n\n  def test_simple_redirect\n    get :simple_redirect\n    assert_response :redirect\n    assert_equal \"http://test.host/redirect/hello_world\", redirect_to_url\n  end\n\n  def test_redirect_with_header_break\n    get :redirect_with_header_break\n    assert_response :redirect\n    assert_equal \"http://test.host/lolwat\", redirect_to_url\n  end\n\n  def test_redirect_with_null_bytes\n    get :redirect_with_null_bytes\n    assert_response :redirect\n    assert_equal \"http://test.host/lolwat\", redirect_to_url\n  end\n\n  def test_redirect_with_no_status\n    get :simple_redirect\n    assert_response 302\n    assert_equal \"http://test.host/redirect/hello_world\", redirect_to_url\n  end\n\n  def test_redirect_with_status\n    get :redirect_with_status\n    assert_response 301\n    assert_equal \"http://test.host/redirect/hello_world\", redirect_to_url\n  end\n\n  def test_redirect_with_status_hash\n    get :redirect_with_status_hash\n    assert_response 301\n    assert_equal \"http://test.host/redirect/hello_world\", redirect_to_url\n  end\n\n  def test_redirect_with_protocol\n    get :redirect_with_protocol\n    assert_response 302\n    assert_equal \"https://test.host/redirect/hello_world\", redirect_to_url\n  end\n\n  def test_url_redirect_with_status\n    get :url_redirect_with_status\n    assert_response 301\n    assert_equal \"http://www.example.com\", redirect_to_url\n  end\n\n  def test_url_redirect_with_status_hash\n    get :url_redirect_with_status_hash\n    assert_response 301\n    assert_equal \"http://www.example.com\", redirect_to_url\n  end\n\n  def test_relative_url_redirect_with_status\n    get :relative_url_redirect_with_status\n    assert_response 302\n    assert_equal \"http://test.host/things/stuff\", redirect_to_url\n  end\n\n  def test_relative_url_redirect_with_status_hash\n    get :relative_url_redirect_with_status_hash\n    assert_response 301\n    assert_equal \"http://test.host/things/stuff\", redirect_to_url\n  end\n\n  def test_relative_url_redirect_host_with_port\n    request.host = \"test.host:1234\"\n    get :relative_url_redirect_with_status\n    assert_response 302\n    assert_equal \"http://test.host:1234/things/stuff\", redirect_to_url\n  end\n\n  def test_simple_redirect_using_options\n    get :host_redirect\n    assert_response :redirect\n    assert_redirected_to action: \"other_host\", only_path: false, host: \"other.test.host\"\n  end\n\n  def test_module_redirect\n    get :module_redirect\n    assert_response :redirect\n    assert_redirected_to \"http://test.host/module_test/module_redirect/hello_world\"\n  end\n\n  def test_module_redirect_using_options\n    get :module_redirect\n    assert_response :redirect\n    assert_redirected_to controller: \"module_test/module_redirect\", action: \"hello_world\"\n  end\n\n  def test_redirect_to_url\n    get :redirect_to_url\n    assert_response :redirect\n    assert_redirected_to \"http://www.rubyonrails.org/\"\n  end\n\n  def test_redirect_to_url_with_unescaped_query_string\n    get :redirect_to_url_with_unescaped_query_string\n    assert_response :redirect\n    assert_redirected_to \"http://example.com/query?status=new\"\n  end\n\n  def test_redirect_to_url_with_complex_scheme\n    get :redirect_to_url_with_complex_scheme\n    assert_response :redirect\n    assert_equal \"x-test+scheme.complex:redirect\", redirect_to_url\n  end\n\n  def test_redirect_to_url_with_network_path_reference\n    get :redirect_to_url_with_network_path_reference\n    assert_response :redirect\n    assert_equal \"//www.rubyonrails.org/\", redirect_to_url\n  end\n\n  def test_redirect_back\n    referer = \"http://www.example.com/coming/from\"\n    @request.env[\"HTTP_REFERER\"] = referer\n\n    get :redirect_back_with_status\n\n    assert_response 307\n    assert_equal referer, redirect_to_url\n  end\n\n  def test_redirect_back_with_no_referer\n    get :redirect_back_with_status\n\n    assert_response 307\n    assert_equal \"http://test.host/things/stuff\", redirect_to_url\n  end\n\n  def test_redirect_back_with_no_referer_redirects_to_another_host\n    get :redirect_back_with_status_and_fallback_location_to_another_host\n\n    assert_response 307\n    assert_equal \"http://www.rubyonrails.org/\", redirect_to_url\n  end\n\n  def test_safe_redirect_back_from_other_host\n    @request.env[\"HTTP_REFERER\"] = \"http://another.host/coming/from\"\n    get :safe_redirect_back_with_status\n\n    assert_response 307\n    assert_equal \"http://test.host/things/stuff\", redirect_to_url\n  end\n\n  def test_safe_redirect_back_from_the_same_host\n    referer = \"http://test.host/coming/from\"\n    @request.env[\"HTTP_REFERER\"] = referer\n    get :safe_redirect_back_with_status\n\n    assert_response 307\n    assert_equal referer, redirect_to_url\n  end\n\n  def test_safe_redirect_back_with_no_referer\n    get :safe_redirect_back_with_status\n\n    assert_response 307\n    assert_equal \"http://test.host/things/stuff\", redirect_to_url\n  end\n\n  def test_safe_redirect_back_with_no_referer_redirects_to_another_host\n    get :safe_redirect_back_with_status_and_fallback_location_to_another_host\n\n    assert_response 307\n    assert_equal \"http://www.rubyonrails.org/\", redirect_to_url\n  end\n\n  def test_redirect_to_record\n    with_routing do |set|\n      set.draw do\n        resources :workshops\n\n        ActiveSupport::Deprecation.silence do\n          get \":controller/:action\"\n        end\n      end\n\n      get :redirect_to_existing_record\n      assert_equal \"http://test.host/workshops/5\", redirect_to_url\n      assert_redirected_to Workshop.new(5)\n\n      get :redirect_to_new_record\n      assert_equal \"http://test.host/workshops\", redirect_to_url\n      assert_redirected_to Workshop.new(nil)\n    end\n  end\n\n  def test_polymorphic_redirect\n    with_routing do |set|\n      set.draw do\n        namespace :internal do\n          resources :workshops\n        end\n\n        ActiveSupport::Deprecation.silence do\n          get \":controller/:action\"\n        end\n      end\n\n      get :redirect_to_polymorphic\n      assert_equal \"http://test.host/internal/workshops/5\", redirect_to_url\n      assert_redirected_to [:internal, Workshop.new(5)]\n    end\n  end\n\n  def test_polymorphic_redirect_with_string_args\n    with_routing do |set|\n      set.draw do\n        namespace :internal do\n          resources :workshops\n        end\n\n        ActiveSupport::Deprecation.silence do\n          get \":controller/:action\"\n        end\n      end\n\n      error = assert_raises(ArgumentError) do\n        get :redirect_to_polymorphic_string_args\n      end\n      assert_equal(\"Please use symbols for polymorphic route arguments.\", error.message)\n    end\n  end\n\n  def test_redirect_to_nil\n    error = assert_raise(ActionController::ActionControllerError) do\n      get :redirect_to_nil\n    end\n    assert_equal \"Cannot redirect to nil!\", error.message\n  end\n\n  def test_redirect_to_params\n    error = assert_raise(ActionController::UnfilteredParameters) do\n      get :redirect_to_params\n    end\n    assert_equal \"unable to convert unpermitted parameters to hash\", error.message\n  end\n\n  def test_redirect_to_with_block\n    get :redirect_to_with_block\n    assert_response :redirect\n    assert_redirected_to \"http://www.rubyonrails.org/\"\n  end\n\n  def test_redirect_to_with_block_and_assigns\n    get :redirect_to_with_block_and_assigns\n    assert_response :redirect\n    assert_redirected_to \"http://www.rubyonrails.org/\"\n  end\n\n  def test_redirect_to_out_of_scope_block\n    get :redirect_to_out_of_scope_block\n    assert_response :redirect\n    assert_redirected_to \"http://test.host/redirect/redirect_to_out_of_scope_block\"\n  end\n\n  def test_redirect_to_with_block_and_accepted_options\n    with_routing do |set|\n      set.draw do\n        ActiveSupport::Deprecation.silence do\n          get \":controller/:action\"\n        end\n      end\n\n      get :redirect_to_with_block_and_options\n\n      assert_response :redirect\n      assert_redirected_to \"http://test.host/redirect/hello_world\"\n    end\n  end\n\n  def test_unsafe_redirect_with_illegal_http_header_value_character\n    error = assert_raise(ActionController::Redirecting::UnsafeRedirectError) do\n      get :unsafe_redirect_with_illegal_http_header_value_character\n    end\n\n    msg = \"The redirect URL javascript:alert(document.domain)\\b contains one or more illegal HTTP header field character. \" \\\n      \"Set of legal characters defined in https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.6\"\n\n    assert_equal msg, error.message\n  end\n\nend\n\nmodule ModuleTest\n  class ModuleRedirectController < ::RedirectController\n    def module_redirect\n      redirect_to controller: \"/redirect\", action: \"hello_world\"\n    end\n  end\n\n  class ModuleRedirectTest < ActionController::TestCase\n    tests ModuleRedirectController\n\n    def test_simple_redirect\n      get :simple_redirect\n      assert_response :redirect\n      assert_equal \"http://test.host/module_test/module_redirect/hello_world\", redirect_to_url\n    end\n\n    def test_simple_redirect_using_options\n      get :host_redirect\n      assert_response :redirect\n      assert_redirected_to action: \"other_host\", only_path: false, host: \"other.test.host\"\n    end\n\n    def test_module_redirect\n      get :module_redirect\n      assert_response :redirect\n      assert_equal \"http://test.host/redirect/hello_world\", redirect_to_url\n    end\n\n    def test_module_redirect_using_options\n      get :module_redirect\n      assert_response :redirect\n      assert_redirected_to controller: \"/redirect\", action: \"hello_world\"\n    end\n  end\nend\n", "patch": "@@ -153,6 +153,11 @@ def redirect_with_null_bytes\n     redirect_to \"\\000/lol\\r\\nwat\"\n   end\n \n+  def unsafe_redirect_with_illegal_http_header_value_character\n+    redirect_to \"javascript:alert(document.domain)\\b\"\n+  end\n+\n+\n   def rescue_errors(e) raise e end\n \n   private\n@@ -437,6 +442,18 @@ def test_redirect_to_with_block_and_accepted_options\n       assert_redirected_to \"http://test.host/redirect/hello_world\"\n     end\n   end\n+\n+  def test_unsafe_redirect_with_illegal_http_header_value_character\n+    error = assert_raise(ActionController::Redirecting::UnsafeRedirectError) do\n+      get :unsafe_redirect_with_illegal_http_header_value_character\n+    end\n+\n+    msg = \"The redirect URL javascript:alert(document.domain)\\b contains one or more illegal HTTP header field character. \" \\\n+      \"Set of legal characters defined in https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.6\"\n+\n+    assert_equal msg, error.message\n+  end\n+\n end\n \n module ModuleTest"}
{"patches_id": 12, "files_id": 45, "language": "rb", "raw_url": "https://github.com/rails/rails/raw/c9ab9b32bcdcfd8bcd55907f6c7b20b4e004cc23/actionpack%2Flib%2Faction_controller%2Fmetal%2Fredirecting.rb", "raw_code": "# frozen_string_literal: true\n\nmodule ActionController\n  module Redirecting\n    extend ActiveSupport::Concern\n\n    ILLEGAL_HEADER_VALUE_REGEX = /[\\x00-\\x08\\x0A-\\x1F]/.freeze\n\n    include AbstractController::Logger\n    include ActionController::UrlFor\n\n    class UnsafeRedirectError < StandardError; end\n\n    included do\n      mattr_accessor :raise_on_open_redirects, default: false\n    end\n\n    # Redirects the browser to the target specified in +options+. This parameter can be any one of:\n    #\n    # * <tt>Hash</tt> - The URL will be generated by calling url_for with the +options+.\n    # * <tt>Record</tt> - The URL will be generated by calling url_for with the +options+, which will reference a named URL for that record.\n    # * <tt>String</tt> starting with <tt>protocol://</tt> (like <tt>http://</tt>) or a protocol relative reference (like <tt>//</tt>) - Is passed straight through as the target for redirection.\n    # * <tt>String</tt> not containing a protocol - The current protocol and host is prepended to the string.\n    # * <tt>Proc</tt> - A block that will be executed in the controller's context. Should return any option accepted by +redirect_to+.\n    #\n    # === Examples:\n    #\n    #   redirect_to action: \"show\", id: 5\n    #   redirect_to @post\n    #   redirect_to \"http://www.rubyonrails.org\"\n    #   redirect_to \"/images/screenshot.jpg\"\n    #   redirect_to posts_url\n    #   redirect_to proc { edit_post_url(@post) }\n    #\n    # The redirection happens as a <tt>302 Found</tt> header unless otherwise specified using the <tt>:status</tt> option:\n    #\n    #   redirect_to post_url(@post), status: :found\n    #   redirect_to action: 'atom', status: :moved_permanently\n    #   redirect_to post_url(@post), status: 301\n    #   redirect_to action: 'atom', status: 302\n    #\n    # The status code can either be a standard {HTTP Status code}[https://www.iana.org/assignments/http-status-codes] as an\n    # integer, or a symbol representing the downcased, underscored and symbolized description.\n    # Note that the status code must be a 3xx HTTP code, or redirection will not occur.\n    #\n    # If you are using XHR requests other than GET or POST and redirecting after the\n    # request then some browsers will follow the redirect using the original request\n    # method. This may lead to undesirable behavior such as a double DELETE. To work\n    # around this you can return a <tt>303 See Other</tt> status code which will be\n    # followed using a GET request.\n    #\n    #   redirect_to posts_url, status: :see_other\n    #   redirect_to action: 'index', status: 303\n    #\n    # It is also possible to assign a flash message as part of the redirection. There are two special accessors for the commonly used flash names\n    # +alert+ and +notice+ as well as a general purpose +flash+ bucket.\n    #\n    #   redirect_to post_url(@post), alert: \"Watch it, mister!\"\n    #   redirect_to post_url(@post), status: :found, notice: \"Pay attention to the road\"\n    #   redirect_to post_url(@post), status: 301, flash: { updated_post_id: @post.id }\n    #   redirect_to({ action: 'atom' }, alert: \"Something serious happened\")\n    #\n    # Statements after +redirect_to+ in our controller get executed, so +redirect_to+ doesn't stop the execution of the function.\n    # To terminate the execution of the function immediately after the +redirect_to+, use return.\n    #\n    #   redirect_to post_url(@post) and return\n    #\n    # === Open Redirect protection\n    #\n    # By default, Rails protects against redirecting to external hosts for your app's safety, so called open redirects.\n    # Note: this was a new default in Rails 7.0, after upgrading opt-in by uncommenting the line with +raise_on_open_redirects+ in <tt>config/initializers/new_framework_defaults_7_0.rb</tt>\n    #\n    # Here #redirect_to automatically validates the potentially-unsafe URL:\n    #\n    #   redirect_to params[:redirect_url]\n    #\n    # Raises UnsafeRedirectError in the case of an unsafe redirect.\n    #\n    # To allow any external redirects pass <tt>allow_other_host: true</tt>, though using a user-provided param in that case is unsafe.\n    #\n    #   redirect_to \"https://rubyonrails.org\", allow_other_host: true\n    #\n    # See #url_from for more information on what an internal and safe URL is, or how to fall back to an alternate redirect URL in the unsafe case.\n    def redirect_to(options = {}, response_options = {})\n      raise ActionControllerError.new(\"Cannot redirect to nil!\") unless options\n      raise AbstractController::DoubleRenderError if response_body\n\n      allow_other_host = response_options.delete(:allow_other_host) { _allow_other_host }\n\n      self.status        = _extract_redirect_to_status(options, response_options)\n\n      redirect_to_location = _compute_redirect_to_location(request, options)\n      _ensure_url_is_http_header_safe(redirect_to_location)\n\n      self.location      = _enforce_open_redirect_protection(redirect_to_location, allow_other_host: allow_other_host)\n      self.response_body = \"<html><body>You are being <a href=\\\"#{ERB::Util.unwrapped_html_escape(response.location)}\\\">redirected</a>.</body></html>\"\n    end\n\n    # Soft deprecated alias for #redirect_back_or_to where the +fallback_location+ location is supplied as a keyword argument instead\n    # of the first positional argument.\n    def redirect_back(fallback_location:, allow_other_host: _allow_other_host, **args)\n      redirect_back_or_to fallback_location, allow_other_host: allow_other_host, **args\n    end\n\n    # Redirects the browser to the page that issued the request (the referrer)\n    # if possible, otherwise redirects to the provided default fallback\n    # location.\n    #\n    # The referrer information is pulled from the HTTP +Referer+ (sic) header on\n    # the request. This is an optional header and its presence on the request is\n    # subject to browser security settings and user preferences. If the request\n    # is missing this header, the <tt>fallback_location</tt> will be used.\n    #\n    #   redirect_back_or_to({ action: \"show\", id: 5 })\n    #   redirect_back_or_to @post\n    #   redirect_back_or_to \"http://www.rubyonrails.org\"\n    #   redirect_back_or_to \"/images/screenshot.jpg\"\n    #   redirect_back_or_to posts_url\n    #   redirect_back_or_to proc { edit_post_url(@post) }\n    #   redirect_back_or_to '/', allow_other_host: false\n    #\n    # ==== Options\n    # * <tt>:allow_other_host</tt> - Allow or disallow redirection to the host that is different to the current host, defaults to true.\n    #\n    # All other options that can be passed to #redirect_to are accepted as\n    # options, and the behavior is identical.\n    def redirect_back_or_to(fallback_location, allow_other_host: _allow_other_host, **options)\n      if request.referer && (allow_other_host || _url_host_allowed?(request.referer))\n        redirect_to request.referer, allow_other_host: allow_other_host, **options\n      else\n        # The method level `allow_other_host` doesn't apply in the fallback case, omit and let the `redirect_to` handling take over.\n        redirect_to fallback_location, **options\n      end\n    end\n\n    def _compute_redirect_to_location(request, options) # :nodoc:\n      case options\n      # The scheme name consist of a letter followed by any combination of\n      # letters, digits, and the plus (\"+\"), period (\".\"), or hyphen (\"-\")\n      # characters; and is terminated by a colon (\":\").\n      # See https://tools.ietf.org/html/rfc3986#section-3.1\n      # The protocol relative scheme starts with a double slash \"//\".\n      when /\\A([a-z][a-z\\d\\-+.]*:|\\/\\/).*/i\n        options.to_str\n      when String\n        request.protocol + request.host_with_port + options\n      when Proc\n        _compute_redirect_to_location request, instance_eval(&options)\n      else\n        url_for(options)\n      end.delete(\"\\0\\r\\n\")\n    end\n    module_function :_compute_redirect_to_location\n    public :_compute_redirect_to_location\n\n    # Verifies the passed +location+ is an internal URL that's safe to redirect to and returns it, or nil if not.\n    # Useful to wrap a params provided redirect URL and fallback to an alternate URL to redirect to:\n    #\n    #   redirect_to url_from(params[:redirect_url]) || root_url\n    #\n    # The +location+ is considered internal, and safe, if it's on the same host as <tt>request.host</tt>:\n    #\n    #   # If request.host is example.com:\n    #   url_from(\"https://example.com/profile\") # => \"https://example.com/profile\"\n    #   url_from(\"http://example.com/profile\")  # => \"http://example.com/profile\"\n    #   url_from(\"http://evil.com/profile\")     # => nil\n    #\n    # Subdomains are considered part of the host:\n    #\n    #   # If request.host is on https://example.com or https://app.example.com, you'd get:\n    #   url_from(\"https://dev.example.com/profile\") # => nil\n    #\n    # NOTE: there's a similarity with {url_for}[rdoc-ref:ActionDispatch::Routing::UrlFor#url_for], which generates an internal URL from various options from within the app, e.g. <tt>url_for(@post)</tt>.\n    # However, #url_from is meant to take an external parameter to verify as in <tt>url_from(params[:redirect_url])</tt>.\n    def url_from(location)\n      location = location.presence\n      location if location && _url_host_allowed?(location)\n    end\n\n    private\n      def _allow_other_host\n        !raise_on_open_redirects\n      end\n\n      def _extract_redirect_to_status(options, response_options)\n        if options.is_a?(Hash) && options.key?(:status)\n          Rack::Utils.status_code(options.delete(:status))\n        elsif response_options.key?(:status)\n          Rack::Utils.status_code(response_options[:status])\n        else\n          302\n        end\n      end\n\n      def _enforce_open_redirect_protection(location, allow_other_host:)\n        if allow_other_host || _url_host_allowed?(location)\n          location\n        else\n          raise UnsafeRedirectError, \"Unsafe redirect to #{location.truncate(100).inspect}, pass allow_other_host: true to redirect anyway.\"\n        end\n      end\n\n      def _url_host_allowed?(url)\n        host = URI(url.to_s).host\n\n        return true if host == request.host\n        return false unless host.nil?\n        return false unless url.to_s.start_with?(\"/\")\n        !url.to_s.start_with?(\"//\")\n      rescue ArgumentError, URI::Error\n        false\n      end\n\n      def _ensure_url_is_http_header_safe(url)\n        # Attempt to comply with the set of valid token characters\n        # defined for an HTTP header value in\n        # https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.6\n        if url.match(ILLEGAL_HEADER_VALUE_REGEX)\n          msg = \"The redirect URL #{url} contains one or more illegal HTTP header field character. \" \\\n            \"Set of legal characters defined in https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.6\"\n          raise UnsafeRedirectError, msg\n        end\n      end\n  end\nend\n", "patch": "@@ -4,6 +4,8 @@ module ActionController\n   module Redirecting\n     extend ActiveSupport::Concern\n \n+    ILLEGAL_HEADER_VALUE_REGEX = /[\\x00-\\x08\\x0A-\\x1F]/.freeze\n+\n     include AbstractController::Logger\n     include ActionController::UrlFor\n \n@@ -86,7 +88,11 @@ def redirect_to(options = {}, response_options = {})\n       allow_other_host = response_options.delete(:allow_other_host) { _allow_other_host }\n \n       self.status        = _extract_redirect_to_status(options, response_options)\n-      self.location      = _enforce_open_redirect_protection(_compute_redirect_to_location(request, options), allow_other_host: allow_other_host)\n+\n+      redirect_to_location = _compute_redirect_to_location(request, options)\n+      _ensure_url_is_http_header_safe(redirect_to_location)\n+\n+      self.location      = _enforce_open_redirect_protection(redirect_to_location, allow_other_host: allow_other_host)\n       self.response_body = \"<html><body>You are being <a href=\\\"#{ERB::Util.unwrapped_html_escape(response.location)}\\\">redirected</a>.</body></html>\"\n     end\n \n@@ -204,5 +210,16 @@ def _url_host_allowed?(url)\n       rescue ArgumentError, URI::Error\n         false\n       end\n+\n+      def _ensure_url_is_http_header_safe(url)\n+        # Attempt to comply with the set of valid token characters\n+        # defined for an HTTP header value in\n+        # https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.6\n+        if url.match(ILLEGAL_HEADER_VALUE_REGEX)\n+          msg = \"The redirect URL #{url} contains one or more illegal HTTP header field character. \" \\\n+            \"Set of legal characters defined in https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.6\"\n+          raise UnsafeRedirectError, msg\n+        end\n+      end\n   end\n end"}
{"patches_id": 12, "files_id": 46, "language": "rb", "raw_url": "https://github.com/rails/rails/raw/c9ab9b32bcdcfd8bcd55907f6c7b20b4e004cc23/actionpack%2Ftest%2Fcontroller%2Fredirect_test.rb", "raw_code": "# frozen_string_literal: true\n\nrequire \"abstract_unit\"\n\nclass Workshop\n  extend ActiveModel::Naming\n  include ActiveModel::Conversion\n\n  OUT_OF_SCOPE_BLOCK = proc do\n    raise \"Not executed in controller's context\" unless RedirectController === self\n    request.original_url\n  end\n\n  attr_accessor :id\n\n  def initialize(id)\n    @id = id\n  end\n\n  def persisted?\n    id.present?\n  end\n\n  def to_s\n    id.to_s\n  end\nend\n\nclass RedirectController < ActionController::Base\n  # empty method not used anywhere to ensure methods like\n  # `status` and `location` aren't called on `redirect_to` calls\n  def status; raise \"Should not be called!\"; end\n  def location; raise \"Should not be called!\"; end\n\n  def simple_redirect\n    redirect_to action: \"hello_world\"\n  end\n\n  def redirect_with_status\n    redirect_to(action: \"hello_world\", status: 301)\n  end\n\n  def redirect_with_status_hash\n    redirect_to({ action: \"hello_world\" }, { status: 301 })\n  end\n\n  def redirect_with_protocol\n    redirect_to action: \"hello_world\", protocol: \"https\"\n  end\n\n  def url_redirect_with_status\n    redirect_to(\"http://www.example.com\", status: :moved_permanently)\n  end\n\n  def url_redirect_with_status_hash\n    redirect_to(\"http://www.example.com\", status: 301)\n  end\n\n  def relative_url_redirect_with_status\n    redirect_to(\"/things/stuff\", status: :found)\n  end\n\n  def relative_url_redirect_with_status_hash\n    redirect_to(\"/things/stuff\", status: 301)\n  end\n\n  def redirect_back_with_status\n    redirect_back_or_to \"/things/stuff\", status: 307\n  end\n\n  def redirect_back_with_status_and_fallback_location_to_another_host\n    redirect_back_or_to \"http://www.rubyonrails.org/\", status: 307\n  end\n\n  def safe_redirect_back_with_status\n    redirect_back_or_to \"/things/stuff\", status: 307, allow_other_host: false\n  end\n\n  def safe_redirect_back_with_status_and_fallback_location_to_another_host\n    redirect_back_or_to \"http://www.rubyonrails.org/\", status: 307, allow_other_host: false\n  end\n\n  def safe_redirect_to_root\n    redirect_to url_from(\"/\")\n  end\n\n  def unsafe_redirect\n    redirect_to \"http://www.rubyonrails.org/\"\n  end\n\n  def unsafe_redirect_back\n    redirect_back_or_to \"http://www.rubyonrails.org/\"\n  end\n\n  def unsafe_redirect_malformed\n    redirect_to \"http:///www.rubyonrails.org/\"\n  end\n\n  def unsafe_redirect_protocol_relative_double_slash\n    redirect_to \"//www.rubyonrails.org/\"\n  end\n\n  def unsafe_redirect_protocol_relative_triple_slash\n    redirect_to \"///www.rubyonrails.org/\"\n  end\n\n  def unsafe_redirect_with_illegal_http_header_value_character\n    redirect_to \"javascript:alert(document.domain)\\b\", allow_other_host: true\n  end\n\n  def only_path_redirect\n    redirect_to action: \"other_host\", only_path: true\n  end\n\n  def safe_redirect_with_fallback\n    redirect_to url_from(params[:redirect_url]) || \"/fallback\"\n  end\n\n  def redirect_back_with_explicit_fallback_kwarg\n    redirect_back(fallback_location: \"/things/stuff\", status: 307)\n  end\n\n  def host_redirect\n    redirect_to action: \"other_host\", only_path: false, host: \"other.test.host\"\n  end\n\n  def module_redirect\n    redirect_to controller: \"module_test/module_redirect\", action: \"hello_world\"\n  end\n\n  def redirect_to_url\n    redirect_to \"http://www.rubyonrails.org/\"\n  end\n\n  def redirect_to_url_with_stringlike\n    stringlike = Object.new\n\n    def stringlike.to_str\n      \"http://www.rubyonrails.org/\"\n    end\n\n    redirect_to stringlike\n  end\n\n  def redirect_to_url_with_unescaped_query_string\n    redirect_to \"http://example.com/query?status=new\"\n  end\n\n  def redirect_to_url_with_complex_scheme\n    redirect_to \"x-test+scheme.complex:redirect\"\n  end\n\n  def redirect_to_url_with_network_path_reference\n    redirect_to \"//www.rubyonrails.org/\"\n  end\n\n  def redirect_to_existing_record\n    redirect_to Workshop.new(5)\n  end\n\n  def redirect_to_new_record\n    redirect_to Workshop.new(nil)\n  end\n\n  def redirect_to_nil\n    redirect_to nil\n  end\n\n  def redirect_to_polymorphic\n    redirect_to [:internal, Workshop.new(5)]\n  end\n\n  def redirect_to_polymorphic_string_args\n    redirect_to [\"internal\", Workshop.new(5)]\n  end\n\n  def redirect_to_params\n    redirect_to ActionController::Parameters.new(status: 200, protocol: \"javascript\", f: \"%0Aeval(name)\")\n  end\n\n  def redirect_to_with_block\n    redirect_to proc { \"http://www.rubyonrails.org/\" }\n  end\n\n  def redirect_to_with_block_and_assigns\n    @url = \"http://www.rubyonrails.org/\"\n    redirect_to proc { @url }\n  end\n\n  def redirect_to_with_block_and_options\n    redirect_to proc { { action: \"hello_world\" } }\n  end\n\n  def redirect_to_out_of_scope_block\n    redirect_to Workshop::OUT_OF_SCOPE_BLOCK\n  end\n\n  def redirect_with_header_break\n    redirect_to \"/lol\\r\\nwat\"\n  end\n\n  def redirect_with_null_bytes\n    redirect_to \"\\000/lol\\r\\nwat\"\n  end\n\n  def rescue_errors(e) raise e end\n\n  private\n    def dashboard_url(id, message)\n      url_for action: \"dashboard\", params: { \"id\" => id, \"message\" => message }\n    end\nend\n\nclass RedirectTest < ActionController::TestCase\n  tests RedirectController\n\n  def test_simple_redirect\n    get :simple_redirect\n    assert_response :redirect\n    assert_equal \"http://test.host/redirect/hello_world\", redirect_to_url\n  end\n\n  def test_redirect_with_header_break\n    get :redirect_with_header_break\n    assert_response :redirect\n    assert_equal \"http://test.host/lolwat\", redirect_to_url\n  end\n\n  def test_redirect_with_null_bytes\n    get :redirect_with_null_bytes\n    assert_response :redirect\n    assert_equal \"http://test.host/lolwat\", redirect_to_url\n  end\n\n  def test_redirect_with_no_status\n    get :simple_redirect\n    assert_response 302\n    assert_equal \"http://test.host/redirect/hello_world\", redirect_to_url\n  end\n\n  def test_redirect_with_status\n    get :redirect_with_status\n    assert_response 301\n    assert_equal \"http://test.host/redirect/hello_world\", redirect_to_url\n  end\n\n  def test_redirect_with_status_hash\n    get :redirect_with_status_hash\n    assert_response 301\n    assert_equal \"http://test.host/redirect/hello_world\", redirect_to_url\n  end\n\n  def test_redirect_with_protocol\n    get :redirect_with_protocol\n    assert_response 302\n    assert_equal \"https://test.host/redirect/hello_world\", redirect_to_url\n  end\n\n  def test_url_redirect_with_status\n    get :url_redirect_with_status\n    assert_response 301\n    assert_equal \"http://www.example.com\", redirect_to_url\n  end\n\n  def test_url_redirect_with_status_hash\n    get :url_redirect_with_status_hash\n    assert_response 301\n    assert_equal \"http://www.example.com\", redirect_to_url\n  end\n\n  def test_relative_url_redirect_with_status\n    get :relative_url_redirect_with_status\n    assert_response 302\n    assert_equal \"http://test.host/things/stuff\", redirect_to_url\n  end\n\n  def test_relative_url_redirect_with_status_hash\n    get :relative_url_redirect_with_status_hash\n    assert_response 301\n    assert_equal \"http://test.host/things/stuff\", redirect_to_url\n  end\n\n  def test_relative_url_redirect_host_with_port\n    request.host = \"test.host:1234\"\n    get :relative_url_redirect_with_status\n    assert_response 302\n    assert_equal \"http://test.host:1234/things/stuff\", redirect_to_url\n  end\n\n  def test_simple_redirect_using_options\n    get :host_redirect\n    assert_response :redirect\n    assert_redirected_to action: \"other_host\", only_path: false, host: \"other.test.host\"\n  end\n\n  def test_module_redirect\n    get :module_redirect\n    assert_response :redirect\n    assert_redirected_to \"http://test.host/module_test/module_redirect/hello_world\"\n  end\n\n  def test_module_redirect_using_options\n    get :module_redirect\n    assert_response :redirect\n    assert_redirected_to controller: \"module_test/module_redirect\", action: \"hello_world\"\n  end\n\n  def test_redirect_to_url\n    get :redirect_to_url\n    assert_response :redirect\n    assert_redirected_to \"http://www.rubyonrails.org/\"\n  end\n\n  def test_redirect_to_url_with_stringlike\n    get :redirect_to_url_with_stringlike\n    assert_response :redirect\n    assert_redirected_to \"http://www.rubyonrails.org/\"\n  end\n\n  def test_redirect_to_url_with_unescaped_query_string\n    get :redirect_to_url_with_unescaped_query_string\n    assert_response :redirect\n    assert_redirected_to \"http://example.com/query?status=new\"\n  end\n\n  def test_redirect_to_url_with_complex_scheme\n    get :redirect_to_url_with_complex_scheme\n    assert_response :redirect\n    assert_equal \"x-test+scheme.complex:redirect\", redirect_to_url\n  end\n\n  def test_redirect_to_url_with_network_path_reference\n    get :redirect_to_url_with_network_path_reference\n    assert_response :redirect\n    assert_equal \"//www.rubyonrails.org/\", redirect_to_url\n  end\n\n  def test_redirect_back\n    referer = \"http://www.example.com/coming/from\"\n    @request.env[\"HTTP_REFERER\"] = referer\n\n    get :redirect_back_with_status\n\n    assert_response 307\n    assert_equal referer, redirect_to_url\n  end\n\n  def test_redirect_back_with_no_referer\n    get :redirect_back_with_status\n\n    assert_response 307\n    assert_equal \"http://test.host/things/stuff\", redirect_to_url\n  end\n\n  def test_redirect_back_with_no_referer_redirects_to_another_host\n    get :redirect_back_with_status_and_fallback_location_to_another_host\n\n    assert_response 307\n    assert_equal \"http://www.rubyonrails.org/\", redirect_to_url\n  end\n\n  def test_safe_redirect_back_from_other_host\n    @request.env[\"HTTP_REFERER\"] = \"http://another.host/coming/from\"\n    get :safe_redirect_back_with_status\n\n    assert_response 307\n    assert_equal \"http://test.host/things/stuff\", redirect_to_url\n  end\n\n  def test_safe_redirect_back_from_the_same_host\n    referer = \"http://test.host/coming/from\"\n    @request.env[\"HTTP_REFERER\"] = referer\n    get :safe_redirect_back_with_status\n\n    assert_response 307\n    assert_equal referer, redirect_to_url\n  end\n\n  def test_safe_redirect_back_with_no_referer\n    get :safe_redirect_back_with_status\n\n    assert_response 307\n    assert_equal \"http://test.host/things/stuff\", redirect_to_url\n  end\n\n  def test_safe_redirect_back_with_no_referer_redirects_to_another_host\n    get :safe_redirect_back_with_status_and_fallback_location_to_another_host\n\n    assert_response 307\n    assert_equal \"http://www.rubyonrails.org/\", redirect_to_url\n  end\n\n  def test_safe_redirect_to_root\n    get :safe_redirect_to_root\n\n    assert_equal \"http://test.host/\", redirect_to_url\n  end\n\n  def test_redirect_back_with_explicit_fallback_kwarg\n    referer = \"http://www.example.com/coming/from\"\n    @request.env[\"HTTP_REFERER\"] = referer\n\n    get :redirect_back_with_explicit_fallback_kwarg\n\n    assert_response 307\n    assert_equal referer, redirect_to_url\n  end\n\n  def test_redirect_to_record\n    with_routing do |set|\n      set.draw do\n        resources :workshops\n\n        ActiveSupport::Deprecation.silence do\n          get \":controller/:action\"\n        end\n      end\n\n      get :redirect_to_existing_record\n      assert_equal \"http://test.host/workshops/5\", redirect_to_url\n      assert_redirected_to Workshop.new(5)\n\n      get :redirect_to_new_record\n      assert_equal \"http://test.host/workshops\", redirect_to_url\n      assert_redirected_to Workshop.new(nil)\n    end\n  end\n\n  def test_polymorphic_redirect\n    with_routing do |set|\n      set.draw do\n        namespace :internal do\n          resources :workshops\n        end\n\n        ActiveSupport::Deprecation.silence do\n          get \":controller/:action\"\n        end\n      end\n\n      get :redirect_to_polymorphic\n      assert_equal \"http://test.host/internal/workshops/5\", redirect_to_url\n      assert_redirected_to [:internal, Workshop.new(5)]\n    end\n  end\n\n  def test_polymorphic_redirect_with_string_args\n    with_routing do |set|\n      set.draw do\n        namespace :internal do\n          resources :workshops\n        end\n\n        ActiveSupport::Deprecation.silence do\n          get \":controller/:action\"\n        end\n      end\n\n      error = assert_raises(ArgumentError) do\n        get :redirect_to_polymorphic_string_args\n      end\n      assert_equal(\"Please use symbols for polymorphic route arguments.\", error.message)\n    end\n  end\n\n  def test_redirect_to_nil\n    error = assert_raise(ActionController::ActionControllerError) do\n      get :redirect_to_nil\n    end\n    assert_equal \"Cannot redirect to nil!\", error.message\n  end\n\n  def test_redirect_to_params\n    error = assert_raise(ActionController::UnfilteredParameters) do\n      get :redirect_to_params\n    end\n    assert_equal \"unable to convert unpermitted parameters to hash\", error.message\n  end\n\n  def test_redirect_to_with_block\n    get :redirect_to_with_block\n    assert_response :redirect\n    assert_redirected_to \"http://www.rubyonrails.org/\"\n  end\n\n  def test_redirect_to_with_block_and_assigns\n    get :redirect_to_with_block_and_assigns\n    assert_response :redirect\n    assert_redirected_to \"http://www.rubyonrails.org/\"\n  end\n\n  def test_redirect_to_out_of_scope_block\n    get :redirect_to_out_of_scope_block\n    assert_response :redirect\n    assert_redirected_to \"http://test.host/redirect/redirect_to_out_of_scope_block\"\n  end\n\n  def test_redirect_to_with_block_and_accepted_options\n    with_routing do |set|\n      set.draw do\n        ActiveSupport::Deprecation.silence do\n          get \":controller/:action\"\n        end\n      end\n\n      get :redirect_to_with_block_and_options\n\n      assert_response :redirect\n      assert_redirected_to \"http://test.host/redirect/hello_world\"\n    end\n  end\n\n  def test_unsafe_redirect\n    with_raise_on_open_redirects do\n      error = assert_raise(ActionController::Redirecting::UnsafeRedirectError) do\n        get :unsafe_redirect\n      end\n\n      assert_equal \"Unsafe redirect to \\\"http://www.rubyonrails.org/\\\", pass allow_other_host: true to redirect anyway.\", error.message\n    end\n  end\n\n  def test_unsafe_redirect_back\n    with_raise_on_open_redirects do\n      error = assert_raise(ActionController::Redirecting::UnsafeRedirectError) do\n        get :unsafe_redirect_back\n      end\n\n      assert_equal \"Unsafe redirect to \\\"http://www.rubyonrails.org/\\\", pass allow_other_host: true to redirect anyway.\", error.message\n    end\n  end\n\n  def test_unsafe_redirect_with_malformed_url\n    with_raise_on_open_redirects do\n      error = assert_raise(ActionController::Redirecting::UnsafeRedirectError) do\n        get :unsafe_redirect_malformed\n      end\n\n      assert_equal \"Unsafe redirect to \\\"http:///www.rubyonrails.org/\\\", pass allow_other_host: true to redirect anyway.\", error.message\n    end\n  end\n\n  def test_unsafe_redirect_with_protocol_relative_double_slash_url\n    with_raise_on_open_redirects do\n      error = assert_raise(ActionController::Redirecting::UnsafeRedirectError) do\n        get :unsafe_redirect_protocol_relative_double_slash\n      end\n\n      assert_equal \"Unsafe redirect to \\\"//www.rubyonrails.org/\\\", pass allow_other_host: true to redirect anyway.\", error.message\n    end\n  end\n\n  def test_unsafe_redirect_with_protocol_relative_triple_slash_url\n    with_raise_on_open_redirects do\n      error = assert_raise(ActionController::Redirecting::UnsafeRedirectError) do\n        get :unsafe_redirect_protocol_relative_triple_slash\n      end\n\n      assert_equal \"Unsafe redirect to \\\"///www.rubyonrails.org/\\\", pass allow_other_host: true to redirect anyway.\", error.message\n    end\n  end\n\n  def test_unsafe_redirect_with_illegal_http_header_value_character\n    with_raise_on_open_redirects do\n      error = assert_raise(ActionController::Redirecting::UnsafeRedirectError) do\n        get :unsafe_redirect_with_illegal_http_header_value_character\n      end\n\n      msg = \"The redirect URL javascript:alert(document.domain)\\b contains one or more illegal HTTP header field character. \" \\\n        \"Set of legal characters defined in https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.6\"\n\n      assert_equal msg, error.message\n    end\n  end\n\n  def test_only_path_redirect\n    with_raise_on_open_redirects do\n      get :only_path_redirect\n      assert_response :redirect\n      assert_redirected_to \"/redirect/other_host\"\n    end\n  end\n\n  def test_url_from\n    with_raise_on_open_redirects do\n      get :safe_redirect_with_fallback, params: { redirect_url: \"http://test.host/app\" }\n      assert_response :redirect\n      assert_redirected_to \"http://test.host/app\"\n    end\n  end\n\n  def test_url_from_fallback\n    with_raise_on_open_redirects do\n      get :safe_redirect_with_fallback, params: { redirect_url: \"http://www.rubyonrails.org/\" }\n      assert_response :redirect\n      assert_redirected_to \"http://test.host/fallback\"\n\n      get :safe_redirect_with_fallback, params: { redirect_url: \"\" }\n      assert_response :redirect\n      assert_redirected_to \"http://test.host/fallback\"\n    end\n  end\n\n  private\n    def with_raise_on_open_redirects\n      old_raise_on_open_redirects = ActionController::Base.raise_on_open_redirects\n      ActionController::Base.raise_on_open_redirects = true\n      yield\n    ensure\n      ActionController::Base.raise_on_open_redirects = old_raise_on_open_redirects\n    end\nend\n\nmodule ModuleTest\n  class ModuleRedirectController < ::RedirectController\n    def module_redirect\n      redirect_to controller: \"/redirect\", action: \"hello_world\"\n    end\n  end\n\n  class ModuleRedirectTest < ActionController::TestCase\n    tests ModuleRedirectController\n\n    def test_simple_redirect\n      get :simple_redirect\n      assert_response :redirect\n      assert_equal \"http://test.host/module_test/module_redirect/hello_world\", redirect_to_url\n    end\n\n    def test_simple_redirect_using_options\n      get :host_redirect\n      assert_response :redirect\n      assert_redirected_to action: \"other_host\", only_path: false, host: \"other.test.host\"\n    end\n\n    def test_module_redirect\n      get :module_redirect\n      assert_response :redirect\n      assert_equal \"http://test.host/redirect/hello_world\", redirect_to_url\n    end\n\n    def test_module_redirect_using_options\n      get :module_redirect\n      assert_response :redirect\n      assert_redirected_to controller: \"/redirect\", action: \"hello_world\"\n    end\n  end\nend\n", "patch": "@@ -104,6 +104,10 @@ def unsafe_redirect_protocol_relative_triple_slash\n     redirect_to \"///www.rubyonrails.org/\"\n   end\n \n+  def unsafe_redirect_with_illegal_http_header_value_character\n+    redirect_to \"javascript:alert(document.domain)\\b\", allow_other_host: true\n+  end\n+\n   def only_path_redirect\n     redirect_to action: \"other_host\", only_path: true\n   end\n@@ -556,6 +560,19 @@ def test_unsafe_redirect_with_protocol_relative_triple_slash_url\n     end\n   end\n \n+  def test_unsafe_redirect_with_illegal_http_header_value_character\n+    with_raise_on_open_redirects do\n+      error = assert_raise(ActionController::Redirecting::UnsafeRedirectError) do\n+        get :unsafe_redirect_with_illegal_http_header_value_character\n+      end\n+\n+      msg = \"The redirect URL javascript:alert(document.domain)\\b contains one or more illegal HTTP header field character. \" \\\n+        \"Set of legal characters defined in https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.6\"\n+\n+      assert_equal msg, error.message\n+    end\n+  end\n+\n   def test_only_path_redirect\n     with_raise_on_open_redirects do\n       get :only_path_redirect"}
