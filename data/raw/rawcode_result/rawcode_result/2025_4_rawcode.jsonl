{"patches_id": 1, "files_id": 1, "language": "go", "raw_url": "https://github.com/rancher/steve/raw/2175e090fe4b1e603a54e1cdc5148a2b1c11b4d9/pkg%2Fstores%2Fproxy%2Frbac_store.go", "raw_code": "package proxy\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n\n\t\"github.com/rancher/apiserver/pkg/types\"\n\t\"github.com/rancher/steve/pkg/accesscontrol\"\n\t\"github.com/rancher/steve/pkg/attributes\"\n\t\"github.com/rancher/steve/pkg/stores/partition\"\n\t\"github.com/rancher/wrangler/v3/pkg/kv\"\n\t\"github.com/sirupsen/logrus\"\n\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"\n\t\"k8s.io/apimachinery/pkg/util/sets\"\n\t\"k8s.io/apimachinery/pkg/watch\"\n)\n\nvar (\n\tpassthroughPartitions = []partition.Partition{\n\t\tPartition{Passthrough: true},\n\t}\n)\n\n// Partition is an implementation of the partition.Partition interface that uses RBAC to determine how a set of resources should be segregated and accessed.\ntype Partition struct {\n\tNamespace   string\n\tAll         bool\n\tPassthrough bool\n\tNames       sets.String\n}\n\n// Name returns the name of the partition, which for this type is the namespace.\nfunc (p Partition) Name() string {\n\treturn p.Namespace\n}\n\n// rbacPartitioner is an implementation of the partition.Partioner interface.\ntype rbacPartitioner struct {\n\tproxyStore *Store\n}\n\n// Lookup returns the default passthrough partition which is used only for retrieving single resources.\n// Listing or watching resources require custom partitions.\nfunc (p *rbacPartitioner) Lookup(apiOp *types.APIRequest, schema *types.APISchema, verb, id string) (partition.Partition, error) {\n\tswitch verb {\n\tcase \"create\":\n\t\tfallthrough\n\tcase \"get\":\n\t\tfallthrough\n\tcase \"update\":\n\t\tfallthrough\n\tcase \"delete\":\n\t\treturn passthroughPartitions[0], nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"partition list: invalid verb %s\", verb)\n\t}\n}\n\n// All returns a slice of partitions applicable to the API schema and the user's access level.\n// For watching individual resources or for blanket access permissions, it returns the passthrough partition.\n// For more granular permissions, it returns a slice of partitions matching an allowed namespace or resource names.\nfunc (p *rbacPartitioner) All(apiOp *types.APIRequest, schema *types.APISchema, verb, id string) ([]partition.Partition, error) {\n\tswitch verb {\n\tcase \"list\":\n\t\tfallthrough\n\tcase \"watch\":\n\t\tif id != \"\" {\n\t\t\tpartitions := generatePartitionsByID(apiOp, schema, verb, id)\n\t\t\treturn partitions, nil\n\t\t}\n\t\tpartitions, passthrough := generateAggregatePartitions(apiOp, schema, verb)\n\t\tif passthrough {\n\t\t\treturn passthroughPartitions, nil\n\t\t}\n\t\tsort.Slice(partitions, func(i, j int) bool {\n\t\t\treturn partitions[i].(Partition).Namespace < partitions[j].(Partition).Namespace\n\t\t})\n\t\treturn partitions, nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"parition all: invalid verb %s\", verb)\n\t}\n}\n\n// Store returns an UnstructuredStore suited to listing and watching resources by partition.\nfunc (p *rbacPartitioner) Store(apiOp *types.APIRequest, partition partition.Partition) (partition.UnstructuredStore, error) {\n\treturn &byNameOrNamespaceStore{\n\t\tStore:     p.proxyStore,\n\t\tpartition: partition.(Partition),\n\t}, nil\n}\n\ntype byNameOrNamespaceStore struct {\n\t*Store\n\tpartition Partition\n}\n\n// List returns a list of resources by partition.\nfunc (b *byNameOrNamespaceStore) List(apiOp *types.APIRequest, schema *types.APISchema) (*unstructured.UnstructuredList, []types.Warning, error) {\n\tif b.partition.Passthrough {\n\t\treturn b.Store.List(apiOp, schema)\n\t}\n\n\tapiOp.Namespace = b.partition.Namespace\n\tif b.partition.All {\n\t\treturn b.Store.List(apiOp, schema)\n\t}\n\treturn b.Store.ByNames(apiOp, schema, b.partition.Names)\n}\n\n// Watch returns a channel of resources by partition.\nfunc (b *byNameOrNamespaceStore) Watch(apiOp *types.APIRequest, schema *types.APISchema, wr types.WatchRequest) (chan watch.Event, error) {\n\tif b.partition.Passthrough {\n\t\treturn b.Store.Watch(apiOp, schema, wr)\n\t}\n\n\tapiOp.Namespace = b.partition.Namespace\n\tif b.partition.All {\n\t\treturn b.Store.Watch(apiOp, schema, wr)\n\t}\n\treturn b.Store.WatchNames(apiOp, schema, wr, b.partition.Names)\n}\n\n// generatePartitionsById determines whether a requester can access a particular resource\n// and if so, returns the corresponding partitions\nfunc generatePartitionsByID(apiOp *types.APIRequest, schema *types.APISchema, verb string, id string) []partition.Partition {\n\taccessListByVerb, _ := attributes.Access(schema).(accesscontrol.AccessListByVerb)\n\tresources := accessListByVerb.Granted(verb)\n\n\tidNamespace, name := kv.RSplit(id, \"/\")\n\tapiNamespace := apiOp.Namespace\n\teffectiveNamespace := idNamespace\n\n\t// If a non-empty namespace was provided, be sure to select that for filtering and permissions checks\n\tif idNamespace == \"\" && apiNamespace != \"\" {\n\t\teffectiveNamespace = apiNamespace\n\t}\n\n\t// The external API is flexible, and permits specifying a namespace as a separate key or embedded\n\t// within the ID of the object. Both of these cases should be valid:\n\t//   {\"namespace\": \"n1\", \"id\": \"r1\"}\n\t//   {\"id\": \"n1/r1\"}\n\t// however, the following conflicting request is not valid, but was previously accepted:\n\t//   {\"namespace\": \"n1\", \"id\": \"n2/r1\"}\n\t// To avoid breaking UI plugins that may inadvertently rely on the feature, we issue a deprecation\n\t// warning for now. We still need to pick one of the namespaces for permission verification purposes.\n\tif idNamespace != \"\" && apiNamespace != \"\" && idNamespace != apiNamespace {\n\t\tlogrus.Warningf(\"DEPRECATION: Conflicting namespaces '%v' and '%v' requested. \"+\n\t\t\t\"Selecting '%v' as the effective namespace. Future steve versions will reject this request.\",\n\t\t\tidNamespace, apiNamespace, effectiveNamespace)\n\t}\n\n\tif accessListByVerb.All(verb) {\n\t\treturn []partition.Partition{\n\t\t\tPartition{\n\t\t\t\tNamespace:   effectiveNamespace,\n\t\t\t\tAll:         false,\n\t\t\t\tPassthrough: false,\n\t\t\t\tNames:       sets.NewString(name),\n\t\t\t},\n\t\t}\n\t}\n\n\tif effectiveNamespace != \"\" {\n\t\tif resources[effectiveNamespace].All {\n\t\t\treturn []partition.Partition{\n\t\t\t\tPartition{\n\t\t\t\t\tNamespace:   effectiveNamespace,\n\t\t\t\t\tAll:         false,\n\t\t\t\t\tPassthrough: false,\n\t\t\t\t\tNames:       sets.NewString(name),\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}\n\n\t// For cluster-scoped resources, we will have parsed a \"\" out\n\t// of the ID field from RSplit, but accessListByVerb specifies \"*\" for\n\t// the namespace, so correct that here\n\tresourceNamespace := effectiveNamespace\n\tif resourceNamespace == \"\" {\n\t\tresourceNamespace = accesscontrol.All\n\t}\n\n\tnameset, ok := resources[resourceNamespace]\n\tif ok && nameset.Names.Has(name) {\n\t\treturn []partition.Partition{\n\t\t\tPartition{\n\t\t\t\tNamespace:   effectiveNamespace,\n\t\t\t\tAll:         false,\n\t\t\t\tPassthrough: false,\n\t\t\t\tNames:       sets.NewString(name),\n\t\t\t},\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// generateAggregatePartitions determines whether a request can be passed through directly to the underlying store\n// or if the results need to be partitioned by namespace and name based on the requester's access.\nfunc generateAggregatePartitions(apiOp *types.APIRequest, schema *types.APISchema, verb string) ([]partition.Partition, bool) {\n\taccessListByVerb, _ := attributes.Access(schema).(accesscontrol.AccessListByVerb)\n\tresources := accessListByVerb.Granted(verb)\n\n\tif accessListByVerb.All(verb) {\n\t\treturn nil, true\n\t}\n\n\tif apiOp.Namespace != \"\" {\n\t\tif resources[apiOp.Namespace].All {\n\t\t\treturn nil, true\n\t\t}\n\t\treturn []partition.Partition{\n\t\t\tPartition{\n\t\t\t\tNamespace: apiOp.Namespace,\n\t\t\t\tNames:     resources[apiOp.Namespace].Names,\n\t\t\t},\n\t\t}, false\n\t}\n\n\tvar result []partition.Partition\n\n\tif attributes.Namespaced(schema) {\n\t\tfor k, v := range resources {\n\t\t\tresult = append(result, Partition{\n\t\t\t\tNamespace: k,\n\t\t\t\tAll:       v.All,\n\t\t\t\tNames:     v.Names,\n\t\t\t})\n\t\t}\n\t} else {\n\t\tfor _, v := range resources {\n\t\t\tresult = append(result, Partition{\n\t\t\t\tAll:   v.All,\n\t\t\t\tNames: v.Names,\n\t\t\t})\n\t\t}\n\t}\n\n\treturn result, false\n}\n", "patch": "@@ -9,6 +9,7 @@ import (\n \t\"github.com/rancher/steve/pkg/attributes\"\n \t\"github.com/rancher/steve/pkg/stores/partition\"\n \t\"github.com/rancher/wrangler/v3/pkg/kv\"\n+\t\"github.com/sirupsen/logrus\"\n \t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"\n \t\"k8s.io/apimachinery/pkg/util/sets\"\n \t\"k8s.io/apimachinery/pkg/watch\"\n@@ -64,17 +65,10 @@ func (p *rbacPartitioner) All(apiOp *types.APIRequest, schema *types.APISchema,\n \t\tfallthrough\n \tcase \"watch\":\n \t\tif id != \"\" {\n-\t\t\tns, name := kv.RSplit(id, \"/\")\n-\t\t\treturn []partition.Partition{\n-\t\t\t\tPartition{\n-\t\t\t\t\tNamespace:   ns,\n-\t\t\t\t\tAll:         false,\n-\t\t\t\t\tPassthrough: false,\n-\t\t\t\t\tNames:       sets.NewString(name),\n-\t\t\t\t},\n-\t\t\t}, nil\n+\t\t\tpartitions := generatePartitionsByID(apiOp, schema, verb, id)\n+\t\t\treturn partitions, nil\n \t\t}\n-\t\tpartitions, passthrough := isPassthrough(apiOp, schema, verb)\n+\t\tpartitions, passthrough := generateAggregatePartitions(apiOp, schema, verb)\n \t\tif passthrough {\n \t\t\treturn passthroughPartitions, nil\n \t\t}\n@@ -126,15 +120,92 @@ func (b *byNameOrNamespaceStore) Watch(apiOp *types.APIRequest, schema *types.AP\n \treturn b.Store.WatchNames(apiOp, schema, wr, b.partition.Names)\n }\n \n-// isPassthrough determines whether a request can be passed through directly to the underlying store\n+// generatePartitionsById determines whether a requester can access a particular resource\n+// and if so, returns the corresponding partitions\n+func generatePartitionsByID(apiOp *types.APIRequest, schema *types.APISchema, verb string, id string) []partition.Partition {\n+\taccessListByVerb, _ := attributes.Access(schema).(accesscontrol.AccessListByVerb)\n+\tresources := accessListByVerb.Granted(verb)\n+\n+\tidNamespace, name := kv.RSplit(id, \"/\")\n+\tapiNamespace := apiOp.Namespace\n+\teffectiveNamespace := idNamespace\n+\n+\t// If a non-empty namespace was provided, be sure to select that for filtering and permissions checks\n+\tif idNamespace == \"\" && apiNamespace != \"\" {\n+\t\teffectiveNamespace = apiNamespace\n+\t}\n+\n+\t// The external API is flexible, and permits specifying a namespace as a separate key or embedded\n+\t// within the ID of the object. Both of these cases should be valid:\n+\t//   {\"namespace\": \"n1\", \"id\": \"r1\"}\n+\t//   {\"id\": \"n1/r1\"}\n+\t// however, the following conflicting request is not valid, but was previously accepted:\n+\t//   {\"namespace\": \"n1\", \"id\": \"n2/r1\"}\n+\t// To avoid breaking UI plugins that may inadvertently rely on the feature, we issue a deprecation\n+\t// warning for now. We still need to pick one of the namespaces for permission verification purposes.\n+\tif idNamespace != \"\" && apiNamespace != \"\" && idNamespace != apiNamespace {\n+\t\tlogrus.Warningf(\"DEPRECATION: Conflicting namespaces '%v' and '%v' requested. \"+\n+\t\t\t\"Selecting '%v' as the effective namespace. Future steve versions will reject this request.\",\n+\t\t\tidNamespace, apiNamespace, effectiveNamespace)\n+\t}\n+\n+\tif accessListByVerb.All(verb) {\n+\t\treturn []partition.Partition{\n+\t\t\tPartition{\n+\t\t\t\tNamespace:   effectiveNamespace,\n+\t\t\t\tAll:         false,\n+\t\t\t\tPassthrough: false,\n+\t\t\t\tNames:       sets.NewString(name),\n+\t\t\t},\n+\t\t}\n+\t}\n+\n+\tif effectiveNamespace != \"\" {\n+\t\tif resources[effectiveNamespace].All {\n+\t\t\treturn []partition.Partition{\n+\t\t\t\tPartition{\n+\t\t\t\t\tNamespace:   effectiveNamespace,\n+\t\t\t\t\tAll:         false,\n+\t\t\t\t\tPassthrough: false,\n+\t\t\t\t\tNames:       sets.NewString(name),\n+\t\t\t\t},\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// For cluster-scoped resources, we will have parsed a \"\" out\n+\t// of the ID field from RSplit, but accessListByVerb specifies \"*\" for\n+\t// the namespace, so correct that here\n+\tresourceNamespace := effectiveNamespace\n+\tif resourceNamespace == \"\" {\n+\t\tresourceNamespace = accesscontrol.All\n+\t}\n+\n+\tnameset, ok := resources[resourceNamespace]\n+\tif ok && nameset.Names.Has(name) {\n+\t\treturn []partition.Partition{\n+\t\t\tPartition{\n+\t\t\t\tNamespace:   effectiveNamespace,\n+\t\t\t\tAll:         false,\n+\t\t\t\tPassthrough: false,\n+\t\t\t\tNames:       sets.NewString(name),\n+\t\t\t},\n+\t\t}\n+\t}\n+\n+\treturn nil\n+}\n+\n+// generateAggregatePartitions determines whether a request can be passed through directly to the underlying store\n // or if the results need to be partitioned by namespace and name based on the requester's access.\n-func isPassthrough(apiOp *types.APIRequest, schema *types.APISchema, verb string) ([]partition.Partition, bool) {\n+func generateAggregatePartitions(apiOp *types.APIRequest, schema *types.APISchema, verb string) ([]partition.Partition, bool) {\n \taccessListByVerb, _ := attributes.Access(schema).(accesscontrol.AccessListByVerb)\n+\tresources := accessListByVerb.Granted(verb)\n+\n \tif accessListByVerb.All(verb) {\n \t\treturn nil, true\n \t}\n \n-\tresources := accessListByVerb.Granted(verb)\n \tif apiOp.Namespace != \"\" {\n \t\tif resources[apiOp.Namespace].All {\n \t\t\treturn nil, true"}
{"patches_id": 1, "files_id": 2, "language": "go", "raw_url": "https://github.com/rancher/steve/raw/2175e090fe4b1e603a54e1cdc5148a2b1c11b4d9/pkg%2Fstores%2Fproxy%2Frbac_store_test.go", "raw_code": "package proxy\n\nimport (\n\t\"testing\"\n\n\t\"github.com/rancher/apiserver/pkg/types\"\n\t\"github.com/rancher/steve/pkg/accesscontrol\"\n\t\"github.com/rancher/steve/pkg/stores/partition\"\n\t\"github.com/rancher/wrangler/v3/pkg/schemas\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"k8s.io/apimachinery/pkg/util/sets\"\n)\n\nfunc TestVerbList(t *testing.T) {\n\ttests := []struct {\n\t\tname           string\n\t\tapiOp          *types.APIRequest\n\t\tid             string\n\t\tschema         *types.APISchema\n\t\twantPartitions []partition.Partition\n\t}{\n\t\t{\n\t\t\tname:  \"all passthrough\",\n\t\t\tapiOp: &types.APIRequest{},\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n\t\t\t\t\t\t\t\t\tResourceName: \"*\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: passthroughPartitions,\n\t\t},\n\t\t{\n\t\t\tname:  \"global access for global request\",\n\t\t\tapiOp: &types.APIRequest{},\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: []partition.Partition{\n\t\t\t\tPartition{\n\t\t\t\t\tNames: sets.NewString(\"r1\", \"r2\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"namespace access for global request\",\n\t\t\tapiOp: &types.APIRequest{},\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": true,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n\t\t\t\t\t\t\t\t\tResourceName: \"*\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n2\",\n\t\t\t\t\t\t\t\t\tResourceName: \"*\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: []partition.Partition{\n\t\t\t\tPartition{\n\t\t\t\t\tNamespace: \"n1\",\n\t\t\t\t\tAll:       true,\n\t\t\t\t},\n\t\t\t\tPartition{\n\t\t\t\t\tNamespace: \"n2\",\n\t\t\t\t\tAll:       true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"namespace access for namespaced request\",\n\t\t\tapiOp: &types.APIRequest{\n\t\t\t\tNamespace: \"n1\",\n\t\t\t},\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": true,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n\t\t\t\t\t\t\t\t\tResourceName: \"*\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: passthroughPartitions,\n\t\t},\n\t\t{\n\t\t\t// we still get a partition even if there is no access to it, it will be rejected by the API server later\n\t\t\tname: \"namespace access for invalid namespaced request\",\n\t\t\tapiOp: &types.APIRequest{\n\t\t\t\tNamespace: \"n2\",\n\t\t\t},\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": true,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n\t\t\t\t\t\t\t\t\tResourceName: \"*\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: []partition.Partition{\n\t\t\t\tPartition{\n\t\t\t\t\tNamespace: \"n2\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"by names access for global request\",\n\t\t\tapiOp: &types.APIRequest{},\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": true,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n2\",\n\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: []partition.Partition{\n\t\t\t\tPartition{\n\t\t\t\t\tNamespace: \"n1\",\n\t\t\t\t\tNames:     sets.NewString(\"r1\", \"r2\"),\n\t\t\t\t},\n\t\t\t\tPartition{\n\t\t\t\t\tNamespace: \"n2\",\n\t\t\t\t\tNames:     sets.NewString(\"r1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"by names access for namespaced request\",\n\t\t\tapiOp: &types.APIRequest{\n\t\t\t\tNamespace: \"n1\",\n\t\t\t},\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": true,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n2\",\n\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: []partition.Partition{\n\t\t\t\tPartition{\n\t\t\t\t\tNamespace: \"n1\",\n\t\t\t\t\tNames:     sets.NewString(\"r1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"by id fully unauthorized\",\n\t\t\tapiOp: &types.APIRequest{},\n\t\t\tid:    \"n1/r1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"by id missing namespace\",\n\t\t\tapiOp: &types.APIRequest{},\n\t\t\tid:    \"n1/r1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": true,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n2\",\n\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"by id missing resource\",\n\t\t\tapiOp: &types.APIRequest{},\n\t\t\tid:    \"n1/r1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": true,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"by id authorized by name\",\n\t\t\tapiOp: &types.APIRequest{},\n\t\t\tid:    \"n1/r1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": true,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: []partition.Partition{\n\t\t\t\tPartition{\n\t\t\t\t\tNamespace: \"n1\",\n\t\t\t\t\tNames:     sets.NewString(\"r1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"by id authorized by namespace\",\n\t\t\tapiOp: &types.APIRequest{\n\t\t\t\tNamespace: \"n1\",\n\t\t\t},\n\t\t\tid: \"n1/r1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": true,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n\t\t\t\t\t\t\t\t\tResourceName: \"*\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: []partition.Partition{\n\t\t\t\tPartition{\n\t\t\t\t\tNamespace: \"n1\",\n\t\t\t\t\tNames:     sets.NewString(\"r1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"by namespaced id authorized by name\",\n\t\t\tapiOp: &types.APIRequest{\n\t\t\t\tNamespace: \"n1\",\n\t\t\t},\n\t\t\tid: \"r1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": true,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: []partition.Partition{\n\t\t\t\tPartition{\n\t\t\t\t\tNamespace: \"n1\",\n\t\t\t\t\tNames:     sets.NewString(\"r1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"by id ignores unrequested resources\",\n\t\t\tapiOp: &types.APIRequest{},\n\t\t\tid:    \"n1/r1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": true,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: []partition.Partition{\n\t\t\t\tPartition{\n\t\t\t\t\tNamespace: \"n1\",\n\t\t\t\t\tNames:     sets.NewString(\"r1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t// Note: this is deprecated fallback behavior. When we remove the behavior,\n\t\t// rewrite this test to expect an error instead.\n\t\t{\n\t\t\tname: \"by id prefers id embedded namespace\",\n\t\t\tapiOp: &types.APIRequest{\n\t\t\t\tNamespace: \"n2\",\n\t\t\t},\n\t\t\tid: \"n1/r1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": true,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n2\",\n\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: []partition.Partition{\n\t\t\t\tPartition{\n\t\t\t\t\tNamespace: \"n1\",\n\t\t\t\t\tNames:     sets.NewString(\"r1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"cluster scoped id unauthorized\",\n\t\t\tapiOp: &types.APIRequest{},\n\t\t\tid:    \"c1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"cluster scoped id authorized by name\",\n\t\t\tapiOp: &types.APIRequest{},\n\t\t\tid:    \"c1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": false,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n\t\t\t\t\t\t\t\t\tResourceName: \"c1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: []partition.Partition{\n\t\t\t\tPartition{\n\t\t\t\t\tNamespace: \"\",\n\t\t\t\t\tNames:     sets.NewString(\"c1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"cluster scoped id authorized globally\",\n\t\t\tapiOp: &types.APIRequest{},\n\t\t\tid:    \"c1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": false,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n\t\t\t\t\t\t\t\t\tResourceName: \"*\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: []partition.Partition{\n\t\t\t\tPartition{\n\t\t\t\t\tNamespace: \"\",\n\t\t\t\t\tNames:     sets.NewString(\"c1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"cluster scoped id ignores unrequested resources\",\n\t\t\tapiOp: &types.APIRequest{},\n\t\t\tid:    \"c1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": false,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n\t\t\t\t\t\t\t\t\tResourceName: \"c1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n\t\t\t\t\t\t\t\t\tResourceName: \"c2\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: []partition.Partition{\n\t\t\t\tPartition{\n\t\t\t\t\tNamespace: \"\",\n\t\t\t\t\tNames:     sets.NewString(\"c1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tpartitioner := rbacPartitioner{}\n\t\t\tverb := \"list\"\n\t\t\tgotPartitions, gotErr := partitioner.All(test.apiOp, test.schema, verb, test.id)\n\t\t\tassert.Nil(t, gotErr)\n\t\t\tassert.Equal(t, test.wantPartitions, gotPartitions)\n\t\t})\n\t}\n}\n\nfunc TestVerbWatch(t *testing.T) {\n\ttests := []struct {\n\t\tname           string\n\t\tapiOp          *types.APIRequest\n\t\tid             string\n\t\tschema         *types.APISchema\n\t\twantPartitions []partition.Partition\n\t}{\n\t\t{\n\t\t\tname:  \"by id fully unauthorized\",\n\t\t\tapiOp: &types.APIRequest{},\n\t\t\tid:    \"n1/r1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"by id missing namespace\",\n\t\t\tapiOp: &types.APIRequest{},\n\t\t\tid:    \"n1/r1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": true,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n2\",\n\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"by id missing resource\",\n\t\t\tapiOp: &types.APIRequest{},\n\t\t\tid:    \"n1/r1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": true,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"by id authorized by name\",\n\t\t\tapiOp: &types.APIRequest{},\n\t\t\tid:    \"n1/r1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": true,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: []partition.Partition{\n\t\t\t\tPartition{\n\t\t\t\t\tNamespace: \"n1\",\n\t\t\t\t\tNames:     sets.NewString(\"r1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"by namespaced id authorized by name\",\n\t\t\tapiOp: &types.APIRequest{\n\t\t\t\tNamespace: \"n1\",\n\t\t\t},\n\t\t\tid: \"r1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": true,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: []partition.Partition{\n\t\t\t\tPartition{\n\t\t\t\t\tNamespace: \"n1\",\n\t\t\t\t\tNames:     sets.NewString(\"r1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"by id authorized by namespace\",\n\t\t\tapiOp: &types.APIRequest{\n\t\t\t\tNamespace: \"n1\",\n\t\t\t},\n\t\t\tid: \"n1/r1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": true,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n\t\t\t\t\t\t\t\t\tResourceName: \"*\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: []partition.Partition{\n\t\t\t\tPartition{\n\t\t\t\t\tNamespace: \"n1\",\n\t\t\t\t\tNames:     sets.NewString(\"r1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"by id ignores unrequested resources\",\n\t\t\tapiOp: &types.APIRequest{},\n\t\t\tid:    \"n1/r1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": true,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: []partition.Partition{\n\t\t\t\tPartition{\n\t\t\t\t\tNamespace: \"n1\",\n\t\t\t\t\tNames:     sets.NewString(\"r1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t// Note: this is deprecated fallback behavior. When we remove the behavior,\n\t\t// rewrite this test to expect an error instead.\n\t\t{\n\t\t\tname: \"by id prefers id embedded namespace\",\n\t\t\tapiOp: &types.APIRequest{\n\t\t\t\tNamespace: \"n2\",\n\t\t\t},\n\t\t\tid: \"n1/r1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": true,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n2\",\n\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: []partition.Partition{\n\t\t\t\tPartition{\n\t\t\t\t\tNamespace: \"n1\",\n\t\t\t\t\tNames:     sets.NewString(\"r1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"cluster scoped id unauthorized\",\n\t\t\tapiOp: &types.APIRequest{},\n\t\t\tid:    \"c1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"cluster scoped id authorized by name\",\n\t\t\tapiOp: &types.APIRequest{},\n\t\t\tid:    \"c1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": false,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n\t\t\t\t\t\t\t\t\tResourceName: \"c1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: []partition.Partition{\n\t\t\t\tPartition{\n\t\t\t\t\tNamespace: \"\",\n\t\t\t\t\tNames:     sets.NewString(\"c1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"cluster scoped id authorized globally\",\n\t\t\tapiOp: &types.APIRequest{},\n\t\t\tid:    \"c1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": false,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n\t\t\t\t\t\t\t\t\tResourceName: \"*\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: []partition.Partition{\n\t\t\t\tPartition{\n\t\t\t\t\tNamespace: \"\",\n\t\t\t\t\tNames:     sets.NewString(\"c1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"cluster scoped id ignores unrequested resources\",\n\t\t\tapiOp: &types.APIRequest{},\n\t\t\tid:    \"c1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": false,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n\t\t\t\t\t\t\t\t\tResourceName: \"c1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n\t\t\t\t\t\t\t\t\tResourceName: \"c2\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: []partition.Partition{\n\t\t\t\tPartition{\n\t\t\t\t\tNamespace: \"\",\n\t\t\t\t\tNames:     sets.NewString(\"c1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tpartitioner := rbacPartitioner{}\n\t\t\tverb := \"watch\"\n\t\t\tgotPartitions, gotErr := partitioner.All(test.apiOp, test.schema, verb, test.id)\n\t\t\tassert.Nil(t, gotErr)\n\t\t\tassert.Equal(t, test.wantPartitions, gotPartitions)\n\t\t})\n\t}\n}\n", "patch": "@@ -11,7 +11,7 @@ import (\n \t\"k8s.io/apimachinery/pkg/util/sets\"\n )\n \n-func TestAll(t *testing.T) {\n+func TestVerbList(t *testing.T) {\n \ttests := []struct {\n \t\tname           string\n \t\tapiOp          *types.APIRequest\n@@ -223,23 +223,308 @@ func TestAll(t *testing.T) {\n \t\t\t},\n \t\t},\n \t\t{\n-\t\t\tname:  \"by id\",\n+\t\t\tname:  \"by id fully unauthorized\",\n \t\t\tapiOp: &types.APIRequest{},\n \t\t\tid:    \"n1/r1\",\n \t\t\tschema: &types.APISchema{\n \t\t\t\tSchema: &schemas.Schema{\n \t\t\t\t\tID: \"foo\",\n \t\t\t\t},\n \t\t\t},\n+\t\t\twantPartitions: nil,\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"by id missing namespace\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n2\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: nil,\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"by id missing resource\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: nil,\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"by id authorized by name\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\tPartition{\n+\t\t\t\t\tNamespace: \"n1\",\n+\t\t\t\t\tNames:     sets.NewString(\"r1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"by id authorized by namespace\",\n+\t\t\tapiOp: &types.APIRequest{\n+\t\t\t\tNamespace: \"n1\",\n+\t\t\t},\n+\t\t\tid: \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"*\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\tPartition{\n+\t\t\t\t\tNamespace: \"n1\",\n+\t\t\t\t\tNames:     sets.NewString(\"r1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"by namespaced id authorized by name\",\n+\t\t\tapiOp: &types.APIRequest{\n+\t\t\t\tNamespace: \"n1\",\n+\t\t\t},\n+\t\t\tid: \"r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\tPartition{\n+\t\t\t\t\tNamespace: \"n1\",\n+\t\t\t\t\tNames:     sets.NewString(\"r1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"by id ignores unrequested resources\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\tPartition{\n+\t\t\t\t\tNamespace: \"n1\",\n+\t\t\t\t\tNames:     sets.NewString(\"r1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t// Note: this is deprecated fallback behavior. When we remove the behavior,\n+\t\t// rewrite this test to expect an error instead.\n+\t\t{\n+\t\t\tname: \"by id prefers id embedded namespace\",\n+\t\t\tapiOp: &types.APIRequest{\n+\t\t\t\tNamespace: \"n2\",\n+\t\t\t},\n+\t\t\tid: \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n2\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n \t\t\twantPartitions: []partition.Partition{\n \t\t\t\tPartition{\n \t\t\t\t\tNamespace: \"n1\",\n \t\t\t\t\tNames:     sets.NewString(\"r1\"),\n \t\t\t\t},\n \t\t\t},\n \t\t},\n+\t\t{\n+\t\t\tname:  \"cluster scoped id unauthorized\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"c1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: nil,\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"cluster scoped id authorized by name\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"c1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": false,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"c1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\tPartition{\n+\t\t\t\t\tNamespace: \"\",\n+\t\t\t\t\tNames:     sets.NewString(\"c1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"cluster scoped id authorized globally\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"c1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": false,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"*\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\tPartition{\n+\t\t\t\t\tNamespace: \"\",\n+\t\t\t\t\tNames:     sets.NewString(\"c1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"cluster scoped id ignores unrequested resources\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"c1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": false,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"c1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"c2\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\tPartition{\n+\t\t\t\t\tNamespace: \"\",\n+\t\t\t\t\tNames:     sets.NewString(\"c1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n \t}\n-\n \tfor _, test := range tests {\n \t\tt.Run(test.name, func(t *testing.T) {\n \t\t\tpartitioner := rbacPartitioner{}\n@@ -250,3 +535,325 @@ func TestAll(t *testing.T) {\n \t\t})\n \t}\n }\n+\n+func TestVerbWatch(t *testing.T) {\n+\ttests := []struct {\n+\t\tname           string\n+\t\tapiOp          *types.APIRequest\n+\t\tid             string\n+\t\tschema         *types.APISchema\n+\t\twantPartitions []partition.Partition\n+\t}{\n+\t\t{\n+\t\t\tname:  \"by id fully unauthorized\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: nil,\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"by id missing namespace\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n2\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: nil,\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"by id missing resource\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: nil,\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"by id authorized by name\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\tPartition{\n+\t\t\t\t\tNamespace: \"n1\",\n+\t\t\t\t\tNames:     sets.NewString(\"r1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"by namespaced id authorized by name\",\n+\t\t\tapiOp: &types.APIRequest{\n+\t\t\t\tNamespace: \"n1\",\n+\t\t\t},\n+\t\t\tid: \"r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\tPartition{\n+\t\t\t\t\tNamespace: \"n1\",\n+\t\t\t\t\tNames:     sets.NewString(\"r1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"by id authorized by namespace\",\n+\t\t\tapiOp: &types.APIRequest{\n+\t\t\t\tNamespace: \"n1\",\n+\t\t\t},\n+\t\t\tid: \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"*\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\tPartition{\n+\t\t\t\t\tNamespace: \"n1\",\n+\t\t\t\t\tNames:     sets.NewString(\"r1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"by id ignores unrequested resources\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\tPartition{\n+\t\t\t\t\tNamespace: \"n1\",\n+\t\t\t\t\tNames:     sets.NewString(\"r1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t// Note: this is deprecated fallback behavior. When we remove the behavior,\n+\t\t// rewrite this test to expect an error instead.\n+\t\t{\n+\t\t\tname: \"by id prefers id embedded namespace\",\n+\t\t\tapiOp: &types.APIRequest{\n+\t\t\t\tNamespace: \"n2\",\n+\t\t\t},\n+\t\t\tid: \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n2\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\tPartition{\n+\t\t\t\t\tNamespace: \"n1\",\n+\t\t\t\t\tNames:     sets.NewString(\"r1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"cluster scoped id unauthorized\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"c1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: nil,\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"cluster scoped id authorized by name\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"c1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": false,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"c1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\tPartition{\n+\t\t\t\t\tNamespace: \"\",\n+\t\t\t\t\tNames:     sets.NewString(\"c1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"cluster scoped id authorized globally\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"c1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": false,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"*\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\tPartition{\n+\t\t\t\t\tNamespace: \"\",\n+\t\t\t\t\tNames:     sets.NewString(\"c1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"cluster scoped id ignores unrequested resources\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"c1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": false,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"c1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"c2\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\tPartition{\n+\t\t\t\t\tNamespace: \"\",\n+\t\t\t\t\tNames:     sets.NewString(\"c1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+\tfor _, test := range tests {\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tpartitioner := rbacPartitioner{}\n+\t\t\tverb := \"watch\"\n+\t\t\tgotPartitions, gotErr := partitioner.All(test.apiOp, test.schema, verb, test.id)\n+\t\t\tassert.Nil(t, gotErr)\n+\t\t\tassert.Equal(t, test.wantPartitions, gotPartitions)\n+\t\t})\n+\t}\n+}"}
{"patches_id": 1, "files_id": 3, "language": "go", "raw_url": "https://github.com/rancher/steve/raw/2175e090fe4b1e603a54e1cdc5148a2b1c11b4d9/pkg%2Fstores%2Fsqlpartition%2Fpartitioner.go", "raw_code": "package sqlpartition\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n\n\t\"github.com/rancher/apiserver/pkg/types\"\n\t\"github.com/rancher/lasso/pkg/cache/sql/partition\"\n\t\"github.com/rancher/steve/pkg/accesscontrol\"\n\t\"github.com/rancher/steve/pkg/attributes\"\n\t\"github.com/rancher/wrangler/v3/pkg/kv\"\n\t\"github.com/sirupsen/logrus\"\n\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"\n\t\"k8s.io/apimachinery/pkg/util/sets\"\n\t\"k8s.io/apimachinery/pkg/watch\"\n)\n\nvar (\n\tpassthroughPartitions = []partition.Partition{\n\t\t{Passthrough: true},\n\t}\n)\n\n// UnstructuredStore is like types.Store but deals in k8s unstructured objects instead of apiserver types.\n// This interface exists in order for store to be mocked in tests\ntype UnstructuredStore interface {\n\tByID(apiOp *types.APIRequest, schema *types.APISchema, id string) (*unstructured.Unstructured, []types.Warning, error)\n\tCreate(apiOp *types.APIRequest, schema *types.APISchema, data types.APIObject) (*unstructured.Unstructured, []types.Warning, error)\n\tUpdate(apiOp *types.APIRequest, schema *types.APISchema, data types.APIObject, id string) (*unstructured.Unstructured, []types.Warning, error)\n\tDelete(apiOp *types.APIRequest, schema *types.APISchema, id string) (*unstructured.Unstructured, []types.Warning, error)\n\n\tListByPartitions(apiOp *types.APIRequest, schema *types.APISchema, partitions []partition.Partition) ([]unstructured.Unstructured, int, string, error)\n\tWatchByPartitions(apiOp *types.APIRequest, schema *types.APISchema, wr types.WatchRequest, partitions []partition.Partition) (chan watch.Event, error)\n}\n\n// rbacPartitioner is an implementation of the sqlpartition.Partitioner interface.\ntype rbacPartitioner struct {\n\tproxyStore UnstructuredStore\n}\n\n// All returns a slice of partitions applicable to the API schema and the user's access level.\n// For watching individual resources or for blanket access permissions, it returns the passthrough partition.\n// For more granular permissions, it returns a slice of partitions matching an allowed namespace or resource names.\nfunc (p *rbacPartitioner) All(apiOp *types.APIRequest, schema *types.APISchema, verb, id string) ([]partition.Partition, error) {\n\tswitch verb {\n\tcase \"list\":\n\t\tfallthrough\n\tcase \"watch\":\n\t\tif id != \"\" {\n\t\t\tpartitions := generatePartitionsByID(apiOp, schema, verb, id)\n\t\t\treturn partitions, nil\n\t\t}\n\t\tpartitions, passthrough := generateAggregatePartitions(apiOp, schema, verb)\n\t\tif passthrough {\n\t\t\treturn passthroughPartitions, nil\n\t\t}\n\t\tsort.Slice(partitions, func(i, j int) bool {\n\t\t\treturn partitions[i].Namespace < partitions[j].Namespace\n\t\t})\n\t\treturn partitions, nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"parition all: invalid verb %s\", verb)\n\t}\n}\n\n// Store returns an Store suited to listing and watching resources by partition.\nfunc (p *rbacPartitioner) Store() UnstructuredStore {\n\treturn p.proxyStore\n}\n\n// generatePartitionsById determines whether a requester can access a particular resource\n// and if so, returns the corresponding partitions\nfunc generatePartitionsByID(apiOp *types.APIRequest, schema *types.APISchema, verb string, id string) []partition.Partition {\n\taccessListByVerb, _ := attributes.Access(schema).(accesscontrol.AccessListByVerb)\n\tresources := accessListByVerb.Granted(verb)\n\n\tidNamespace, name := kv.RSplit(id, \"/\")\n\tapiNamespace := apiOp.Namespace\n\teffectiveNamespace := idNamespace\n\n\t// If a non-empty namespace was provided, be sure to select that for filtering and permissions checks\n\tif idNamespace == \"\" && apiNamespace != \"\" {\n\t\teffectiveNamespace = apiNamespace\n\t}\n\n\t// The external API is flexible, and permits specifying a namespace as a separate key or embedded\n\t// within the ID of the object. Both of these cases should be valid:\n\t//   {\"namespace\": \"n1\", \"id\": \"r1\"}\n\t//   {\"id\": \"n1/r1\"}\n\t// however, the following conflicting request is not valid, but was previously accepted:\n\t//   {\"namespace\": \"n1\", \"id\": \"n2/r1\"}\n\t// To avoid breaking UI plugins that may inadvertently rely on the feature, we issue a deprecation\n\t// warning for now. We still need to pick one of the namespaces for permission verification purposes.\n\tif idNamespace != \"\" && apiNamespace != \"\" && idNamespace != apiNamespace {\n\t\tlogrus.Warningf(\"DEPRECATION: Conflicting namespaces '%v' and '%v' requested. \"+\n\t\t\t\"Selecting '%v' as the effective namespace. Future steve versions will reject this request.\",\n\t\t\tidNamespace, apiNamespace, effectiveNamespace)\n\t}\n\n\tif accessListByVerb.All(verb) {\n\t\treturn []partition.Partition{\n\t\t\t{\n\t\t\t\tNamespace:   effectiveNamespace,\n\t\t\t\tAll:         false,\n\t\t\t\tPassthrough: false,\n\t\t\t\tNames:       sets.New(name),\n\t\t\t},\n\t\t}\n\t}\n\n\tif effectiveNamespace != \"\" {\n\t\tif resources[effectiveNamespace].All {\n\t\t\treturn []partition.Partition{\n\t\t\t\t{\n\t\t\t\t\tNamespace:   effectiveNamespace,\n\t\t\t\t\tAll:         false,\n\t\t\t\t\tPassthrough: false,\n\t\t\t\t\tNames:       sets.New(name),\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}\n\n\t// For cluster-scoped resources, we will have parsed a \"\" out\n\t// of the ID field from RSplit, but accessListByVerb specifies \"*\" for\n\t// the nameset, so correct that here\n\tresourceNamespace := effectiveNamespace\n\tif resourceNamespace == \"\" {\n\t\tresourceNamespace = accesscontrol.All\n\t}\n\n\tnameset, ok := resources[resourceNamespace]\n\tif ok && nameset.Names.Has(name) {\n\t\treturn []partition.Partition{\n\t\t\t{\n\t\t\t\tNamespace:   effectiveNamespace,\n\t\t\t\tAll:         false,\n\t\t\t\tPassthrough: false,\n\t\t\t\tNames:       sets.New(name),\n\t\t\t},\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// generateAggregatePartitions determines whether a request can be passed through directly to the underlying store\n// or if the results need to be partitioned by namespace and name based on the requester's access.\nfunc generateAggregatePartitions(apiOp *types.APIRequest, schema *types.APISchema, verb string) ([]partition.Partition, bool) {\n\taccessListByVerb, _ := attributes.Access(schema).(accesscontrol.AccessListByVerb)\n\tresources := accessListByVerb.Granted(verb)\n\n\tif accessListByVerb.All(verb) {\n\t\treturn nil, true\n\t}\n\n\tif apiOp.Namespace != \"\" {\n\t\tif resources[apiOp.Namespace].All {\n\t\t\treturn nil, true\n\t\t}\n\t\treturn []partition.Partition{\n\t\t\t{\n\t\t\t\tNamespace: apiOp.Namespace,\n\t\t\t\tNames:     sets.Set[string](resources[apiOp.Namespace].Names),\n\t\t\t},\n\t\t}, false\n\t}\n\n\tvar result []partition.Partition\n\n\tif attributes.Namespaced(schema) {\n\t\tfor k, v := range resources {\n\t\t\tresult = append(result, partition.Partition{\n\t\t\t\tNamespace: k,\n\t\t\t\tAll:       v.All,\n\t\t\t\tNames:     sets.Set[string](v.Names),\n\t\t\t})\n\t\t}\n\t} else {\n\t\tfor _, v := range resources {\n\t\t\tresult = append(result, partition.Partition{\n\t\t\t\tAll:   v.All,\n\t\t\t\tNames: sets.Set[string](v.Names),\n\t\t\t})\n\t\t}\n\t}\n\n\treturn result, false\n}\n", "patch": "@@ -9,6 +9,7 @@ import (\n \t\"github.com/rancher/steve/pkg/accesscontrol\"\n \t\"github.com/rancher/steve/pkg/attributes\"\n \t\"github.com/rancher/wrangler/v3/pkg/kv\"\n+\t\"github.com/sirupsen/logrus\"\n \t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"\n \t\"k8s.io/apimachinery/pkg/util/sets\"\n \t\"k8s.io/apimachinery/pkg/watch\"\n@@ -46,17 +47,10 @@ func (p *rbacPartitioner) All(apiOp *types.APIRequest, schema *types.APISchema,\n \t\tfallthrough\n \tcase \"watch\":\n \t\tif id != \"\" {\n-\t\t\tns, name := kv.RSplit(id, \"/\")\n-\t\t\treturn []partition.Partition{\n-\t\t\t\t{\n-\t\t\t\t\tNamespace:   ns,\n-\t\t\t\t\tAll:         false,\n-\t\t\t\t\tPassthrough: false,\n-\t\t\t\t\tNames:       sets.New[string](name),\n-\t\t\t\t},\n-\t\t\t}, nil\n+\t\t\tpartitions := generatePartitionsByID(apiOp, schema, verb, id)\n+\t\t\treturn partitions, nil\n \t\t}\n-\t\tpartitions, passthrough := isPassthrough(apiOp, schema, verb)\n+\t\tpartitions, passthrough := generateAggregatePartitions(apiOp, schema, verb)\n \t\tif passthrough {\n \t\t\treturn passthroughPartitions, nil\n \t\t}\n@@ -74,15 +68,92 @@ func (p *rbacPartitioner) Store() UnstructuredStore {\n \treturn p.proxyStore\n }\n \n-// isPassthrough determines whether a request can be passed through directly to the underlying store\n+// generatePartitionsById determines whether a requester can access a particular resource\n+// and if so, returns the corresponding partitions\n+func generatePartitionsByID(apiOp *types.APIRequest, schema *types.APISchema, verb string, id string) []partition.Partition {\n+\taccessListByVerb, _ := attributes.Access(schema).(accesscontrol.AccessListByVerb)\n+\tresources := accessListByVerb.Granted(verb)\n+\n+\tidNamespace, name := kv.RSplit(id, \"/\")\n+\tapiNamespace := apiOp.Namespace\n+\teffectiveNamespace := idNamespace\n+\n+\t// If a non-empty namespace was provided, be sure to select that for filtering and permissions checks\n+\tif idNamespace == \"\" && apiNamespace != \"\" {\n+\t\teffectiveNamespace = apiNamespace\n+\t}\n+\n+\t// The external API is flexible, and permits specifying a namespace as a separate key or embedded\n+\t// within the ID of the object. Both of these cases should be valid:\n+\t//   {\"namespace\": \"n1\", \"id\": \"r1\"}\n+\t//   {\"id\": \"n1/r1\"}\n+\t// however, the following conflicting request is not valid, but was previously accepted:\n+\t//   {\"namespace\": \"n1\", \"id\": \"n2/r1\"}\n+\t// To avoid breaking UI plugins that may inadvertently rely on the feature, we issue a deprecation\n+\t// warning for now. We still need to pick one of the namespaces for permission verification purposes.\n+\tif idNamespace != \"\" && apiNamespace != \"\" && idNamespace != apiNamespace {\n+\t\tlogrus.Warningf(\"DEPRECATION: Conflicting namespaces '%v' and '%v' requested. \"+\n+\t\t\t\"Selecting '%v' as the effective namespace. Future steve versions will reject this request.\",\n+\t\t\tidNamespace, apiNamespace, effectiveNamespace)\n+\t}\n+\n+\tif accessListByVerb.All(verb) {\n+\t\treturn []partition.Partition{\n+\t\t\t{\n+\t\t\t\tNamespace:   effectiveNamespace,\n+\t\t\t\tAll:         false,\n+\t\t\t\tPassthrough: false,\n+\t\t\t\tNames:       sets.New(name),\n+\t\t\t},\n+\t\t}\n+\t}\n+\n+\tif effectiveNamespace != \"\" {\n+\t\tif resources[effectiveNamespace].All {\n+\t\t\treturn []partition.Partition{\n+\t\t\t\t{\n+\t\t\t\t\tNamespace:   effectiveNamespace,\n+\t\t\t\t\tAll:         false,\n+\t\t\t\t\tPassthrough: false,\n+\t\t\t\t\tNames:       sets.New(name),\n+\t\t\t\t},\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// For cluster-scoped resources, we will have parsed a \"\" out\n+\t// of the ID field from RSplit, but accessListByVerb specifies \"*\" for\n+\t// the nameset, so correct that here\n+\tresourceNamespace := effectiveNamespace\n+\tif resourceNamespace == \"\" {\n+\t\tresourceNamespace = accesscontrol.All\n+\t}\n+\n+\tnameset, ok := resources[resourceNamespace]\n+\tif ok && nameset.Names.Has(name) {\n+\t\treturn []partition.Partition{\n+\t\t\t{\n+\t\t\t\tNamespace:   effectiveNamespace,\n+\t\t\t\tAll:         false,\n+\t\t\t\tPassthrough: false,\n+\t\t\t\tNames:       sets.New(name),\n+\t\t\t},\n+\t\t}\n+\t}\n+\n+\treturn nil\n+}\n+\n+// generateAggregatePartitions determines whether a request can be passed through directly to the underlying store\n // or if the results need to be partitioned by namespace and name based on the requester's access.\n-func isPassthrough(apiOp *types.APIRequest, schema *types.APISchema, verb string) ([]partition.Partition, bool) {\n+func generateAggregatePartitions(apiOp *types.APIRequest, schema *types.APISchema, verb string) ([]partition.Partition, bool) {\n \taccessListByVerb, _ := attributes.Access(schema).(accesscontrol.AccessListByVerb)\n+\tresources := accessListByVerb.Granted(verb)\n+\n \tif accessListByVerb.All(verb) {\n \t\treturn nil, true\n \t}\n \n-\tresources := accessListByVerb.Granted(verb)\n \tif apiOp.Namespace != \"\" {\n \t\tif resources[apiOp.Namespace].All {\n \t\t\treturn nil, true"}
{"patches_id": 1, "files_id": 4, "language": "go", "raw_url": "https://github.com/rancher/steve/raw/2175e090fe4b1e603a54e1cdc5148a2b1c11b4d9/pkg%2Fstores%2Fsqlpartition%2Fpartitioner_test.go", "raw_code": "package sqlpartition\n\nimport (\n\t\"testing\"\n\n\t\"go.uber.org/mock/gomock\"\n\n\t\"github.com/rancher/apiserver/pkg/types\"\n\t\"github.com/rancher/lasso/pkg/cache/sql/partition\"\n\t\"github.com/rancher/steve/pkg/accesscontrol\"\n\t\"github.com/rancher/wrangler/v3/pkg/schemas\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"k8s.io/apimachinery/pkg/util/sets\"\n)\n\nfunc TestVerbList(t *testing.T) {\n\ttests := []struct {\n\t\tname           string\n\t\tapiOp          *types.APIRequest\n\t\tid             string\n\t\tschema         *types.APISchema\n\t\twantPartitions []partition.Partition\n\t}{\n\t\t{\n\t\t\tname:  \"all passthrough\",\n\t\t\tapiOp: &types.APIRequest{},\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n\t\t\t\t\t\t\t\t\tResourceName: \"*\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: passthroughPartitions,\n\t\t},\n\t\t{\n\t\t\tname:  \"global access for global request\",\n\t\t\tapiOp: &types.APIRequest{},\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: []partition.Partition{\n\t\t\t\t{\n\t\t\t\t\tNames: sets.New[string](\"r1\", \"r2\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"namespace access for global request\",\n\t\t\tapiOp: &types.APIRequest{},\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": true,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n\t\t\t\t\t\t\t\t\tResourceName: \"*\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n2\",\n\t\t\t\t\t\t\t\t\tResourceName: \"*\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: []partition.Partition{\n\t\t\t\t{\n\t\t\t\t\tNamespace: \"n1\",\n\t\t\t\t\tAll:       true,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tNamespace: \"n2\",\n\t\t\t\t\tAll:       true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"namespace access for namespaced request\",\n\t\t\tapiOp: &types.APIRequest{\n\t\t\t\tNamespace: \"n1\",\n\t\t\t},\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": true,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n\t\t\t\t\t\t\t\t\tResourceName: \"*\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: passthroughPartitions,\n\t\t},\n\t\t{\n\t\t\t// we still get a partition even if there is no access to it, it will be rejected by the API server later\n\t\t\tname: \"namespace access for invalid namespaced request\",\n\t\t\tapiOp: &types.APIRequest{\n\t\t\t\tNamespace: \"n2\",\n\t\t\t},\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": true,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n\t\t\t\t\t\t\t\t\tResourceName: \"*\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: []partition.Partition{\n\t\t\t\t{\n\t\t\t\t\tNamespace: \"n2\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"by names access for global request\",\n\t\t\tapiOp: &types.APIRequest{},\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": true,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n2\",\n\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: []partition.Partition{\n\t\t\t\t{\n\t\t\t\t\tNamespace: \"n1\",\n\t\t\t\t\tNames:     sets.New[string](\"r1\", \"r2\"),\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tNamespace: \"n2\",\n\t\t\t\t\tNames:     sets.New[string](\"r1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"by names access for namespaced request\",\n\t\t\tapiOp: &types.APIRequest{\n\t\t\t\tNamespace: \"n1\",\n\t\t\t},\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": true,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n2\",\n\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: []partition.Partition{\n\t\t\t\t{\n\t\t\t\t\tNamespace: \"n1\",\n\t\t\t\t\tNames:     sets.New[string](\"r1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"by id fully unauthorized\",\n\t\t\tapiOp: &types.APIRequest{},\n\t\t\tid:    \"n1/r1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"by id missing namespace\",\n\t\t\tapiOp: &types.APIRequest{},\n\t\t\tid:    \"n1/r1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": true,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n2\",\n\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"by id missing resource\",\n\t\t\tapiOp: &types.APIRequest{},\n\t\t\tid:    \"n1/r1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": true,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"by id authorized by name\",\n\t\t\tapiOp: &types.APIRequest{},\n\t\t\tid:    \"n1/r1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": true,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: []partition.Partition{\n\t\t\t\t{\n\t\t\t\t\tNamespace: \"n1\",\n\t\t\t\t\tNames:     sets.New[string](\"r1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"by id authorized by namespace\",\n\t\t\tapiOp: &types.APIRequest{\n\t\t\t\tNamespace: \"n1\",\n\t\t\t},\n\t\t\tid: \"n1/r1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": true,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n\t\t\t\t\t\t\t\t\tResourceName: \"*\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: []partition.Partition{\n\t\t\t\t{\n\t\t\t\t\tNamespace: \"n1\",\n\t\t\t\t\tAll:       false,\n\t\t\t\t\tNames:     sets.New[string](\"r1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"by namespaced id authorized by name\",\n\t\t\tapiOp: &types.APIRequest{\n\t\t\t\tNamespace: \"n1\",\n\t\t\t},\n\t\t\tid: \"r1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": true,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: []partition.Partition{\n\t\t\t\t{\n\t\t\t\t\tNamespace: \"n1\",\n\t\t\t\t\tAll:       false,\n\t\t\t\t\tNames:     sets.New[string](\"r1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"by id ignores unrequested resources\",\n\t\t\tapiOp: &types.APIRequest{},\n\t\t\tid:    \"n1/r1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": true,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: []partition.Partition{\n\t\t\t\t{\n\t\t\t\t\tNamespace: \"n1\",\n\t\t\t\t\tNames:     sets.New[string](\"r1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t// Note: this is deprecated fallback behavior. When we remove the behavior,\n\t\t// rewrite this test to expect an error instead.\n\t\t{\n\t\t\tname: \"by id prefers id embedded namespace\",\n\t\t\tapiOp: &types.APIRequest{\n\t\t\t\tNamespace: \"n2\",\n\t\t\t},\n\t\t\tid: \"n1/r1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": true,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n2\",\n\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: []partition.Partition{\n\t\t\t\t{\n\t\t\t\t\tNamespace: \"n1\",\n\t\t\t\t\tNames:     sets.New[string](\"r1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"cluster scoped id unauthorized\",\n\t\t\tapiOp: &types.APIRequest{},\n\t\t\tid:    \"c1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"cluster scoped id authorized by name\",\n\t\t\tapiOp: &types.APIRequest{},\n\t\t\tid:    \"c1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": false,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n\t\t\t\t\t\t\t\t\tResourceName: \"c1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: []partition.Partition{\n\t\t\t\t{\n\t\t\t\t\tNamespace: \"\",\n\t\t\t\t\tNames:     sets.New[string](\"c1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"cluster scoped id authorized globally\",\n\t\t\tapiOp: &types.APIRequest{},\n\t\t\tid:    \"c1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": false,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n\t\t\t\t\t\t\t\t\tResourceName: \"*\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: []partition.Partition{\n\t\t\t\t{\n\t\t\t\t\tNamespace: \"\",\n\t\t\t\t\tNames:     sets.New[string](\"c1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"cluster scoped id ignores unrequested resources\",\n\t\t\tapiOp: &types.APIRequest{},\n\t\t\tid:    \"c1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": false,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n\t\t\t\t\t\t\t\t\tResourceName: \"c1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n\t\t\t\t\t\t\t\t\tResourceName: \"c2\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: []partition.Partition{\n\t\t\t\t{\n\t\t\t\t\tNamespace: \"\",\n\t\t\t\t\tNames:     sets.New[string](\"c1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tpartitioner := rbacPartitioner{}\n\t\t\tverb := \"list\"\n\t\t\tgotPartitions, gotErr := partitioner.All(test.apiOp, test.schema, verb, test.id)\n\t\t\tassert.Nil(t, gotErr)\n\t\t\tassert.Equal(t, test.wantPartitions, gotPartitions)\n\t\t})\n\t}\n}\n\nfunc TestVerbWatch(t *testing.T) {\n\ttests := []struct {\n\t\tname           string\n\t\tapiOp          *types.APIRequest\n\t\tid             string\n\t\tschema         *types.APISchema\n\t\twantPartitions []partition.Partition\n\t}{\n\t\t{\n\t\t\tname:  \"by id fully unauthorized\",\n\t\t\tapiOp: &types.APIRequest{},\n\t\t\tid:    \"n1/r1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"by id missing namespace\",\n\t\t\tapiOp: &types.APIRequest{},\n\t\t\tid:    \"n1/r1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": true,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n2\",\n\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"by id missing resource\",\n\t\t\tapiOp: &types.APIRequest{},\n\t\t\tid:    \"n1/r1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": true,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"by id authorized by name\",\n\t\t\tapiOp: &types.APIRequest{},\n\t\t\tid:    \"n1/r1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": true,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: []partition.Partition{\n\t\t\t\t{\n\t\t\t\t\tNamespace: \"n1\",\n\t\t\t\t\tNames:     sets.New[string](\"r1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"by id authorized by namespace\",\n\t\t\tapiOp: &types.APIRequest{\n\t\t\t\tNamespace: \"n1\",\n\t\t\t},\n\t\t\tid: \"n1/r1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": true,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n\t\t\t\t\t\t\t\t\tResourceName: \"*\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: []partition.Partition{\n\t\t\t\t{\n\t\t\t\t\tNamespace: \"n1\",\n\t\t\t\t\tAll:       false,\n\t\t\t\t\tNames:     sets.New[string](\"r1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"by namespaced id authorized by name\",\n\t\t\tapiOp: &types.APIRequest{\n\t\t\t\tNamespace: \"n1\",\n\t\t\t},\n\t\t\tid: \"r1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": true,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: []partition.Partition{\n\t\t\t\t{\n\t\t\t\t\tNamespace: \"n1\",\n\t\t\t\t\tAll:       false,\n\t\t\t\t\tNames:     sets.New[string](\"r1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"by id ignores unrequested resources\",\n\t\t\tapiOp: &types.APIRequest{},\n\t\t\tid:    \"n1/r1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": true,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: []partition.Partition{\n\t\t\t\t{\n\t\t\t\t\tNamespace: \"n1\",\n\t\t\t\t\tNames:     sets.New[string](\"r1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t// Note: this is deprecated fallback behavior. When we remove the behavior,\n\t\t// rewrite this test to expect an error instead.\n\t\t{\n\t\t\tname: \"by id prefers id embedded namespace\",\n\t\t\tapiOp: &types.APIRequest{\n\t\t\t\tNamespace: \"n2\",\n\t\t\t},\n\t\t\tid: \"n1/r1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": true,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"n2\",\n\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: []partition.Partition{\n\t\t\t\t{\n\t\t\t\t\tNamespace: \"n1\",\n\t\t\t\t\tNames:     sets.New[string](\"r1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"cluster scoped id unauthorized\",\n\t\t\tapiOp: &types.APIRequest{},\n\t\t\tid:    \"c1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"cluster scoped id authorized by name\",\n\t\t\tapiOp: &types.APIRequest{},\n\t\t\tid:    \"c1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": false,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n\t\t\t\t\t\t\t\t\tResourceName: \"c1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: []partition.Partition{\n\t\t\t\t{\n\t\t\t\t\tNamespace: \"\",\n\t\t\t\t\tNames:     sets.New[string](\"c1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"cluster scoped id authorized globally\",\n\t\t\tapiOp: &types.APIRequest{},\n\t\t\tid:    \"c1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": false,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n\t\t\t\t\t\t\t\t\tResourceName: \"*\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: []partition.Partition{\n\t\t\t\t{\n\t\t\t\t\tNamespace: \"\",\n\t\t\t\t\tNames:     sets.New[string](\"c1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"cluster scoped id ignores unrequested resources\",\n\t\t\tapiOp: &types.APIRequest{},\n\t\t\tid:    \"c1\",\n\t\t\tschema: &types.APISchema{\n\t\t\t\tSchema: &schemas.Schema{\n\t\t\t\t\tID: \"foo\",\n\t\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\t\"namespaced\": false,\n\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n\t\t\t\t\t\t\t\t\tResourceName: \"c1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\taccesscontrol.Access{\n\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n\t\t\t\t\t\t\t\t\tResourceName: \"c2\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPartitions: []partition.Partition{\n\t\t\t\t{\n\t\t\t\t\tNamespace: \"\",\n\t\t\t\t\tNames:     sets.New[string](\"c1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tpartitioner := rbacPartitioner{}\n\t\t\tverb := \"watch\"\n\t\t\tgotPartitions, gotErr := partitioner.All(test.apiOp, test.schema, verb, test.id)\n\t\t\tassert.Nil(t, gotErr)\n\t\t\tassert.Equal(t, test.wantPartitions, gotPartitions)\n\t\t})\n\t}\n}\n\nfunc TestStore(t *testing.T) {\n\texpectedStore := NewMockUnstructuredStore(gomock.NewController(t))\n\trp := rbacPartitioner{\n\t\tproxyStore: expectedStore,\n\t}\n\tstore := rp.Store()\n\tassert.Equal(t, expectedStore, store)\n}\n", "patch": "@@ -13,7 +13,7 @@ import (\n \t\"k8s.io/apimachinery/pkg/util/sets\"\n )\n \n-func TestAll(t *testing.T) {\n+func TestVerbList(t *testing.T) {\n \ttests := []struct {\n \t\tname           string\n \t\tapiOp          *types.APIRequest\n@@ -225,21 +225,309 @@ func TestAll(t *testing.T) {\n \t\t\t},\n \t\t},\n \t\t{\n-\t\t\tname:  \"by id\",\n+\t\t\tname:  \"by id fully unauthorized\",\n \t\t\tapiOp: &types.APIRequest{},\n \t\t\tid:    \"n1/r1\",\n \t\t\tschema: &types.APISchema{\n \t\t\t\tSchema: &schemas.Schema{\n \t\t\t\t\tID: \"foo\",\n \t\t\t\t},\n \t\t\t},\n+\t\t\twantPartitions: nil,\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"by id missing namespace\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n2\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: nil,\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"by id missing resource\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: nil,\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"by id authorized by name\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\t{\n+\t\t\t\t\tNamespace: \"n1\",\n+\t\t\t\t\tNames:     sets.New[string](\"r1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"by id authorized by namespace\",\n+\t\t\tapiOp: &types.APIRequest{\n+\t\t\t\tNamespace: \"n1\",\n+\t\t\t},\n+\t\t\tid: \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"*\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\t{\n+\t\t\t\t\tNamespace: \"n1\",\n+\t\t\t\t\tAll:       false,\n+\t\t\t\t\tNames:     sets.New[string](\"r1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"by namespaced id authorized by name\",\n+\t\t\tapiOp: &types.APIRequest{\n+\t\t\t\tNamespace: \"n1\",\n+\t\t\t},\n+\t\t\tid: \"r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\t{\n+\t\t\t\t\tNamespace: \"n1\",\n+\t\t\t\t\tAll:       false,\n+\t\t\t\t\tNames:     sets.New[string](\"r1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"by id ignores unrequested resources\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\t{\n+\t\t\t\t\tNamespace: \"n1\",\n+\t\t\t\t\tNames:     sets.New[string](\"r1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t// Note: this is deprecated fallback behavior. When we remove the behavior,\n+\t\t// rewrite this test to expect an error instead.\n+\t\t{\n+\t\t\tname: \"by id prefers id embedded namespace\",\n+\t\t\tapiOp: &types.APIRequest{\n+\t\t\t\tNamespace: \"n2\",\n+\t\t\t},\n+\t\t\tid: \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n2\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n \t\t\twantPartitions: []partition.Partition{\n \t\t\t\t{\n \t\t\t\t\tNamespace: \"n1\",\n \t\t\t\t\tNames:     sets.New[string](\"r1\"),\n \t\t\t\t},\n \t\t\t},\n \t\t},\n+\t\t{\n+\t\t\tname:  \"cluster scoped id unauthorized\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"c1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: nil,\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"cluster scoped id authorized by name\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"c1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": false,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"c1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\t{\n+\t\t\t\t\tNamespace: \"\",\n+\t\t\t\t\tNames:     sets.New[string](\"c1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"cluster scoped id authorized globally\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"c1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": false,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"*\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\t{\n+\t\t\t\t\tNamespace: \"\",\n+\t\t\t\t\tNames:     sets.New[string](\"c1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"cluster scoped id ignores unrequested resources\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"c1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": false,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"c1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"c2\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\t{\n+\t\t\t\t\tNamespace: \"\",\n+\t\t\t\t\tNames:     sets.New[string](\"c1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n \t}\n \n \tfor _, test := range tests {\n@@ -253,6 +541,330 @@ func TestAll(t *testing.T) {\n \t}\n }\n \n+func TestVerbWatch(t *testing.T) {\n+\ttests := []struct {\n+\t\tname           string\n+\t\tapiOp          *types.APIRequest\n+\t\tid             string\n+\t\tschema         *types.APISchema\n+\t\twantPartitions []partition.Partition\n+\t}{\n+\t\t{\n+\t\t\tname:  \"by id fully unauthorized\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: nil,\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"by id missing namespace\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n2\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: nil,\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"by id missing resource\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: nil,\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"by id authorized by name\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\t{\n+\t\t\t\t\tNamespace: \"n1\",\n+\t\t\t\t\tNames:     sets.New[string](\"r1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"by id authorized by namespace\",\n+\t\t\tapiOp: &types.APIRequest{\n+\t\t\t\tNamespace: \"n1\",\n+\t\t\t},\n+\t\t\tid: \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"*\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\t{\n+\t\t\t\t\tNamespace: \"n1\",\n+\t\t\t\t\tAll:       false,\n+\t\t\t\t\tNames:     sets.New[string](\"r1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"by namespaced id authorized by name\",\n+\t\t\tapiOp: &types.APIRequest{\n+\t\t\t\tNamespace: \"n1\",\n+\t\t\t},\n+\t\t\tid: \"r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\t{\n+\t\t\t\t\tNamespace: \"n1\",\n+\t\t\t\t\tAll:       false,\n+\t\t\t\t\tNames:     sets.New[string](\"r1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"by id ignores unrequested resources\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\t{\n+\t\t\t\t\tNamespace: \"n1\",\n+\t\t\t\t\tNames:     sets.New[string](\"r1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t// Note: this is deprecated fallback behavior. When we remove the behavior,\n+\t\t// rewrite this test to expect an error instead.\n+\t\t{\n+\t\t\tname: \"by id prefers id embedded namespace\",\n+\t\t\tapiOp: &types.APIRequest{\n+\t\t\t\tNamespace: \"n2\",\n+\t\t\t},\n+\t\t\tid: \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n2\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\t{\n+\t\t\t\t\tNamespace: \"n1\",\n+\t\t\t\t\tNames:     sets.New[string](\"r1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"cluster scoped id unauthorized\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"c1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: nil,\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"cluster scoped id authorized by name\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"c1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": false,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"c1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\t{\n+\t\t\t\t\tNamespace: \"\",\n+\t\t\t\t\tNames:     sets.New[string](\"c1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"cluster scoped id authorized globally\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"c1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": false,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"*\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\t{\n+\t\t\t\t\tNamespace: \"\",\n+\t\t\t\t\tNames:     sets.New[string](\"c1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"cluster scoped id ignores unrequested resources\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"c1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": false,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"c1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"c2\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\t{\n+\t\t\t\t\tNamespace: \"\",\n+\t\t\t\t\tNames:     sets.New[string](\"c1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+\tfor _, test := range tests {\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tpartitioner := rbacPartitioner{}\n+\t\t\tverb := \"watch\"\n+\t\t\tgotPartitions, gotErr := partitioner.All(test.apiOp, test.schema, verb, test.id)\n+\t\t\tassert.Nil(t, gotErr)\n+\t\t\tassert.Equal(t, test.wantPartitions, gotPartitions)\n+\t\t})\n+\t}\n+}\n+\n func TestStore(t *testing.T) {\n \texpectedStore := NewMockUnstructuredStore(gomock.NewController(t))\n \trp := rbacPartitioner{"}
