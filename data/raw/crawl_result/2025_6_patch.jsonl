[
    {
        "query_url": "https://api.github.com/repos/fusionforge/fusionforge/commits/30f80503efbfb68c3915ef968c5215ab203d8118",
        "url": "https://api.github.com/repos/fusionforge/fusionforge/commits/30f80503efbfb68c3915ef968c5215ab203d8118",
        "html_url": "https://github.com/fusionforge/fusionforge/commit/30f80503efbfb68c3915ef968c5215ab203d8118",
        "message": "tighten permission on /anonscm/ web subdirectory\n\nAddresses: CVE-2014-0468\nFound by: Sylvain Beucler\nFixes by: Sylvain Beucler, Roland Mas, me\n\nConflicts:\n\tsrc/etc/httpd.conf.d-fhs/plugin-generic.inc\n\tsrc/etc/httpd.conf.d-opt/plugin-generic.inc\n\tsrc/etc/httpd.conf.d-usrlocal/plugin-generic.inc",
        "files": [
            {
                "sha": "ad05445309646b3c712ae7ed3be7b82b2755267d",
                "filename": "src/etc/httpd.conf.d/plugin-generic.inc",
                "status": "modified",
                "additions": 20,
                "deletions": 1,
                "changes": 21,
                "blob_url": "https://github.com/fusionforge/fusionforge/blob/30f80503efbfb68c3915ef968c5215ab203d8118/src%2Fetc%2Fhttpd.conf.d%2Fplugin-generic.inc",
                "raw_url": "https://github.com/fusionforge/fusionforge/raw/30f80503efbfb68c3915ef968c5215ab203d8118/src%2Fetc%2Fhttpd.conf.d%2Fplugin-generic.inc",
                "contents_url": "https://api.github.com/repos/fusionforge/fusionforge/contents/src%2Fetc%2Fhttpd.conf.d%2Fplugin-generic.inc?ref=30f80503efbfb68c3915ef968c5215ab203d8118",
                "patch": "@@ -6,5 +6,24 @@ Alias {core/url_prefix}anonscm/ {core/data_path}/chroot/scmrepos/\n   Options -Indexes\n </DirectoryMatch>\n <DirectoryMatch {core/data_path}/chroot/scmrepos/[^/]*/.*>\n-  Options +Indexes\n+  # Enable directory index listing, but disable symlinks and CGI\n+  Options Indexes\n+\n+  # Permit HTTP Auth for somewhat private projects (mechanism\n+  # other than the SCM anon bit in the forge)\n+  AllowOverride AuthConfig\n+\n+  # Prevent cookie theft in case a script does manage to execute\n+  RequestHeader unset Cookie\n+\n+  # Disable all scripting engines (taken from Savannah)\n+  # except for empty filenames == directory index\n+  <Files \"?*\">\n+    SetHandler default\n+  </Files>\n+\n+  # Disable PHP5 explicitly for security (CVE-2014-0468)\n+  <IfModule mod_php5.c>\n+    php_admin_flag engine off\n+  </IfModule>\n </DirectoryMatch>"
            }
        ]
    },
    {
        "query_url": "https://api.github.com/repos/matplotlib/matplotlib/commits/ba4016014cb4fb4927e36ce8ea429fed47dcb787",
        "url": "https://api.github.com/repos/matplotlib/matplotlib/commits/ba4016014cb4fb4927e36ce8ea429fed47dcb787",
        "html_url": "https://github.com/matplotlib/matplotlib/commit/ba4016014cb4fb4927e36ce8ea429fed47dcb787",
        "message": "Remove use of PyCXX in core C++ extensions",
        "files": [
            {
                "sha": "8c7c1be5411bb50188aec62e16d0e0424d6ddd1e",
                "filename": ".travis.yml",
                "status": "modified",
                "additions": 4,
                "deletions": 3,
                "changes": 7,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/.travis.yml",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/.travis.yml",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/.travis.yml?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787",
                "patch": "@@ -24,8 +24,8 @@ matrix:\n \n install:\n   - pip install -q --use-mirrors nose python-dateutil $NUMPY pep8 pyparsing pillow\n-  - sudo apt-get update && sudo apt-get -qq install inkscape libav-tools\n-  # We use --no-install-recommends to avoid pulling in additional large latex docs that we don't need \n+  - sudo apt-get update && sudo apt-get -qq install inkscape libav-tools gdb\n+  # We use --no-install-recommends to avoid pulling in additional large latex docs that we don't need\n   - if [[ $BUILD_DOCS == true ]]; then sudo apt-get install -qq --no-install-recommends dvipng texlive-latex-base texlive-latex-extra texlive-fonts-recommended graphviz; fi\n   - if [[ $BUILD_DOCS == true ]]; then pip install sphinx numpydoc linkchecker; fi\n   - python setup.py install\n@@ -37,11 +37,12 @@ script:\n   - echo Testing using 8 processes\n   # Generate the font caches in a single process before starting the\n   # multiple processes\n+  - gcc --version\n   - python -c \"from matplotlib import font_manager\"\n   - if [[ $BUILD_DOCS == false ]]; then export MPL_REPO_DIR=$PWD; fi # pep8-conformance test of the examples\n   - if [[ $BUILD_DOCS == false ]]; then mkdir ../tmp_test_dir; fi\n   - if [[ $BUILD_DOCS == false ]]; then cd ../tmp_test_dir; fi\n-  - if [[ $BUILD_DOCS == false ]]; then python ../matplotlib/tests.py -sv --processes=8 --process-timeout=300 $TEST_ARGS; fi\n+  - if [[ $BUILD_DOCS == false ]]; then gdb -return-child-result -batch -ex r -ex bt --args python ../matplotlib/tests.py -sv $TEST_ARGS; fi\n   - if [[ $BUILD_DOCS == true ]]; then cd doc; python make.py html --small; fi\n   # We don't build the LaTeX docs here, so linkchecker will complain\n   - if [[ $BUILD_DOCS == true ]]; then touch build/html/Matplotlib.pdf; fi"
            },
            {
                "sha": "acbe2333a319e127d40b4fcbe8c9e002e69269e6",
                "filename": "examples/pylab_examples/agg_buffer_to_array.py",
                "status": "modified",
                "additions": 1,
                "deletions": 6,
                "changes": 7,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/examples%2Fpylab_examples%2Fagg_buffer_to_array.py",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/examples%2Fpylab_examples%2Fagg_buffer_to_array.py",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/examples%2Fpylab_examples%2Fagg_buffer_to_array.py?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787",
                "patch": "@@ -8,12 +8,7 @@\n fig.canvas.draw()\n \n # grab the pixel buffer and dump it into a numpy array\n-buf = fig.canvas.buffer_rgba()\n-l, b, w, h = fig.bbox.bounds\n-# The array needs to be copied, because the underlying buffer\n-# may be reallocated when the window is resized.\n-X = np.frombuffer(buf, np.uint8).copy()\n-X.shape = h,w,4\n+X = np.array(fig.canvas.renderer._renderer)\n \n # now display the array X as an Axes in a new figure\n fig2 = plt.figure()"
            },
            {
                "sha": "98a9c73c2f70a954373f95a8cbc7c783e4cf2d84",
                "filename": "examples/pylab_examples/mathtext_demo.py",
                "status": "modified",
                "additions": 0,
                "deletions": 1,
                "changes": 1,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/examples%2Fpylab_examples%2Fmathtext_demo.py",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/examples%2Fpylab_examples%2Fmathtext_demo.py",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/examples%2Fpylab_examples%2Fmathtext_demo.py?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787",
                "patch": "@@ -24,5 +24,4 @@\n \n ax.set_title(r'$\\Delta_i^j \\hspace{0.4} \\mathrm{versus} \\hspace{0.4} \\Delta_{i+1}^j$', fontsize=20)\n \n-\n show()"
            },
            {
                "sha": "5978886fa12716b3df8961aafbbb6e044a053672",
                "filename": "lib/matplotlib/__init__.py",
                "status": "modified",
                "additions": 7,
                "deletions": 0,
                "changes": 7,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2F__init__.py",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2F__init__.py",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/lib%2Fmatplotlib%2F__init__.py?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787",
                "patch": "@@ -1405,6 +1405,13 @@ def tk_window_focus():\n \n def test(verbosity=1):\n     \"\"\"run the matplotlib test suite\"\"\"\n+    try:\n+        import faulthandler\n+    except ImportError:\n+        pass\n+    else:\n+        faulthandler.enable()\n+\n     old_backend = rcParams['backend']\n     try:\n         use('agg')"
            },
            {
                "sha": "91dfc0478ae4c6e953338ae84d540d3a3389416b",
                "filename": "lib/matplotlib/axes/_base.py",
                "status": "modified",
                "additions": 2,
                "deletions": 2,
                "changes": 4,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Faxes%2F_base.py",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Faxes%2F_base.py",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/lib%2Fmatplotlib%2Faxes%2F_base.py?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787",
                "patch": "@@ -2063,8 +2063,8 @@ def draw(self, renderer=None, inframe=False):\n                    for z, im in zorder_images]\n \n             l, b, r, t = self.bbox.extents\n-            width = mag * ((round(r) + 0.5) - (round(l) - 0.5))\n-            height = mag * ((round(t) + 0.5) - (round(b) - 0.5))\n+            width = int(mag * ((round(r) + 0.5) - (round(l) - 0.5)))\n+            height = int(mag * ((round(t) + 0.5) - (round(b) - 0.5)))\n             im = mimage.from_images(height,\n                                     width,\n                                     ims)"
            },
            {
                "sha": "c7a59be98ce858a5edb0d79b48ba01c07bde464a",
                "filename": "lib/matplotlib/backends/backend_agg.py",
                "status": "modified",
                "additions": 15,
                "deletions": 13,
                "changes": 28,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Fbackends%2Fbackend_agg.py",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Fbackends%2Fbackend_agg.py",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/lib%2Fmatplotlib%2Fbackends%2Fbackend_agg.py?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787",
                "patch": "@@ -127,15 +127,19 @@ def draw_path_collection(self, *kl, **kw):\n         return self._renderer.draw_path_collection(*kl, **kw)\n \n     def _update_methods(self):\n-        #self.draw_path = self._renderer.draw_path  # see below\n-        #self.draw_markers = self._renderer.draw_markers\n-        #self.draw_path_collection = self._renderer.draw_path_collection\n         self.draw_quad_mesh = self._renderer.draw_quad_mesh\n         self.draw_gouraud_triangle = self._renderer.draw_gouraud_triangle\n         self.draw_gouraud_triangles = self._renderer.draw_gouraud_triangles\n         self.draw_image = self._renderer.draw_image\n         self.copy_from_bbox = self._renderer.copy_from_bbox\n-        self.tostring_rgba_minimized = self._renderer.tostring_rgba_minimized\n+        self.get_content_extents = self._renderer.get_content_extents\n+\n+    def tostring_rgba_minimized(self):\n+        extents = self.get_content_extents()\n+        bbox = [[extents[0], self.height - (extents[1] + extents[3])],\n+                [extents[0] + extents[2], self.height - extents[1]]]\n+        region = self.copy_from_bbox(bbox)\n+        return np.array(region), extents\n \n     def draw_path(self, gc, path, transform, rgbFace=None):\n         \"\"\"\n@@ -203,7 +207,7 @@ def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n \n         #print x, y, int(x), int(y), s\n         self._renderer.draw_text_image(\n-            font.get_image(), np.round(x - xd), np.round(y + yd) + 1, angle, gc)\n+            font, np.round(x - xd), np.round(y + yd) + 1, angle, gc)\n \n     def get_text_width_height_descent(self, s, prop, ismath):\n         \"\"\"\n@@ -354,7 +358,7 @@ def restore_region(self, region, bbox=None, xy=None):\n             else:\n                 ox, oy = xy\n \n-            self._renderer.restore_region2(region, x1, y1, x2, y2, ox, oy)\n+            self._renderer.restore_region(region, x1, y1, x2, y2, ox, oy)\n \n         else:\n             self._renderer.restore_region(region)\n@@ -394,7 +398,7 @@ def post_processing(image, dpi):\n \n         width, height = int(self.width), int(self.height)\n \n-        buffer, bounds = self._renderer.tostring_rgba_minimized()\n+        buffer, bounds = self.tostring_rgba_minimized()\n \n         l, b, w, h = bounds\n \n@@ -407,7 +411,6 @@ def post_processing(image, dpi):\n             img, ox, oy = post_processing(img.reshape((h, w, 4)) / 255.,\n                                           self.dpi)\n             image = fromarray(img, 1)\n-            image.flipud_out()\n \n             gc = self.new_gc()\n             self._renderer.draw_image(gc,\n@@ -505,12 +508,13 @@ def print_raw(self, filename_or_obj, *args, **kwargs):\n         original_dpi = renderer.dpi\n         renderer.dpi = self.figure.dpi\n         if is_string_like(filename_or_obj):\n-            filename_or_obj = open(filename_or_obj, 'wb')\n+            fileobj = open(filename_or_obj, 'wb')\n             close = True\n         else:\n+            fileobj = filename_or_obj\n             close = False\n         try:\n-            renderer._renderer.write_rgba(filename_or_obj)\n+            fileobj.write(renderer._renderer.buffer_rgba())\n         finally:\n             if close:\n                 filename_or_obj.close()\n@@ -528,9 +532,7 @@ def print_png(self, filename_or_obj, *args, **kwargs):\n         else:\n             close = False\n         try:\n-            _png.write_png(renderer._renderer.buffer_rgba(),\n-                           renderer.width, renderer.height,\n-                           filename_or_obj, self.figure.dpi)\n+            _png.write_png(renderer._renderer, filename_or_obj, self.figure.dpi)\n         finally:\n             if close:\n                 filename_or_obj.close()"
            },
            {
                "sha": "4af8562a0940d45256b3c206d62380e1e8ca3737",
                "filename": "lib/matplotlib/backends/backend_cairo.py",
                "status": "modified",
                "additions": 0,
                "deletions": 4,
                "changes": 4,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Fbackends%2Fbackend_cairo.py",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Fbackends%2Fbackend_cairo.py",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/lib%2Fmatplotlib%2Fbackends%2Fbackend_cairo.py?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787",
                "patch": "@@ -167,8 +167,6 @@ def draw_image(self, gc, x, y, im):\n         # bbox - not currently used\n         if _debug: print('%s.%s()' % (self.__class__.__name__, _fn_name()))\n \n-        im.flipud_out()\n-\n         rows, cols, buf = im.color_conv (BYTE_FORMAT)\n         surface = cairo.ImageSurface.create_for_data (\n                       buf, cairo.FORMAT_ARGB32, cols, rows, cols*4)\n@@ -183,8 +181,6 @@ def draw_image(self, gc, x, y, im):\n             ctx.paint()\n         ctx.restore()\n \n-        im.flipud_out()\n-\n     def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n         # Note: x,y are device/display coords, not user-coords, unlike other\n         # draw_* methods"
            },
            {
                "sha": "d3e8e5bb1202b010822ddf1b821f78b2efec0269",
                "filename": "lib/matplotlib/backends/backend_gdk.py",
                "status": "modified",
                "additions": 1,
                "deletions": 5,
                "changes": 6,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Fbackends%2Fbackend_gdk.py",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Fbackends%2Fbackend_gdk.py",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/lib%2Fmatplotlib%2Fbackends%2Fbackend_gdk.py?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787",
                "patch": "@@ -109,7 +109,6 @@ def draw_image(self, gc, x, y, im):\n             #             int(w), int(h))\n             # set clip rect?\n \n-        im.flipud_out()\n         rows, cols, image_str = im.as_rgba_str()\n \n         image_array = np.fromstring(image_str, np.uint8)\n@@ -120,7 +119,7 @@ def draw_image(self, gc, x, y, im):\n                                 width=cols, height=rows)\n \n         array = pixbuf_get_pixels_array(pixbuf)\n-        array[:,:,:] = image_array\n+        array[:,:,:] = image_array[::-1]\n \n         gc = self.new_gc()\n \n@@ -138,9 +137,6 @@ def draw_image(self, gc, x, y, im):\n                                   int(x), int(y), cols, rows,\n                                   gdk.RGB_DITHER_NONE, 0, 0)\n \n-        # unflip\n-        im.flipud_out()\n-\n \n     def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n         x, y = int(x), int(y)"
            },
            {
                "sha": "43434e374e1d2ea913847c5b3ee7cf7e49903207",
                "filename": "lib/matplotlib/backends/backend_macosx.py",
                "status": "modified",
                "additions": 0,
                "deletions": 2,
                "changes": 2,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Fbackends%2Fbackend_macosx.py",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Fbackends%2Fbackend_macosx.py",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/lib%2Fmatplotlib%2Fbackends%2Fbackend_macosx.py?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787",
                "patch": "@@ -110,10 +110,8 @@ def get_image_magnification(self):\n         return self.gc.get_image_magnification()\n \n     def draw_image(self, gc, x, y, im):\n-        im.flipud_out()\n         nrows, ncols, data = im.as_rgba_str()\n         gc.draw_image(x, y, nrows, ncols, data)\n-        im.flipud_out()\n \n     def draw_tex(self, gc, x, y, s, prop, angle, ismath='TeX!', mtext=None):\n         # todo, handle props, angle, origins"
            },
            {
                "sha": "ee48f9274bbe4f62a7b3c5c62e122563aee54828",
                "filename": "lib/matplotlib/backends/backend_mixed.py",
                "status": "modified",
                "additions": 0,
                "deletions": 1,
                "changes": 1,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Fbackends%2Fbackend_mixed.py",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Fbackends%2Fbackend_mixed.py",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/lib%2Fmatplotlib%2Fbackends%2Fbackend_mixed.py?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787",
                "patch": "@@ -121,7 +121,6 @@ def stop_rasterizing(self):\n             if w > 0 and h > 0:\n                 image = frombuffer(buffer, w, h, True)\n                 image.is_grayscale = False\n-                image.flipud_out()\n                 gc = self._renderer.new_gc()\n                 # TODO: If the mixedmode resolution differs from the figure's\n                 #       dpi, the image must be scaled (dpi->_figdpi). Not all"
            },
            {
                "sha": "933e84b2298856f69fdc46f2fac517f19778b4d4",
                "filename": "lib/matplotlib/backends/backend_pdf.py",
                "status": "modified",
                "additions": 2,
                "deletions": 3,
                "changes": 5,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Fbackends%2Fbackend_pdf.py",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Fbackends%2Fbackend_pdf.py",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/lib%2Fmatplotlib%2Fbackends%2Fbackend_pdf.py?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787",
                "patch": "@@ -1241,6 +1241,7 @@ def _rgb(self, im):\n \n         rgba = np.fromstring(s, np.uint8)\n         rgba.shape = (h, w, 4)\n+        rgba = rgba[::-1]\n         rgb = rgba[:, :, :3]\n         a = rgba[:, :, 3:]\n         return h, w, rgb.tostring(), a.tostring()\n@@ -1249,6 +1250,7 @@ def _gray(self, im, rc=0.3, gc=0.59, bc=0.11):\n         rgbat = im.as_rgba_str()\n         rgba = np.fromstring(rgbat[2], np.uint8)\n         rgba.shape = (rgbat[0], rgbat[1], 4)\n+        rgba = rgba[::-1]\n         rgba_f = rgba.astype(np.float32)\n         r = rgba_f[:, :, 0]\n         g = rgba_f[:, :, 1]\n@@ -1258,7 +1260,6 @@ def _gray(self, im, rc=0.3, gc=0.59, bc=0.11):\n \n     def writeImages(self):\n         for img, pair in six.iteritems(self.images):\n-            img.flipud_out()\n             if img.is_grayscale:\n                 height, width, data = self._gray(img)\n                 self.beginStream(\n@@ -1294,8 +1295,6 @@ def writeImages(self):\n                 self.currentstream.write(data)\n                 self.endStream()\n \n-            img.flipud_out()\n-\n     def markerObject(self, path, trans, fillp, strokep, lw, joinstyle,\n                      capstyle):\n         \"\"\"Return name of a marker XObject representing the given path.\"\"\""
            },
            {
                "sha": "e432a340d803b3dffc157d70070aac7ce950fe11",
                "filename": "lib/matplotlib/backends/backend_pgf.py",
                "status": "modified",
                "additions": 3,
                "deletions": 3,
                "changes": 6,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Fbackends%2Fbackend_pgf.py",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Fbackends%2Fbackend_pgf.py",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/lib%2Fmatplotlib%2Fbackends%2Fbackend_pgf.py?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787",
                "patch": "@@ -14,6 +14,8 @@\n import weakref\n import warnings\n \n+import numpy as np\n+\n import matplotlib as mpl\n from matplotlib.backend_bases import RendererBase, GraphicsContextBase,\\\n     FigureManagerBase, FigureCanvasBase\n@@ -619,9 +621,7 @@ def draw_image(self, gc, x, y, im):\n         fname = os.path.splitext(os.path.basename(self.fh.name))[0]\n         fname_img = \"%s-img%d.png\" % (fname, self.image_counter)\n         self.image_counter += 1\n-        im.flipud_out()\n-        rows, cols, buf = im.as_rgba_str()\n-        _png.write_png(buf, cols, rows, os.path.join(path, fname_img))\n+        _png.write_png(np.array(im)[::-1], os.path.join(path, fname_img))\n \n         # reference the image in the pgf picture\n         writeln(self.fh, r\"\\begin{pgfscope}\")"
            },
            {
                "sha": "48c5bdd6cae994e5b07cbdb3ab1c4f0d4f18f8e9",
                "filename": "lib/matplotlib/backends/backend_ps.py",
                "status": "modified",
                "additions": 2,
                "deletions": 6,
                "changes": 8,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Fbackends%2Fbackend_ps.py",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Fbackends%2Fbackend_ps.py",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/lib%2Fmatplotlib%2Fbackends%2Fbackend_ps.py?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787",
                "patch": "@@ -414,13 +414,14 @@ def _rgb(self, im):\n \n         rgba = np.fromstring(s, np.uint8)\n         rgba.shape = (h, w, 4)\n-        rgb = rgba[:,:,:3]\n+        rgb = rgba[::-1,:,:3]\n         return h, w, rgb.tostring()\n \n     def _gray(self, im, rc=0.3, gc=0.59, bc=0.11):\n         rgbat = im.as_rgba_str()\n         rgba = np.fromstring(rgbat[2], np.uint8)\n         rgba.shape = (rgbat[0], rgbat[1], 4)\n+        rgba = rgba[::-1]\n         rgba_f = rgba.astype(np.float32)\n         r = rgba_f[:,:,0]\n         g = rgba_f[:,:,1]\n@@ -472,8 +473,6 @@ def draw_image(self, gc, x, y, im, dx=None, dy=None, transform=None):\n         interpreted as the coordinate of the transform.\n         \"\"\"\n \n-        im.flipud_out()\n-\n         h, w, bits, imagecmd = self._get_image_h_w_bits_command(im)\n         hexlines = b'\\n'.join(self._hex_lines(bits)).decode('ascii')\n \n@@ -524,9 +523,6 @@ def draw_image(self, gc, x, y, im, dx=None, dy=None, transform=None):\n \"\"\" % locals()\n         self._pswriter.write(ps)\n \n-        # unflip\n-        im.flipud_out()\n-\n     def _convert_path(self, path, transform, clip=False, simplify=None):\n         ps = []\n         last_points = None"
            },
            {
                "sha": "5b47101425715248576a2d5047cfb37ccd929703",
                "filename": "lib/matplotlib/backends/backend_svg.py",
                "status": "modified",
                "additions": 2,
                "deletions": 8,
                "changes": 10,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Fbackends%2Fbackend_svg.py",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Fbackends%2Fbackend_svg.py",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/lib%2Fmatplotlib%2Fbackends%2Fbackend_svg.py?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787",
                "patch": "@@ -800,10 +800,7 @@ def draw_image(self, gc, x, y, im, dx=None, dy=None, transform=None):\n             self.writer.start('a', attrib={'xlink:href': url})\n         if rcParams['svg.image_inline']:\n             bytesio = io.BytesIO()\n-            im.flipud_out()\n-            rows, cols, buffer = im.as_rgba_str()\n-            _png.write_png(buffer, cols, rows, bytesio)\n-            im.flipud_out()\n+            _png.write_png(np.array(im)[::-1], bytesio)\n             oid = oid or self._make_id('image', bytesio)\n             attrib['xlink:href'] = (\n                 \"data:image/png;base64,\\n\" +\n@@ -812,10 +809,7 @@ def draw_image(self, gc, x, y, im, dx=None, dy=None, transform=None):\n             self._imaged[self.basename] = self._imaged.get(self.basename,0) + 1\n             filename = '%s.image%d.png'%(self.basename, self._imaged[self.basename])\n             verbose.report( 'Writing image file for inclusion: %s' % filename)\n-            im.flipud_out()\n-            rows, cols, buffer = im.as_rgba_str()\n-            _png.write_png(buffer, cols, rows, filename)\n-            im.flipud_out()\n+            _png.write_png(np.array(im)[::-1], filename)\n             oid = oid or 'Im_' + self._make_id('image', filename)\n             attrib['xlink:href'] = filename\n "
            },
            {
                "sha": "4971b336671c5d8e4582697c2a3c2fe7b97cb6bb",
                "filename": "lib/matplotlib/backends/backend_webagg_core.py",
                "status": "modified",
                "additions": 1,
                "deletions": 2,
                "changes": 3,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Fbackends%2Fbackend_webagg_core.py",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Fbackends%2Fbackend_webagg_core.py",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/lib%2Fmatplotlib%2Fbackends%2Fbackend_webagg_core.py?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787",
                "patch": "@@ -143,8 +143,7 @@ def get_diff_image(self):\n             # TODO: We should write a new version of write_png that\n             # handles the differencing inline\n             _png.write_png(\n-                output.tostring(),\n-                output.shape[1], output.shape[0],\n+                output,\n                 self._png_buffer)\n \n             # Swap the renderer frames"
            },
            {
                "sha": "5d75bb8f5bb0f397f058aa65c931cab75b7534d3",
                "filename": "lib/matplotlib/figure.py",
                "status": "modified",
                "additions": 2,
                "deletions": 2,
                "changes": 4,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Ffigure.py",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Ffigure.py",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/lib%2Fmatplotlib%2Ffigure.py?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787",
                "patch": "@@ -1045,8 +1045,8 @@ def draw(self, renderer):\n             ims = [(im.make_image(mag), im.ox, im.oy, im.get_alpha())\n                    for im in self.images]\n \n-            im = _image.from_images(self.bbox.height * mag,\n-                                    self.bbox.width * mag,\n+            im = _image.from_images(int(self.bbox.height * mag),\n+                                    int(self.bbox.width * mag),\n                                     ims)\n \n             im.is_grayscale = False"
            },
            {
                "sha": "9dd9599a67f7a8a39bfdb20d585bbee6a483174a",
                "filename": "lib/matplotlib/image.py",
                "status": "modified",
                "additions": 24,
                "deletions": 24,
                "changes": 48,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Fimage.py",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Fimage.py",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/lib%2Fmatplotlib%2Fimage.py?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787",
                "patch": "@@ -204,15 +204,19 @@ def _get_unsampled_image(self, A, image_extents, viewlim):\n             self._oldyslice = yslice\n \n         if self._imcache is None:\n-            if self._A.dtype == np.uint8 and self._A.ndim == 3:\n-                im = _image.frombyte(self._A[yslice, xslice, :], 0)\n+            A = self._A\n+            if self.origin == 'upper':\n+                A = A[::-1]\n+\n+            if A.dtype == np.uint8 and A.ndim == 3:\n+                im = _image.frombyte(A[yslice, xslice, :], 0)\n                 im.is_grayscale = False\n             else:\n                 if self._rgbacache is None:\n-                    x = self.to_rgba(self._A, bytes=False)\n+                    x = self.to_rgba(A, bytes=False)\n                     # Avoid side effects: to_rgba can return its argument\n                     # unchanged.\n-                    if np.may_share_memory(x, self._A):\n+                    if np.may_share_memory(x, A):\n                         x = x.copy()\n                     # premultiply the colors\n                     x[..., 0:3] *= x[..., 3:4]\n@@ -226,9 +230,6 @@ def _get_unsampled_image(self, A, image_extents, viewlim):\n                 else:\n                     im.is_grayscale = False\n             self._imcache = im\n-\n-            if self.origin == 'upper':\n-                im.flipud_in()\n         else:\n             im = self._imcache\n \n@@ -413,9 +414,7 @@ def write_png(self, fname, noscale=False):\n             im.reset_matrix()\n             im.set_interpolation(0)\n             im.resize(numcols, numrows)\n-        im.flipud_out()\n-        rows, cols, buffer = im.as_rgba_str()\n-        _png.write_png(buffer, cols, rows, fname)\n+        _png.write_png(im, fname)\n \n     def set_data(self, A):\n         \"\"\"\n@@ -732,7 +731,7 @@ def make_image(self, magnification=1.0):\n         width *= magnification\n         height *= magnification\n         im = _image.pcolor(self._Ax, self._Ay, A,\n-                           height, width,\n+                           int(height), int(width),\n                            (x0, x0+v_width, y0, y0+v_height),\n                            self._interpd[self._interpolation])\n \n@@ -1005,7 +1004,11 @@ def make_image(self, magnification=1.0):\n         if self._A is None:\n             raise RuntimeError('You must first set the image array')\n \n-        x = self.to_rgba(self._A, bytes=True)\n+        A = self._A\n+        if self.origin == 'upper':\n+            A = A[::-1]\n+\n+        x = self.to_rgba(A, bytes=True)\n         self.magnification = magnification\n         # if magnification is not one, we need to resize\n         ismag = magnification != 1\n@@ -1018,16 +1021,14 @@ def make_image(self, magnification=1.0):\n         fc = self.figure.get_facecolor()\n         im.set_bg(*mcolors.colorConverter.to_rgba(fc, 0))\n         im.is_grayscale = (self.cmap.name == \"gray\" and\n-                           len(self._A.shape) == 2)\n+                           len(A.shape) == 2)\n \n         if ismag:\n             numrows, numcols = self.get_size()\n             numrows *= magnification\n             numcols *= magnification\n             im.set_interpolation(_image.NEAREST)\n             im.resize(numcols, numrows)\n-        if self.origin == 'upper':\n-            im.flipud_out()\n \n         return im\n \n@@ -1047,8 +1048,7 @@ def draw(self, renderer, *args, **kwargs):\n     def write_png(self, fname):\n         \"\"\"Write the image to png file with fname\"\"\"\n         im = self.make_image()\n-        rows, cols, buffer = im.as_rgba_str()\n-        _png.write_png(buffer, cols, rows, fname)\n+        _png.write_png(im, fname)\n \n \n class BboxImage(_AxesImageBase):\n@@ -1131,24 +1131,24 @@ def make_image(self, renderer, magnification=1.0):\n                                'array or the image attribute')\n \n         if self._imcache is None:\n-            if self._A.dtype == np.uint8 and len(self._A.shape) == 3:\n-                im = _image.frombyte(self._A, 0)\n+            A = self._A\n+            if self.origin == 'upper':\n+                A = A[::-1]\n+            if A.dtype == np.uint8 and len(A.shape) == 3:\n+                im = _image.frombyte(A, 0)\n                 im.is_grayscale = False\n             else:\n                 if self._rgbacache is None:\n-                    x = self.to_rgba(self._A, bytes=True)\n+                    x = self.to_rgba(A, bytes=True)\n                     self._rgbacache = x\n                 else:\n                     x = self._rgbacache\n                 im = _image.frombyte(x, 0)\n-                if len(self._A.shape) == 2:\n+                if len(A.shape) == 2:\n                     im.is_grayscale = self.cmap.is_gray()\n                 else:\n                     im.is_grayscale = False\n             self._imcache = im\n-\n-            if self.origin == 'upper':\n-                im.flipud_in()\n         else:\n             im = self._imcache\n "
            },
            {
                "sha": "ce0807376ec19bebcd1d89e44f2aa833b192e8d0",
                "filename": "lib/matplotlib/mathtext.py",
                "status": "modified",
                "additions": 1,
                "deletions": 2,
                "changes": 3,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Fmathtext.py",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Fmathtext.py",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/lib%2Fmatplotlib%2Fmathtext.py?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787",
                "patch": "@@ -3092,8 +3092,7 @@ def to_png(self, filename, texstr, color='black', dpi=120, fontsize=14):\n         image in pixels.\n         \"\"\"\n         rgba, depth = self.to_rgba(texstr, color=color, dpi=dpi, fontsize=fontsize)\n-        numrows, numcols, tmp = rgba.shape\n-        _png.write_png(rgba.tostring(), numcols, numrows, filename)\n+        _png.write_png(rgba, filename)\n         return depth\n \n     def get_depth(self, texstr, dpi=120, fontsize=14):"
            },
            {
                "sha": "e02f3c2f3c34c30db4d9234a53c21efd2bb3f061",
                "filename": "lib/matplotlib/testing/compare.py",
                "status": "modified",
                "additions": 1,
                "deletions": 1,
                "changes": 2,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Ftesting%2Fcompare.py",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Ftesting%2Fcompare.py",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/lib%2Fmatplotlib%2Ftesting%2Fcompare.py?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787",
                "patch": "@@ -375,4 +375,4 @@ def save_diff_image(expected, actual, output):\n     # Hard-code the alpha channel to fully solid\n     save_image_np[:, :, 3] = 255\n \n-    _png.write_png(save_image_np.tostring(), width, height, output)\n+    _png.write_png(save_image_np, output)"
            },
            {
                "sha": "583715ea662ff6b8a844f885d74564ef2c8ae73a",
                "filename": "lib/matplotlib/tests/baseline_images/test_image/rasterize_10dpi.pdf",
                "status": "modified",
                "additions": 0,
                "deletions": 0,
                "changes": 0,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Ftests%2Fbaseline_images%2Ftest_image%2Frasterize_10dpi.pdf",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Ftests%2Fbaseline_images%2Ftest_image%2Frasterize_10dpi.pdf",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/lib%2Fmatplotlib%2Ftests%2Fbaseline_images%2Ftest_image%2Frasterize_10dpi.pdf?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787"
            },
            {
                "sha": "b6629abd2c7657577a7f2398fb89cfc15eef4423",
                "filename": "lib/matplotlib/tests/baseline_images/test_image/rasterize_10dpi.svg",
                "status": "modified",
                "additions": 3,
                "deletions": 3,
                "changes": 6,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Ftests%2Fbaseline_images%2Ftest_image%2Frasterize_10dpi.svg",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Ftests%2Fbaseline_images%2Ftest_image%2Frasterize_10dpi.svg",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/lib%2Fmatplotlib%2Ftests%2Fbaseline_images%2Ftest_image%2Frasterize_10dpi.svg?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787",
                "patch": "@@ -29,7 +29,7 @@ z\n \" style=\"fill:#ffffff;\"/>\n    </g>\n    <g clip-path=\"url(#pc31db6f15f)\">\n-    <image height=\"50.4\" id=\"image6e276badb5\" width=\"57.6\" x=\"27.0\" xlink:href=\"data:image/png;base64,\n+    <image height=\"50.4\" id=\"image4a0f195e76\" width=\"57.6\" x=\"27.0\" xlink:href=\"data:image/png;base64,\n iVBORw0KGgoAAAANSUhEUgAAAAgAAAAHCAYAAAA1WQxeAAAABHNCSVQICAgIfAhkiAAAAIZJREFUCJmFzjkOQWEAReHPkDyFsUVhCSIhap1VWZRFWIBWPBGiIX7zEDzFK5Rucpqbk5ubYZSARo1u60e9ArL+JN9rr8GrevQsPT2uZ494570rpsJwMAO3pCB8Ng7HWJhW3ZMIZCbjZgKnfc4mjlLmkXPIpwv9zgqEJYst5QvRnJDW/09+AWTgMQoHvFOEAAAAAElFTkSuQmCC\" y=\"10.2176470588\"/>\n    </g>\n    <g id=\"matplotlib.axis_1\"/>\n@@ -45,8 +45,8 @@ L86.0824 7.2\n z\n \" style=\"fill:#ffffff;\"/>\n    </g>\n-   <image height=\"43.2\" id=\"imagea9b52b76c7\" width=\"50.4\" x=\"79.2\" xlink:href=\"data:image/png;base64,\n-iVBORw0KGgoAAAANSUhEUgAAAAcAAAAGCAYAAAAPDoR2AAAABHNCSVQICAgIfAhkiAAAAE5JREFUCJl1jUENgEAAw7qEoAARmMEDFtCBGExgARNY4NF7HRByLOmn2bKo/KVryYQemFBvwBFcwRMeOYM76JuoJHyPL2Cry9o+wAUcVApQADT0Nho0cQAAAABJRU5ErkJggg==\" y=\"7.2\"/>\n+   <image height=\"64.8\" id=\"image9000a8cf24\" width=\"136.8\" x=\"79.2\" xlink:href=\"data:image/png;base64,\n+iVBORw0KGgoAAAANSUhEUgAAABMAAAAJCAYAAADQHRcxAAAABHNCSVQICAgIfAhkiAAAAHNJREFUKJG10kENwlAQBuH5OVQBImoBAzVQA1hABxoQUAUYqIWaqIRepqdHmoaE9AGbzGU3+U4blV/N6d0yoUnoE56HNPUV2IJ3cAYF3d4/VZArOBZgWw22RxZwALtvsAm8gecjyB57gBcwNUgpf3+N2lkBB3gBDVzLDTYAAAAASUVORK5CYII=\" y=\"7.2\"/>\n    <g id=\"matplotlib.axis_3\"/>\n    <g id=\"matplotlib.axis_4\"/>\n   </g>"
            },
            {
                "sha": "af8ddca37f4dbe266439beca00f06d6098330d4e",
                "filename": "lib/matplotlib/tests/test_axes.py",
                "status": "modified",
                "additions": 5,
                "deletions": 1,
                "changes": 6,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Ftests%2Ftest_axes.py",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Ftests%2Ftest_axes.py",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/lib%2Fmatplotlib%2Ftests%2Ftest_axes.py?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787",
                "patch": "@@ -4,6 +4,8 @@\n import six\n from six.moves import xrange\n \n+import io\n+\n from nose.tools import assert_equal, assert_raises\n import datetime\n \n@@ -3392,11 +3394,13 @@ def test_margins():\n @cleanup\n def test_pathological_hexbin():\n     # issue #2863\n+    out = io.BytesIO()\n+\n     with warnings.catch_warnings(record=True) as w:\n         mylist = [10] * 100\n         fig, ax = plt.subplots(1, 1)\n         ax.hexbin(mylist, mylist)\n-        plt.show()\n+        fig.savefig(out)\n         assert_equal(len(w), 0)\n \n "
            },
            {
                "sha": "00e89629e2688444f3dc646aa948318be6bccd50",
                "filename": "lib/matplotlib/transforms.py",
                "status": "modified",
                "additions": 2,
                "deletions": 2,
                "changes": 4,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Ftransforms.py",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Ftransforms.py",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/lib%2Fmatplotlib%2Ftransforms.py?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787",
                "patch": "@@ -662,7 +662,7 @@ def count_overlaps(self, bboxes):\n \n         bboxes is a sequence of :class:`BboxBase` objects\n         \"\"\"\n-        return count_bboxes_overlapping_bbox(self, bboxes)\n+        return count_bboxes_overlapping_bbox(self, [np.array(x) for x in bboxes])\n \n     def expanded(self, sw, sh):\n         \"\"\"\n@@ -1668,7 +1668,7 @@ def transform_affine(self, points):\n \n     def transform_point(self, point):\n         mtx = self.get_matrix()\n-        return affine_transform(point, mtx)\n+        return affine_transform([point], mtx)[0]\n     transform_point.__doc__ = AffineBase.transform_point.__doc__\n \n     if DEBUG:"
            },
            {
                "sha": "94dc2eb3e97502097037f29786ad4c8b306f8449",
                "filename": "lib/matplotlib/tri/_tri.cpp",
                "status": "modified",
                "additions": 25,
                "deletions": 25,
                "changes": 50,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Ftri%2F_tri.cpp",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmatplotlib%2Ftri%2F_tri.cpp",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/lib%2Fmatplotlib%2Ftri%2F_tri.cpp?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787",
                "patch": "@@ -234,13 +234,13 @@ Triangulation::Triangulation(PyArrayObject* x,\n       _edges(edges),\n       _neighbors(neighbors)\n {\n-    _VERBOSE(\"Triangulation::Triangulation\");\n+\n     correct_triangles();\n }\n \n Triangulation::~Triangulation()\n {\n-    _VERBOSE(\"Triangulation::~Triangulation\");\n+\n     Py_XDECREF(_x);\n     Py_XDECREF(_y);\n     Py_XDECREF(_triangles);\n@@ -251,7 +251,7 @@ Triangulation::~Triangulation()\n \n void Triangulation::calculate_boundaries()\n {\n-    _VERBOSE(\"Triangulation::calculate_boundaries\");\n+\n \n     get_neighbors();  // Ensure _neighbors has been created.\n \n@@ -309,7 +309,7 @@ void Triangulation::calculate_boundaries()\n \n void Triangulation::calculate_edges()\n {\n-    _VERBOSE(\"Triangulation::calculate_edges\");\n+\n     Py_XDECREF(_edges);\n \n     // Create set of all edges, storing them with start point index less than\n@@ -338,7 +338,7 @@ void Triangulation::calculate_edges()\n \n void Triangulation::calculate_neighbors()\n {\n-    _VERBOSE(\"Triangulation::calculate_neighbors\");\n+\n     Py_XDECREF(_neighbors);\n \n     // Create _neighbors array with shape (ntri,3) and initialise all to -1.\n@@ -382,7 +382,7 @@ void Triangulation::calculate_neighbors()\n \n Py::Object Triangulation::calculate_plane_coefficients(const Py::Tuple &args)\n {\n-    _VERBOSE(\"Triangulation::calculate_plane_coefficients\");\n+\n     args.verify_length(1);\n \n     PyArrayObject* z = (PyArrayObject*)PyArray_ContiguousFromObject(\n@@ -485,7 +485,7 @@ void Triangulation::correct_triangles()\n \n const Triangulation::Boundaries& Triangulation::get_boundaries() const\n {\n-    _VERBOSE(\"Triangulation::get_boundaries\");\n+\n     if (_boundaries.empty())\n         const_cast<Triangulation*>(this)->calculate_boundaries();\n     return _boundaries;\n@@ -517,7 +517,7 @@ int Triangulation::get_edge_in_triangle(int tri, int point) const\n \n Py::Object Triangulation::get_edges()\n {\n-    _VERBOSE(\"Triangulation::get_edges\");\n+\n     if (_edges == 0)\n         calculate_edges();\n     return Py::asObject(Py::new_reference_to((PyObject*)_edges));\n@@ -544,7 +544,7 @@ TriEdge Triangulation::get_neighbor_edge(int tri, int edge) const\n \n Py::Object Triangulation::get_neighbors()\n {\n-    _VERBOSE(\"Triangulation::get_neighbors\");\n+\n     if (_neighbors == 0) calculate_neighbors();\n     return Py::asObject(Py::new_reference_to((PyObject*)_neighbors));\n }\n@@ -592,7 +592,7 @@ const int* Triangulation::get_triangles_ptr() const\n \n void Triangulation::init_type()\n {\n-    _VERBOSE(\"Triangulation::init_type\");\n+\n \n     behaviors().name(\"Triangulation\");\n     behaviors().doc(\"Triangulation\");\n@@ -616,7 +616,7 @@ bool Triangulation::is_masked(int tri) const\n \n Py::Object Triangulation::set_mask(const Py::Tuple &args)\n {\n-    _VERBOSE(\"Triangulation::set_mask\");\n+\n     args.verify_length(1);\n \n     Py_XDECREF(_mask);\n@@ -667,12 +667,12 @@ TriContourGenerator::TriContourGenerator(Py::Object triangulation,\n       _boundaries_visited(0),\n       _boundaries_used(0)\n {\n-    _VERBOSE(\"TriContourGenerator::TriContourGenerator\");\n+\n }\n \n TriContourGenerator::~TriContourGenerator()\n {\n-    _VERBOSE(\"TriContourGenerator::~TriContourGenerator\");\n+\n     Py_XDECREF(_z);\n }\n \n@@ -761,7 +761,7 @@ Py::Object TriContourGenerator::contour_to_segs_and_kinds(const Contour& contour\n \n Py::Object TriContourGenerator::create_contour(const Py::Tuple &args)\n {\n-    _VERBOSE(\"TriContourGenerator::create_contour\");\n+\n     args.verify_length(1);\n \n     double level = (Py::Float)args[0];\n@@ -777,7 +777,7 @@ Py::Object TriContourGenerator::create_contour(const Py::Tuple &args)\n \n Py::Object TriContourGenerator::create_filled_contour(const Py::Tuple &args)\n {\n-    _VERBOSE(\"TriContourGenerator::create_filled_contour\");\n+\n     args.verify_length(2);\n \n     double lower_level = (Py::Float)args[0];\n@@ -1089,7 +1089,7 @@ const double& TriContourGenerator::get_z(int point) const\n \n void TriContourGenerator::init_type()\n {\n-    _VERBOSE(\"TriContourGenerator::init_type\");\n+\n \n     behaviors().name(\"TriContourGenerator\");\n     behaviors().doc(\"TriContourGenerator\");\n@@ -1124,12 +1124,12 @@ TrapezoidMapTriFinder::TrapezoidMapTriFinder(Py::Object triangulation)\n       _points(0),\n       _tree(0)\n {\n-    _VERBOSE(\"TrapezoidMapTriFinder::TrapezoidMapTriFinder\");\n+\n }\n \n TrapezoidMapTriFinder::~TrapezoidMapTriFinder()\n {\n-    _VERBOSE(\"TrapezoidMapTriFinder::~TrapezoidMapTriFinder\");\n+\n     clear();\n }\n \n@@ -1452,7 +1452,7 @@ TrapezoidMapTriFinder::find_trapezoids_intersecting_edge(\n Py::Object\n TrapezoidMapTriFinder::get_tree_stats()\n {\n-    _VERBOSE(\"TrapezoidMapTriFinder::get_tree_stats\");\n+\n \n     NodeStats stats;\n     _tree->get_stats(0, stats);\n@@ -1477,7 +1477,7 @@ TrapezoidMapTriFinder::get_triangulation() const\n void\n TrapezoidMapTriFinder::init_type()\n {\n-    _VERBOSE(\"TrapezoidMapTriFinder::init_type\");\n+\n \n     behaviors().name(\"TrapezoidMapTriFinder\");\n     behaviors().doc(\"TrapezoidMapTriFinder\");\n@@ -1499,7 +1499,7 @@ TrapezoidMapTriFinder::init_type()\n Py::Object\n TrapezoidMapTriFinder::initialize()\n {\n-    _VERBOSE(\"TrapezoidMapTriFinder::initialize\");\n+\n \n     clear();\n     const Triangulation& triang = get_triangulation();\n@@ -1594,7 +1594,7 @@ TrapezoidMapTriFinder::initialize()\n Py::Object\n TrapezoidMapTriFinder::print_tree()\n {\n-    _VERBOSE(\"TrapezoidMapTriFinder::print_tree\");\n+\n \n     assert(_tree != 0 && \"Null Node tree\");\n     _tree->print();\n@@ -2229,7 +2229,7 @@ TriModule::TriModule()\n \n Py::Object TriModule::new_triangulation(const Py::Tuple &args)\n {\n-    _VERBOSE(\"TriModule::new_triangulation\");\n+\n     args.verify_length(6);\n \n     // x and y.\n@@ -2310,7 +2310,7 @@ Py::Object TriModule::new_triangulation(const Py::Tuple &args)\n \n Py::Object TriModule::new_tricontourgenerator(const Py::Tuple &args)\n {\n-    _VERBOSE(\"TriModule::new_tricontourgenerator\");\n+\n     args.verify_length(2);\n \n     Py::Object tri = args[0];\n@@ -2332,7 +2332,7 @@ Py::Object TriModule::new_tricontourgenerator(const Py::Tuple &args)\n Py::Object\n TriModule::new_TrapezoidMapTriFinder(const Py::Tuple &args)\n {\n-    _VERBOSE(\"TriModule::new_TrapezoidMapTriFinder\");\n+\n     args.verify_length(1);\n \n     Py::Object triangulation = args[0];"
            },
            {
                "sha": "12516fc715ff9f72e5c75193a19dcbb6037639d3",
                "filename": "lib/mpl_toolkits/mplot3d/axis3d.py",
                "status": "modified",
                "additions": 2,
                "deletions": 2,
                "changes": 4,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmpl_toolkits%2Fmplot3d%2Faxis3d.py",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/lib%2Fmpl_toolkits%2Fmplot3d%2Faxis3d.py",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/lib%2Fmpl_toolkits%2Fmplot3d%2Faxis3d.py?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787",
                "patch": "@@ -260,8 +260,8 @@ def draw(self, renderer):\n         # edge points of the plane to display coordinates and calculate\n         # an angle from that.\n         # TODO: Maybe Text objects should handle this themselves?\n-        dx, dy = (self.axes.transAxes.transform(peparray[0:2, 1]) -\n-                  self.axes.transAxes.transform(peparray[0:2, 0]))\n+        dx, dy = (self.axes.transAxes.transform([peparray[0:2, 1]]) -\n+                  self.axes.transAxes.transform([peparray[0:2, 0]]))[0]\n \n         lxyz = 0.5*(edgep1 + edgep2)\n "
            },
            {
                "sha": "27a8b8bf5ec3c48d87750d0d5c2888f3398b70f6",
                "filename": "setupext.py",
                "status": "modified",
                "additions": 14,
                "deletions": 19,
                "changes": 33,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/setupext.py",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/setupext.py",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/setupext.py?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787",
                "patch": "@@ -1005,12 +1005,12 @@ class FT2Font(SetupPackage):\n     def get_extension(self):\n         sources = [\n             'src/ft2font.cpp',\n+            'src/ft2font_wrapper.cpp',\n             'src/mplutils.cpp'\n             ]\n         ext = make_extension('matplotlib.ft2font', sources)\n         FreeType().add_flags(ext)\n         Numpy().add_flags(ext)\n-        CXX().add_flags(ext)\n         return ext\n \n \n@@ -1039,14 +1039,14 @@ def check(self):\n \n     def get_extension(self):\n         sources = [\n-            'src/_png.cpp', 'src/mplutils.cpp'\n+            'src/_png.cpp',\n+            'src/mplutils.cpp'\n             ]\n         ext = make_extension('matplotlib._png', sources)\n         pkg_config.setup_extension(\n             ext, 'libpng', default_libraries=['png', 'z'],\n             alt_exec='libpng-config --ldflags')\n         Numpy().add_flags(ext)\n-        CXX().add_flags(ext)\n         return ext\n \n \n@@ -1092,7 +1092,6 @@ def get_extension(self):\n             ]\n         ext = make_extension('matplotlib.ttconv', sources)\n         Numpy().add_flags(ext)\n-        CXX().add_flags(ext)\n         ext.include_dirs.append('extern')\n         return ext\n \n@@ -1102,15 +1101,13 @@ class Path(SetupPackage):\n \n     def get_extension(self):\n         sources = [\n-            'src/_path.cpp',\n-            'src/path_cleanup.cpp',\n-            'src/agg_py_transforms.cpp'\n+            'src/py_converters.cpp',\n+            'src/_path_wrapper.cpp'\n             ]\n \n         ext = make_extension('matplotlib._path', sources)\n         Numpy().add_flags(ext)\n         LibAgg().add_flags(ext)\n-        CXX().add_flags(ext)\n         return ext\n \n \n@@ -1119,12 +1116,13 @@ class Image(SetupPackage):\n \n     def get_extension(self):\n         sources = [\n-            'src/_image.cpp', 'src/mplutils.cpp'\n+            'src/_image.cpp',\n+            'src/mplutils.cpp',\n+            'src/_image_wrapper.cpp'\n             ]\n         ext = make_extension('matplotlib._image', sources)\n         Numpy().add_flags(ext)\n         LibAgg().add_flags(ext)\n-        CXX().add_flags(ext)\n         return ext\n \n \n@@ -1317,14 +1315,14 @@ class BackendAgg(OptionalBackendPackage):\n     def get_extension(self):\n         sources = [\n             \"src/mplutils.cpp\",\n-            \"src/agg_py_transforms.cpp\",\n-            \"src/_backend_agg.cpp\"\n+            \"src/py_converters.cpp\",\n+            \"src/_backend_agg.cpp\",\n+            \"src/_backend_agg_wrapper.cpp\"\n             ]\n         ext = make_extension('matplotlib.backends._backend_agg', sources)\n         Numpy().add_flags(ext)\n         LibAgg().add_flags(ext)\n         FreeType().add_flags(ext)\n-        CXX().add_flags(ext)\n         return ext\n \n \n@@ -1363,15 +1361,14 @@ def check_requirements(self):\n \n     def get_extension(self):\n         sources = [\n-            'src/agg_py_transforms.cpp',\n+            'src/py_converters.cpp',\n             'src/_tkagg.cpp'\n             ]\n \n         ext = make_extension('matplotlib.backends._tkagg', sources)\n         self.add_flags(ext)\n         Numpy().add_flags(ext)\n         LibAgg().add_flags(ext)\n-        CXX().add_flags(ext)\n         return ext\n \n     def query_tcltk(self):\n@@ -1740,14 +1737,13 @@ def get_package_data(self):\n \n     def get_extension(self):\n         sources = [\n-            'src/agg_py_transforms.cpp',\n+            'src/py_converters.cpp',\n             'src/_gtkagg.cpp',\n             'src/mplutils.cpp'\n             ]\n         ext = make_extension('matplotlib.backends._gtkagg', sources)\n         self.add_flags(ext)\n         LibAgg().add_flags(ext)\n-        CXX().add_flags(ext)\n         Numpy().add_flags(ext)\n         return ext\n \n@@ -1919,14 +1915,13 @@ def check_requirements(self):\n     def get_extension(self):\n         sources = [\n             'src/_macosx.m',\n-            'src/agg_py_transforms.cpp',\n+            'src/py_converters.cpp',\n             'src/path_cleanup.cpp'\n             ]\n \n         ext = make_extension('matplotlib.backends._macosx', sources)\n         Numpy().add_flags(ext)\n         LibAgg().add_flags(ext)\n-        CXX().add_flags(ext)\n         ext.extra_link_args.extend(['-framework', 'Cocoa'])\n         return ext\n "
            },
            {
                "sha": "2590309ec678537eb4d441691641afb06d7c7382",
                "filename": "src/_backend_agg.cpp",
                "status": "modified",
                "additions": 116,
                "deletions": 2519,
                "changes": 2635,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_backend_agg.cpp",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_backend_agg.cpp",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/src%2F_backend_agg.cpp?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787",
                "patch": "@@ -3,428 +3,57 @@\n /* A rewrite of _backend_agg using PyCXX to handle ref counting, etc..\n  */\n \n-/* Python API mandates Python.h is included *first* */\n-#include \"Python.h\"\n+#define NO_IMPORT_ARRAY\n \n-/* TODO: Remove this dependency */\n-#include \"ft2font.h\"\n-#include \"_image.h\"\n #include \"_backend_agg.h\"\n #include \"mplutils.h\"\n-\n-#include <iostream>\n-#include <fstream>\n-#include <cmath>\n-#include <cstdio>\n-#include <stdexcept>\n-#include <time.h>\n-#include <algorithm>\n-\n-#include \"agg_conv_curve.h\"\n-#include \"agg_conv_transform.h\"\n-#include \"agg_image_accessors.h\"\n-#include \"agg_renderer_primitives.h\"\n-#include \"agg_scanline_storage_aa.h\"\n-#include \"agg_scanline_storage_bin.h\"\n-#include \"agg_span_allocator.h\"\n-#include \"agg_span_converter.h\"\n-#include \"agg_span_image_filter_gray.h\"\n-#include \"agg_span_image_filter_rgba.h\"\n-#include \"agg_span_interpolator_linear.h\"\n-#include \"agg_span_pattern_rgba.h\"\n-#include \"agg_span_gouraud_rgba.h\"\n-#include \"agg_conv_shorten_path.h\"\n-#include \"util/agg_color_conv_rgb8.h\"\n-\n #include \"MPL_isnan.h\"\n \n-#include \"numpy/arrayobject.h\"\n-#include \"agg_py_transforms.h\"\n-\n-#include \"file_compat.h\"\n-\n-#ifndef M_PI\n-#define M_PI       3.14159265358979323846\n-#endif\n-#ifndef M_PI_4\n-#define M_PI_4     0.785398163397448309616\n-#endif\n-#ifndef M_PI_2\n-#define M_PI_2     1.57079632679489661923\n-#endif\n-\n-\n-/*\n- Convert dashes from the Python representation as nested sequences to\n- the C++ representation as a std::vector<std::pair<double, double> >\n- (GCAgg::dash_t) */\n-void\n-convert_dashes(const Py::Tuple& dashes, double dpi,\n-               GCAgg::dash_t& dashes_out, double& dashOffset_out)\n-{\n-    if (dashes.length() != 2)\n-    {\n-        throw Py::ValueError(\n-            Printf(\"Dash descriptor must be a length 2 tuple; found %d\",\n-                   dashes.length()).str()\n-        );\n-    }\n-\n-    dashes_out.clear();\n-    dashOffset_out = 0.0;\n-    if (dashes[0].ptr() == Py_None)\n-    {\n-        return;\n-    }\n-\n-    dashOffset_out = double(Py::Float(dashes[0])) * dpi / 72.0;\n-\n-    Py::SeqBase<Py::Object> dashSeq = dashes[1];\n-\n-    size_t Ndash = dashSeq.length();\n-    if (Ndash % 2 != 0)\n-    {\n-        throw Py::ValueError(\n-            Printf(\"Dash sequence must be an even length sequence; found %d\", Ndash).str()\n-        );\n-    }\n-\n-    dashes_out.clear();\n-    dashes_out.reserve(Ndash / 2);\n-\n-    double val0, val1;\n-    for (size_t i = 0; i < Ndash; i += 2)\n-    {\n-        val0 = double(Py::Float(dashSeq[i])) * dpi / 72.0;\n-        val1 = double(Py::Float(dashSeq[i+1])) * dpi / 72.0;\n-        dashes_out.push_back(std::make_pair(val0, val1));\n-    }\n-}\n-\n-\n-Py::Object\n-BufferRegion::to_string(const Py::Tuple &args)\n-{\n-    // owned=true to prevent memory leak\n-    #if PY3K\n-    return Py::Bytes\n-    #else\n-    return Py::String\n-    #endif\n-        (PyBytes_FromStringAndSize((const char*)data, height*stride), true);\n-}\n-\n-\n-Py::Object\n-BufferRegion::set_x(const Py::Tuple &args)\n-{\n-    args.verify_length(1);\n-    size_t x = (long) Py::Int(args[0]);\n-    rect.x1 = x;\n-    return Py::Object();\n-}\n-\n-\n-Py::Object\n-BufferRegion::set_y(const Py::Tuple &args)\n-{\n-    args.verify_length(1);\n-    size_t y = (long)Py::Int(args[0]);\n-    rect.y1 = y;\n-    return Py::Object();\n-}\n-\n-\n-Py::Object\n-BufferRegion::get_extents(const Py::Tuple &args)\n-{\n-    args.verify_length(0);\n-\n-    Py::Tuple extents(4);\n-    extents[0] = Py::Int(rect.x1);\n-    extents[1] = Py::Int(rect.y1);\n-    extents[2] = Py::Int(rect.x2);\n-    extents[3] = Py::Int(rect.y2);\n-\n-    return extents;\n-}\n-\n-\n-Py::Object\n-BufferRegion::to_string_argb(const Py::Tuple &args)\n+void BufferRegion::to_string_argb(uint8_t *buf)\n {\n-    // owned=true to prevent memory leak\n-    Py_ssize_t length;\n-    unsigned char* pix;\n-    unsigned char* begin;\n+    unsigned char *pix;\n     unsigned char tmp;\n     size_t i, j;\n \n-    PyObject* str = PyBytes_FromStringAndSize((const char*)data, height * stride);\n-    if (PyBytes_AsStringAndSize(str, (char**)&begin, &length))\n-    {\n-        throw Py::TypeError(\"Could not create memory for blit\");\n-    }\n+    memcpy(buf, data, height * stride);\n \n-    for (i = 0; i < (size_t)height; ++i)\n-    {\n-        pix = begin + i * stride;\n-        for (j = 0; j < (size_t)width; ++j)\n-        {\n+    for (i = 0; i < (size_t)height; ++i) {\n+        pix = buf + i * stride;\n+        for (j = 0; j < (size_t)width; ++j) {\n             // Convert rgba to argb\n             tmp = pix[2];\n             pix[2] = pix[0];\n             pix[0] = tmp;\n             pix += 4;\n         }\n     }\n-\n-    #if PY3K\n-    return Py::Bytes\n-    #else\n-    return Py::String\n-    #endif\n-        (str, true);\n-}\n-\n-\n-GCAgg::GCAgg(const Py::Object &gc, double dpi) :\n-        dpi(dpi), isaa(true), dashOffset(0.0)\n-{\n-    _VERBOSE(\"GCAgg::GCAgg\");\n-    linewidth = points_to_pixels(gc.getAttr(\"_linewidth\")) ;\n-    alpha = Py::Float(gc.getAttr(\"_alpha\"));\n-    forced_alpha = Py::Boolean(gc.getAttr(\"_forced_alpha\"));\n-    color = get_color(gc);\n-    _set_antialiased(gc);\n-    _set_linecap(gc);\n-    _set_joinstyle(gc);\n-    _set_dashes(gc);\n-    _set_clip_rectangle(gc);\n-    _set_clip_path(gc);\n-    _set_snap(gc);\n-    _set_hatch_path(gc);\n-    _set_sketch_params(gc);\n-}\n-\n-\n-void\n-GCAgg::_set_antialiased(const Py::Object& gc)\n-{\n-    _VERBOSE(\"GCAgg::antialiased\");\n-    isaa = Py::Boolean(gc.getAttr(\"_antialiased\"));\n-}\n-\n-\n-agg::rgba\n-GCAgg::get_color(const Py::Object& gc)\n-{\n-    _VERBOSE(\"GCAgg::get_color\");\n-    Py::Tuple rgb = Py::Tuple(gc.getAttr(\"_rgb\"));\n-\n-    double r = Py::Float(rgb[0]);\n-    double g = Py::Float(rgb[1]);\n-    double b = Py::Float(rgb[2]);\n-    double a = Py::Float(rgb[3]);\n-    return agg::rgba(r, g, b, a);\n-}\n-\n-\n-double\n-GCAgg::points_to_pixels(const Py::Object& points)\n-{\n-    _VERBOSE(\"GCAgg::points_to_pixels\");\n-    double p = Py::Float(points) ;\n-    return p * dpi / 72.0;\n-}\n-\n-\n-void\n-GCAgg::_set_linecap(const Py::Object& gc)\n-{\n-    _VERBOSE(\"GCAgg::_set_linecap\");\n-\n-    std::string capstyle = Py::String(gc.getAttr(\"_capstyle\")).encode(\"utf-8\");\n-\n-    if (capstyle == \"butt\")\n-    {\n-        cap = agg::butt_cap;\n-    }\n-    else if (capstyle == \"round\")\n-    {\n-        cap = agg::round_cap;\n-    }\n-    else if (capstyle == \"projecting\")\n-    {\n-        cap = agg::square_cap;\n-    }\n-    else\n-    {\n-        throw Py::ValueError(Printf(\"GC _capstyle attribute must be one of butt, round, projecting; found %s\", capstyle.c_str()).str());\n-    }\n-}\n-\n-\n-void\n-GCAgg::_set_joinstyle(const Py::Object& gc)\n-{\n-    _VERBOSE(\"GCAgg::_set_joinstyle\");\n-\n-    std::string joinstyle = Py::String(gc.getAttr(\"_joinstyle\")).encode(\"utf-8\");\n-\n-    if (joinstyle == \"miter\")\n-    {\n-        join = agg::miter_join_revert;\n-    }\n-    else if (joinstyle == \"round\")\n-    {\n-        join = agg::round_join;\n-    }\n-    else if (joinstyle == \"bevel\")\n-    {\n-        join = agg::bevel_join;\n-    }\n-    else\n-    {\n-        throw Py::ValueError(Printf(\"GC _joinstyle attribute must be one of butt, round, projecting; found %s\", joinstyle.c_str()).str());\n-    }\n-}\n-\n-\n-void\n-GCAgg::_set_dashes(const Py::Object& gc)\n-{\n-    //return the dashOffset, dashes sequence tuple.\n-    _VERBOSE(\"GCAgg::_set_dashes\");\n-\n-    Py::Object dash_obj(gc.getAttr(\"_dashes\"));\n-    if (dash_obj.ptr() == Py_None)\n-    {\n-        dashes.clear();\n-        return;\n-    }\n-\n-    convert_dashes(dash_obj, dpi, dashes, dashOffset);\n-}\n-\n-\n-void\n-GCAgg::_set_clip_rectangle(const Py::Object& gc)\n-{\n-    //set the clip rectangle from the gc\n-\n-    _VERBOSE(\"GCAgg::_set_clip_rectangle\");\n-\n-    Py::Object o(gc.getAttr(\"_cliprect\"));\n-    cliprect = o;\n-}\n-\n-\n-void\n-GCAgg::_set_clip_path(const Py::Object& gc)\n-{\n-    //set the clip path from the gc\n-\n-    _VERBOSE(\"GCAgg::_set_clip_path\");\n-\n-    Py::Object method_obj = gc.getAttr(\"get_clip_path\");\n-    Py::Callable method(method_obj);\n-    Py::Tuple path_and_transform = method.apply(Py::Tuple());\n-    if (path_and_transform[0].ptr() != Py_None)\n-    {\n-        clippath = path_and_transform[0];\n-        clippath_trans = py_to_agg_transformation_matrix(path_and_transform[1].ptr());\n-    }\n-}\n-\n-\n-void\n-GCAgg::_set_snap(const Py::Object& gc)\n-{\n-    //set the snap setting\n-\n-    _VERBOSE(\"GCAgg::_set_snap\");\n-\n-    Py::Object method_obj = gc.getAttr(\"get_snap\");\n-    Py::Callable method(method_obj);\n-    Py::Object py_snap = method.apply(Py::Tuple());\n-    if (py_snap.isNone())\n-    {\n-        snap_mode = SNAP_AUTO;\n-    }\n-    else if (py_snap.isTrue())\n-    {\n-        snap_mode = SNAP_TRUE;\n-    }\n-    else\n-    {\n-        snap_mode = SNAP_FALSE;\n-    }\n-}\n-\n-\n-void\n-GCAgg::_set_hatch_path(const Py::Object& gc)\n-{\n-    _VERBOSE(\"GCAgg::_set_hatch_path\");\n-\n-    Py::Object method_obj = gc.getAttr(\"get_hatch_path\");\n-    Py::Callable method(method_obj);\n-    hatchpath = method.apply(Py::Tuple());\n-    if (hatchpath.ptr() == NULL)\n-        throw Py::Exception();\n-}\n-\n-void\n-GCAgg::_set_sketch_params(const Py::Object& gc)\n-{\n-    _VERBOSE(\"GCAgg::_get_sketch_params\");\n-\n-    Py::Object method_obj = gc.getAttr(\"get_sketch_params\");\n-    Py::Callable method(method_obj);\n-    Py::Object result = method.apply(Py::Tuple());\n-    if (result.ptr() == Py_None) {\n-        sketch_scale = 0.0;\n-    } else {\n-        Py::Tuple sketch_params(result);\n-        sketch_scale = Py::Float(sketch_params[0]);\n-        sketch_length = Py::Float(sketch_params[1]);\n-        sketch_randomness = Py::Float(sketch_params[2]);\n-    }\n }\n \n-\n-const size_t\n-RendererAgg::PIXELS_PER_INCH(96);\n-\n-\n-RendererAgg::RendererAgg(unsigned int width, unsigned int height, double dpi,\n-                         int debug) :\n-    width(width),\n-    height(height),\n-    dpi(dpi),\n-    NUMBYTES(width*height*4),\n-    pixBuffer(NULL),\n-    renderingBuffer(),\n-    alphaBuffer(NULL),\n-    alphaMaskRenderingBuffer(),\n-    alphaMask(alphaMaskRenderingBuffer),\n-    pixfmtAlphaMask(alphaMaskRenderingBuffer),\n-    rendererBaseAlphaMask(),\n-    rendererAlphaMask(),\n-    scanlineAlphaMask(),\n-    slineP8(),\n-    slineBin(),\n-    pixFmt(),\n-    rendererBase(),\n-    rendererAA(),\n-    rendererBin(),\n-    theRasterizer(),\n-    debug(debug),\n-    _fill_color(agg::rgba(1, 1, 1, 0))\n-{\n-    _VERBOSE(\"RendererAgg::RendererAgg\");\n-    unsigned stride(width*4);\n+RendererAgg::RendererAgg(unsigned int width, unsigned int height, double dpi)\n+    : width(width),\n+      height(height),\n+      dpi(dpi),\n+      NUMBYTES(width * height * 4),\n+      pixBuffer(NULL),\n+      renderingBuffer(),\n+      alphaBuffer(NULL),\n+      alphaMaskRenderingBuffer(),\n+      alphaMask(alphaMaskRenderingBuffer),\n+      pixfmtAlphaMask(alphaMaskRenderingBuffer),\n+      rendererBaseAlphaMask(),\n+      rendererAlphaMask(),\n+      scanlineAlphaMask(),\n+      slineP8(),\n+      slineBin(),\n+      pixFmt(),\n+      rendererBase(),\n+      rendererAA(),\n+      rendererBin(),\n+      theRasterizer(),\n+      lastclippath(NULL),\n+      _fill_color(agg::rgba(1, 1, 1, 0))\n+{\n+    unsigned stride(width * 4);\n \n     pixBuffer = new agg::int8u[NUMBYTES];\n     renderingBuffer.attach(pixBuffer, width, height, stride);\n@@ -433,2201 +62,169 @@ RendererAgg::RendererAgg(unsigned int width, unsigned int height, double dpi,\n     rendererBase.clear(_fill_color);\n     rendererAA.attach(rendererBase);\n     rendererBin.attach(rendererBase);\n-    hatchRenderingBuffer.attach(hatchBuffer, HATCH_SIZE, HATCH_SIZE,\n-                                HATCH_SIZE*4);\n+    hatchRenderingBuffer.attach(hatchBuffer, HATCH_SIZE, HATCH_SIZE, HATCH_SIZE * 4);\n }\n \n+RendererAgg::~RendererAgg()\n+{\n+    delete[] alphaBuffer;\n+    delete[] pixBuffer;\n+}\n \n-void\n-RendererAgg::create_alpha_buffers()\n+void RendererAgg::create_alpha_buffers()\n {\n-    if (!alphaBuffer)\n-    {\n+    if (!alphaBuffer) {\n         alphaBuffer = new agg::int8u[width * height];\n         alphaMaskRenderingBuffer.attach(alphaBuffer, width, height, width);\n         rendererBaseAlphaMask.attach(pixfmtAlphaMask);\n         rendererAlphaMask.attach(rendererBaseAlphaMask);\n     }\n }\n \n-\n-template<class R>\n-void\n-RendererAgg::set_clipbox(const Py::Object& cliprect, R& rasterizer)\n-{\n-    //set the clip rectangle from the gc\n-\n-    _VERBOSE(\"RendererAgg::set_clipbox\");\n-\n-    double l, b, r, t;\n-    if (py_convert_bbox(cliprect.ptr(), l, b, r, t))\n-    {\n-        rasterizer.clip_box(std::max(int(floor(l + 0.5)), 0),\n-                            std::max(int(floor(height - b + 0.5)), 0),\n-                            std::min(int(floor(r + 0.5)), int(width)),\n-                            std::min(int(floor(height - t + 0.5)), int(height)));\n-    }\n-    else\n-    {\n-        rasterizer.clip_box(0, 0, width, height);\n-    }\n-\n-    _VERBOSE(\"RendererAgg::set_clipbox done\");\n-}\n-\n-\n-std::pair<bool, agg::rgba>\n-RendererAgg::_get_rgba_face(const Py::Object& rgbFace, double alpha, bool forced_alpha)\n-{\n-    _VERBOSE(\"RendererAgg::_get_rgba_face\");\n-    std::pair<bool, agg::rgba> face;\n-\n-    if (rgbFace.ptr() == Py_None)\n-    {\n-        face.first = false;\n-    }\n-    else\n-    {\n-        face.first = true;\n-        Py::Tuple rgb = Py::Tuple(rgbFace);\n-        if (forced_alpha || rgb.length() < 4)\n-        {\n-            face.second = rgb_to_color(rgb, alpha);\n-        }\n-        else\n-        {\n-            face.second = rgb_to_color(rgb, Py::Float(rgb[3]));\n-        }\n-    }\n-    return face;\n-}\n-\n-\n-Py::Object\n-RendererAgg::copy_from_bbox(const Py::Tuple& args)\n+BufferRegion *RendererAgg::copy_from_bbox(agg::rect_d in_rect)\n {\n-    //copy region in bbox to buffer and return swig/agg buffer object\n-    args.verify_length(1);\n-\n-    Py::Object box_obj = args[0];\n-    double l, b, r, t;\n-    if (!py_convert_bbox(box_obj.ptr(), l, b, r, t))\n-    {\n-        throw Py::TypeError(\"Invalid bbox provided to copy_from_bbox\");\n-    }\n-\n-    agg::rect_i rect((int)l, height - (int)t, (int)r, height - (int)b);\n+    agg::rect_i rect(\n+        (int)in_rect.x1, height - (int)in_rect.y2, (int)in_rect.x2, height - (int)in_rect.y1);\n \n-    BufferRegion* reg = NULL;\n-    try\n-    {\n-        reg = new BufferRegion(rect, true);\n-    }\n-    catch (...)\n-    {\n-        throw Py::MemoryError(\n-            \"RendererAgg::copy_from_bbox could not allocate memory for buffer\");\n-    }\n+    BufferRegion *reg = NULL;\n+    reg = new BufferRegion(rect);\n \n-    if (!reg)\n-    {\n-        throw Py::MemoryError(\n-            \"RendererAgg::copy_from_bbox could not allocate memory for buffer\");\n-    }\n+    agg::rendering_buffer rbuf;\n+    rbuf.attach(reg->get_data(), reg->get_width(), reg->get_height(), reg->get_stride());\n \n-    try\n-    {\n-        agg::rendering_buffer rbuf;\n-        rbuf.attach(reg->data, reg->width, reg->height, reg->stride);\n+    pixfmt pf(rbuf);\n+    renderer_base rb(pf);\n+    rb.copy_from(renderingBuffer, &rect, -rect.x1, -rect.y1);\n \n-        pixfmt pf(rbuf);\n-        renderer_base rb(pf);\n-        rb.copy_from(renderingBuffer, &rect, -rect.x1, -rect.y1);\n-    }\n-    catch (...)\n-    {\n-        delete reg;\n-        throw Py::RuntimeError(\"An unknown error occurred in copy_from_bbox\");\n-    }\n-    return Py::asObject(reg);\n+    return reg;\n }\n \n-\n-Py::Object\n-RendererAgg::restore_region(const Py::Tuple& args)\n+void RendererAgg::restore_region(BufferRegion &region)\n {\n-    //copy BufferRegion to buffer\n-    args.verify_length(1);\n-    BufferRegion* region  = static_cast<BufferRegion*>(args[0].ptr());\n-\n-    if (region->data == NULL)\n-    {\n-        throw Py::ValueError(\"Cannot restore_region from NULL data\");\n+    if (region.get_data() == NULL) {\n+        throw \"Cannot restore_region from NULL data\";\n     }\n \n     agg::rendering_buffer rbuf;\n-    rbuf.attach(region->data,\n-                region->width,\n-                region->height,\n-                region->stride);\n+    rbuf.attach(region.get_data(), region.get_width(), region.get_height(), region.get_stride());\n \n-    rendererBase.copy_from(rbuf, 0, region->rect.x1, region->rect.y1);\n-\n-    return Py::Object();\n+    rendererBase.copy_from(rbuf, 0, region.get_rect().x1, region.get_rect().y1);\n }\n \n-\n // Restore the part of the saved region with offsets\n-Py::Object\n-RendererAgg::restore_region2(const Py::Tuple& args)\n+void\n+RendererAgg::restore_region(BufferRegion &region, int x, int y, int xx1, int yy1, int xx2, int yy2)\n {\n-    //copy BufferRegion to buffer\n-    args.verify_length(7);\n-\n-    int x(0), y(0), xx1(0), yy1(0), xx2(0), yy2(0);\n-    try\n-    {\n-        xx1 = Py::Int(args[1]);\n-        yy1 = Py::Int(args[2]);\n-        xx2 = Py::Int(args[3]);\n-        yy2 = Py::Int(args[4]);\n-        x = Py::Int(args[5]);\n-        y = Py::Int(args[6]);\n+    if (region.get_data() == NULL) {\n+        throw \"Cannot restore_region from NULL data\";\n     }\n-    catch (Py::TypeError)\n-    {\n-        throw Py::TypeError(\"Invalid input arguments to restore_region2\");\n-    }\n-\n \n-    BufferRegion* region  = static_cast<BufferRegion*>(args[0].ptr());\n+    agg::rect_i &rrect = region.get_rect();\n \n-    if (region->data == NULL)\n-    {\n-        throw Py::ValueError(\"Cannot restore_region from NULL data\");\n-    }\n-\n-    agg::rect_i rect(xx1 - region->rect.x1, (yy1 - region->rect.y1),\n-                     xx2 - region->rect.x1, (yy2 - region->rect.y1));\n+    agg::rect_i rect(xx1 - rrect.x1, (yy1 - rrect.y1), xx2 - rrect.x1, (yy2 - rrect.y1));\n \n     agg::rendering_buffer rbuf;\n-    rbuf.attach(region->data,\n-                region->width,\n-                region->height,\n-                region->stride);\n+    rbuf.attach(region.get_data(), region.get_width(), region.get_height(), region.get_stride());\n \n     rendererBase.copy_from(rbuf, &rect, x, y);\n-\n-    return Py::Object();\n }\n \n-\n-bool\n-RendererAgg::render_clippath(const Py::Object& clippath,\n-                             const agg::trans_affine& clippath_trans)\n+bool RendererAgg::render_clippath(py::PathIterator &clippath,\n+                                  const agg::trans_affine &clippath_trans)\n {\n-    typedef agg::conv_transform<PathIterator> transformed_path_t;\n+    typedef agg::conv_transform<py::PathIterator> transformed_path_t;\n     typedef agg::conv_curve<transformed_path_t> curve_t;\n \n-    bool has_clippath = (clippath.ptr() != Py_None);\n+    bool has_clippath = (clippath.total_vertices() != 0);\n \n     if (has_clippath &&\n-        (clippath.ptr() != lastclippath.ptr() ||\n-         clippath_trans != lastclippath_transform))\n-    {\n+        (clippath.get_id() != lastclippath || clippath_trans != lastclippath_transform)) {\n         create_alpha_buffers();\n         agg::trans_affine trans(clippath_trans);\n         trans *= agg::trans_affine_scaling(1.0, -1.0);\n         trans *= agg::trans_affine_translation(0.0, (double)height);\n \n-        PathIterator clippath_iter(clippath);\n         rendererBaseAlphaMask.clear(agg::gray8(0, 0));\n-        transformed_path_t transformed_clippath(clippath_iter, trans);\n+        transformed_path_t transformed_clippath(clippath, trans);\n         curve_t curved_clippath(transformed_clippath);\n-        try {\n-            theRasterizer.add_path(curved_clippath);\n-        } catch (std::overflow_error &e) {\n-            throw Py::OverflowError(e.what());\n-        }\n+        theRasterizer.add_path(curved_clippath);\n         rendererAlphaMask.color(agg::gray8(255, 255));\n         agg::render_scanlines(theRasterizer, scanlineAlphaMask, rendererAlphaMask);\n-        lastclippath = clippath;\n+        lastclippath = clippath.get_id();\n         lastclippath_transform = clippath_trans;\n     }\n \n     return has_clippath;\n }\n \n-#define MARKER_CACHE_SIZE 512\n-\n-\n-Py::Object\n-RendererAgg::draw_markers(const Py::Tuple& args)\n+void RendererAgg::tostring_rgb(uint8_t *buf)\n {\n-    typedef agg::conv_transform<PathIterator>                  transformed_path_t;\n-    typedef PathSnapper<transformed_path_t>                    snap_t;\n-    typedef agg::conv_curve<snap_t>                            curve_t;\n-    typedef agg::conv_stroke<curve_t>                          stroke_t;\n-    typedef agg::pixfmt_amask_adaptor<pixfmt, alpha_mask_type> pixfmt_amask_type;\n-    typedef agg::renderer_base<pixfmt_amask_type>              amask_ren_type;\n-    typedef agg::renderer_scanline_aa_solid<amask_ren_type>    amask_aa_renderer_type;\n-    args.verify_length(5, 6);\n-\n-    Py::Object        gc_obj          = args[0];\n-    Py::Object        marker_path_obj = args[1];\n-    agg::trans_affine marker_trans    = py_to_agg_transformation_matrix(args[2].ptr());\n-    Py::Object        path_obj        = args[3];\n-    agg::trans_affine trans           = py_to_agg_transformation_matrix(args[4].ptr());\n-    Py::Object        face_obj;\n-    if (args.size() == 6)\n-    {\n-        face_obj = args[5];\n-    }\n-\n-    GCAgg gc(gc_obj, dpi);\n-\n-    // Deal with the difference in y-axis direction\n-    marker_trans *= agg::trans_affine_scaling(1.0, -1.0);\n-    trans *= agg::trans_affine_scaling(1.0, -1.0);\n-    trans *= agg::trans_affine_translation(0.5, (double)height + 0.5);\n-\n-    PathIterator       marker_path(marker_path_obj);\n-    transformed_path_t marker_path_transformed(marker_path, marker_trans);\n-    snap_t             marker_path_snapped(marker_path_transformed,\n-                                           gc.snap_mode,\n-                                           marker_path.total_vertices(),\n-                                           gc.linewidth);\n-    curve_t            marker_path_curve(marker_path_snapped);\n-\n-    PathIterator path(path_obj);\n-    transformed_path_t path_transformed(path, trans);\n-    snap_t             path_snapped(path_transformed,\n-                                    SNAP_FALSE,\n-                                    path.total_vertices(),\n-                                    0.0);\n-    curve_t            path_curve(path_snapped);\n-    path_curve.rewind(0);\n-\n-    facepair_t face = _get_rgba_face(face_obj, gc.alpha, gc.forced_alpha);\n-\n-    //maxim's suggestions for cached scanlines\n-    agg::scanline_storage_aa8 scanlines;\n-    theRasterizer.reset();\n-    theRasterizer.reset_clipping();\n-    rendererBase.reset_clipping(true);\n-\n-    agg::int8u  staticFillCache[MARKER_CACHE_SIZE];\n-    agg::int8u  staticStrokeCache[MARKER_CACHE_SIZE];\n-    agg::int8u* fillCache = staticFillCache;\n-    agg::int8u* strokeCache = staticStrokeCache;\n-\n-    try\n-    {\n-        unsigned fillSize = 0;\n-        if (face.first)\n-        {\n-            try {\n-                theRasterizer.add_path(marker_path_curve);\n-            } catch (std::overflow_error &e) {\n-                throw Py::OverflowError(e.what());\n-            }\n-            agg::render_scanlines(theRasterizer, slineP8, scanlines);\n-            fillSize = scanlines.byte_size();\n-            if (fillSize >= MARKER_CACHE_SIZE)\n-            {\n-                fillCache = new agg::int8u[fillSize];\n-            }\n-            scanlines.serialize(fillCache);\n-        }\n+    // \"Return the rendered buffer as an RGB string\"\n \n-        stroke_t stroke(marker_path_curve);\n-        stroke.width(gc.linewidth);\n-        stroke.line_cap(gc.cap);\n-        stroke.line_join(gc.join);\n-        theRasterizer.reset();\n-        try {\n-            theRasterizer.add_path(stroke);\n-        } catch (std::overflow_error &e) {\n-            throw Py::OverflowError(e.what());\n-        }\n-        agg::render_scanlines(theRasterizer, slineP8, scanlines);\n-        unsigned strokeSize = scanlines.byte_size();\n-        if (strokeSize >= MARKER_CACHE_SIZE)\n-        {\n-            strokeCache = new agg::int8u[strokeSize];\n-        }\n-        scanlines.serialize(strokeCache);\n-\n-        theRasterizer.reset_clipping();\n-        rendererBase.reset_clipping(true);\n-        set_clipbox(gc.cliprect, rendererBase);\n-        bool has_clippath = render_clippath(gc.clippath, gc.clippath_trans);\n-\n-        double x, y;\n-\n-        agg::serialized_scanlines_adaptor_aa8 sa;\n-        agg::serialized_scanlines_adaptor_aa8::embedded_scanline sl;\n-\n-        agg::rect_d clipping_rect(\n-            -1.0 - scanlines.max_x(),\n-            -1.0 - scanlines.max_y(),\n-            1.0 + width - scanlines.min_x(),\n-            1.0 + height - scanlines.min_y());\n-\n-        if (has_clippath)\n-        {\n-            while (path_curve.vertex(&x, &y) != agg::path_cmd_stop)\n-            {\n-                if (MPL_notisfinite64(x) || MPL_notisfinite64(y))\n-                {\n-                    continue;\n-                }\n-\n-                /* These values are correctly snapped above -- so we don't want\n-                   to round here, we really only want to truncate */\n-                x = floor(x);\n-                y = floor(y);\n-\n-                // Cull points outside the boundary of the image.\n-                // Values that are too large may overflow and create\n-                // segfaults.\n-                // http://sourceforge.net/tracker/?func=detail&aid=2865490&group_id=80706&atid=560720\n-                if (!clipping_rect.hit_test(x, y))\n-                {\n-                    continue;\n-                }\n-\n-                pixfmt_amask_type pfa(pixFmt, alphaMask);\n-                amask_ren_type r(pfa);\n-                amask_aa_renderer_type ren(r);\n-\n-                if (face.first)\n-                {\n-                    ren.color(face.second);\n-                    sa.init(fillCache, fillSize, x, y);\n-                    agg::render_scanlines(sa, sl, ren);\n-                }\n-                ren.color(gc.color);\n-                sa.init(strokeCache, strokeSize, x, y);\n-                agg::render_scanlines(sa, sl, ren);\n-            }\n-        }\n-        else\n-        {\n-            while (path_curve.vertex(&x, &y) != agg::path_cmd_stop)\n-            {\n-                if (MPL_notisfinite64(x) || MPL_notisfinite64(y))\n-                {\n-                    continue;\n-                }\n-\n-                /* These values are correctly snapped above -- so we don't want\n-                   to round here, we really only want to truncate */\n-                x = floor(x);\n-                y = floor(y);\n-\n-                // Cull points outside the boundary of the image.\n-                // Values that are too large may overflow and create\n-                // segfaults.\n-                // http://sourceforge.net/tracker/?func=detail&aid=2865490&group_id=80706&atid=560720\n-                if (!clipping_rect.hit_test(x, y))\n-                {\n-                    continue;\n-                }\n-\n-                if (face.first)\n-                {\n-                    rendererAA.color(face.second);\n-                    sa.init(fillCache, fillSize, x, y);\n-                    agg::render_scanlines(sa, sl, rendererAA);\n-                }\n-\n-                rendererAA.color(gc.color);\n-                sa.init(strokeCache, strokeSize, x, y);\n-                agg::render_scanlines(sa, sl, rendererAA);\n-            }\n-        }\n-    }\n-    catch (...)\n-    {\n-        if (fillCache != staticFillCache)\n-            delete[] fillCache;\n-        if (strokeCache != staticStrokeCache)\n-            delete[] strokeCache;\n-        theRasterizer.reset_clipping();\n-        rendererBase.reset_clipping(true);\n-        throw;\n-    }\n-\n-    if (fillCache != staticFillCache)\n-        delete[] fillCache;\n-    if (strokeCache != staticStrokeCache)\n-        delete[] strokeCache;\n+    int row_len = width * 3;\n \n-    theRasterizer.reset_clipping();\n-    rendererBase.reset_clipping(true);\n+    agg::rendering_buffer renderingBufferTmp;\n+    renderingBufferTmp.attach(buf, width, height, row_len);\n \n-    return Py::Object();\n+    agg::color_conv(&renderingBufferTmp, &renderingBuffer, agg::color_conv_rgba32_to_rgb24());\n }\n \n-\n-/**\n- * This is a custom span generator that converts spans in the\n- * 8-bit inverted greyscale font buffer to rgba that agg can use.\n- */\n-template<class ChildGenerator>\n-class font_to_rgba\n+void RendererAgg::tostring_argb(uint8_t *buf)\n {\n-public:\n-    typedef ChildGenerator child_type;\n-    typedef agg::rgba8 color_type;\n-    typedef typename child_type::color_type child_color_type;\n-    typedef agg::span_allocator<child_color_type> span_alloc_type;\n-\n-private:\n-    child_type* _gen;\n-    color_type _color;\n-    span_alloc_type _allocator;\n+    //\"Return the rendered buffer as an RGB string\";\n \n-public:\n-    font_to_rgba(child_type* gen, color_type color) :\n-        _gen(gen),\n-        _color(color)\n-    {\n+    int row_len = width * 4;\n \n-    }\n+    agg::rendering_buffer renderingBufferTmp;\n+    renderingBufferTmp.attach(buf, width, height, row_len);\n+    agg::color_conv(&renderingBufferTmp, &renderingBuffer, agg::color_conv_rgba32_to_argb32());\n+}\n \n-    inline void\n-    generate(color_type* output_span, int x, int y, unsigned len)\n-    {\n-        _allocator.allocate(len);\n-        child_color_type* input_span = _allocator.span();\n-        _gen->generate(input_span, x, y, len);\n+void RendererAgg::tostring_bgra(uint8_t *buf)\n+{\n+    //\"Return the rendered buffer as an RGB string\";\n \n-        do\n-        {\n-            *output_span = _color;\n-            output_span->a = ((unsigned int)_color.a *\n-                              (unsigned int)input_span->v) >> 8;\n-            ++output_span;\n-            ++input_span;\n-        }\n-        while (--len);\n-    }\n+    int row_len = width * 4;\n \n-    void\n-    prepare()\n-    {\n-        _gen->prepare();\n-    }\n-};\n+    agg::rendering_buffer renderingBufferTmp;\n+    renderingBufferTmp.attach(buf, width, height, row_len);\n \n+    agg::color_conv(&renderingBufferTmp, &renderingBuffer, agg::color_conv_rgba32_to_bgra32());\n+}\n \n-// MGDTODO: Support clip paths\n-Py::Object\n-RendererAgg::draw_text_image(const Py::Tuple& args)\n+agg::rect_i RendererAgg::get_content_extents()\n {\n-    _VERBOSE(\"RendererAgg::draw_text\");\n-\n-    typedef agg::span_allocator<agg::rgba8> color_span_alloc_type;\n-    typedef agg::span_interpolator_linear<> interpolator_type;\n-    typedef agg::image_accessor_clip<agg::pixfmt_gray8> image_accessor_type;\n-    typedef agg::span_image_filter_gray<image_accessor_type,\n-                                        interpolator_type> image_span_gen_type;\n-    typedef font_to_rgba<image_span_gen_type> span_gen_type;\n-    typedef agg::renderer_scanline_aa<renderer_base, color_span_alloc_type,\n-                                      span_gen_type> renderer_type;\n-\n-    args.verify_length(5);\n-\n-    const unsigned char* buffer = NULL;\n-    int width, height;\n-    Py::Object image_obj = args[0];\n+    agg::rect_i r(width, height, 0, 0);\n \n-    if (PyArray_Check(image_obj.ptr()))\n-    {\n-        PyObject* image_array = PyArray_FromObject(\n-            image_obj.ptr(), NPY_UBYTE, 2, 2);\n-        if (!image_array)\n-        {\n-            throw Py::ValueError(\n-                \"First argument to draw_text_image must be a FT2Font.Image object or a Nx2 uint8 numpy array.\");\n-        }\n-        image_obj = Py::Object(image_array, true);\n-        buffer = (unsigned char *)PyArray_DATA((PyArrayObject*)image_array);\n-        width = PyArray_DIM((PyArrayObject*)image_array, 1);\n-        height = PyArray_DIM((PyArrayObject*)image_array, 0);\n-    }\n-    else\n-    {\n-        FT2Image* image = static_cast<FT2Image *>(\n-            Py::getPythonExtensionBase(image_obj.ptr()));\n-        if (!image->get_buffer())\n-        {\n-            throw Py::ValueError(\n-                \"First argument to draw_text_image must be a FT2Font.Image object or a Nx2 uint8 numpy array.\");\n+    // Looks at the alpha channel to find the minimum extents of the image\n+    unsigned char *pixel = pixBuffer + 3;\n+    for (int y = 0; y < (int)height; ++y) {\n+        for (int x = 0; x < (int)width; ++x) {\n+            if (*pixel) {\n+                if (x < r.x1)\n+                    r.x1 = x;\n+                if (y < r.y1)\n+                    r.y1 = y;\n+                if (x > r.x2)\n+                    r.x2 = x;\n+                if (y > r.y2)\n+                    r.y2 = y;\n+            }\n+            pixel += 4;\n         }\n-        buffer = image->get_buffer();\n-        width = image->get_width();\n-        height = image->get_height();\n-    }\n-\n-    int x(0), y(0);\n-    try\n-    {\n-        x = Py::Int(args[1]);\n-        y = Py::Int(args[2]);\n-    }\n-    catch (Py::TypeError)\n-    {\n-        throw Py::TypeError(\"Invalid input arguments to draw_text_image\");\n     }\n \n-    double angle = Py::Float(args[3]);\n+    r.x1 = std::max(0, r.x1 - 1);\n+    r.y1 = std::max(0, r.y1 - 1);\n+    r.x2 = std::max(r.x2 + 1, (int)width);\n+    r.y2 = std::max(r.y2 + 1, (int)height);\n \n-    GCAgg gc(args[4], dpi);\n-\n-    theRasterizer.reset_clipping();\n-    rendererBase.reset_clipping(true);\n-    set_clipbox(gc.cliprect, theRasterizer);\n-\n-    agg::rendering_buffer srcbuf((agg::int8u*)buffer, width, height, width);\n-    agg::pixfmt_gray8 pixf_img(srcbuf);\n-\n-    agg::trans_affine mtx;\n-    mtx *= agg::trans_affine_translation(0, -height);\n-    mtx *= agg::trans_affine_rotation(-angle * agg::pi / 180.0);\n-    mtx *= agg::trans_affine_translation(x, y);\n-\n-    agg::path_storage rect;\n-    rect.move_to(0, 0);\n-    rect.line_to(width, 0);\n-    rect.line_to(width, height);\n-    rect.line_to(0, height);\n-    rect.line_to(0, 0);\n-    agg::conv_transform<agg::path_storage> rect2(rect, mtx);\n-\n-    agg::trans_affine inv_mtx(mtx);\n-    inv_mtx.invert();\n-\n-    agg::image_filter_lut filter;\n-    filter.calculate(agg::image_filter_spline36());\n-    interpolator_type interpolator(inv_mtx);\n-    color_span_alloc_type sa;\n-    image_accessor_type ia(pixf_img, 0);\n-    image_span_gen_type image_span_generator(ia, interpolator, filter);\n-    span_gen_type output_span_generator(&image_span_generator, gc.color);\n-    renderer_type ri(rendererBase, sa, output_span_generator);\n-\n-    try {\n-        theRasterizer.add_path(rect2);\n-    } catch (std::overflow_error &e) {\n-        throw Py::OverflowError(e.what());\n-    }\n-    agg::render_scanlines(theRasterizer, slineP8, ri);\n-\n-    return Py::Object();\n+    return r;\n }\n \n-class span_conv_alpha\n+void RendererAgg::clear()\n {\n-public:\n-    typedef agg::rgba8 color_type;\n-\n-    double m_alpha;\n-\n-    span_conv_alpha(double alpha) :\n-        m_alpha(alpha)\n-    {\n-    }\n-\n-    void prepare() {}\n-    void generate(color_type* span, int x, int y, unsigned len) const\n-    {\n-        do\n-            {\n-                span->a = (agg::int8u)((double)span->a * m_alpha);\n-                ++span;\n-            }\n-        while(--len);\n-    }\n-};\n+    //\"clear the rendered buffer\";\n \n-\n-Py::Object\n-RendererAgg::draw_image(const Py::Tuple& args)\n-{\n-    _VERBOSE(\"RendererAgg::draw_image\");\n-\n-    args.verify_length(4, 7); // 7 if affine matrix if given\n-\n-    GCAgg gc(args[0], dpi);\n-    Image *image = static_cast<Image*>(args[3].ptr());\n-    bool has_clippath = false;\n-    agg::trans_affine affine_trans;\n-    bool has_affine = false;\n-    double x, y, w, h;\n-    double alpha;\n-\n-    if (args.size() == 7)\n-    {\n-        has_affine = true;\n-        x = Py::Float(args[1]);\n-        y = Py::Float(args[2]);\n-        w = Py::Float(args[4]);\n-        h = Py::Float(args[5]);\n-        affine_trans = py_to_agg_transformation_matrix(args[6].ptr());\n-    }\n-    else\n-    {\n-        x = mpl_round(Py::Float(args[1]));\n-        y = mpl_round(Py::Float(args[2]));\n-        w = h = 0; /* w and h not used in this case, but assign to prevent\n-                  warnings from the compiler */\n-    }\n-\n-    alpha = gc.alpha;\n-\n-    theRasterizer.reset_clipping();\n-    rendererBase.reset_clipping(true);\n-    set_clipbox(gc.cliprect, theRasterizer);\n-    has_clippath = render_clippath(gc.clippath, gc.clippath_trans);\n-\n-    Py::Tuple empty;\n-    image->flipud_out(empty);\n-    pixfmt pixf(*(image->rbufOut));\n-\n-    if (has_affine | has_clippath)\n-    {\n-        agg::trans_affine mtx;\n-        agg::path_storage rect;\n-\n-        if (has_affine)\n-        {\n-            mtx *= agg::trans_affine_scaling(1, -1);\n-            mtx *= agg::trans_affine_translation(0, image->rowsOut);\n-            mtx *= agg::trans_affine_scaling(w / (image->colsOut),\n-                                             h / (image->rowsOut));\n-            mtx *= agg::trans_affine_translation(x, y);\n-            mtx *= affine_trans;\n-            mtx *= agg::trans_affine_scaling(1.0, -1.0);\n-            mtx *= agg::trans_affine_translation(0.0, (double) height);\n-        }\n-        else\n-        {\n-            mtx *= agg::trans_affine_translation(\n-                (int)x,\n-                (int)(height - (y + image->rowsOut)));\n-        }\n-\n-        rect.move_to(0, 0);\n-        rect.line_to(image->colsOut, 0);\n-        rect.line_to(image->colsOut, image->rowsOut);\n-        rect.line_to(0, image->rowsOut);\n-        rect.line_to(0, 0);\n-\n-        agg::conv_transform<agg::path_storage> rect2(rect, mtx);\n-\n-        agg::trans_affine inv_mtx(mtx);\n-        inv_mtx.invert();\n-\n-        typedef agg::span_allocator<agg::rgba8> color_span_alloc_type;\n-        typedef agg::image_accessor_clip<agg::pixfmt_rgba32_plain>\n-            image_accessor_type;\n-        typedef agg::span_interpolator_linear<> interpolator_type;\n-        typedef agg::span_image_filter_rgba_nn<image_accessor_type,\n-                                               interpolator_type> image_span_gen_type;\n-        typedef agg::span_converter<image_span_gen_type, span_conv_alpha> span_conv;\n-\n-        color_span_alloc_type sa;\n-        image_accessor_type ia(pixf, agg::rgba8(0, 0, 0, 0));\n-        interpolator_type interpolator(inv_mtx);\n-        image_span_gen_type image_span_generator(ia, interpolator);\n-        span_conv_alpha conv_alpha(alpha);\n-        span_conv spans(image_span_generator, conv_alpha);\n-\n-        if (has_clippath)\n-        {\n-            typedef agg::pixfmt_amask_adaptor<pixfmt, alpha_mask_type>\n-                pixfmt_amask_type;\n-            typedef agg::renderer_base<pixfmt_amask_type> amask_ren_type;\n-            typedef agg::renderer_scanline_aa<amask_ren_type,\n-                                              color_span_alloc_type,\n-                                              span_conv>\n-                renderer_type_alpha;\n-\n-            pixfmt_amask_type pfa(pixFmt, alphaMask);\n-            amask_ren_type r(pfa);\n-            renderer_type_alpha ri(r, sa, spans);\n-\n-            try {\n-                theRasterizer.add_path(rect2);\n-            } catch (std::overflow_error &e) {\n-                throw Py::OverflowError(e.what());\n-            }\n-            agg::render_scanlines(theRasterizer, scanlineAlphaMask, ri);\n-        }\n-        else\n-        {\n-            typedef agg::renderer_base<pixfmt> ren_type;\n-            typedef agg::renderer_scanline_aa<ren_type,\n-                                              color_span_alloc_type,\n-                                              span_conv>\n-                renderer_type;\n-\n-            ren_type r(pixFmt);\n-            renderer_type ri(r, sa, spans);\n-\n-            try {\n-                theRasterizer.add_path(rect2);\n-            } catch (std::overflow_error &e) {\n-                throw Py::OverflowError(e.what());\n-            }\n-            agg::render_scanlines(theRasterizer, slineP8, ri);\n-        }\n-\n-    }\n-    else\n-    {\n-        set_clipbox(gc.cliprect, rendererBase);\n-        rendererBase.blend_from(\n-            pixf, 0, (int)x, (int)(height - (y + image->rowsOut)),\n-            (agg::int8u)(alpha * 255));\n-    }\n-\n-    rendererBase.reset_clipping(true);\n-    image->flipud_out(empty);\n-\n-    return Py::Object();\n-}\n-\n-\n-template<class path_t>\n-void RendererAgg::_draw_path(path_t& path, bool has_clippath,\n-                             const facepair_t& face, const GCAgg& gc)\n-{\n-    typedef agg::conv_stroke<path_t>                           stroke_t;\n-    typedef agg::conv_dash<path_t>                             dash_t;\n-    typedef agg::conv_stroke<dash_t>                           stroke_dash_t;\n-    typedef agg::pixfmt_amask_adaptor<pixfmt, alpha_mask_type> pixfmt_amask_type;\n-    typedef agg::renderer_base<pixfmt_amask_type>              amask_ren_type;\n-    typedef agg::renderer_scanline_aa_solid<amask_ren_type>    amask_aa_renderer_type;\n-    typedef agg::renderer_scanline_bin_solid<amask_ren_type>   amask_bin_renderer_type;\n-\n-    // Render face\n-    if (face.first)\n-    {\n-        try {\n-            theRasterizer.add_path(path);\n-        } catch (std::overflow_error &e) {\n-            throw Py::OverflowError(e.what());\n-        }\n-\n-        if (gc.isaa)\n-        {\n-            if (has_clippath)\n-            {\n-                pixfmt_amask_type pfa(pixFmt, alphaMask);\n-                amask_ren_type r(pfa);\n-                amask_aa_renderer_type ren(r);\n-                ren.color(face.second);\n-                agg::render_scanlines(theRasterizer, scanlineAlphaMask, ren);\n-            }\n-            else\n-            {\n-                rendererAA.color(face.second);\n-                agg::render_scanlines(theRasterizer, slineP8, rendererAA);\n-            }\n-        }\n-        else\n-        {\n-            if (has_clippath)\n-            {\n-                pixfmt_amask_type pfa(pixFmt, alphaMask);\n-                amask_ren_type r(pfa);\n-                amask_bin_renderer_type ren(r);\n-                ren.color(face.second);\n-                agg::render_scanlines(theRasterizer, scanlineAlphaMask, ren);\n-            }\n-            else\n-            {\n-                rendererBin.color(face.second);\n-                agg::render_scanlines(theRasterizer, slineP8, rendererBin);\n-            }\n-        }\n-    }\n-\n-    // Render hatch\n-    if (!gc.hatchpath.isNone())\n-    {\n-        // Reset any clipping that may be in effect, since we'll be\n-        // drawing the hatch in a scratch buffer at origin (0, 0)\n-        theRasterizer.reset_clipping();\n-        rendererBase.reset_clipping(true);\n-\n-        // Create and transform the path\n-        typedef agg::conv_transform<PathIterator> hatch_path_trans_t;\n-        typedef agg::conv_curve<hatch_path_trans_t> hatch_path_curve_t;\n-        typedef agg::conv_stroke<hatch_path_curve_t> hatch_path_stroke_t;\n-\n-        PathIterator hatch_path(gc.hatchpath);\n-        agg::trans_affine hatch_trans;\n-        hatch_trans *= agg::trans_affine_scaling(1.0, -1.0);\n-        hatch_trans *= agg::trans_affine_translation(0.0, 1.0);\n-        hatch_trans *= agg::trans_affine_scaling(HATCH_SIZE, HATCH_SIZE);\n-        hatch_path_trans_t hatch_path_trans(hatch_path, hatch_trans);\n-        hatch_path_curve_t hatch_path_curve(hatch_path_trans);\n-        hatch_path_stroke_t hatch_path_stroke(hatch_path_curve);\n-        hatch_path_stroke.width(1.0);\n-        hatch_path_stroke.line_cap(agg::square_cap);\n-\n-        // Render the path into the hatch buffer\n-        pixfmt hatch_img_pixf(hatchRenderingBuffer);\n-        renderer_base rb(hatch_img_pixf);\n-        renderer_aa rs(rb);\n-        rb.clear(_fill_color);\n-        rs.color(gc.color);\n-\n-        try {\n-            theRasterizer.add_path(hatch_path_curve);\n-        } catch (std::overflow_error &e) {\n-            throw Py::OverflowError(e.what());\n-        }\n-        agg::render_scanlines(theRasterizer, slineP8, rs);\n-        try {\n-            theRasterizer.add_path(hatch_path_stroke);\n-        } catch (std::overflow_error &e) {\n-            throw Py::OverflowError(e.what());\n-        }\n-        agg::render_scanlines(theRasterizer, slineP8, rs);\n-\n-        // Put clipping back on, if originally set on entry to this\n-        // function\n-        set_clipbox(gc.cliprect, theRasterizer);\n-        if (has_clippath)\n-            render_clippath(gc.clippath, gc.clippath_trans);\n-\n-        // Transfer the hatch to the main image buffer\n-        typedef agg::image_accessor_wrap < pixfmt,\n-        agg::wrap_mode_repeat_auto_pow2,\n-        agg::wrap_mode_repeat_auto_pow2 > img_source_type;\n-        typedef agg::span_pattern_rgba<img_source_type> span_gen_type;\n-        agg::span_allocator<agg::rgba8> sa;\n-        img_source_type img_src(hatch_img_pixf);\n-        span_gen_type sg(img_src, 0, 0);\n-        try {\n-            theRasterizer.add_path(path);\n-        } catch (std::overflow_error &e) {\n-            throw Py::OverflowError(e.what());\n-        }\n-\n-        if (has_clippath)\n-        {\n-           pixfmt_amask_type pfa(pixFmt, alphaMask);\n-           amask_ren_type ren(pfa);\n-           agg::render_scanlines_aa(theRasterizer, slineP8, ren, sa, sg);\n-        }\n-        else\n-        {\n-           agg::render_scanlines_aa(theRasterizer, slineP8, rendererBase, sa, sg);\n-        }\n-    }\n-\n-    // Render stroke\n-    if (gc.linewidth != 0.0)\n-    {\n-        double linewidth = gc.linewidth;\n-        if (!gc.isaa)\n-        {\n-            linewidth = (linewidth < 0.5) ? 0.5 : mpl_round(linewidth);\n-        }\n-        if (gc.dashes.size() == 0)\n-        {\n-            stroke_t stroke(path);\n-            stroke.width(linewidth);\n-            stroke.line_cap(gc.cap);\n-            stroke.line_join(gc.join);\n-            try {\n-                theRasterizer.add_path(stroke);\n-            } catch (std::overflow_error &e) {\n-                throw Py::OverflowError(e.what());\n-            }\n-        }\n-        else\n-        {\n-            dash_t dash(path);\n-            for (GCAgg::dash_t::const_iterator i = gc.dashes.begin();\n-                    i != gc.dashes.end(); ++i)\n-            {\n-                double val0 = i->first;\n-                double val1 = i->second;\n-                if (!gc.isaa)\n-                {\n-                    val0 = (int)val0 + 0.5;\n-                    val1 = (int)val1 + 0.5;\n-                }\n-                dash.add_dash(val0, val1);\n-            }\n-            stroke_dash_t stroke(dash);\n-            stroke.line_cap(gc.cap);\n-            stroke.line_join(gc.join);\n-            stroke.width(linewidth);\n-            try {\n-                theRasterizer.add_path(stroke);\n-            } catch (std::overflow_error &e) {\n-                throw Py::OverflowError(e.what());\n-            }\n-        }\n-\n-        if (gc.isaa)\n-        {\n-            if (has_clippath)\n-            {\n-                pixfmt_amask_type pfa(pixFmt, alphaMask);\n-                amask_ren_type r(pfa);\n-                amask_aa_renderer_type ren(r);\n-                ren.color(gc.color);\n-                agg::render_scanlines(theRasterizer, scanlineAlphaMask, ren);\n-            }\n-            else\n-            {\n-                rendererAA.color(gc.color);\n-                agg::render_scanlines(theRasterizer, slineP8, rendererAA);\n-            }\n-        }\n-        else\n-        {\n-            if (has_clippath)\n-            {\n-                pixfmt_amask_type pfa(pixFmt, alphaMask);\n-                amask_ren_type r(pfa);\n-                amask_bin_renderer_type ren(r);\n-                ren.color(gc.color);\n-                agg::render_scanlines(theRasterizer, scanlineAlphaMask, ren);\n-            }\n-            else\n-            {\n-                rendererBin.color(gc.color);\n-                agg::render_scanlines(theRasterizer, slineBin, rendererBin);\n-            }\n-        }\n-    }\n-}\n-\n-\n-Py::Object\n-RendererAgg::draw_path(const Py::Tuple& args)\n-{\n-    typedef agg::conv_transform<PathIterator>  transformed_path_t;\n-    typedef PathNanRemover<transformed_path_t> nan_removed_t;\n-    typedef PathClipper<nan_removed_t>         clipped_t;\n-    typedef PathSnapper<clipped_t>             snapped_t;\n-    typedef PathSimplifier<snapped_t>          simplify_t;\n-    typedef agg::conv_curve<simplify_t>        curve_t;\n-    typedef Sketch<curve_t>                    sketch_t;\n-\n-    _VERBOSE(\"RendererAgg::draw_path\");\n-    args.verify_length(3, 4);\n-\n-    GCAgg gc(args[0], dpi);\n-    PathIterator path(args[1]);\n-    agg::trans_affine trans = py_to_agg_transformation_matrix(args[2].ptr());\n-    Py::Object face_obj;\n-    if (args.size() == 4)\n-        face_obj = args[3];\n-\n-    facepair_t face = _get_rgba_face(face_obj, gc.alpha, gc.forced_alpha);\n-\n-    theRasterizer.reset_clipping();\n-    rendererBase.reset_clipping(true);\n-    set_clipbox(gc.cliprect, theRasterizer);\n-    bool has_clippath = render_clippath(gc.clippath, gc.clippath_trans);\n-\n-    trans *= agg::trans_affine_scaling(1.0, -1.0);\n-    trans *= agg::trans_affine_translation(0.0, (double)height);\n-    bool clip = !face.first && gc.hatchpath.isNone() && !path.has_curves();\n-    bool simplify = path.should_simplify() && clip;\n-    double snapping_linewidth = gc.linewidth;\n-    if (gc.color.a == 0.0) {\n-        snapping_linewidth = 0.0;\n-    }\n-\n-    transformed_path_t tpath(path, trans);\n-    nan_removed_t      nan_removed(tpath, true, path.has_curves());\n-    clipped_t          clipped(nan_removed, clip, width, height);\n-    snapped_t          snapped(clipped, gc.snap_mode, path.total_vertices(), snapping_linewidth);\n-    simplify_t         simplified(snapped, simplify, path.simplify_threshold());\n-    curve_t            curve(simplified);\n-    sketch_t           sketch(curve, gc.sketch_scale, gc.sketch_length, gc.sketch_randomness);\n-\n-    try\n-    {\n-        _draw_path(sketch, has_clippath, face, gc);\n-    }\n-    catch (const char* e)\n-    {\n-        throw Py::RuntimeError(e);\n-    }\n-\n-    return Py::Object();\n-}\n-\n-\n-template<class PathGenerator, int check_snap, int has_curves>\n-Py::Object\n-RendererAgg::_draw_path_collection_generic\n-(GCAgg&                         gc,\n- agg::trans_affine              master_transform,\n- const Py::Object&              cliprect,\n- const Py::Object&              clippath,\n- const agg::trans_affine&       clippath_trans,\n- const PathGenerator&           path_generator,\n- const Py::Object&              transforms_obj,\n- const Py::Object&              offsets_obj,\n- const agg::trans_affine&       offset_trans,\n- const Py::Object&              facecolors_obj,\n- const Py::Object&              edgecolors_obj,\n- const Py::SeqBase<Py::Float>&  linewidths,\n- const Py::SeqBase<Py::Object>& linestyles_obj,\n- const Py::SeqBase<Py::Int>&    antialiaseds,\n- const bool                     data_offsets)\n-{\n-    typedef agg::conv_transform<typename PathGenerator::path_iterator> transformed_path_t;\n-    typedef PathNanRemover<transformed_path_t>                         nan_removed_t;\n-    typedef PathClipper<nan_removed_t>                                 clipped_t;\n-    typedef PathSnapper<clipped_t>                                     snapped_t;\n-    typedef agg::conv_curve<snapped_t>                                 snapped_curve_t;\n-    typedef agg::conv_curve<clipped_t>                                 curve_t;\n-\n-    PyArrayObject* offsets = (PyArrayObject*)PyArray_FromObject\n-        (offsets_obj.ptr(), NPY_DOUBLE, 0, 2);\n-    if (!offsets ||\n-        (PyArray_NDIM(offsets) == 2 && PyArray_DIM(offsets, 1) != 2) ||\n-        (PyArray_NDIM(offsets) == 1 && PyArray_DIM(offsets, 0) != 0))\n-    {\n-        Py_XDECREF(offsets);\n-        throw Py::ValueError(\"Offsets array must be Nx2\");\n-    }\n-    Py::Object offsets_arr_obj((PyObject*)offsets, true);\n-\n-    PyArrayObject* facecolors = (PyArrayObject*)PyArray_FromObject\n-        (facecolors_obj.ptr(), NPY_DOUBLE, 1, 2);\n-    if (!facecolors ||\n-        (PyArray_NDIM(facecolors) == 1 && PyArray_DIM(facecolors, 0) != 0) ||\n-        (PyArray_NDIM(facecolors) == 2 && PyArray_DIM(facecolors, 1) != 4))\n-    {\n-        Py_XDECREF(facecolors);\n-        throw Py::ValueError(\"Facecolors must be a Nx4 numpy array or empty\");\n-    }\n-    Py::Object facecolors_arr_obj((PyObject*)facecolors, true);\n-\n-    PyArrayObject* edgecolors = (PyArrayObject*)PyArray_FromObject\n-        (edgecolors_obj.ptr(), NPY_DOUBLE, 1, 2);\n-    if (!edgecolors ||\n-        (PyArray_NDIM(edgecolors) == 1 && PyArray_DIM(edgecolors, 0) != 0) ||\n-        (PyArray_NDIM(edgecolors) == 2 && PyArray_DIM(edgecolors, 1) != 4))\n-    {\n-        Py_XDECREF(edgecolors);\n-        throw Py::ValueError(\"Edgecolors must be a Nx4 numpy array\");\n-    }\n-    Py::Object edgecolors_arr_obj((PyObject*)edgecolors, true);\n-\n-    PyArrayObject* transforms_arr = (PyArrayObject*)PyArray_FromObject\n-        (transforms_obj.ptr(), NPY_DOUBLE, 1, 3);\n-    if (!transforms_arr ||\n-        (PyArray_NDIM(transforms_arr) == 1 && PyArray_DIM(transforms_arr, 0) != 0) ||\n-        (PyArray_NDIM(transforms_arr) == 2) ||\n-        (PyArray_NDIM(transforms_arr) == 3 &&\n-         ((PyArray_DIM(transforms_arr, 1) != 3) ||\n-          (PyArray_DIM(transforms_arr, 2) != 3))))\n-    {\n-        Py_XDECREF(transforms_arr);\n-        throw Py::ValueError(\"Transforms must be a Nx3x3 numpy array\");\n-    }\n-\n-    size_t Npaths      = path_generator.num_paths();\n-    size_t Noffsets    = PyArray_DIM(offsets, 0);\n-    size_t N           = std::max(Npaths, Noffsets);\n-    size_t Ntransforms = PyArray_DIM(transforms_arr, 0);\n-    size_t Nfacecolors = PyArray_DIM(facecolors, 0);\n-    size_t Nedgecolors = PyArray_DIM(edgecolors, 0);\n-    size_t Nlinewidths = linewidths.length();\n-    size_t Nlinestyles = std::min(linestyles_obj.length(), N);\n-    size_t Naa         = antialiaseds.length();\n-\n-    if ((Nfacecolors == 0 && Nedgecolors == 0) || Npaths == 0)\n-    {\n-        Py_XDECREF(transforms_arr);\n-        return Py::Object();\n-    }\n-\n-    size_t i = 0;\n-\n-    // Convert all of the transforms up front\n-    typedef std::vector<agg::trans_affine> transforms_t;\n-    transforms_t transforms;\n-    transforms.reserve(Ntransforms);\n-    for (i = 0; i < Ntransforms; ++i)\n-    {\n-        /* TODO: Use a Numpy iterator */\n-        agg::trans_affine trans(\n-            *(double *)PyArray_GETPTR3(transforms_arr, i, 0, 0),\n-            *(double *)PyArray_GETPTR3(transforms_arr, i, 1, 0),\n-            *(double *)PyArray_GETPTR3(transforms_arr, i, 0, 1),\n-            *(double *)PyArray_GETPTR3(transforms_arr, i, 1, 1),\n-            *(double *)PyArray_GETPTR3(transforms_arr, i, 0, 2),\n-            *(double *)PyArray_GETPTR3(transforms_arr, i, 1, 2));\n-        trans *= master_transform;\n-\n-        transforms.push_back(trans);\n-    }\n-\n-    // Convert all the dashes up front\n-    typedef std::vector<std::pair<double, GCAgg::dash_t> > dashes_t;\n-    dashes_t dashes;\n-    dashes.resize(Nlinestyles);\n-    i = 0;\n-    for (dashes_t::iterator d = dashes.begin();\n-         d != dashes.end(); ++d, ++i)\n-    {\n-        convert_dashes(Py::Tuple(linestyles_obj[i]), dpi, d->second,\n-                       d->first);\n-    }\n-\n-    // Handle any clipping globally\n-    theRasterizer.reset_clipping();\n-    rendererBase.reset_clipping(true);\n-    set_clipbox(cliprect, theRasterizer);\n-    bool has_clippath = render_clippath(clippath, clippath_trans);\n-\n-    // Set some defaults, assuming no face or edge\n-    gc.linewidth = 0.0;\n-    facepair_t face;\n-    face.first = Nfacecolors != 0;\n-    agg::trans_affine trans;\n-\n-    for (i = 0; i < N; ++i)\n-    {\n-        typename PathGenerator::path_iterator path = path_generator(i);\n-\n-        if (Ntransforms)\n-        {\n-            trans = transforms[i % Ntransforms];\n-        }\n-        else\n-        {\n-            trans = master_transform;\n-        }\n-\n-        if (Noffsets)\n-        {\n-            double xo = *(double*)PyArray_GETPTR2(offsets, i % Noffsets, 0);\n-            double yo = *(double*)PyArray_GETPTR2(offsets, i % Noffsets, 1);\n-            offset_trans.transform(&xo, &yo);\n-            if (data_offsets) {\n-                trans = agg::trans_affine_translation(xo, yo) * trans;\n-            } else {\n-                trans *= agg::trans_affine_translation(xo, yo);\n-            }\n-        }\n-\n-        // These transformations must be done post-offsets\n-        trans *= agg::trans_affine_scaling(1.0, -1.0);\n-        trans *= agg::trans_affine_translation(0.0, (double)height);\n-\n-        if (Nfacecolors)\n-        {\n-            size_t fi = i % Nfacecolors;\n-            face.second = agg::rgba(\n-                *(double*)PyArray_GETPTR2(facecolors, fi, 0),\n-                *(double*)PyArray_GETPTR2(facecolors, fi, 1),\n-                *(double*)PyArray_GETPTR2(facecolors, fi, 2),\n-                *(double*)PyArray_GETPTR2(facecolors, fi, 3));\n-        }\n-\n-        if (Nedgecolors)\n-        {\n-            size_t ei = i % Nedgecolors;\n-            gc.color = agg::rgba(\n-                *(double*)PyArray_GETPTR2(edgecolors, ei, 0),\n-                *(double*)PyArray_GETPTR2(edgecolors, ei, 1),\n-                *(double*)PyArray_GETPTR2(edgecolors, ei, 2),\n-                *(double*)PyArray_GETPTR2(edgecolors, ei, 3));\n-\n-            if (Nlinewidths)\n-            {\n-                gc.linewidth = double(Py::Float(linewidths[i % Nlinewidths])) * dpi / 72.0;\n-            }\n-            else\n-            {\n-                gc.linewidth = 1.0;\n-            }\n-            if (Nlinestyles)\n-            {\n-                gc.dashes = dashes[i % Nlinestyles].second;\n-                gc.dashOffset = dashes[i % Nlinestyles].first;\n-            }\n-        }\n-\n-        bool do_clip = !face.first && gc.hatchpath.isNone() && !has_curves;\n-\n-        if (check_snap)\n-        {\n-            gc.isaa = Py::Boolean(antialiaseds[i % Naa]);\n-\n-            transformed_path_t tpath(path, trans);\n-            nan_removed_t      nan_removed(tpath, true, has_curves);\n-            clipped_t          clipped(nan_removed, do_clip, width, height);\n-            snapped_t          snapped(clipped, gc.snap_mode,\n-                                       path.total_vertices(), gc.linewidth);\n-            if (has_curves)\n-            {\n-                snapped_curve_t curve(snapped);\n-                _draw_path(curve, has_clippath, face, gc);\n-            }\n-            else\n-            {\n-                _draw_path(snapped, has_clippath, face, gc);\n-            }\n-        }\n-        else\n-        {\n-            gc.isaa = Py::Boolean(antialiaseds[i % Naa]);\n-\n-            transformed_path_t tpath(path, trans);\n-            nan_removed_t      nan_removed(tpath, true, has_curves);\n-            clipped_t          clipped(nan_removed, do_clip, width, height);\n-            if (has_curves)\n-            {\n-                curve_t curve(clipped);\n-                _draw_path(curve, has_clippath, face, gc);\n-            }\n-            else\n-            {\n-                _draw_path(clipped, has_clippath, face, gc);\n-            }\n-        }\n-    }\n-\n-    Py_XDECREF(transforms_arr);\n-\n-    return Py::Object();\n-}\n-\n-\n-class PathListGenerator\n-{\n-    const Py::SeqBase<Py::Object>& m_paths;\n-    size_t m_npaths;\n-\n-public:\n-    typedef PathIterator path_iterator;\n-\n-    inline\n-    PathListGenerator(const Py::SeqBase<Py::Object>& paths) :\n-        m_paths(paths), m_npaths(paths.size())\n-    {\n-\n-    }\n-\n-    inline size_t\n-    num_paths() const\n-    {\n-        return m_npaths;\n-    }\n-\n-    inline path_iterator\n-    operator()(size_t i) const\n-    {\n-        return PathIterator(m_paths[i % m_npaths]);\n-    }\n-};\n-\n-\n-Py::Object\n-RendererAgg::draw_path_collection(const Py::Tuple& args)\n-{\n-    _VERBOSE(\"RendererAgg::draw_path_collection\");\n-    args.verify_length(13);\n-\n-    Py::Object gc_obj = args[0];\n-    GCAgg gc(gc_obj, dpi);\n-    agg::trans_affine       master_transform = py_to_agg_transformation_matrix(args[1].ptr());\n-    Py::SeqBase<Py::Object> path   = args[2];\n-    PathListGenerator       path_generator(path);\n-    Py::Object              transforms_obj   = args[3];\n-    Py::Object              offsets_obj      = args[4];\n-    agg::trans_affine       offset_trans     = py_to_agg_transformation_matrix(args[5].ptr());\n-    Py::Object              facecolors_obj   = args[6];\n-    Py::Object              edgecolors_obj   = args[7];\n-    Py::SeqBase<Py::Float>  linewidths       = args[8];\n-    Py::SeqBase<Py::Object> linestyles_obj   = args[9];\n-    Py::SeqBase<Py::Int>    antialiaseds     = args[10];\n-    // We don't actually care about urls for Agg, so just ignore it.\n-    // Py::SeqBase<Py::Object> urls             = args[11];\n-    std::string             offset_position  = Py::String(args[12]).encode(\"utf-8\");\n-\n-    bool data_offsets = (offset_position == \"data\");\n-\n-    try\n-    {\n-        _draw_path_collection_generic<PathListGenerator, 1, 1>\n-        (gc,\n-         master_transform,\n-         gc.cliprect,\n-         gc.clippath,\n-         gc.clippath_trans,\n-         path_generator,\n-         transforms_obj,\n-         offsets_obj,\n-         offset_trans,\n-         facecolors_obj,\n-         edgecolors_obj,\n-         linewidths,\n-         linestyles_obj,\n-         antialiaseds,\n-         data_offsets);\n-    }\n-    catch (const char *e)\n-    {\n-        throw Py::RuntimeError(e);\n-    }\n-\n-    return Py::Object();\n-}\n-\n-\n-class QuadMeshGenerator\n-{\n-    size_t m_meshWidth;\n-    size_t m_meshHeight;\n-    PyArrayObject* m_coordinates;\n-\n-    class QuadMeshPathIterator\n-    {\n-        size_t m_iterator;\n-        size_t m_m, m_n;\n-        PyArrayObject* m_coordinates;\n-\n-    public:\n-        QuadMeshPathIterator(size_t m, size_t n, PyArrayObject* coordinates) :\n-            m_iterator(0), m_m(m), m_n(n), m_coordinates(coordinates)\n-        {\n-\n-        }\n-\n-    private:\n-        inline unsigned\n-        vertex(unsigned idx, double* x, double* y)\n-        {\n-            size_t m = m_m + ((idx     & 0x2) >> 1);\n-            size_t n = m_n + (((idx + 1) & 0x2) >> 1);\n-            double* pair = (double*)PyArray_GETPTR2(m_coordinates, n, m);\n-            *x = *pair++;\n-            *y = *pair;\n-            return (idx) ? agg::path_cmd_line_to : agg::path_cmd_move_to;\n-        }\n-\n-    public:\n-        inline unsigned\n-        vertex(double* x, double* y)\n-        {\n-            if (m_iterator >= total_vertices())\n-            {\n-                return agg::path_cmd_stop;\n-            }\n-            return vertex(m_iterator++, x, y);\n-        }\n-\n-        inline void\n-        rewind(unsigned path_id)\n-        {\n-            m_iterator = path_id;\n-        }\n-\n-        inline unsigned\n-        total_vertices()\n-        {\n-            return 5;\n-        }\n-\n-        inline bool\n-        should_simplify()\n-        {\n-            return false;\n-        }\n-    };\n-\n-public:\n-    typedef QuadMeshPathIterator path_iterator;\n-\n-    inline\n-    QuadMeshGenerator(size_t meshWidth, size_t meshHeight, PyObject* coordinates) :\n-        m_meshWidth(meshWidth), m_meshHeight(meshHeight), m_coordinates(NULL)\n-    {\n-        PyArrayObject* coordinates_array = \\\n-            (PyArrayObject*)PyArray_ContiguousFromObject(\n-                coordinates, NPY_DOUBLE, 3, 3);\n-\n-        if (!coordinates_array)\n-        {\n-            throw Py::ValueError(\"Invalid coordinates array.\");\n-        }\n-\n-        m_coordinates = coordinates_array;\n-    }\n-\n-    inline\n-    ~QuadMeshGenerator()\n-    {\n-        Py_XDECREF(m_coordinates);\n-    }\n-\n-    inline size_t\n-    num_paths() const\n-    {\n-        return m_meshWidth * m_meshHeight;\n-    }\n-\n-    inline path_iterator\n-    operator()(size_t i) const\n-    {\n-        return QuadMeshPathIterator(i % m_meshWidth, i / m_meshWidth, m_coordinates);\n-    }\n-};\n-\n-Py::Object\n-RendererAgg::draw_quad_mesh(const Py::Tuple& args)\n-{\n-    _VERBOSE(\"RendererAgg::draw_quad_mesh\");\n-    args.verify_length(10);\n-\n-    //segments, trans, clipbox, colors, linewidths, antialiaseds\n-    GCAgg gc(args[0], dpi);\n-    agg::trans_affine master_transform = py_to_agg_transformation_matrix(args[1].ptr());\n-    size_t            mesh_width       = (long)Py::Int(args[2]);\n-    size_t            mesh_height      = (long)Py::Int(args[3]);\n-    Py::Object        coordinates      = args[4];\n-    Py::Object        offsets_obj      = args[5];\n-    agg::trans_affine offset_trans     = py_to_agg_transformation_matrix(args[6].ptr());\n-    Py::Object        facecolors_obj   = args[7];\n-    bool              antialiased      = (bool)Py::Boolean(args[8]);\n-    Py::Object        edgecolors_obj   = args[9];\n-\n-    QuadMeshGenerator path_generator(mesh_width, mesh_height, coordinates.ptr());\n-\n-    Py::Object transforms_obj = Py::List(0);\n-    Py::Tuple linewidths(1);\n-    linewidths[0] = Py::Float(gc.linewidth);\n-    Py::SeqBase<Py::Object> linestyles_obj;\n-    Py::Tuple antialiaseds(1);\n-    antialiaseds[0] = Py::Int(antialiased ? 1 : 0);\n-\n-    if (edgecolors_obj.isNone()) {\n-        if (antialiased)\n-        {\n-            edgecolors_obj = facecolors_obj;\n-        }\n-        else\n-        {\n-            npy_intp dims[] = { 0, 0 };\n-            edgecolors_obj = PyArray_SimpleNew(1, dims, NPY_DOUBLE);\n-        }\n-    }\n-\n-    try\n-    {\n-        _draw_path_collection_generic<QuadMeshGenerator, 0, 0>\n-            (gc,\n-             master_transform,\n-             gc.cliprect,\n-             gc.clippath,\n-             gc.clippath_trans,\n-             path_generator,\n-             transforms_obj,\n-             offsets_obj,\n-             offset_trans,\n-             facecolors_obj,\n-             edgecolors_obj,\n-             linewidths,\n-             linestyles_obj,\n-             antialiaseds,\n-             false);\n-    }\n-    catch (const char* e)\n-    {\n-        throw Py::RuntimeError(e);\n-    }\n-\n-    return Py::Object();\n-}\n-\n-void\n-RendererAgg::_draw_gouraud_triangle(const double* points,\n-                                    const double* colors,\n-                                    agg::trans_affine trans,\n-                                    bool has_clippath)\n-{\n-    typedef agg::rgba8                                         color_t;\n-    typedef agg::span_gouraud_rgba<color_t>                    span_gen_t;\n-    typedef agg::span_allocator<color_t>                       span_alloc_t;\n-\n-    trans *= agg::trans_affine_scaling(1.0, -1.0);\n-    trans *= agg::trans_affine_translation(0.0, (double)height);\n-\n-    double tpoints[6];\n-\n-    for (int i = 0; i < 6; i += 2)\n-    {\n-        tpoints[i] = points[i];\n-        tpoints[i+1] = points[i+1];\n-        trans.transform(&tpoints[i], &tpoints[i+1]);\n-    }\n-\n-    span_alloc_t span_alloc;\n-    span_gen_t span_gen;\n-\n-    span_gen.colors(\n-        agg::rgba(colors[0], colors[1], colors[2], colors[3]),\n-        agg::rgba(colors[4], colors[5], colors[6], colors[7]),\n-        agg::rgba(colors[8], colors[9], colors[10], colors[11]));\n-    span_gen.triangle(\n-        tpoints[0], tpoints[1],\n-        tpoints[2], tpoints[3],\n-        tpoints[4], tpoints[5],\n-        0.5);\n-\n-    try {\n-        theRasterizer.add_path(span_gen);\n-    } catch (std::overflow_error &e) {\n-        throw Py::OverflowError(e.what()\n-                                );\n-    }\n-\n-    if (has_clippath)\n-    {\n-        typedef agg::pixfmt_amask_adaptor<pixfmt, alpha_mask_type> pixfmt_amask_type;\n-        typedef agg::renderer_base<pixfmt_amask_type>              amask_ren_type;\n-        typedef agg::renderer_scanline_aa<amask_ren_type, span_alloc_t, span_gen_t>\n-        amask_aa_renderer_type;\n-\n-        pixfmt_amask_type pfa(pixFmt, alphaMask);\n-        amask_ren_type r(pfa);\n-        amask_aa_renderer_type ren(r, span_alloc, span_gen);\n-        agg::render_scanlines(theRasterizer, scanlineAlphaMask, ren);\n-    }\n-    else\n-    {\n-        agg::render_scanlines_aa(theRasterizer, slineP8, rendererBase, span_alloc, span_gen);\n-    }\n-}\n-\n-\n-Py::Object\n-RendererAgg::draw_gouraud_triangle(const Py::Tuple& args)\n-{\n-    _VERBOSE(\"RendererAgg::draw_gouraud_triangle\");\n-    args.verify_length(4);\n-\n-    GCAgg             gc(args[0], dpi);\n-    Py::Object        points_obj = args[1];\n-    Py::Object        colors_obj = args[2];\n-    agg::trans_affine trans      = py_to_agg_transformation_matrix(args[3].ptr());\n-\n-    theRasterizer.reset_clipping();\n-    rendererBase.reset_clipping(true);\n-    set_clipbox(gc.cliprect, theRasterizer);\n-    bool has_clippath = render_clippath(gc.clippath, gc.clippath_trans);\n-\n-    PyArrayObject* points = (PyArrayObject*)PyArray_ContiguousFromAny\n-        (points_obj.ptr(), NPY_DOUBLE, 2, 2);\n-    if (!points ||\n-        PyArray_DIM(points, 0) != 3 || PyArray_DIM(points, 1) != 2)\n-    {\n-        Py_XDECREF(points);\n-        throw Py::ValueError(\"points must be a 3x2 numpy array\");\n-    }\n-    points_obj = Py::Object((PyObject*)points, true);\n-\n-    PyArrayObject* colors = (PyArrayObject*)PyArray_ContiguousFromAny\n-        (colors_obj.ptr(), NPY_DOUBLE, 2, 2);\n-    if (!colors ||\n-        PyArray_DIM(colors, 0) != 3 || PyArray_DIM(colors, 1) != 4)\n-    {\n-        Py_XDECREF(colors);\n-        throw Py::ValueError(\"colors must be a 3x4 numpy array\");\n-    }\n-    colors_obj = Py::Object((PyObject*)colors, true);\n-\n-    _draw_gouraud_triangle(\n-        (double*)PyArray_DATA(points), (double*)PyArray_DATA(colors),\n-        trans, has_clippath);\n-\n-    return Py::Object();\n-}\n-\n-\n-Py::Object\n-RendererAgg::draw_gouraud_triangles(const Py::Tuple& args)\n-{\n-    _VERBOSE(\"RendererAgg::draw_gouraud_triangles\");\n-    args.verify_length(4);\n-\n-    typedef agg::rgba8                      color_t;\n-    typedef agg::span_gouraud_rgba<color_t> span_gen_t;\n-\n-    GCAgg             gc(args[0], dpi);\n-    Py::Object        points_obj = args[1];\n-    Py::Object        colors_obj = args[2];\n-    agg::trans_affine trans      = py_to_agg_transformation_matrix(args[3].ptr());\n-    double            c_points[6];\n-    double            c_colors[12];\n-\n-    theRasterizer.reset_clipping();\n-    rendererBase.reset_clipping(true);\n-    set_clipbox(gc.cliprect, theRasterizer);\n-    bool has_clippath = render_clippath(gc.clippath, gc.clippath_trans);\n-\n-    PyArrayObject* points = (PyArrayObject*)PyArray_FromObject\n-        (points_obj.ptr(), NPY_DOUBLE, 3, 3);\n-    if (!points ||\n-        PyArray_DIM(points, 1) != 3 || PyArray_DIM(points, 2) != 2)\n-    {\n-        Py_XDECREF(points);\n-        throw Py::ValueError(\"points must be a Nx3x2 numpy array\");\n-    }\n-    points_obj = Py::Object((PyObject*)points, true);\n-\n-    PyArrayObject* colors = (PyArrayObject*)PyArray_FromObject\n-        (colors_obj.ptr(), NPY_DOUBLE, 3, 3);\n-    if (!colors ||\n-        PyArray_DIM(colors, 1) != 3 || PyArray_DIM(colors, 2) != 4)\n-    {\n-        Py_XDECREF(colors);\n-        throw Py::ValueError(\"colors must be a Nx3x4 numpy array\");\n-    }\n-    colors_obj = Py::Object((PyObject*)colors, true);\n-\n-    if (PyArray_DIM(points, 0) != PyArray_DIM(colors, 0))\n-    {\n-        throw Py::ValueError(\"points and colors arrays must be the same length\");\n-    }\n-\n-    for (int i = 0; i < PyArray_DIM(points, 0); ++i)\n-    {\n-        for (int j = 0; j < 3; ++j) {\n-            for (int k = 0; k < 2; ++k) {\n-                c_points[j*2+k] = *(double *)PyArray_GETPTR3(points, i, j, k);\n-            }\n-        }\n-\n-        for (int j = 0; j < 3; ++j) {\n-            for (int k = 0; k < 4; ++k) {\n-                c_colors[j*4+k] = *(double *)PyArray_GETPTR3(colors, i, j, k);\n-            }\n-        }\n-\n-        _draw_gouraud_triangle(\n-                c_points, c_colors, trans, has_clippath);\n-    }\n-\n-    return Py::Object();\n-}\n-\n-\n-Py::Object\n-RendererAgg::write_rgba(const Py::Tuple& args)\n-{\n-    _VERBOSE(\"RendererAgg::write_rgba\");\n-\n-    args.verify_length(1);\n-\n-    FILE *fp = NULL;\n-    mpl_off_t offset;\n-    Py::Object py_fileobj = Py::Object(args[0]);\n-    PyObject* py_file = NULL;\n-    bool close_file = false;\n-\n-    if (py_fileobj.isString())\n-    {\n-        if ((py_file = mpl_PyFile_OpenFile(py_fileobj.ptr(), (char *)\"wb\")) == NULL) {\n-            throw Py::Exception();\n-        }\n-    }\n-    else\n-    {\n-        py_file = py_fileobj.ptr();\n-    }\n-\n-    if ((fp = mpl_PyFile_Dup(py_file, (char *)\"wb\", &offset)))\n-    {\n-        if (fwrite(pixBuffer, 1, NUMBYTES, fp) != NUMBYTES)\n-        {\n-            if (mpl_PyFile_DupClose(py_file, fp, offset)) {\n-              throw Py::RuntimeError(\"Error closing dupe file handle\");\n-            }\n-\n-            if (close_file) {\n-                mpl_PyFile_CloseFile(py_file);\n-                Py_DECREF(py_file);\n-            }\n-\n-            throw Py::RuntimeError(\"Error writing to file\");\n-        }\n-\n-        if (mpl_PyFile_DupClose(py_file, fp, offset)) {\n-          throw Py::RuntimeError(\"Error closing dupe file handle\");\n-        }\n-\n-        if (close_file) {\n-            mpl_PyFile_CloseFile(py_file);\n-            Py_DECREF(py_file);\n-        }\n-    }\n-    else\n-    {\n-        PyErr_Clear();\n-        PyObject* write_method = PyObject_GetAttrString(py_fileobj.ptr(),\n-                                                        \"write\");\n-        if (!(write_method && PyCallable_Check(write_method)))\n-        {\n-            Py_XDECREF(write_method);\n-            throw Py::TypeError(\n-                \"Object does not appear to be a 8-bit string path or a Python file-like object\");\n-        }\n-\n-        #if PY3K\n-        PyObject_CallFunction(write_method, (char *)\"y#\", pixBuffer, NUMBYTES);\n-        #else\n-        PyObject_CallFunction(write_method, (char *)\"s#\", pixBuffer, NUMBYTES);\n-        #endif\n-\n-        Py_XDECREF(write_method);\n-    }\n-\n-    return Py::Object();\n-}\n-\n-\n-Py::Object\n-RendererAgg::tostring_rgb(const Py::Tuple& args)\n-{\n-    //\"Return the rendered buffer as an RGB string\";\n-\n-    _VERBOSE(\"RendererAgg::tostring_rgb\");\n-\n-    args.verify_length(0);\n-    int row_len = width * 3;\n-    unsigned char* buf_tmp = new unsigned char[row_len * height];\n-    if (buf_tmp == NULL)\n-    {\n-        //todo: also handle allocation throw\n-        throw Py::MemoryError(\n-            \"RendererAgg::tostring_rgb could not allocate memory\");\n-    }\n-\n-    try\n-    {\n-        agg::rendering_buffer renderingBufferTmp;\n-        renderingBufferTmp.attach(buf_tmp,\n-                                  width,\n-                                  height,\n-                                  row_len);\n-\n-        agg::color_conv(&renderingBufferTmp, &renderingBuffer,\n-                        agg::color_conv_rgba32_to_rgb24());\n-    }\n-    catch (...)\n-    {\n-        delete [] buf_tmp;\n-        throw Py::RuntimeError(\"Unknown exception occurred in tostring_rgb\");\n-    }\n-\n-    //todo: how to do this with native CXX\n-    #if PY3K\n-    PyObject* o = Py_BuildValue(\"y#\", buf_tmp, row_len * height);\n-    #else\n-    PyObject* o = Py_BuildValue(\"s#\", buf_tmp, row_len * height);\n-    #endif\n-\n-    delete [] buf_tmp;\n-    return Py::asObject(o);\n-}\n-\n-\n-Py::Object\n-RendererAgg::tostring_argb(const Py::Tuple& args)\n-{\n-    //\"Return the rendered buffer as an RGB string\";\n-\n-    _VERBOSE(\"RendererAgg::tostring_argb\");\n-\n-    args.verify_length(0);\n-    int row_len = width * 4;\n-    unsigned char* buf_tmp = new unsigned char[row_len * height];\n-    if (buf_tmp == NULL)\n-    {\n-        //todo: also handle allocation throw\n-        throw Py::MemoryError(\"RendererAgg::tostring_argb could not allocate memory\");\n-    }\n-\n-    try\n-    {\n-        agg::rendering_buffer renderingBufferTmp;\n-        renderingBufferTmp.attach(buf_tmp, width, height, row_len);\n-        agg::color_conv(&renderingBufferTmp, &renderingBuffer, agg::color_conv_rgba32_to_argb32());\n-    }\n-    catch (...)\n-    {\n-        delete [] buf_tmp;\n-        throw Py::RuntimeError(\"Unknown exception occurred in tostring_argb\");\n-    }\n-\n-    //todo: how to do this with native CXX\n-\n-    #if PY3K\n-    PyObject* o = Py_BuildValue(\"y#\", buf_tmp, row_len * height);\n-    #else\n-    PyObject* o = Py_BuildValue(\"s#\", buf_tmp, row_len * height);\n-    #endif\n-    delete [] buf_tmp;\n-    return Py::asObject(o);\n-}\n-\n-\n-Py::Object\n-RendererAgg::tostring_bgra(const Py::Tuple& args)\n-{\n-    //\"Return the rendered buffer as an RGB string\";\n-\n-    _VERBOSE(\"RendererAgg::tostring_bgra\");\n-\n-    args.verify_length(0);\n-    int row_len = width * 4;\n-    unsigned char* buf_tmp = new unsigned char[row_len * height];\n-    if (buf_tmp == NULL)\n-    {\n-        //todo: also handle allocation throw\n-        throw Py::MemoryError(\"RendererAgg::tostring_bgra could not allocate memory\");\n-    }\n-\n-    try\n-    {\n-        agg::rendering_buffer renderingBufferTmp;\n-        renderingBufferTmp.attach(buf_tmp,\n-                                  width,\n-                                  height,\n-                                  row_len);\n-\n-        agg::color_conv(&renderingBufferTmp, &renderingBuffer, agg::color_conv_rgba32_to_bgra32());\n-    }\n-    catch (...)\n-    {\n-        delete [] buf_tmp;\n-        throw Py::RuntimeError(\"Unknown exception occurred in tostring_bgra\");\n-    }\n-\n-    //todo: how to do this with native CXX\n-    #if PY3K\n-    PyObject* o = Py_BuildValue(\"y#\", buf_tmp, row_len * height);\n-    #else\n-    PyObject* o = Py_BuildValue(\"s#\", buf_tmp, row_len * height);\n-    #endif\n-    delete [] buf_tmp;\n-    return Py::asObject(o);\n-}\n-\n-\n-Py::Object\n-RendererAgg::buffer_rgba(const Py::Tuple& args)\n-{\n-    //\"expose the rendered buffer as Python buffer object, starting from postion x,y\";\n-\n-    _VERBOSE(\"RendererAgg::buffer_rgba\");\n-\n-    args.verify_length(0);\n-\n-    #if PY3K\n-    return Py::asObject(PyMemoryView_FromObject(this));\n-    #else\n-    int row_len = width * 4;\n-    return Py::asObject(PyBuffer_FromReadWriteMemory(\n-                            pixBuffer, row_len*height));\n-    #endif\n-}\n-\n-\n-Py::Object\n-RendererAgg::tostring_rgba_minimized(const Py::Tuple& args)\n-{\n-    args.verify_length(0);\n-\n-    int xmin = width;\n-    int ymin = height;\n-    int xmax = 0;\n-    int ymax = 0;\n-\n-    // Looks at the alpha channel to find the minimum extents of the image\n-    unsigned char* pixel = pixBuffer + 3;\n-    for (int y = 0; y < (int)height; ++y)\n-    {\n-        for (int x = 0; x < (int)width; ++x)\n-        {\n-            if (*pixel)\n-            {\n-                if (x < xmin) xmin = x;\n-                if (y < ymin) ymin = y;\n-                if (x > xmax) xmax = x;\n-                if (y > ymax) ymax = y;\n-            }\n-            pixel += 4;\n-        }\n-    }\n-\n-    int newwidth = 0;\n-    int newheight = 0;\n-    PyObject *data;\n-\n-    if (xmin < xmax && ymin < ymax)\n-    {\n-        // Expand the bounds by 1 pixel on all sides\n-        xmin = std::max(0, xmin - 1);\n-        ymin = std::max(0, ymin - 1);\n-        xmax = std::min(xmax, (int)width);\n-        ymax = std::min(ymax, (int)height);\n-\n-        newwidth    = xmax - xmin;\n-        newheight   = ymax - ymin;\n-        int newsize = newwidth * newheight * 4;\n-\n-        // NULL pointer causes Python to allocate uninitialized memory.\n-        // We then grab Python's pointer to uninitialized memory using\n-        // the _AsString() API.\n-        unsigned int* dst;\n-\n-        data = PyBytes_FromStringAndSize(NULL, newsize);\n-        if (data == NULL)\n-        {\n-            throw Py::MemoryError(\"RendererAgg::tostring_rgba_minimized could not allocate memory\");\n-        }\n-        dst = (unsigned int *)PyBytes_AsString(data);\n-\n-        unsigned int*  src = (unsigned int*)pixBuffer;\n-        for (int y = ymin; y < ymax; ++y)\n-        {\n-            for (int x = xmin; x < xmax; ++x, ++dst)\n-            {\n-                *dst = src[y * width + x];\n-            }\n-        }\n-    } else {\n-        data = PyBytes_FromStringAndSize(NULL, 0);\n-        if (data == NULL)\n-        {\n-            throw Py::MemoryError(\"RendererAgg::tostring_rgba_minimized could not allocate memory\");\n-        }\n-    }\n-\n-    Py::Tuple bounds(4);\n-    bounds[0] = Py::Int(xmin);\n-    bounds[1] = Py::Int(ymin);\n-    bounds[2] = Py::Int(newwidth);\n-    bounds[3] = Py::Int(newheight);\n-\n-    Py::Tuple result(2);\n-    result[0] = Py::Object(data, true);\n-    result[1] = bounds;\n-\n-    return result;\n-}\n-\n-\n-Py::Object\n-RendererAgg::clear(const Py::Tuple& args)\n-{\n-    //\"clear the rendered buffer\";\n-\n-    _VERBOSE(\"RendererAgg::clear\");\n-\n-    args.verify_length(0);\n     rendererBase.clear(_fill_color);\n-\n-    return Py::Object();\n-}\n-\n-\n-agg::rgba\n-RendererAgg::rgb_to_color(const Py::SeqBase<Py::Object>& rgb, double alpha)\n-{\n-    _VERBOSE(\"RendererAgg::rgb_to_color\");\n-\n-    double r = Py::Float(rgb[0]);\n-    double g = Py::Float(rgb[1]);\n-    double b = Py::Float(rgb[2]);\n-    return agg::rgba(r, g, b, alpha);\n-}\n-\n-\n-double\n-RendererAgg::points_to_pixels(const Py::Object& points)\n-{\n-    _VERBOSE(\"RendererAgg::points_to_pixels\");\n-    double p = Py::Float(points) ;\n-    return p * dpi / 72.0;\n-}\n-\n-#if PY3K\n-int\n-RendererAgg::buffer_get( Py_buffer* buf, int flags )\n-{\n-    return PyBuffer_FillInfo(buf, this, pixBuffer, width * height * 4, 1,\n-                             PyBUF_SIMPLE);\n-}\n-#endif\n-\n-RendererAgg::~RendererAgg()\n-{\n-\n-    _VERBOSE(\"RendererAgg::~RendererAgg\");\n-\n-    delete [] alphaBuffer;\n-    delete [] pixBuffer;\n-}\n-\n-/* ------------ module methods ------------- */\n-Py::Object _backend_agg_module::new_renderer(const Py::Tuple &args,\n-        const Py::Dict &kws)\n-{\n-\n-    if (args.length() != 3)\n-    {\n-        throw Py::RuntimeError(\"Incorrect # of args to RendererAgg(width, height, dpi).\");\n-    }\n-\n-    int debug;\n-    if (kws.hasKey(\"debug\"))\n-    {\n-        debug = Py::Int(kws[\"debug\"]);\n-    }\n-    else\n-    {\n-        debug = 0;\n-    }\n-\n-    unsigned int width = (int)Py::Int(args[0]);\n-    unsigned int height = (int)Py::Int(args[1]);\n-    double dpi = Py::Float(args[2]);\n-\n-    if (width > 1 << 15 || height > 1 << 15)\n-    {\n-        throw Py::ValueError(\"width and height must each be below 32768\");\n-    }\n-\n-    if (dpi <= 0.0)\n-    {\n-        throw Py::ValueError(\"dpi must be positive\");\n-    }\n-\n-    RendererAgg* renderer = NULL;\n-    try\n-    {\n-        renderer = new RendererAgg(width, height, dpi, debug);\n-    }\n-    catch (std::bad_alloc)\n-    {\n-        throw Py::RuntimeError(\"Could not allocate memory for image\");\n-    }\n-\n-    return Py::asObject(renderer);\n-}\n-\n-\n-void BufferRegion::init_type()\n-{\n-    behaviors().name(\"BufferRegion\");\n-    behaviors().doc(\"A wrapper to pass agg buffer objects to and from the python level\");\n-\n-\n-    add_varargs_method(\"set_x\", &BufferRegion::set_x,\n-                       \"set_x(x)\");\n-\n-    add_varargs_method(\"set_y\", &BufferRegion::set_y,\n-                       \"set_y(y)\");\n-\n-    add_varargs_method(\"get_extents\", &BufferRegion::get_extents,\n-                       \"get_extents()\");\n-\n-    add_varargs_method(\"to_string\", &BufferRegion::to_string,\n-                       \"to_string()\");\n-    add_varargs_method(\"to_string_argb\", &BufferRegion::to_string_argb,\n-                       \"to_string_argb()\");\n-}\n-\n-\n-void RendererAgg::init_type()\n-{\n-    behaviors().name(\"RendererAgg\");\n-    behaviors().doc(\"The agg backend extension module\");\n-\n-    add_varargs_method(\"draw_path\", &RendererAgg::draw_path,\n-                       \"draw_path(gc, path, transform, rgbFace)\\n\");\n-    add_varargs_method(\"draw_path_collection\", &RendererAgg::draw_path_collection,\n-                       \"draw_path_collection(gc, master_transform, paths, transforms, offsets, offsetTrans, facecolors, edgecolors, linewidths, linestyles, antialiaseds)\\n\");\n-    add_varargs_method(\"draw_quad_mesh\", &RendererAgg::draw_quad_mesh,\n-                       \"draw_quad_mesh(gc, master_transform, meshWidth, meshHeight, coordinates, offsets, offsetTrans, facecolors, antialiaseds, showedges)\\n\");\n-    add_varargs_method(\"draw_gouraud_triangle\", &RendererAgg::draw_gouraud_triangle,\n-                       \"draw_gouraud_triangle(gc, points, colors, master_transform)\\n\");\n-    add_varargs_method(\"draw_gouraud_triangles\", &RendererAgg::draw_gouraud_triangles,\n-                       \"draw_gouraud_triangles(gc, points, colors, master_transform)\\n\");\n-    add_varargs_method(\"draw_markers\", &RendererAgg::draw_markers,\n-                       \"draw_markers(gc, marker_path, marker_trans, path, rgbFace)\\n\");\n-    add_varargs_method(\"draw_text_image\", &RendererAgg::draw_text_image,\n-                       \"draw_text_image(font_image, x, y, r, g, b, a)\\n\");\n-    add_varargs_method(\"draw_image\", &RendererAgg::draw_image,\n-                       \"draw_image(gc, x, y, im)\");\n-    add_varargs_method(\"write_rgba\", &RendererAgg::write_rgba,\n-                       \"write_rgba(fname)\");\n-    add_varargs_method(\"tostring_rgb\", &RendererAgg::tostring_rgb,\n-                       \"s = tostring_rgb()\");\n-    add_varargs_method(\"tostring_argb\", &RendererAgg::tostring_argb,\n-                       \"s = tostring_argb()\");\n-    add_varargs_method(\"tostring_bgra\", &RendererAgg::tostring_bgra,\n-                       \"s = tostring_bgra()\");\n-    add_varargs_method(\"tostring_rgba_minimized\", &RendererAgg::tostring_rgba_minimized,\n-                       \"s = tostring_rgba_minimized()\");\n-    add_varargs_method(\"buffer_rgba\", &RendererAgg::buffer_rgba,\n-                       \"buffer = buffer_rgba()\");\n-    add_varargs_method(\"clear\", &RendererAgg::clear,\n-                       \"clear()\");\n-    add_varargs_method(\"copy_from_bbox\", &RendererAgg::copy_from_bbox,\n-                       \"copy_from_bbox(bbox)\");\n-    add_varargs_method(\"restore_region\", &RendererAgg::restore_region,\n-                       \"restore_region(region)\");\n-    add_varargs_method(\"restore_region2\", &RendererAgg::restore_region2,\n-                       \"restore_region(region, x1, y1, x2, y2, x3, y3)\");\n-\n-    #if PY3K\n-    behaviors().supportBufferType();\n-    #endif\n-}\n-\n-PyMODINIT_FUNC\n-#if PY3K\n-PyInit__backend_agg(void)\n-#else\n-init_backend_agg(void)\n-#endif\n-{\n-    //static _backend_agg_module* _backend_agg = new _backend_agg_module;\n-\n-    _VERBOSE(\"init_backend_agg\");\n-\n-    import_array();\n-\n-    static _backend_agg_module* _backend_agg = NULL;\n-    _backend_agg = new _backend_agg_module;\n-\n-    #if PY3K\n-    return _backend_agg->module().ptr();\n-    #endif\n }"
            },
            {
                "sha": "172fbfc5d1c1c699a5ca9f31c299cc1c92d04b12",
                "filename": "src/_backend_agg.h",
                "status": "modified",
                "additions": 1187,
                "deletions": 209,
                "changes": 1396,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_backend_agg.h",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_backend_agg.h",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/src%2F_backend_agg.h?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787",
                "patch": "@@ -1,57 +1,42 @@\n /* -*- mode: c++; c-basic-offset: 4 -*- */\n \n-/* _backend_agg.h - A rewrite of _backend_agg using PyCXX to handle\n-   ref counting, etc..\n+/* _backend_agg.h\n */\n \n-#ifndef __BACKEND_AGG_H\n-#define __BACKEND_AGG_H\n-#include <utility>\n-#include \"CXX/Extensions.hxx\"\n-\n-#include \"agg_arrowhead.h\"\n-#include \"agg_basics.h\"\n-#include \"agg_bezier_arc.h\"\n-#include \"agg_color_rgba.h\"\n-#include \"agg_conv_concat.h\"\n-#include \"agg_conv_contour.h\"\n+#ifndef __BACKEND_AGG_H__\n+#define __BACKEND_AGG_H__\n+\n+#include <vector>\n+\n+#include \"agg_alpha_mask_u8.h\"\n #include \"agg_conv_curve.h\"\n #include \"agg_conv_dash.h\"\n-#include \"agg_conv_marker.h\"\n-#include \"agg_conv_marker_adaptor.h\"\n-#include \"agg_math_stroke.h\"\n #include \"agg_conv_stroke.h\"\n-#include \"agg_ellipse.h\"\n-#include \"agg_embedded_raster_fonts.h\"\n-#include \"agg_path_storage.h\"\n-#include \"agg_pixfmt_rgb.h\"\n-#include \"agg_pixfmt_rgba.h\"\n-#include \"agg_pixfmt_gray.h\"\n-#include \"agg_alpha_mask_u8.h\"\n+#include \"agg_image_accessors.h\"\n #include \"agg_pixfmt_amask_adaptor.h\"\n-#include \"agg_rasterizer_outline.h\"\n+#include \"agg_pixfmt_gray.h\"\n+#include \"agg_pixfmt_rgba.h\"\n #include \"agg_rasterizer_scanline_aa.h\"\n-#include \"agg_renderer_outline_aa.h\"\n-#include \"agg_renderer_raster_text.h\"\n+#include \"agg_renderer_base.h\"\n #include \"agg_renderer_scanline.h\"\n #include \"agg_rendering_buffer.h\"\n #include \"agg_scanline_bin.h\"\n-#include \"agg_scanline_u.h\"\n #include \"agg_scanline_p.h\"\n-#include \"agg_vcgen_markers_term.h\"\n+#include \"agg_scanline_storage_aa.h\"\n+#include \"agg_scanline_storage_bin.h\"\n+#include \"agg_scanline_u.h\"\n+#include \"agg_span_allocator.h\"\n+#include \"agg_span_converter.h\"\n+#include \"agg_span_gouraud_rgba.h\"\n+#include \"agg_span_image_filter_gray.h\"\n+#include \"agg_span_image_filter_rgba.h\"\n+#include \"agg_span_interpolator_linear.h\"\n+#include \"agg_span_pattern_rgba.h\"\n+#include \"util/agg_color_conv_rgb8.h\"\n \n-#include \"agg_py_path_iterator.h\"\n+#include \"_backend_agg_basic_types.h\"\n #include \"path_converters.h\"\n-\n-// These are copied directly from path.py, and must be kept in sync\n-#define STOP   0\n-#define MOVETO 1\n-#define LINETO 2\n-#define CURVE3 3\n-#define CURVE4 4\n-#define CLOSEPOLY 5\n-\n-const size_t NUM_VERTICES[] = { 1, 1, 1, 2, 3, 1 };\n+#include \"array.h\"\n \n typedef agg::pixfmt_rgba32_plain pixfmt;\n typedef agg::renderer_base<pixfmt> renderer_base;\n@@ -69,109 +54,74 @@ typedef agg::renderer_scanline_aa_solid<renderer_base_alpha_mask_type> renderer_\n \n // a helper class to pass agg::buffer objects around.  agg::buffer is\n // a class in the swig wrapper\n-class BufferRegion : public Py::PythonExtension<BufferRegion>\n+class BufferRegion\n {\n-public:\n-    BufferRegion(const agg::rect_i &r, bool freemem = true) :\n-        rect(r), freemem(freemem)\n+  public:\n+    BufferRegion(const agg::rect_i &r) : rect(r)\n     {\n         width = r.x2 - r.x1;\n         height = r.y2 - r.y1;\n         stride = width * 4;\n         data = new agg::int8u[stride * height];\n     }\n \n-    agg::int8u* data;\n-    agg::rect_i rect;\n-    int width;\n-    int height;\n-    int stride;\n+    virtual ~BufferRegion()\n+    {\n+        delete[] data;\n+    };\n \n-    bool freemem;\n+    agg::int8u *get_data()\n+    {\n+        return data;\n+    }\n \n-    // set the x and y corners of the rectangle\n-    Py::Object set_x(const Py::Tuple &args);\n-    Py::Object set_y(const Py::Tuple &args);\n+    agg::rect_i &get_rect()\n+    {\n+        return rect;\n+    }\n \n-    Py::Object get_extents(const Py::Tuple &args);\n+    int get_width()\n+    {\n+        return width;\n+    }\n \n-    Py::Object to_string(const Py::Tuple &args);\n-    Py::Object to_string_argb(const Py::Tuple &args);\n-    static void init_type(void);\n+    int get_height()\n+    {\n+        return height;\n+    }\n \n-    virtual ~BufferRegion()\n+    int get_stride()\n     {\n-        if (freemem)\n-        {\n-            delete [] data;\n-            data = NULL;\n-        }\n-    };\n+        return stride;\n+    }\n \n-private:\n-    // prevent copying\n-    BufferRegion(const BufferRegion&);\n-    BufferRegion& operator=(const BufferRegion&);\n-};\n+    void to_string_argb(uint8_t *buf);\n \n-class GCAgg\n-{\n-public:\n-    GCAgg(const Py::Object& gc, double dpi);\n+  private:\n+    agg::int8u *data;\n+    agg::rect_i rect;\n+    int width;\n+    int height;\n+    int stride;\n \n-    double dpi;\n-    bool isaa;\n-\n-    agg::line_cap_e cap;\n-    agg::line_join_e join;\n-\n-    double linewidth;\n-    double alpha;\n-    bool forced_alpha;\n-    agg::rgba color;\n-\n-    Py::Object cliprect;\n-    Py::Object clippath;\n-    agg::trans_affine clippath_trans;\n-\n-    //dashes\n-    typedef std::vector<std::pair<double, double> > dash_t;\n-    double dashOffset;\n-    dash_t dashes;\n-    e_snap_mode snap_mode;\n-\n-    Py::Object hatchpath;\n-\n-    double sketch_scale;\n-    double sketch_length;\n-    double sketch_randomness;\n-\n-protected:\n-    agg::rgba get_color(const Py::Object& gc);\n-    double points_to_pixels(const Py::Object& points);\n-    void _set_linecap(const Py::Object& gc) ;\n-    void _set_joinstyle(const Py::Object& gc) ;\n-    void _set_dashes(const Py::Object& gc) ;\n-    void _set_clip_rectangle(const Py::Object& gc);\n-    void _set_clip_path(const Py::Object& gc);\n-    void _set_antialiased(const Py::Object& gc);\n-    void _set_snap(const Py::Object& gc);\n-    void _set_hatch_path(const Py::Object& gc);\n-    void _set_sketch_params(const Py::Object& gc);\n+  private:\n+    // prevent copying\n+    BufferRegion(const BufferRegion &);\n+    BufferRegion &operator=(const BufferRegion &);\n };\n \n-\n-//struct AMRenderer {\n-//\n-//}\n+#define MARKER_CACHE_SIZE 512\n \n // the renderer\n-class RendererAgg: public Py::PythonExtension<RendererAgg>\n+class RendererAgg\n {\n+    /* TODO: Remove facepair_t */\n     typedef std::pair<bool, agg::rgba> facepair_t;\n-public:\n-    RendererAgg(unsigned int width, unsigned int height, double dpi, int debug);\n-    static void init_type(void);\n+\n+  public:\n+    RendererAgg(unsigned int width, unsigned int height, double dpi);\n+\n+    virtual ~RendererAgg();\n \n     unsigned int get_width()\n     {\n@@ -183,40 +133,86 @@ class RendererAgg: public Py::PythonExtension<RendererAgg>\n         return height;\n     }\n \n-    // the drawing methods\n-    //Py::Object _draw_markers_nocache(const Py::Tuple & args);\n-    //Py::Object _draw_markers_cache(const Py::Tuple & args);\n-    Py::Object draw_markers(const Py::Tuple & args);\n-    Py::Object draw_text_image(const Py::Tuple & args);\n-    Py::Object draw_image(const Py::Tuple & args);\n-    Py::Object draw_path(const Py::Tuple & args);\n-    Py::Object draw_path_collection(const Py::Tuple & args);\n-    Py::Object draw_quad_mesh(const Py::Tuple& args);\n-    Py::Object draw_gouraud_triangle(const Py::Tuple& args);\n-    Py::Object draw_gouraud_triangles(const Py::Tuple& args);\n-\n-    Py::Object write_rgba(const Py::Tuple & args);\n-    Py::Object tostring_rgb(const Py::Tuple & args);\n-    Py::Object tostring_argb(const Py::Tuple & args);\n-    Py::Object tostring_bgra(const Py::Tuple & args);\n-    Py::Object tostring_rgba_minimized(const Py::Tuple & args);\n-    Py::Object buffer_rgba(const Py::Tuple & args);\n-    Py::Object clear(const Py::Tuple & args);\n-\n-    Py::Object copy_from_bbox(const Py::Tuple & args);\n-    Py::Object restore_region(const Py::Tuple & args);\n-    Py::Object restore_region2(const Py::Tuple & args);\n-\n-    #if PY3K\n-    virtual int buffer_get( Py_buffer *, int flags );\n-    #endif\n+    template <class PathIterator>\n+    void draw_path(GCAgg &gc, PathIterator &path, agg::trans_affine &trans, agg::rgba &color);\n \n-    virtual ~RendererAgg();\n+    template <class PathIterator>\n+    void draw_markers(GCAgg &gc,\n+                      PathIterator &marker_path,\n+                      agg::trans_affine &marker_path_trans,\n+                      PathIterator &path,\n+                      agg::trans_affine &trans,\n+                      agg::rgba face);\n+\n+    template <class ImageArray>\n+    void draw_text_image(GCAgg &gc, ImageArray &image, int x, int y, double angle);\n+\n+    template <class ImageArray>\n+    void draw_image(GCAgg &gc,\n+                    double x,\n+                    double y,\n+                    ImageArray &image,\n+                    double w,\n+                    double h,\n+                    agg::trans_affine trans,\n+                    bool resize);\n+\n+    template <class PathGenerator,\n+              class TransformArray,\n+              class OffsetArray,\n+              class ColorArray,\n+              class LineWidthArray,\n+              class AntialiasedArray>\n+    void draw_path_collection(GCAgg &gc,\n+                              agg::trans_affine &master_transform,\n+                              PathGenerator &path,\n+                              TransformArray &transforms,\n+                              OffsetArray &offsets,\n+                              agg::trans_affine &offset_trans,\n+                              ColorArray &facecolors,\n+                              ColorArray &edgecolors,\n+                              LineWidthArray &linewidths,\n+                              DashesVector &linestyles,\n+                              AntialiasedArray &antialiaseds,\n+                              e_offset_position offset_position);\n+\n+    template <class CoordinateArray, class OffsetArray, class ColorArray>\n+    void draw_quad_mesh(GCAgg &gc,\n+                        agg::trans_affine &master_transform,\n+                        size_t mesh_width,\n+                        size_t mesh_height,\n+                        CoordinateArray &coordinates,\n+                        OffsetArray &offsets,\n+                        agg::trans_affine &offset_trans,\n+                        ColorArray &facecolors,\n+                        bool antialiased,\n+                        ColorArray &edgecolors);\n+\n+    template <class PointArray, class ColorArray>\n+    void draw_gouraud_triangle(GCAgg &gc,\n+                               PointArray &points,\n+                               ColorArray &colors,\n+                               agg::trans_affine &trans);\n+\n+    template <class PointArray, class ColorArray>\n+    void draw_gouraud_triangles(GCAgg &gc,\n+                                PointArray &points,\n+                                ColorArray &colors,\n+                                agg::trans_affine &trans);\n+\n+    void tostring_rgb(uint8_t *buf);\n+    void tostring_argb(uint8_t *buf);\n+    void tostring_bgra(uint8_t *buf);\n+    agg::rect_i get_content_extents();\n+    void clear();\n+\n+    BufferRegion *copy_from_bbox(agg::rect_d in_rect);\n+    void restore_region(BufferRegion &reg);\n+    void restore_region(BufferRegion &region, int x, int y, int xx1, int yy1, int xx2, int yy2);\n \n-    static const size_t PIXELS_PER_INCH;\n     unsigned int width, height;\n     double dpi;\n-    size_t NUMBYTES;  //the number of bytes in buffer\n+    size_t NUMBYTES; // the number of bytes in buffer\n \n     agg::int8u *pixBuffer;\n     agg::rendering_buffer renderingBuffer;\n@@ -237,90 +233,1072 @@ class RendererAgg: public Py::PythonExtension<RendererAgg>\n     renderer_bin rendererBin;\n     rasterizer theRasterizer;\n \n-    Py::Object lastclippath;\n+    void *lastclippath;\n     agg::trans_affine lastclippath_transform;\n \n     static const size_t HATCH_SIZE = 72;\n     agg::int8u hatchBuffer[HATCH_SIZE * HATCH_SIZE * 4];\n     agg::rendering_buffer hatchRenderingBuffer;\n \n-    const int debug;\n-\n     agg::rgba _fill_color;\n \n+  protected:\n+    inline double points_to_pixels(double points)\n+    {\n+        return points * dpi / 72.0;\n+    }\n+\n+    template <class R>\n+    void set_clipbox(const agg::rect_d &cliprect, R &rasterizer);\n+\n+    bool render_clippath(py::PathIterator &clippath, const agg::trans_affine &clippath_trans);\n+\n+    template <class PathIteratorType>\n+    void _draw_path(PathIteratorType &path, bool has_clippath, const facepair_t &face, GCAgg &gc);\n+\n+    template <class PathIterator,\n+              class PathGenerator,\n+              class TransformArray,\n+              class OffsetArray,\n+              class ColorArray,\n+              class LineWidthArray,\n+              class AntialiasedArray>\n+    void _draw_path_collection_generic(GCAgg &gc,\n+                                       agg::trans_affine master_transform,\n+                                       const agg::rect_d &cliprect,\n+                                       PathIterator &clippath,\n+                                       const agg::trans_affine &clippath_trans,\n+                                       PathGenerator &path_generator,\n+                                       TransformArray &transforms,\n+                                       OffsetArray &offsets,\n+                                       const agg::trans_affine &offset_trans,\n+                                       ColorArray &facecolors,\n+                                       ColorArray &edgecolors,\n+                                       LineWidthArray &linewidths,\n+                                       DashesVector &linestyles,\n+                                       AntialiasedArray &antialiaseds,\n+                                       e_offset_position offset_position,\n+                                       int check_snap,\n+                                       int has_curves);\n \n-protected:\n-    double points_to_pixels(const Py::Object& points);\n-    agg::rgba rgb_to_color(const Py::SeqBase<Py::Object>& rgb, double alpha);\n-    facepair_t _get_rgba_face(const Py::Object& rgbFace, double alpha, bool forced_alpha);\n-\n-    template<class R>\n-    void set_clipbox(const Py::Object& cliprect, R& rasterizer);\n-\n-    bool render_clippath(const Py::Object& clippath, const agg::trans_affine& clippath_trans);\n-\n-    template<class PathIteratorType>\n-    void _draw_path(PathIteratorType& path, bool has_clippath,\n-                    const facepair_t& face, const GCAgg& gc);\n-\n-    template<class PathGenerator, int check_snap, int has_curves>\n-    Py::Object\n-    _draw_path_collection_generic\n-    (GCAgg&                         gc,\n-     agg::trans_affine              master_transform,\n-     const Py::Object&              cliprect,\n-     const Py::Object&              clippath,\n-     const agg::trans_affine&       clippath_trans,\n-     const PathGenerator&           path_generator,\n-     const Py::Object&              transforms_obj,\n-     const Py::Object&              offsets_obj,\n-     const agg::trans_affine&       offset_trans,\n-     const Py::Object&              facecolors_obj,\n-     const Py::Object&              edgecolors_obj,\n-     const Py::SeqBase<Py::Float>&  linewidths,\n-     const Py::SeqBase<Py::Object>& linestyles_obj,\n-     const Py::SeqBase<Py::Int>&    antialiaseds,\n-     const bool                     data_offsets);\n-\n-    void\n-    _draw_gouraud_triangle(\n-        const double* points, const double* colors,\n-        agg::trans_affine trans, bool has_clippath);\n-\n-private:\n+    template <class PointArray, class ColorArray>\n+    void _draw_gouraud_triangle(PointArray &points,\n+                                ColorArray &colors,\n+                                agg::trans_affine trans,\n+                                bool has_clippath);\n+\n+  private:\n     void create_alpha_buffers();\n \n     // prevent copying\n-    RendererAgg(const RendererAgg&);\n-    RendererAgg& operator=(const RendererAgg&);\n+    RendererAgg(const RendererAgg &);\n+    RendererAgg &operator=(const RendererAgg &);\n };\n \n-// the extension module\n-class _backend_agg_module : public Py::ExtensionModule<_backend_agg_module>\n+/***************************************************************************\n+ * Implementation\n+ */\n+\n+template <class path_t>\n+inline void\n+RendererAgg::_draw_path(path_t &path, bool has_clippath, const facepair_t &face, GCAgg &gc)\n+{\n+    typedef agg::conv_stroke<path_t> stroke_t;\n+    typedef agg::conv_dash<path_t> dash_t;\n+    typedef agg::conv_stroke<dash_t> stroke_dash_t;\n+    typedef agg::pixfmt_amask_adaptor<pixfmt, alpha_mask_type> pixfmt_amask_type;\n+    typedef agg::renderer_base<pixfmt_amask_type> amask_ren_type;\n+    typedef agg::renderer_scanline_aa_solid<amask_ren_type> amask_aa_renderer_type;\n+    typedef agg::renderer_scanline_bin_solid<amask_ren_type> amask_bin_renderer_type;\n+\n+    // Render face\n+    if (face.first) {\n+        theRasterizer.add_path(path);\n+\n+        if (gc.isaa) {\n+            if (has_clippath) {\n+                pixfmt_amask_type pfa(pixFmt, alphaMask);\n+                amask_ren_type r(pfa);\n+                amask_aa_renderer_type ren(r);\n+                ren.color(face.second);\n+                agg::render_scanlines(theRasterizer, scanlineAlphaMask, ren);\n+            } else {\n+                rendererAA.color(face.second);\n+                agg::render_scanlines(theRasterizer, slineP8, rendererAA);\n+            }\n+        } else {\n+            if (has_clippath) {\n+                pixfmt_amask_type pfa(pixFmt, alphaMask);\n+                amask_ren_type r(pfa);\n+                amask_bin_renderer_type ren(r);\n+                ren.color(face.second);\n+                agg::render_scanlines(theRasterizer, scanlineAlphaMask, ren);\n+            } else {\n+                rendererBin.color(face.second);\n+                agg::render_scanlines(theRasterizer, slineP8, rendererBin);\n+            }\n+        }\n+    }\n+\n+    // Render hatch\n+    if (gc.has_hatchpath()) {\n+        // Reset any clipping that may be in effect, since we'll be\n+        // drawing the hatch in a scratch buffer at origin (0, 0)\n+        theRasterizer.reset_clipping();\n+        rendererBase.reset_clipping(true);\n+\n+        // Create and transform the path\n+        typedef agg::conv_transform<py::PathIterator> hatch_path_trans_t;\n+        typedef agg::conv_curve<hatch_path_trans_t> hatch_path_curve_t;\n+        typedef agg::conv_stroke<hatch_path_curve_t> hatch_path_stroke_t;\n+\n+        py::PathIterator hatch_path(gc.hatchpath);\n+        agg::trans_affine hatch_trans;\n+        hatch_trans *= agg::trans_affine_scaling(1.0, -1.0);\n+        hatch_trans *= agg::trans_affine_translation(0.0, 1.0);\n+        hatch_trans *= agg::trans_affine_scaling(HATCH_SIZE, HATCH_SIZE);\n+        hatch_path_trans_t hatch_path_trans(hatch_path, hatch_trans);\n+        hatch_path_curve_t hatch_path_curve(hatch_path_trans);\n+        hatch_path_stroke_t hatch_path_stroke(hatch_path_curve);\n+        hatch_path_stroke.width(1.0);\n+        hatch_path_stroke.line_cap(agg::square_cap);\n+\n+        // Render the path into the hatch buffer\n+        pixfmt hatch_img_pixf(hatchRenderingBuffer);\n+        renderer_base rb(hatch_img_pixf);\n+        renderer_aa rs(rb);\n+        rb.clear(_fill_color);\n+        rs.color(gc.color);\n+\n+        theRasterizer.add_path(hatch_path_curve);\n+        agg::render_scanlines(theRasterizer, slineP8, rs);\n+        theRasterizer.add_path(hatch_path_stroke);\n+        agg::render_scanlines(theRasterizer, slineP8, rs);\n+\n+        // Put clipping back on, if originally set on entry to this\n+        // function\n+        set_clipbox(gc.cliprect, theRasterizer);\n+        if (has_clippath) {\n+            render_clippath(gc.clippath.path, gc.clippath.trans);\n+        }\n+\n+        // Transfer the hatch to the main image buffer\n+        typedef agg::image_accessor_wrap<pixfmt,\n+                                         agg::wrap_mode_repeat_auto_pow2,\n+                                         agg::wrap_mode_repeat_auto_pow2> img_source_type;\n+        typedef agg::span_pattern_rgba<img_source_type> span_gen_type;\n+        agg::span_allocator<agg::rgba8> sa;\n+        img_source_type img_src(hatch_img_pixf);\n+        span_gen_type sg(img_src, 0, 0);\n+        theRasterizer.add_path(path);\n+\n+        if (has_clippath) {\n+            pixfmt_amask_type pfa(pixFmt, alphaMask);\n+            amask_ren_type ren(pfa);\n+            agg::render_scanlines_aa(theRasterizer, slineP8, ren, sa, sg);\n+        } else {\n+            agg::render_scanlines_aa(theRasterizer, slineP8, rendererBase, sa, sg);\n+        }\n+    }\n+\n+    // Render stroke\n+    if (gc.linewidth != 0.0) {\n+        double linewidth = points_to_pixels(gc.linewidth);\n+        if (!gc.isaa) {\n+            linewidth = (linewidth < 0.5) ? 0.5 : mpl_round(linewidth);\n+        }\n+        if (gc.dashes.size() == 0) {\n+            stroke_t stroke(path);\n+            stroke.width(points_to_pixels(gc.linewidth));\n+            stroke.line_cap(gc.cap);\n+            stroke.line_join(gc.join);\n+            theRasterizer.add_path(stroke);\n+        } else {\n+            dash_t dash(path);\n+            gc.dashes.dash_to_stroke(dash, dpi, gc.isaa);\n+            stroke_dash_t stroke(dash);\n+            stroke.line_cap(gc.cap);\n+            stroke.line_join(gc.join);\n+            stroke.width(linewidth);\n+            theRasterizer.add_path(stroke);\n+        }\n+\n+        if (gc.isaa) {\n+            if (has_clippath) {\n+                pixfmt_amask_type pfa(pixFmt, alphaMask);\n+                amask_ren_type r(pfa);\n+                amask_aa_renderer_type ren(r);\n+                ren.color(gc.color);\n+                agg::render_scanlines(theRasterizer, scanlineAlphaMask, ren);\n+            } else {\n+                rendererAA.color(gc.color);\n+                agg::render_scanlines(theRasterizer, slineP8, rendererAA);\n+            }\n+        } else {\n+            if (has_clippath) {\n+                pixfmt_amask_type pfa(pixFmt, alphaMask);\n+                amask_ren_type r(pfa);\n+                amask_bin_renderer_type ren(r);\n+                ren.color(gc.color);\n+                agg::render_scanlines(theRasterizer, scanlineAlphaMask, ren);\n+            } else {\n+                rendererBin.color(gc.color);\n+                agg::render_scanlines(theRasterizer, slineBin, rendererBin);\n+            }\n+        }\n+    }\n+}\n+\n+template <class PathIterator>\n+inline void\n+RendererAgg::draw_path(GCAgg &gc, PathIterator &path, agg::trans_affine &trans, agg::rgba &color)\n+{\n+    typedef agg::conv_transform<py::PathIterator> transformed_path_t;\n+    typedef PathNanRemover<transformed_path_t> nan_removed_t;\n+    typedef PathClipper<nan_removed_t> clipped_t;\n+    typedef PathSnapper<clipped_t> snapped_t;\n+    typedef PathSimplifier<snapped_t> simplify_t;\n+    typedef agg::conv_curve<simplify_t> curve_t;\n+    typedef Sketch<curve_t> sketch_t;\n+\n+    facepair_t face(color.a != 0.0, color);\n+\n+    theRasterizer.reset_clipping();\n+    rendererBase.reset_clipping(true);\n+    set_clipbox(gc.cliprect, theRasterizer);\n+    bool has_clippath = render_clippath(gc.clippath.path, gc.clippath.trans);\n+\n+    trans *= agg::trans_affine_scaling(1.0, -1.0);\n+    trans *= agg::trans_affine_translation(0.0, (double)height);\n+    bool clip = !face.first && gc.has_hatchpath() && !path.has_curves();\n+    bool simplify = path.should_simplify() && clip;\n+    double snapping_linewidth = points_to_pixels(gc.linewidth);\n+    if (gc.color.a == 0.0) {\n+        snapping_linewidth = 0.0;\n+    }\n+\n+    transformed_path_t tpath(path, trans);\n+    nan_removed_t nan_removed(tpath, true, path.has_curves());\n+    clipped_t clipped(nan_removed, clip, width, height);\n+    snapped_t snapped(clipped, gc.snap_mode, path.total_vertices(), snapping_linewidth);\n+    simplify_t simplified(snapped, simplify, path.simplify_threshold());\n+    curve_t curve(simplified);\n+    sketch_t sketch(curve, gc.sketch.scale, gc.sketch.length, gc.sketch.randomness);\n+\n+    _draw_path(sketch, has_clippath, face, gc);\n+}\n+\n+template <class PathIterator>\n+inline void RendererAgg::draw_markers(GCAgg &gc,\n+                                      PathIterator &marker_path,\n+                                      agg::trans_affine &marker_trans,\n+                                      PathIterator &path,\n+                                      agg::trans_affine &trans,\n+                                      agg::rgba color)\n {\n-public:\n-    _backend_agg_module()\n-        : Py::ExtensionModule<_backend_agg_module>(\"_backend_agg\")\n+    typedef agg::conv_transform<py::PathIterator> transformed_path_t;\n+    typedef PathSnapper<transformed_path_t> snap_t;\n+    typedef agg::conv_curve<snap_t> curve_t;\n+    typedef agg::conv_stroke<curve_t> stroke_t;\n+    typedef agg::pixfmt_amask_adaptor<pixfmt, alpha_mask_type> pixfmt_amask_type;\n+    typedef agg::renderer_base<pixfmt_amask_type> amask_ren_type;\n+    typedef agg::renderer_scanline_aa_solid<amask_ren_type> amask_aa_renderer_type;\n+\n+    // Deal with the difference in y-axis direction\n+    marker_trans *= agg::trans_affine_scaling(1.0, -1.0);\n+    trans *= agg::trans_affine_scaling(1.0, -1.0);\n+    trans *= agg::trans_affine_translation(0.5, (double)height + 0.5);\n+\n+    transformed_path_t marker_path_transformed(marker_path, marker_trans);\n+    snap_t marker_path_snapped(marker_path_transformed,\n+                               gc.snap_mode,\n+                               marker_path.total_vertices(),\n+                               points_to_pixels(gc.linewidth));\n+    curve_t marker_path_curve(marker_path_snapped);\n+\n+    transformed_path_t path_transformed(path, trans);\n+    snap_t path_snapped(path_transformed, SNAP_FALSE, path.total_vertices(), 0.0);\n+    curve_t path_curve(path_snapped);\n+    path_curve.rewind(0);\n+\n+    facepair_t face(color.a != 0.0, color);\n+\n+    // maxim's suggestions for cached scanlines\n+    agg::scanline_storage_aa8 scanlines;\n+    theRasterizer.reset();\n+    theRasterizer.reset_clipping();\n+    rendererBase.reset_clipping(true);\n+\n+    agg::int8u staticFillCache[MARKER_CACHE_SIZE];\n+    agg::int8u staticStrokeCache[MARKER_CACHE_SIZE];\n+    agg::int8u *fillCache = staticFillCache;\n+    agg::int8u *strokeCache = staticStrokeCache;\n+\n+    try\n     {\n-        RendererAgg::init_type();\n-        BufferRegion::init_type();\n+        unsigned fillSize = 0;\n+        if (face.first) {\n+            theRasterizer.add_path(marker_path_curve);\n+            agg::render_scanlines(theRasterizer, slineP8, scanlines);\n+            fillSize = scanlines.byte_size();\n+            if (fillSize >= MARKER_CACHE_SIZE) {\n+                fillCache = new agg::int8u[fillSize];\n+            }\n+            scanlines.serialize(fillCache);\n+        }\n+\n+        stroke_t stroke(marker_path_curve);\n+        stroke.width(points_to_pixels(gc.linewidth));\n+        stroke.line_cap(gc.cap);\n+        stroke.line_join(gc.join);\n+        theRasterizer.reset();\n+        theRasterizer.add_path(stroke);\n+        agg::render_scanlines(theRasterizer, slineP8, scanlines);\n+        unsigned strokeSize = scanlines.byte_size();\n+        if (strokeSize >= MARKER_CACHE_SIZE) {\n+            strokeCache = new agg::int8u[strokeSize];\n+        }\n+        scanlines.serialize(strokeCache);\n+\n+        theRasterizer.reset_clipping();\n+        rendererBase.reset_clipping(true);\n+        set_clipbox(gc.cliprect, rendererBase);\n+        bool has_clippath = render_clippath(gc.clippath.path, gc.clippath.trans);\n \n-        add_keyword_method(\"RendererAgg\", &_backend_agg_module::new_renderer,\n-                           \"RendererAgg(width, height, dpi)\");\n-        initialize(\"The agg rendering backend\");\n+        double x, y;\n+\n+        agg::serialized_scanlines_adaptor_aa8 sa;\n+        agg::serialized_scanlines_adaptor_aa8::embedded_scanline sl;\n+\n+        agg::rect_d clipping_rect(-1.0 - scanlines.max_x(),\n+                                  -1.0 - scanlines.max_y(),\n+                                  1.0 + width - scanlines.min_x(),\n+                                  1.0 + height - scanlines.min_y());\n+\n+        if (has_clippath) {\n+            while (path_curve.vertex(&x, &y) != agg::path_cmd_stop) {\n+                if (MPL_notisfinite64(x) || MPL_notisfinite64(y)) {\n+                    continue;\n+                }\n+\n+                /* These values are correctly snapped above -- so we don't want\n+                   to round here, we really only want to truncate */\n+                x = floor(x);\n+                y = floor(y);\n+\n+                // Cull points outside the boundary of the image.\n+                // Values that are too large may overflow and create\n+                // segfaults.\n+                // http://sourceforge.net/tracker/?func=detail&aid=2865490&group_id=80706&atid=560720\n+                if (!clipping_rect.hit_test(x, y)) {\n+                    continue;\n+                }\n+\n+                pixfmt_amask_type pfa(pixFmt, alphaMask);\n+                amask_ren_type r(pfa);\n+                amask_aa_renderer_type ren(r);\n+\n+                if (face.first) {\n+                    ren.color(face.second);\n+                    sa.init(fillCache, fillSize, x, y);\n+                    agg::render_scanlines(sa, sl, ren);\n+                }\n+                ren.color(gc.color);\n+                sa.init(strokeCache, strokeSize, x, y);\n+                agg::render_scanlines(sa, sl, ren);\n+            }\n+        } else {\n+            while (path_curve.vertex(&x, &y) != agg::path_cmd_stop) {\n+                if (MPL_notisfinite64(x) || MPL_notisfinite64(y)) {\n+                    continue;\n+                }\n+\n+                /* These values are correctly snapped above -- so we don't want\n+                   to round here, we really only want to truncate */\n+                x = floor(x);\n+                y = floor(y);\n+\n+                // Cull points outside the boundary of the image.\n+                // Values that are too large may overflow and create\n+                // segfaults.\n+                // http://sourceforge.net/tracker/?func=detail&aid=2865490&group_id=80706&atid=560720\n+                if (!clipping_rect.hit_test(x, y)) {\n+                    continue;\n+                }\n+\n+                if (face.first) {\n+                    rendererAA.color(face.second);\n+                    sa.init(fillCache, fillSize, x, y);\n+                    agg::render_scanlines(sa, sl, rendererAA);\n+                }\n+\n+                rendererAA.color(gc.color);\n+                sa.init(strokeCache, strokeSize, x, y);\n+                agg::render_scanlines(sa, sl, rendererAA);\n+            }\n+        }\n+    }\n+    catch (...)\n+    {\n+        if (fillCache != staticFillCache)\n+            delete[] fillCache;\n+        if (strokeCache != staticStrokeCache)\n+            delete[] strokeCache;\n+        theRasterizer.reset_clipping();\n+        rendererBase.reset_clipping(true);\n+        throw;\n     }\n \n-    virtual ~_backend_agg_module() {}\n+    if (fillCache != staticFillCache)\n+        delete[] fillCache;\n+    if (strokeCache != staticStrokeCache)\n+        delete[] strokeCache;\n \n-private:\n+    theRasterizer.reset_clipping();\n+    rendererBase.reset_clipping(true);\n+}\n \n-    Py::Object new_renderer(const Py::Tuple &args, const Py::Dict &kws);\n+/**\n+ * This is a custom span generator that converts spans in the\n+ * 8-bit inverted greyscale font buffer to rgba that agg can use.\n+ */\n+template <class ChildGenerator>\n+class font_to_rgba\n+{\n+  public:\n+    typedef ChildGenerator child_type;\n+    typedef agg::rgba8 color_type;\n+    typedef typename child_type::color_type child_color_type;\n+    typedef agg::span_allocator<child_color_type> span_alloc_type;\n \n-    // prevent copying\n-    _backend_agg_module(const _backend_agg_module&);\n-    _backend_agg_module& operator=(const _backend_agg_module&);\n+  private:\n+    child_type *_gen;\n+    color_type _color;\n+    span_alloc_type _allocator;\n+\n+  public:\n+    font_to_rgba(child_type *gen, color_type color) : _gen(gen), _color(color)\n+    {\n+    }\n+\n+    inline void generate(color_type *output_span, int x, int y, unsigned len)\n+    {\n+        _allocator.allocate(len);\n+        child_color_type *input_span = _allocator.span();\n+        _gen->generate(input_span, x, y, len);\n+\n+        do {\n+            *output_span = _color;\n+            output_span->a = ((unsigned int)_color.a * (unsigned int)input_span->v) >> 8;\n+            ++output_span;\n+            ++input_span;\n+        } while (--len);\n+    }\n+\n+    void prepare()\n+    {\n+        _gen->prepare();\n+    }\n+};\n+\n+template <class ImageArray>\n+inline void RendererAgg::draw_text_image(GCAgg &gc, ImageArray &image, int x, int y, double angle)\n+{\n+    typedef agg::span_allocator<agg::rgba8> color_span_alloc_type;\n+    typedef agg::span_interpolator_linear<> interpolator_type;\n+    typedef agg::image_accessor_clip<agg::pixfmt_gray8> image_accessor_type;\n+    typedef agg::span_image_filter_gray<image_accessor_type, interpolator_type> image_span_gen_type;\n+    typedef font_to_rgba<image_span_gen_type> span_gen_type;\n+    typedef agg::renderer_scanline_aa<renderer_base, color_span_alloc_type, span_gen_type>\n+    renderer_type;\n+\n+    theRasterizer.reset_clipping();\n+    rendererBase.reset_clipping(true);\n+    set_clipbox(gc.cliprect, theRasterizer);\n+\n+    agg::rendering_buffer srcbuf(\n+        image.data(), (unsigned)image.dim(1), (unsigned)image.dim(0), (unsigned)image.dim(1));\n+    agg::pixfmt_gray8 pixf_img(srcbuf);\n+\n+    agg::trans_affine mtx;\n+    mtx *= agg::trans_affine_translation(0, -image.dim(0));\n+    mtx *= agg::trans_affine_rotation(-angle * agg::pi / 180.0);\n+    mtx *= agg::trans_affine_translation(x, y);\n+\n+    agg::path_storage rect;\n+    rect.move_to(0, 0);\n+    rect.line_to(image.dim(1), 0);\n+    rect.line_to(image.dim(1), image.dim(0));\n+    rect.line_to(0, image.dim(0));\n+    rect.line_to(0, 0);\n+    agg::conv_transform<agg::path_storage> rect2(rect, mtx);\n+\n+    agg::trans_affine inv_mtx(mtx);\n+    inv_mtx.invert();\n+\n+    agg::image_filter_lut filter;\n+    filter.calculate(agg::image_filter_spline36());\n+    interpolator_type interpolator(inv_mtx);\n+    color_span_alloc_type sa;\n+    image_accessor_type ia(pixf_img, 0);\n+    image_span_gen_type image_span_generator(ia, interpolator, filter);\n+    span_gen_type output_span_generator(&image_span_generator, gc.color);\n+    renderer_type ri(rendererBase, sa, output_span_generator);\n+\n+    theRasterizer.add_path(rect2);\n+    agg::render_scanlines(theRasterizer, slineP8, ri);\n+}\n+\n+class span_conv_alpha\n+{\n+  public:\n+    typedef agg::rgba8 color_type;\n+\n+    double m_alpha;\n+\n+    span_conv_alpha(double alpha) : m_alpha(alpha)\n+    {\n+    }\n+\n+    void prepare()\n+    {\n+    }\n+    void generate(color_type *span, int x, int y, unsigned len) const\n+    {\n+        do {\n+            span->a = (agg::int8u)((double)span->a * m_alpha);\n+            ++span;\n+        } while (--len);\n+    }\n+};\n+\n+template <class ImageArray>\n+inline void RendererAgg::draw_image(GCAgg &gc,\n+                                    double x,\n+                                    double y,\n+                                    ImageArray &image,\n+                                    double w,\n+                                    double h,\n+                                    agg::trans_affine trans,\n+                                    bool resize)\n+{\n+    double alpha = gc.alpha;\n+\n+    theRasterizer.reset_clipping();\n+    rendererBase.reset_clipping(true);\n+    set_clipbox(gc.cliprect, theRasterizer);\n+    bool has_clippath = render_clippath(gc.clippath.path, gc.clippath.trans);\n+\n+    agg::rendering_buffer buffer;\n+    buffer.attach(\n+        image.data(), (unsigned)image.dim(1), (unsigned)image.dim(0), -(int)image.dim(1) * 4);\n+    pixfmt pixf(buffer);\n+\n+    if (resize | has_clippath) {\n+        agg::trans_affine mtx;\n+        agg::path_storage rect;\n+\n+        if (resize) {\n+            mtx *= agg::trans_affine_scaling(1, -1);\n+            mtx *= agg::trans_affine_translation(0, image.dim(0));\n+            mtx *= agg::trans_affine_scaling(w / (image.dim(1)), h / (image.dim(0)));\n+            mtx *= agg::trans_affine_translation(x, y);\n+            mtx *= trans;\n+            mtx *= agg::trans_affine_scaling(1.0, -1.0);\n+            mtx *= agg::trans_affine_translation(0.0, (double)height);\n+        } else {\n+            mtx *= agg::trans_affine_translation((int)x, (int)(height - (y + image.dim(0))));\n+        }\n+\n+        rect.move_to(0, 0);\n+        rect.line_to(image.dim(1), 0);\n+        rect.line_to(image.dim(1), image.dim(0));\n+        rect.line_to(0, image.dim(0));\n+        rect.line_to(0, 0);\n+\n+        agg::conv_transform<agg::path_storage> rect2(rect, mtx);\n+\n+        agg::trans_affine inv_mtx(mtx);\n+        inv_mtx.invert();\n+\n+        typedef agg::span_allocator<agg::rgba8> color_span_alloc_type;\n+        typedef agg::image_accessor_clip<agg::pixfmt_rgba32_plain> image_accessor_type;\n+        typedef agg::span_interpolator_linear<> interpolator_type;\n+        typedef agg::span_image_filter_rgba_nn<image_accessor_type, interpolator_type>\n+        image_span_gen_type;\n+        typedef agg::span_converter<image_span_gen_type, span_conv_alpha> span_conv;\n+\n+        color_span_alloc_type sa;\n+        image_accessor_type ia(pixf, agg::rgba8(0, 0, 0, 0));\n+        interpolator_type interpolator(inv_mtx);\n+        image_span_gen_type image_span_generator(ia, interpolator);\n+        span_conv_alpha conv_alpha(alpha);\n+        span_conv spans(image_span_generator, conv_alpha);\n+\n+        if (has_clippath) {\n+            typedef agg::pixfmt_amask_adaptor<pixfmt, alpha_mask_type> pixfmt_amask_type;\n+            typedef agg::renderer_base<pixfmt_amask_type> amask_ren_type;\n+            typedef agg::renderer_scanline_aa<amask_ren_type, color_span_alloc_type, span_conv>\n+            renderer_type_alpha;\n+\n+            pixfmt_amask_type pfa(pixFmt, alphaMask);\n+            amask_ren_type r(pfa);\n+            renderer_type_alpha ri(r, sa, spans);\n+\n+            theRasterizer.add_path(rect2);\n+            agg::render_scanlines(theRasterizer, scanlineAlphaMask, ri);\n+        } else {\n+            typedef agg::renderer_base<pixfmt> ren_type;\n+            typedef agg::renderer_scanline_aa<ren_type, color_span_alloc_type, span_conv>\n+            renderer_type;\n+\n+            ren_type r(pixFmt);\n+            renderer_type ri(r, sa, spans);\n+\n+            theRasterizer.add_path(rect2);\n+            agg::render_scanlines(theRasterizer, slineP8, ri);\n+        }\n+\n+    } else {\n+        set_clipbox(gc.cliprect, rendererBase);\n+        rendererBase.blend_from(\n+            pixf, 0, (int)x, (int)(height - (y + image.dim(0))), (agg::int8u)(alpha * 255));\n+    }\n+\n+    rendererBase.reset_clipping(true);\n+}\n+\n+template <class PathIterator,\n+          class PathGenerator,\n+          class TransformArray,\n+          class OffsetArray,\n+          class ColorArray,\n+          class LineWidthArray,\n+          class AntialiasedArray>\n+inline void RendererAgg::_draw_path_collection_generic(GCAgg &gc,\n+                                                       agg::trans_affine master_transform,\n+                                                       const agg::rect_d &cliprect,\n+                                                       PathIterator &clippath,\n+                                                       const agg::trans_affine &clippath_trans,\n+                                                       PathGenerator &path_generator,\n+                                                       TransformArray &transforms,\n+                                                       OffsetArray &offsets,\n+                                                       const agg::trans_affine &offset_trans,\n+                                                       ColorArray &facecolors,\n+                                                       ColorArray &edgecolors,\n+                                                       LineWidthArray &linewidths,\n+                                                       DashesVector &linestyles,\n+                                                       AntialiasedArray &antialiaseds,\n+                                                       e_offset_position offset_position,\n+                                                       int check_snap,\n+                                                       int has_curves)\n+{\n+    typedef agg::conv_transform<typename PathGenerator::path_iterator> transformed_path_t;\n+    typedef PathNanRemover<transformed_path_t> nan_removed_t;\n+    typedef PathClipper<nan_removed_t> clipped_t;\n+    typedef PathSnapper<clipped_t> snapped_t;\n+    typedef agg::conv_curve<snapped_t> snapped_curve_t;\n+    typedef agg::conv_curve<clipped_t> curve_t;\n+\n+    if (offsets.dim(0) != 0 && offsets.dim(1) != 2) {\n+        throw \"Offsets array must be Nx2 or empty\";\n+    }\n+\n+    if (facecolors.dim(0) != 0 && facecolors.dim(1) != 4) {\n+        throw \"Facecolors array must be a Nx4 array or empty\";\n+    }\n+\n+    if (edgecolors.dim(0) != 0 && edgecolors.dim(1) != 4) {\n+        throw \"Edgecolors array must by Nx4 or empty\";\n+    }\n+\n+    if (transforms.dim(0) != 0 && (transforms.dim(1) != 3 || transforms.dim(2) != 3)) {\n+        throw \"Transforms array must by Nx3x3 or empty\";\n+    }\n+\n+    size_t Npaths = path_generator.num_paths();\n+    size_t Noffsets = offsets.size();\n+    size_t N = std::max(Npaths, Noffsets);\n+\n+    size_t Ntransforms = transforms.size();\n+    size_t Nfacecolors = facecolors.size();\n+    size_t Nedgecolors = edgecolors.size();\n+    size_t Nlinewidths = linewidths.size();\n+    size_t Nlinestyles = std::min(linestyles.size(), N);\n+    size_t Naa = antialiaseds.size();\n+\n+    if ((Nfacecolors == 0 && Nedgecolors == 0) || Npaths == 0) {\n+        return;\n+    }\n+\n+    // Handle any clipping globally\n+    theRasterizer.reset_clipping();\n+    rendererBase.reset_clipping(true);\n+    set_clipbox(cliprect, theRasterizer);\n+    bool has_clippath = render_clippath(clippath, clippath_trans);\n+\n+    // Set some defaults, assuming no face or edge\n+    gc.linewidth = 0.0;\n+    facepair_t face;\n+    face.first = Nfacecolors != 0;\n+    agg::trans_affine trans;\n+\n+    for (int i = 0; i < (int)N; ++i) {\n+        typename PathGenerator::path_iterator path = path_generator(i);\n+\n+        if (Ntransforms) {\n+            typename TransformArray::sub_t subtrans = transforms[i % Ntransforms];\n+            trans = agg::trans_affine(subtrans(0, 0),\n+                                      subtrans(1, 0),\n+                                      subtrans(0, 1),\n+                                      subtrans(1, 1),\n+                                      subtrans(0, 2),\n+                                      subtrans(1, 2));\n+        } else {\n+            trans = master_transform;\n+        }\n+\n+        if (Noffsets) {\n+            double xo = offsets(i % Noffsets, 0);\n+            double yo = offsets(i % Noffsets, 1);\n+            offset_trans.transform(&xo, &yo);\n+            if (offset_position == OFFSET_POSITION_DATA) {\n+                trans = agg::trans_affine_translation(xo, yo) * trans;\n+            } else {\n+                trans *= agg::trans_affine_translation(xo, yo);\n+            }\n+        }\n+\n+        // These transformations must be done post-offsets\n+        trans *= agg::trans_affine_scaling(1.0, -1.0);\n+        trans *= agg::trans_affine_translation(0.0, (double)height);\n+\n+        if (Nfacecolors) {\n+            typename ColorArray::sub_t facecolor = facecolors[i % Nfacecolors];\n+            face.second = agg::rgba(facecolor(0), facecolor(1), facecolor(2), facecolor(3));\n+        }\n+\n+        if (Nedgecolors) {\n+            typename ColorArray::sub_t edgecolor = edgecolors[i % Nedgecolors];\n+            gc.color = agg::rgba(edgecolor(0), edgecolor(1), edgecolor(2), edgecolor(3));\n+\n+            if (Nlinewidths) {\n+                gc.linewidth = linewidths(i % Nlinewidths);\n+            } else {\n+                gc.linewidth = 1.0;\n+            }\n+            if (Nlinestyles) {\n+                gc.dashes = linestyles[i % Nlinestyles];\n+            }\n+        }\n+\n+        bool do_clip = !face.first && !gc.has_hatchpath() && !has_curves;\n+\n+        if (check_snap) {\n+            gc.isaa = antialiaseds(i % Naa);\n+\n+            transformed_path_t tpath(path, trans);\n+            nan_removed_t nan_removed(tpath, true, has_curves);\n+            clipped_t clipped(nan_removed, do_clip, width, height);\n+            snapped_t snapped(\n+                clipped, gc.snap_mode, path.total_vertices(), points_to_pixels(gc.linewidth));\n+            if (has_curves) {\n+                snapped_curve_t curve(snapped);\n+                _draw_path(curve, has_clippath, face, gc);\n+            } else {\n+                _draw_path(snapped, has_clippath, face, gc);\n+            }\n+        } else {\n+            gc.isaa = antialiaseds(i % Naa);\n+\n+            transformed_path_t tpath(path, trans);\n+            nan_removed_t nan_removed(tpath, true, has_curves);\n+            clipped_t clipped(nan_removed, do_clip, width, height);\n+            if (has_curves) {\n+                curve_t curve(clipped);\n+                _draw_path(curve, has_clippath, face, gc);\n+            } else {\n+                _draw_path(clipped, has_clippath, face, gc);\n+            }\n+        }\n+    }\n+}\n+\n+template <class PathGenerator,\n+          class TransformArray,\n+          class OffsetArray,\n+          class ColorArray,\n+          class LineWidthArray,\n+          class AntialiasedArray>\n+inline void RendererAgg::draw_path_collection(GCAgg &gc,\n+                                              agg::trans_affine &master_transform,\n+                                              PathGenerator &path,\n+                                              TransformArray &transforms,\n+                                              OffsetArray &offsets,\n+                                              agg::trans_affine &offset_trans,\n+                                              ColorArray &facecolors,\n+                                              ColorArray &edgecolors,\n+                                              LineWidthArray &linewidths,\n+                                              DashesVector &linestyles,\n+                                              AntialiasedArray &antialiaseds,\n+                                              e_offset_position offset_position)\n+{\n+    _draw_path_collection_generic(gc,\n+                                  master_transform,\n+                                  gc.cliprect,\n+                                  gc.clippath.path,\n+                                  gc.clippath.trans,\n+                                  path,\n+                                  transforms,\n+                                  offsets,\n+                                  offset_trans,\n+                                  facecolors,\n+                                  edgecolors,\n+                                  linewidths,\n+                                  linestyles,\n+                                  antialiaseds,\n+                                  offset_position,\n+                                  1,\n+                                  1);\n+}\n+\n+template <class CoordinateArray>\n+class QuadMeshGenerator\n+{\n+    unsigned m_meshWidth;\n+    unsigned m_meshHeight;\n+    CoordinateArray m_coordinates;\n+\n+    class QuadMeshPathIterator\n+    {\n+        unsigned m_iterator;\n+        unsigned m_m, m_n;\n+        const CoordinateArray *m_coordinates;\n+\n+      public:\n+        QuadMeshPathIterator(unsigned m, unsigned n, const CoordinateArray *coordinates)\n+            : m_iterator(0), m_m(m), m_n(n), m_coordinates(coordinates)\n+        {\n+        }\n+\n+      private:\n+        inline unsigned vertex(unsigned idx, double *x, double *y)\n+        {\n+            size_t m = m_m + ((idx & 0x2) >> 1);\n+            size_t n = m_n + (((idx + 1) & 0x2) >> 1);\n+            *x = (*m_coordinates)(n, m, 0);\n+            *y = (*m_coordinates)(n, m, 1);\n+            return (idx) ? agg::path_cmd_line_to : agg::path_cmd_move_to;\n+        }\n+\n+      public:\n+        inline unsigned vertex(double *x, double *y)\n+        {\n+            if (m_iterator >= total_vertices()) {\n+                return agg::path_cmd_stop;\n+            }\n+            return vertex(m_iterator++, x, y);\n+        }\n+\n+        inline void rewind(unsigned path_id)\n+        {\n+            m_iterator = path_id;\n+        }\n+\n+        inline unsigned total_vertices()\n+        {\n+            return 5;\n+        }\n+\n+        inline bool should_simplify()\n+        {\n+            return false;\n+        }\n+    };\n+\n+  public:\n+    typedef QuadMeshPathIterator path_iterator;\n+\n+    inline QuadMeshGenerator(unsigned meshWidth, unsigned meshHeight, CoordinateArray &coordinates)\n+        : m_meshWidth(meshWidth), m_meshHeight(meshHeight), m_coordinates(coordinates)\n+    {\n+    }\n+\n+    inline size_t num_paths() const\n+    {\n+        return m_meshWidth * m_meshHeight;\n+    }\n+\n+    inline path_iterator operator()(size_t i) const\n+    {\n+        return QuadMeshPathIterator(i % m_meshWidth, i / m_meshWidth, &m_coordinates);\n+    }\n };\n \n+template <class CoordinateArray, class OffsetArray, class ColorArray>\n+inline void RendererAgg::draw_quad_mesh(GCAgg &gc,\n+                                        agg::trans_affine &master_transform,\n+                                        size_t mesh_width,\n+                                        size_t mesh_height,\n+                                        CoordinateArray &coordinates,\n+                                        OffsetArray &offsets,\n+                                        agg::trans_affine &offset_trans,\n+                                        ColorArray &facecolors,\n+                                        bool antialiased,\n+                                        ColorArray &edgecolors)\n+{\n+    QuadMeshGenerator<CoordinateArray> path_generator(mesh_width, mesh_height, coordinates);\n+\n+    array::empty<double> transforms;\n+    array::scalar<double, 1> linewidths(points_to_pixels(gc.linewidth));\n+    array::scalar<uint8_t, 1> antialiaseds(antialiased);\n+    DashesVector linestyles;\n+    ColorArray *edgecolors_ptr = &edgecolors;\n+\n+    if (edgecolors.size() == 0) {\n+        if (antialiased) {\n+            edgecolors_ptr = &facecolors;\n+        }\n+    }\n \n+    _draw_path_collection_generic(gc,\n+                                  master_transform,\n+                                  gc.cliprect,\n+                                  gc.clippath.path,\n+                                  gc.clippath.trans,\n+                                  path_generator,\n+                                  transforms,\n+                                  offsets,\n+                                  offset_trans,\n+                                  facecolors,\n+                                  *edgecolors_ptr,\n+                                  linewidths,\n+                                  linestyles,\n+                                  antialiaseds,\n+                                  OFFSET_POSITION_FIGURE,\n+                                  0,\n+                                  0);\n+}\n+\n+template <class PointArray, class ColorArray>\n+inline void RendererAgg::_draw_gouraud_triangle(PointArray &points,\n+                                                ColorArray &colors,\n+                                                agg::trans_affine trans,\n+                                                bool has_clippath)\n+{\n+    typedef agg::rgba8 color_t;\n+    typedef agg::span_gouraud_rgba<color_t> span_gen_t;\n+    typedef agg::span_allocator<color_t> span_alloc_t;\n+\n+    trans *= agg::trans_affine_scaling(1.0, -1.0);\n+    trans *= agg::trans_affine_translation(0.0, (double)height);\n+\n+    double tpoints[3][2];\n+\n+    for (int i = 0; i < 3; ++i) {\n+        for (int j = 0; j < 2; ++j) {\n+            tpoints[i][j] = points(i, j);\n+        }\n+        trans.transform(&tpoints[i][0], &tpoints[i][1]);\n+    }\n+\n+    span_alloc_t span_alloc;\n+    span_gen_t span_gen;\n+\n+    span_gen.colors(agg::rgba(colors(0, 0), colors(0, 1), colors(0, 2), colors(0, 3)),\n+                    agg::rgba(colors(1, 0), colors(1, 1), colors(1, 2), colors(1, 3)),\n+                    agg::rgba(colors(2, 0), colors(2, 1), colors(2, 2), colors(2, 3)));\n+    span_gen.triangle(tpoints[0][0],\n+                      tpoints[0][1],\n+                      tpoints[1][0],\n+                      tpoints[1][1],\n+                      tpoints[2][0],\n+                      tpoints[2][1],\n+                      0.5);\n+\n+    theRasterizer.add_path(span_gen);\n+\n+    if (has_clippath) {\n+        typedef agg::pixfmt_amask_adaptor<pixfmt, alpha_mask_type> pixfmt_amask_type;\n+        typedef agg::renderer_base<pixfmt_amask_type> amask_ren_type;\n+        typedef agg::renderer_scanline_aa<amask_ren_type, span_alloc_t, span_gen_t>\n+        amask_aa_renderer_type;\n+\n+        pixfmt_amask_type pfa(pixFmt, alphaMask);\n+        amask_ren_type r(pfa);\n+        amask_aa_renderer_type ren(r, span_alloc, span_gen);\n+        agg::render_scanlines(theRasterizer, scanlineAlphaMask, ren);\n+    } else {\n+        agg::render_scanlines_aa(theRasterizer, slineP8, rendererBase, span_alloc, span_gen);\n+    }\n+}\n+\n+template <class PointArray, class ColorArray>\n+inline void RendererAgg::draw_gouraud_triangle(GCAgg &gc,\n+                                               PointArray &points,\n+                                               ColorArray &colors,\n+                                               agg::trans_affine &trans)\n+{\n+    theRasterizer.reset_clipping();\n+    rendererBase.reset_clipping(true);\n+    set_clipbox(gc.cliprect, theRasterizer);\n+    bool has_clippath = render_clippath(gc.clippath.path, gc.clippath.trans);\n+\n+    if (points.dim(0) != 3 || points.dim(1) != 2) {\n+        throw \"points must be a 3x2 array\";\n+    }\n+\n+    if (colors.dim(0) != 3 || colors.dim(1) != 4) {\n+        throw \"colors must be a 3x4 array\";\n+    }\n+\n+    _draw_gouraud_triangle(points, colors, trans, has_clippath);\n+}\n+\n+template <class PointArray, class ColorArray>\n+inline void RendererAgg::draw_gouraud_triangles(GCAgg &gc,\n+                                                PointArray &points,\n+                                                ColorArray &colors,\n+                                                agg::trans_affine &trans)\n+{\n+    theRasterizer.reset_clipping();\n+    rendererBase.reset_clipping(true);\n+    set_clipbox(gc.cliprect, theRasterizer);\n+    bool has_clippath = render_clippath(gc.clippath.path, gc.clippath.trans);\n+\n+    if (points.dim(1) != 3 || points.dim(2) != 2) {\n+        throw \"points must be a Nx3x2 array\";\n+    }\n+\n+    if (colors.dim(1) != 3 || colors.dim(2) != 4) {\n+        throw \"colors must be a Nx3x4 array\";\n+    }\n+\n+    if (points.dim(0) != colors.dim(0)) {\n+        throw \"points and colors arrays must be the same length\";\n+    }\n+\n+    for (int i = 0; i < points.dim(0); ++i) {\n+        typename PointArray::sub_t point = points[i];\n+        typename ColorArray::sub_t color = colors[i];\n+\n+        _draw_gouraud_triangle(point, color, trans, has_clippath);\n+    }\n+}\n+\n+template <class R>\n+void RendererAgg::set_clipbox(const agg::rect_d &cliprect, R &rasterizer)\n+{\n+    // set the clip rectangle from the gc\n+\n+    if (cliprect.x1 != 0.0 || cliprect.y1 != 0.0 || cliprect.x2 != 0.0 || cliprect.y2 != 0.0) {\n+        rasterizer.clip_box(std::max(int(floor(cliprect.x1 + 0.5)), 0),\n+                            std::max(int(floor(height - cliprect.y1 + 0.5)), 0),\n+                            std::min(int(floor(cliprect.x2 + 0.5)), int(width)),\n+                            std::min(int(floor(height - cliprect.y2 + 0.5)), int(height)));\n+    } else {\n+        rasterizer.clip_box(0, 0, width, height);\n+    }\n+}\n \n #endif"
            },
            {
                "sha": "cea2b7e14f0f58da4b9ce3b9220b700bb2f779d1",
                "filename": "src/_backend_agg_basic_types.h",
                "status": "added",
                "additions": 124,
                "deletions": 0,
                "changes": 124,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_backend_agg_basic_types.h",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_backend_agg_basic_types.h",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/src%2F_backend_agg_basic_types.h?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787",
                "patch": "@@ -0,0 +1,124 @@\n+#ifndef __BACKEND_AGG_BASIC_TYPES_H__\n+#define __BACKEND_AGG_BASIC_TYPES_H__\n+\n+/* Contains some simple types from the Agg backend that are also used\n+   by other modules */\n+\n+#include <vector>\n+\n+#include \"agg_color_rgba.h\"\n+#include \"agg_math_stroke.h\"\n+#include \"path_converters.h\"\n+\n+#include \"py_adaptors.h\"\n+\n+struct ClipPath\n+{\n+    py::PathIterator path;\n+    agg::trans_affine trans;\n+};\n+\n+struct SketchParams\n+{\n+    double scale;\n+    double length;\n+    double randomness;\n+};\n+\n+class Dashes\n+{\n+    typedef std::vector<std::pair<double, double> > dash_t;\n+    double dash_offset;\n+    dash_t dashes;\n+\n+  public:\n+    double get_dash_offset() const\n+    {\n+        return dash_offset;\n+    }\n+    void set_dash_offset(double x)\n+    {\n+        dash_offset = x;\n+    }\n+    void add_dash_pair(double length, double skip)\n+    {\n+        dashes.push_back(std::make_pair(length, skip));\n+    }\n+    size_t size() const\n+    {\n+        return dashes.size();\n+    }\n+\n+    template <class T>\n+    void dash_to_stroke(T &stroke, double dpi, bool isaa)\n+    {\n+        for (dash_t::const_iterator i = dashes.begin(); i != dashes.end(); ++i) {\n+            double val0 = i->first;\n+            double val1 = i->second;\n+            val0 = val0 * dpi / 72.0;\n+            val1 = val1 * dpi / 72.0;\n+            if (!isaa) {\n+                val0 = (int)val0 + 0.5;\n+                val1 = (int)val1 + 0.5;\n+            }\n+            stroke.add_dash(val0, val1);\n+        }\n+    }\n+};\n+\n+typedef std::vector<Dashes> DashesVector;\n+\n+enum e_offset_position {\n+    OFFSET_POSITION_FIGURE,\n+    OFFSET_POSITION_DATA\n+};\n+\n+class GCAgg\n+{\n+  public:\n+    GCAgg()\n+        : linewidth(1.0),\n+          alpha(1.0),\n+          cap(agg::butt_cap),\n+          join(agg::round_join),\n+          snap_mode(SNAP_FALSE)\n+    {\n+    }\n+\n+    ~GCAgg()\n+    {\n+    }\n+\n+    double linewidth;\n+    double alpha;\n+    bool forced_alpha;\n+    agg::rgba color;\n+    bool isaa;\n+\n+    agg::line_cap_e cap;\n+    agg::line_join_e join;\n+\n+    agg::rect_d cliprect;\n+\n+    ClipPath clippath;\n+\n+    Dashes dashes;\n+\n+    e_snap_mode snap_mode;\n+\n+    py::PathIterator hatchpath;\n+\n+    SketchParams sketch;\n+\n+    bool has_hatchpath()\n+    {\n+        return hatchpath.total_vertices();\n+    }\n+\n+  private:\n+    // prevent copying\n+    GCAgg(const GCAgg &);\n+    GCAgg &operator=(const GCAgg &);\n+};\n+\n+#endif"
            },
            {
                "sha": "1e9b62e3b31dc26b6f203e54dd30d35eab529933",
                "filename": "src/_backend_agg_wrapper.cpp",
                "status": "added",
                "additions": 730,
                "deletions": 0,
                "changes": 730,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_backend_agg_wrapper.cpp",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_backend_agg_wrapper.cpp",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/src%2F_backend_agg_wrapper.cpp?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787",
                "patch": "@@ -0,0 +1,730 @@\n+#include \"_backend_agg_wrapper.h\"\n+\n+/**********************************************************************\n+ * BufferRegion\n+ * */\n+\n+static PyObject *PyBufferRegion_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n+{\n+    PyBufferRegion *self;\n+    self = (PyBufferRegion *)type->tp_alloc(type, 0);\n+    self->x = NULL;\n+    return (PyObject *)self;\n+}\n+\n+static void PyBufferRegion_dealloc(PyBufferRegion *self)\n+{\n+    delete self->x;\n+    Py_TYPE(self)->tp_free((PyObject *)self);\n+}\n+\n+static PyObject *PyBufferRegion_to_string(PyBufferRegion *self, PyObject *args, PyObject *kwds)\n+{\n+    return PyBytes_FromStringAndSize((const char *)self->x->get_data(),\n+                                     self->x->get_height() * self->x->get_stride());\n+}\n+\n+/* TODO: This doesn't seem to be used internally.  Remove? */\n+\n+static PyObject *PyBufferRegion_set_x(PyBufferRegion *self, PyObject *args, PyObject *kwds)\n+{\n+    int x;\n+    if (!PyArg_ParseTuple(args, \"i:set_x\", &x)) {\n+        return NULL;\n+    }\n+    self->x->get_rect().x1 = x;\n+\n+    Py_RETURN_NONE;\n+}\n+\n+static PyObject *PyBufferRegion_set_y(PyBufferRegion *self, PyObject *args, PyObject *kwds)\n+{\n+    int y;\n+    if (!PyArg_ParseTuple(args, \"i:set_y\", &y)) {\n+        return NULL;\n+    }\n+    self->x->get_rect().y1 = y;\n+\n+    Py_RETURN_NONE;\n+}\n+\n+static PyObject *PyBufferRegion_get_extents(PyBufferRegion *self, PyObject *args, PyObject *kwds)\n+{\n+    agg::rect_i rect = self->x->get_rect();\n+\n+    return Py_BuildValue(\"IIII\", rect.x1, rect.y1, rect.x2, rect.y2);\n+}\n+\n+static PyObject *PyBufferRegion_to_string_argb(PyBufferRegion *self, PyObject *args, PyObject *kwds)\n+{\n+    PyObject *bufobj;\n+    uint8_t *buf;\n+\n+    bufobj = PyBytes_FromStringAndSize(NULL, self->x->get_height() * self->x->get_stride());\n+    buf = (uint8_t *)PyBytes_AS_STRING(bufobj);\n+\n+    CALL_CPP_CLEANUP(\"to_string_argb\", (self->x->to_string_argb(buf)), Py_DECREF(bufobj));\n+\n+    return bufobj;\n+}\n+\n+int PyBufferRegion_get_buffer(PyBufferRegion *self, Py_buffer *buf, int flags)\n+{\n+    Py_INCREF(self);\n+    buf->obj = (PyObject *)self;\n+    buf->buf = self->x->get_data();\n+    buf->len = self->x->get_width() * self->x->get_height() * 4;\n+    buf->readonly = 0;\n+    buf->format = (char *)\"B\";\n+    buf->ndim = 3;\n+    self->shape[0] = self->x->get_height();\n+    self->shape[1] = self->x->get_width();\n+    self->shape[2] = 4;\n+    buf->shape = self->shape;\n+    self->strides[0] = self->x->get_width() * 4;\n+    self->strides[1] = 4;\n+    self->strides[2] = 1;\n+    buf->strides = self->strides;\n+    buf->suboffsets = NULL;\n+    buf->itemsize = 1;\n+    buf->internal = NULL;\n+\n+    return 1;\n+}\n+\n+static PyTypeObject PyBufferRegionType;\n+\n+static PyTypeObject *PyBufferRegion_init_type(PyObject *m, PyTypeObject *type)\n+{\n+    static PyMethodDef methods[] = {\n+        { \"to_string\", (PyCFunction)PyBufferRegion_to_string, METH_NOARGS, NULL },\n+        { \"to_string_argb\", (PyCFunction)PyBufferRegion_to_string_argb, METH_NOARGS, NULL },\n+        { \"set_x\", (PyCFunction)PyBufferRegion_set_x, METH_VARARGS, NULL },\n+        { \"set_y\", (PyCFunction)PyBufferRegion_set_y, METH_VARARGS, NULL },\n+        { \"get_extents\", (PyCFunction)PyBufferRegion_get_extents, METH_NOARGS, NULL },\n+        { NULL }\n+    };\n+\n+    static PyBufferProcs buffer_procs;\n+    memset(&buffer_procs, 0, sizeof(PyBufferProcs));\n+    buffer_procs.bf_getbuffer = (getbufferproc)PyBufferRegion_get_buffer;\n+\n+    memset(type, 0, sizeof(PyTypeObject));\n+    type->tp_name = \"matplotlib.backends._backend_agg.BufferRegion\";\n+    type->tp_basicsize = sizeof(PyBufferRegion);\n+    type->tp_dealloc = (destructor)PyBufferRegion_dealloc;\n+    type->tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_NEWBUFFER;\n+    type->tp_methods = methods;\n+    type->tp_new = PyBufferRegion_new;\n+    type->tp_as_buffer = &buffer_procs;\n+\n+    if (PyType_Ready(type) < 0) {\n+        return NULL;\n+    }\n+\n+    /* Don't need to add to module, since you can't create buffer\n+       regions directly from Python */\n+\n+    return type;\n+}\n+\n+/**********************************************************************\n+ * RendererAgg\n+ * */\n+\n+static PyObject *PyRendererAgg_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n+{\n+    PyRendererAgg *self;\n+    self = (PyRendererAgg *)type->tp_alloc(type, 0);\n+    self->x = NULL;\n+    return (PyObject *)self;\n+}\n+\n+static int PyRendererAgg_init(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n+{\n+    unsigned int width;\n+    unsigned int height;\n+    double dpi;\n+    int debug = 0;\n+\n+    if (!PyArg_ParseTuple(args, \"IId|i:RendererAgg\", &width, &height, &dpi, &debug)) {\n+        return -1;\n+    }\n+\n+    if (dpi <= 0.0) {\n+        PyErr_SetString(PyExc_ValueError, \"dpi must be positive\");\n+        return -1;\n+    }\n+\n+    CALL_CPP_INIT(\"RendererAgg\", self->x = new RendererAgg(width, height, dpi))\n+\n+    return 0;\n+}\n+\n+static void PyRendererAgg_dealloc(PyRendererAgg *self)\n+{\n+    delete self->x;\n+    Py_TYPE(self)->tp_free((PyObject *)self);\n+}\n+\n+static PyObject *PyRendererAgg_draw_path(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n+{\n+    GCAgg gc;\n+    py::PathIterator path;\n+    agg::trans_affine trans;\n+    PyObject *faceobj = NULL;\n+    agg::rgba face;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"O&O&O&|O:draw_path\",\n+                          &convert_gcagg,\n+                          &gc,\n+                          &convert_path,\n+                          &path,\n+                          &convert_trans_affine,\n+                          &trans,\n+                          &faceobj)) {\n+        return NULL;\n+    }\n+\n+    if (!convert_face(faceobj, gc, &face)) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP(\"draw_path\", (self->x->draw_path(gc, path, trans, face)));\n+\n+    Py_RETURN_NONE;\n+}\n+\n+static PyObject *PyRendererAgg_draw_text_image(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n+{\n+    numpy::array_view<agg::int8u, 2> image;\n+    double x;\n+    double y;\n+    double angle;\n+    GCAgg gc;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"O&dddO&:draw_text_image\",\n+                          &numpy::convert_array_contiguous<agg::int8u, 2>,\n+                          &image,\n+                          &x,\n+                          &y,\n+                          &angle,\n+                          &convert_gcagg,\n+                          &gc)) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP(\"draw_text_image\", (self->x->draw_text_image(gc, image, x, y, angle)));\n+\n+    Py_RETURN_NONE;\n+}\n+\n+PyObject *PyRendererAgg_draw_markers(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n+{\n+    GCAgg gc;\n+    py::PathIterator marker_path;\n+    agg::trans_affine marker_path_trans;\n+    py::PathIterator path;\n+    agg::trans_affine trans;\n+    PyObject *faceobj = NULL;\n+    agg::rgba face;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"O&O&O&O&O&|O:draw_markers\",\n+                          &convert_gcagg,\n+                          &gc,\n+                          &convert_path,\n+                          &marker_path,\n+                          &convert_trans_affine,\n+                          &marker_path_trans,\n+                          &convert_path,\n+                          &path,\n+                          &convert_trans_affine,\n+                          &trans,\n+                          &faceobj)) {\n+        return NULL;\n+    }\n+\n+    if (!convert_face(faceobj, gc, &face)) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP(\"draw_markers\",\n+             (self->x->draw_markers(gc, marker_path, marker_path_trans, path, trans, face)));\n+\n+    Py_RETURN_NONE;\n+}\n+\n+static PyObject *PyRendererAgg_draw_image(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n+{\n+    GCAgg gc;\n+    double x;\n+    double y;\n+    numpy::array_view<agg::int8u, 3> image;\n+    double w = 0;\n+    double h = 0;\n+    agg::trans_affine trans;\n+    bool resize = false;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"O&ddO&|ddO&:draw_image\",\n+                          &convert_gcagg,\n+                          &gc,\n+                          &x,\n+                          &y,\n+                          &numpy::convert_array_contiguous<agg::int8u, 3>,\n+                          &image,\n+                          &w,\n+                          &h,\n+                          &convert_trans_affine,\n+                          &trans)) {\n+        return NULL;\n+    }\n+\n+    if (PyTuple_Size(args) == 4) {\n+        x = mpl_round(x);\n+        y = mpl_round(y);\n+    } else {\n+        resize = true;\n+    }\n+\n+    CALL_CPP(\"draw_image\", (self->x->draw_image(gc, x, y, image, w, h, trans, resize)));\n+\n+    Py_RETURN_NONE;\n+}\n+\n+static PyObject *\n+PyRendererAgg_draw_path_collection(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n+{\n+    GCAgg gc;\n+    agg::trans_affine master_transform;\n+    PyObject *pathobj;\n+    numpy::array_view<const double, 3> transforms;\n+    numpy::array_view<const double, 2> offsets;\n+    agg::trans_affine offset_trans;\n+    numpy::array_view<const double, 2> facecolors;\n+    numpy::array_view<const double, 2> edgecolors;\n+    numpy::array_view<const double, 1> linewidths;\n+    DashesVector dashes;\n+    numpy::array_view<const uint8_t, 1> antialiaseds;\n+    PyObject *ignored;\n+    e_offset_position offset_position;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"O&O&OO&O&O&O&O&O&O&O&OO&:draw_path_collection\",\n+                          &convert_gcagg,\n+                          &gc,\n+                          &convert_trans_affine,\n+                          &master_transform,\n+                          &pathobj,\n+                          &numpy::convert_array<const double, 3>,\n+                          &transforms,\n+                          &numpy::convert_array<const double, 2>,\n+                          &offsets,\n+                          &convert_trans_affine,\n+                          &offset_trans,\n+                          &numpy::convert_array<const double, 2>,\n+                          &facecolors,\n+                          &numpy::convert_array<const double, 2>,\n+                          &edgecolors,\n+                          &numpy::convert_array<const double, 1>,\n+                          &linewidths,\n+                          &convert_dashes_vector,\n+                          &dashes,\n+                          &numpy::convert_array<const uint8_t, 1>,\n+                          &antialiaseds,\n+                          &ignored,\n+                          &convert_offset_position,\n+                          &offset_position)) {\n+        return NULL;\n+    }\n+\n+    try\n+    {\n+        py::PathGenerator path(pathobj);\n+\n+        CALL_CPP(\"draw_path_collection\",\n+                 (self->x->draw_path_collection(gc,\n+                                                master_transform,\n+                                                path,\n+                                                transforms,\n+                                                offsets,\n+                                                offset_trans,\n+                                                facecolors,\n+                                                edgecolors,\n+                                                linewidths,\n+                                                dashes,\n+                                                antialiaseds,\n+                                                offset_position)));\n+    }\n+    catch (py::exception &e)\n+    {\n+        return NULL;\n+    }\n+\n+    Py_RETURN_NONE;\n+}\n+\n+static PyObject *PyRendererAgg_draw_quad_mesh(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n+{\n+    GCAgg gc;\n+    agg::trans_affine master_transform;\n+    size_t mesh_width;\n+    size_t mesh_height;\n+    numpy::array_view<const double, 3> coordinates;\n+    numpy::array_view<const double, 2> offsets;\n+    agg::trans_affine offset_trans;\n+    numpy::array_view<const double, 2> facecolors;\n+    int antialiased;\n+    numpy::array_view<const double, 2> edgecolors;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"O&O&IIO&O&O&O&iO&:draw_quad_mesh\",\n+                          &convert_gcagg,\n+                          &gc,\n+                          &convert_trans_affine,\n+                          &master_transform,\n+                          &mesh_width,\n+                          &mesh_height,\n+                          &numpy::convert_array<const double, 3>,\n+                          &coordinates,\n+                          &numpy::convert_array<const double, 2>,\n+                          &offsets,\n+                          &convert_trans_affine,\n+                          &offset_trans,\n+                          &numpy::convert_array<const double, 2>,\n+                          &facecolors,\n+                          &antialiased,\n+                          &numpy::convert_array<const double, 2>,\n+                          &edgecolors)) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP(\"draw_quad_mesh\",\n+             (self->x->draw_quad_mesh(gc,\n+                                      master_transform,\n+                                      mesh_width,\n+                                      mesh_height,\n+                                      coordinates,\n+                                      offsets,\n+                                      offset_trans,\n+                                      facecolors,\n+                                      antialiased,\n+                                      edgecolors)));\n+\n+    Py_RETURN_NONE;\n+}\n+\n+static PyObject *\n+PyRendererAgg_draw_gouraud_triangle(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n+{\n+    GCAgg gc;\n+    numpy::array_view<const double, 2> points;\n+    numpy::array_view<const double, 2> colors;\n+    agg::trans_affine trans;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"O&O&O&O&|O:draw_gouraud_triangle\",\n+                          &convert_gcagg,\n+                          &gc,\n+                          &numpy::convert_array<const double, 2>,\n+                          &points,\n+                          &numpy::convert_array<const double, 2>,\n+                          &colors,\n+                          &convert_trans_affine,\n+                          &trans)) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP(\"draw_gouraud_triangle\", (self->x->draw_gouraud_triangle(gc, points, colors, trans)));\n+\n+    Py_RETURN_NONE;\n+}\n+\n+static PyObject *\n+PyRendererAgg_draw_gouraud_triangles(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n+{\n+    GCAgg gc;\n+    numpy::array_view<const double, 3> points;\n+    numpy::array_view<const double, 3> colors;\n+    agg::trans_affine trans;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"O&O&O&O&|O:draw_gouraud_triangles\",\n+                          &convert_gcagg,\n+                          &gc,\n+                          &numpy::convert_array<const double, 3>,\n+                          &points,\n+                          &numpy::convert_array<const double, 3>,\n+                          &colors,\n+                          &convert_trans_affine,\n+                          &trans)) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP(\"draw_gouraud_triangles\", self->x->draw_gouraud_triangles(gc, points, colors, trans));\n+\n+    Py_RETURN_NONE;\n+}\n+\n+static PyObject *PyRendererAgg_tostring_rgb(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n+{\n+    PyObject *buffobj = NULL;\n+\n+    buffobj = PyBytes_FromStringAndSize(NULL, self->x->get_width() * self->x->get_height() * 3);\n+    if (buffobj == NULL) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP_CLEANUP(\"tostring_rgb\",\n+                     (self->x->tostring_rgb((uint8_t *)PyBytes_AS_STRING(buffobj))),\n+                     Py_DECREF(buffobj));\n+\n+    return buffobj;\n+}\n+\n+static PyObject *PyRendererAgg_tostring_argb(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n+{\n+    PyObject *buffobj = NULL;\n+\n+    buffobj = PyBytes_FromStringAndSize(NULL, self->x->get_width() * self->x->get_height() * 4);\n+    if (buffobj == NULL) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP_CLEANUP(\"tostring_argb\",\n+                     (self->x->tostring_argb((uint8_t *)PyBytes_AS_STRING(buffobj))),\n+                     Py_DECREF(buffobj));\n+\n+    return buffobj;\n+}\n+\n+static PyObject *PyRendererAgg_tostring_bgra(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n+{\n+    PyObject *buffobj = NULL;\n+\n+    buffobj = PyBytes_FromStringAndSize(NULL, self->x->get_width() * self->x->get_height() * 4);\n+    if (buffobj == NULL) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP_CLEANUP(\"to_string_bgra\",\n+                     (self->x->tostring_bgra((uint8_t *)PyBytes_AS_STRING(buffobj))),\n+                     Py_DECREF(buffobj));\n+\n+    return buffobj;\n+}\n+\n+static PyObject *\n+PyRendererAgg_get_content_extents(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n+{\n+    agg::rect_i extents;\n+\n+    CALL_CPP(\"get_content_extents\", (extents = self->x->get_content_extents()));\n+\n+    return Py_BuildValue(\n+        \"iiii\", extents.x1, extents.y1, extents.x2 - extents.x1, extents.y2 - extents.y1);\n+}\n+\n+static PyObject *PyRendererAgg_buffer_rgba(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n+{\n+#if PY3K\n+    return PyBytes_FromStringAndSize((const char *)self->x->pixBuffer,\n+                                     self->x->get_width() * self->x->get_height() * 4);\n+#else\n+    return PyBuffer_FromReadWriteMemory(self->x->pixBuffer,\n+                                        self->x->get_width() * self->x->get_height() * 4);\n+#endif\n+}\n+\n+int PyRendererAgg_get_buffer(PyRendererAgg *self, Py_buffer *buf, int flags)\n+{\n+    Py_INCREF(self);\n+    buf->obj = (PyObject *)self;\n+    buf->buf = self->x->pixBuffer;\n+    buf->len = self->x->get_width() * self->x->get_height() * 4;\n+    buf->readonly = 0;\n+    buf->format = (char *)\"B\";\n+    buf->ndim = 3;\n+    self->shape[0] = self->x->get_height();\n+    self->shape[1] = self->x->get_width();\n+    self->shape[2] = 4;\n+    buf->shape = self->shape;\n+    self->strides[0] = self->x->get_width() * 4;\n+    self->strides[1] = 4;\n+    self->strides[2] = 1;\n+    buf->strides = self->strides;\n+    buf->suboffsets = NULL;\n+    buf->itemsize = 1;\n+    buf->internal = NULL;\n+\n+    return 1;\n+}\n+\n+static PyObject *PyRendererAgg_clear(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n+{\n+    CALL_CPP(\"clear\", self->x->clear());\n+\n+    Py_RETURN_NONE;\n+}\n+\n+static PyObject *PyRendererAgg_copy_from_bbox(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n+{\n+    agg::rect_d bbox;\n+    BufferRegion *reg;\n+    PyObject *regobj;\n+\n+    if (!PyArg_ParseTuple(args, \"O&:copy_from_bbox\", &convert_rect, &bbox)) {\n+        return 0;\n+    }\n+\n+    CALL_CPP(\"copy_from_bbox\", (reg = self->x->copy_from_bbox(bbox)));\n+\n+    regobj = PyBufferRegion_new(&PyBufferRegionType, NULL, NULL);\n+    ((PyBufferRegion *)regobj)->x = reg;\n+\n+    return regobj;\n+}\n+\n+static PyObject *PyRendererAgg_restore_region(PyRendererAgg *self, PyObject *args, PyObject *kwds)\n+{\n+    PyBufferRegion *regobj;\n+    int xx1 = 0, yy1 = 0, xx2 = 0, yy2 = 0, x = 0, y = 0;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"O!|iiiiii:restore_region\",\n+                          &PyBufferRegionType,\n+                          &regobj,\n+                          &xx1,\n+                          &yy1,\n+                          &xx2,\n+                          &yy2,\n+                          &x,\n+                          &y)) {\n+        return 0;\n+    }\n+\n+    if (PySequence_Size(args) == 1) {\n+        CALL_CPP(\"restore_region\", (self->x->restore_region(*(regobj->x))));\n+    } else {\n+        CALL_CPP(\"restore_region\", self->x->restore_region(*(regobj->x), xx1, yy1, xx2, yy2, x, y));\n+    }\n+\n+    Py_RETURN_NONE;\n+}\n+\n+PyTypeObject PyRendererAggType;\n+\n+static PyTypeObject *PyRendererAgg_init_type(PyObject *m, PyTypeObject *type)\n+{\n+    static PyMethodDef methods[] = {\n+        {\"draw_path\", (PyCFunction)PyRendererAgg_draw_path, METH_VARARGS, NULL},\n+        {\"draw_markers\", (PyCFunction)PyRendererAgg_draw_markers, METH_VARARGS, NULL},\n+        {\"draw_text_image\", (PyCFunction)PyRendererAgg_draw_text_image, METH_VARARGS, NULL},\n+        {\"draw_image\", (PyCFunction)PyRendererAgg_draw_image, METH_VARARGS, NULL},\n+        {\"draw_path_collection\", (PyCFunction)PyRendererAgg_draw_path_collection, METH_VARARGS, NULL},\n+        {\"draw_quad_mesh\", (PyCFunction)PyRendererAgg_draw_quad_mesh, METH_VARARGS, NULL},\n+        {\"draw_gouraud_triangle\", (PyCFunction)PyRendererAgg_draw_gouraud_triangle, METH_VARARGS, NULL},\n+        {\"draw_gouraud_triangles\", (PyCFunction)PyRendererAgg_draw_gouraud_triangles, METH_VARARGS, NULL},\n+\n+        {\"tostring_rgb\", (PyCFunction)PyRendererAgg_tostring_rgb, METH_NOARGS, NULL},\n+        {\"tostring_argb\", (PyCFunction)PyRendererAgg_tostring_argb, METH_NOARGS, NULL},\n+        {\"tostring_bgra\", (PyCFunction)PyRendererAgg_tostring_bgra, METH_NOARGS, NULL},\n+        {\"get_content_extents\", (PyCFunction)PyRendererAgg_get_content_extents, METH_NOARGS, NULL},\n+        {\"buffer_rgba\", (PyCFunction)PyRendererAgg_buffer_rgba, METH_NOARGS, NULL},\n+        {\"clear\", (PyCFunction)PyRendererAgg_clear, METH_NOARGS, NULL},\n+\n+        {\"copy_from_bbox\", (PyCFunction)PyRendererAgg_copy_from_bbox, METH_VARARGS, NULL},\n+        {\"restore_region\", (PyCFunction)PyRendererAgg_restore_region, METH_VARARGS, NULL},\n+        {NULL}\n+    };\n+\n+    static PyBufferProcs buffer_procs;\n+    memset(&buffer_procs, 0, sizeof(PyBufferProcs));\n+    buffer_procs.bf_getbuffer = (getbufferproc)PyRendererAgg_get_buffer;\n+\n+    memset(type, 0, sizeof(PyTypeObject));\n+    type->tp_name = \"matplotlib.backends._backend_agg.RendererAgg\";\n+    type->tp_basicsize = sizeof(PyRendererAgg);\n+    type->tp_dealloc = (destructor)PyRendererAgg_dealloc;\n+    type->tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_NEWBUFFER;\n+    type->tp_methods = methods;\n+    type->tp_init = (initproc)PyRendererAgg_init;\n+    type->tp_new = PyRendererAgg_new;\n+    type->tp_as_buffer = &buffer_procs;\n+\n+    if (PyType_Ready(type) < 0) {\n+        return NULL;\n+    }\n+\n+    if (PyModule_AddObject(m, \"RendererAgg\", (PyObject *)type)) {\n+        return NULL;\n+    }\n+\n+    return type;\n+}\n+\n+extern \"C\" {\n+\n+struct module_state\n+{\n+/* The Sun compiler can't handle empty structs */\n+#if defined(__SUNPRO_C) || defined(_MSC_VER)\n+    int _dummy;\n+#endif\n+};\n+\n+#if PY3K\n+static struct PyModuleDef moduledef = {\n+    PyModuleDef_HEAD_INIT,\n+    \"_backend_agg\",\n+    NULL,\n+    sizeof(struct module_state),\n+    NULL,\n+    NULL,\n+    NULL,\n+    NULL,\n+    NULL\n+};\n+\n+#define INITERROR return NULL\n+\n+PyMODINIT_FUNC PyInit__backend_agg(void)\n+\n+#else\n+#define INITERROR return\n+\n+PyMODINIT_FUNC init_backend_agg(void)\n+#endif\n+\n+{\n+    PyObject *m;\n+\n+#if PY3K\n+    m = PyModule_Create(&moduledef);\n+#else\n+    m = Py_InitModule3(\"_backend_agg\", NULL, NULL);\n+#endif\n+\n+    if (m == NULL) {\n+        INITERROR;\n+    }\n+\n+    import_array();\n+\n+    if (!PyRendererAgg_init_type(m, &PyRendererAggType)) {\n+        INITERROR;\n+    }\n+\n+    if (!PyBufferRegion_init_type(m, &PyBufferRegionType)) {\n+        INITERROR;\n+    }\n+\n+#if PY3K\n+    return m;\n+#endif\n+}\n+\n+} // extern \"C\""
            },
            {
                "sha": "f625b4ce43b7b84d3f85e8c786dcfdf0d154dfbd",
                "filename": "src/_backend_agg_wrapper.h",
                "status": "added",
                "additions": 29,
                "deletions": 0,
                "changes": 29,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_backend_agg_wrapper.h",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_backend_agg_wrapper.h",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/src%2F_backend_agg_wrapper.h?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787",
                "patch": "@@ -0,0 +1,29 @@\n+#ifndef __BACKEND_AGG_WRAPPER_H__\n+#define __BACKEND_AGG_WRAPPER_H__\n+\n+#include \"mplutils.h\"\n+#include \"py_converters.h\"\n+#include \"_backend_agg.h\"\n+\n+extern \"C\" {\n+\n+typedef struct\n+{\n+    PyObject_HEAD;\n+    RendererAgg *x;\n+    Py_ssize_t shape[3];\n+    Py_ssize_t strides[3];\n+    Py_ssize_t suboffsets[3];\n+} PyRendererAgg;\n+\n+typedef struct\n+{\n+    PyObject_HEAD;\n+    BufferRegion *x;\n+    Py_ssize_t shape[3];\n+    Py_ssize_t strides[3];\n+    Py_ssize_t suboffsets[3];\n+} PyBufferRegion;\n+}\n+\n+#endif"
            },
            {
                "sha": "9ccc3c5f0acbb8da32e276bcaa80bc77b60878fc",
                "filename": "src/_backend_gdk.c",
                "status": "modified",
                "additions": 7,
                "deletions": 12,
                "changes": 19,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_backend_gdk.c",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_backend_gdk.c",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/src%2F_backend_gdk.c?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787",
                "patch": "@@ -7,22 +7,19 @@\n \n #include <pygtk/pygtk.h>\n \n-\n static PyTypeObject *_PyGdkPixbuf_Type;\n #define PyGdkPixbuf_Type (*_PyGdkPixbuf_Type)\n \n-static PyObject *\n-pixbuf_get_pixels_array(PyObject *self, PyObject *args)\n+static PyObject *pixbuf_get_pixels_array(PyObject *self, PyObject *args)\n {\n     /* 1) read in Python pixbuf, get the underlying gdk_pixbuf */\n     PyGObject *py_pixbuf;\n     GdkPixbuf *gdk_pixbuf;\n     PyArrayObject *array;\n     npy_intp dims[3] = { 0, 0, 3 };\n \n-    if (!PyArg_ParseTuple(args, \"O!:pixbuf_get_pixels_array\",\n-\t\t\t  &PyGdkPixbuf_Type, &py_pixbuf))\n-\treturn NULL;\n+    if (!PyArg_ParseTuple(args, \"O!:pixbuf_get_pixels_array\", &PyGdkPixbuf_Type, &py_pixbuf))\n+        return NULL;\n \n     gdk_pixbuf = GDK_PIXBUF(py_pixbuf->obj);\n \n@@ -35,8 +32,8 @@ pixbuf_get_pixels_array(PyObject *self, PyObject *args)\n     if (gdk_pixbuf_get_has_alpha(gdk_pixbuf))\n         dims[2] = 4;\n \n-    array = (PyArrayObject *)PyArray_SimpleNewFromData(3, dims, NPY_UBYTE,\n-\t\t\t     (char *)gdk_pixbuf_get_pixels(gdk_pixbuf));\n+    array = (PyArrayObject *)PyArray_SimpleNewFromData(\n+        3, dims, PyArray_UBYTE, (char *)gdk_pixbuf_get_pixels(gdk_pixbuf));\n     if (array == NULL)\n         return NULL;\n \n@@ -52,12 +49,10 @@ static PyMethodDef _backend_gdk_functions[] = {\n     { NULL, NULL, 0 }\n };\n \n-PyMODINIT_FUNC\n-init_backend_gdk(void)\n+PyMODINIT_FUNC init_backend_gdk(void)\n {\n     PyObject *mod;\n-    mod = Py_InitModule(\"matplotlib.backends._backend_gdk\",\n-                                        _backend_gdk_functions);\n+    mod = Py_InitModule(\"matplotlib.backends._backend_gdk\", _backend_gdk_functions);\n     import_array();\n     init_pygtk();\n "
            },
            {
                "sha": "af16a78f59faa18cc68ea2dc85575a824d9a0198",
                "filename": "src/_gtkagg.cpp",
                "status": "modified",
                "additions": 138,
                "deletions": 127,
                "changes": 265,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_gtkagg.cpp",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_gtkagg.cpp",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/src%2F_gtkagg.cpp?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787",
                "patch": "@@ -1,153 +1,164 @@\n \n /* -*- mode: c++; c-basic-offset: 4 -*- */\n \n+#include <vector>\n+\n #include <pygobject.h>\n #include <pygtk/pygtk.h>\n \n-#include <cstring>\n-#include <cerrno>\n-#include <cstdio>\n-#include <iostream>\n-#include <cmath>\n-#include <utility>\n-#include <fstream>\n-\n #include \"agg_basics.h\"\n-#include \"numpy/arrayobject.h\"\n-#include \"_backend_agg.h\"\n-#include \"agg_py_transforms.h\"\n+#include \"agg_pixfmt_rgba.h\"\n+#include \"agg_renderer_base.h\"\n+#include \"agg_rendering_buffer.h\"\n \n-// the extension module\n-class _gtkagg_module : public Py::ExtensionModule<_gtkagg_module>\n+#include \"numpy_cpp.h\"\n+#include \"py_converters.h\"\n+\n+static PyObject *Py_agg_to_gtk_drawable(PyObject *self, PyObject *args, PyObject *kwds)\n {\n-public:\n-    _gtkagg_module()\n-        : Py::ExtensionModule<_gtkagg_module>(\"_gtkagg\")\n-    {\n-        add_varargs_method(\"agg_to_gtk_drawable\",\n-                           &_gtkagg_module::agg_to_gtk_drawable,\n-                           \"Draw to a gtk drawable from a agg buffer.\");\n-        initialize(\"The _gtkagg module\");\n+    typedef agg::pixfmt_rgba32_plain pixfmt;\n+    typedef agg::renderer_base<pixfmt> renderer_base;\n+\n+    PyGObject *py_drawable;\n+    numpy::array_view<agg::int8u, 3> buffer;\n+    agg::rect_d rect;\n+\n+    // args are gc, renderer, bbox where bbox is a transforms BBox\n+    // (possibly None).  If bbox is None, blit the entire agg buffer\n+    // to gtk.  If bbox is not None, blit only the region defined by\n+    // the bbox\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"OO&O&:agg_to_gtk_drawable\",\n+                          &py_drawable,\n+                          &numpy::convert_array<agg::int8u, 3>,\n+                          &buffer,\n+                          &convert_rect,\n+                          &rect)) {\n+        return NULL;\n     }\n \n-    virtual ~_gtkagg_module() {}\n-\n-private:\n-\n-    Py::Object agg_to_gtk_drawable(const Py::Tuple &args)\n-    {\n-        // args are gc, renderer, bbox where bbox is a transforms BBox\n-        // (possibly None).  If bbox is None, blit the entire agg buffer\n-        // to gtk.  If bbox is not None, blit only the region defined by\n-        // the bbox\n-        args.verify_length(3);\n-\n-        PyGObject *py_drawable = (PyGObject *)(args[0].ptr());\n-        RendererAgg* aggRenderer = static_cast<RendererAgg*>(args[1].ptr());\n-\n-        GdkDrawable *drawable = GDK_DRAWABLE(py_drawable->obj);\n-        GdkGC* gc = gdk_gc_new(drawable);\n+    if (buffer.dim(2) != 4) {\n+        PyErr_SetString(PyExc_ValueError, \"Invalid image buffer.  Must be NxMx4.\");\n+        return NULL;\n+    }\n \n-        int srcstride = aggRenderer->get_width() * 4;\n-        int srcwidth = (int)aggRenderer->get_width();\n-        int srcheight = (int)aggRenderer->get_height();\n+    GdkDrawable *drawable = GDK_DRAWABLE(py_drawable->obj);\n+    GdkGC *gc = gdk_gc_new(drawable);\n+\n+    int srcstride = buffer.dim(1) * 4;\n+    int srcwidth = buffer.dim(1);\n+    int srcheight = buffer.dim(0);\n+\n+    // these three will be overridden below\n+    int destx = 0;\n+    int desty = 0;\n+    int destwidth = 1;\n+    int destheight = 1;\n+    int deststride = 1;\n+\n+    std::vector<agg::int8u> destbuffer;\n+    agg::int8u *destbufferptr;\n+\n+    if (rect.x1 == 0.0 && rect.x2 == 0.0 && rect.y1 == 0.0 && rect.y2 == 0.0) {\n+        // bbox is None; copy the entire image\n+        destbufferptr = (agg::int8u *)buffer;\n+        destwidth = srcwidth;\n+        destheight = srcheight;\n+        deststride = srcstride;\n+    } else {\n+        destx = (int)rect.x1;\n+        desty = srcheight - (int)rect.y2;\n+        destwidth = (int)(rect.x2 - rect.x1);\n+        destheight = (int)(rect.y2 - rect.y1);\n+        deststride = destwidth * 4;\n+        destbuffer.reserve(destheight * deststride);\n+        destbufferptr = &destbuffer[0];\n+\n+        agg::rendering_buffer destrbuf;\n+        destrbuf.attach(destbufferptr, destwidth, destheight, deststride);\n+        pixfmt destpf(destrbuf);\n+        renderer_base destrb(destpf);\n+\n+        agg::rendering_buffer srcrbuf;\n+        srcrbuf.attach((agg::int8u *)buffer, buffer.dim(1), buffer.dim(0), buffer.dim(1) * 4);\n+\n+        agg::rect_base<int> region(destx, desty, (int)rect.x2, srcheight - (int)rect.y1);\n+        destrb.copy_from(srcrbuf, &region, -destx, -desty);\n+    }\n \n-        // these three will be overridden below\n-        int destx = 0;\n-        int desty = 0;\n-        int destwidth = 1;\n-        int destheight = 1;\n-        int deststride = 1;\n+    gdk_draw_rgb_32_image(drawable,\n+                          gc,\n+                          destx,\n+                          desty,\n+                          destwidth,\n+                          destheight,\n+                          GDK_RGB_DITHER_NORMAL,\n+                          destbufferptr,\n+                          deststride);\n \n+    gdk_gc_destroy(gc);\n \n-        bool needfree = false;\n+    Py_RETURN_NONE;\n+}\n \n-        agg::int8u *destbuffer = NULL;\n+static PyMethodDef module_methods[] = {\n+    {\"agg_to_gtk_drawable\", (PyCFunction)Py_agg_to_gtk_drawable, METH_VARARGS, NULL},\n+    NULL\n+};\n \n-        if (args[2].ptr() == Py_None)\n-        {\n-            //bbox is None; copy the entire image\n-            destbuffer = aggRenderer->pixBuffer;\n-            destwidth = srcwidth;\n-            destheight = srcheight;\n-            deststride = srcstride;\n-        }\n-        else\n-        {\n-            //bbox is not None; copy the image in the bbox\n-            PyObject* clipbox = args[2].ptr();\n-            double l, b, r, t;\n-\n-            if (!py_convert_bbox(clipbox, l, b, r, t))\n-            {\n-                throw Py::TypeError\n-                (\"Argument 3 to agg_to_gtk_drawable must be a Bbox object.\");\n-            }\n-\n-            destx = (int)l;\n-            desty = srcheight - (int)t;\n-            destwidth = (int)(r - l);\n-            destheight = (int)(t - b);\n-            deststride = destwidth * 4;\n-\n-            needfree = true;\n-            destbuffer = new agg::int8u[deststride*destheight];\n-            if (destbuffer == NULL)\n-            {\n-                throw Py::MemoryError(\"_gtkagg could not allocate memory for destbuffer\");\n-            }\n-\n-            agg::rendering_buffer destrbuf;\n-            destrbuf.attach(destbuffer, destwidth, destheight, deststride);\n-            pixfmt destpf(destrbuf);\n-            renderer_base destrb(destpf);\n-\n-            //destrb.clear(agg::rgba(1, 1, 1, 0));\n-\n-            agg::rect_base<int> region(destx, desty, (int)r, srcheight - (int)b);\n-            destrb.copy_from(aggRenderer->renderingBuffer, &region,\n-                             -destx, -desty);\n-        }\n+extern \"C\" {\n \n-        /*std::cout << desty << \" \"\n-              << destheight << \" \"\n-              << srcheight << std::endl;*/\n+    struct module_state\n+    {\n+        /* The Sun compiler can't handle empty structs */\n+#if defined(__SUNPRO_C) || defined(_MSC_VER)\n+        int _dummy;\n+#endif\n+    };\n+\n+#if PY3K\n+    static struct PyModuleDef moduledef = {\n+        PyModuleDef_HEAD_INIT,\n+        \"_gtkagg\",\n+        NULL,\n+        sizeof(struct module_state),\n+        module_methods,\n+        NULL,\n+        NULL,\n+        NULL,\n+        NULL\n+    };\n+\n+#define INITERROR return NULL\n+\n+    PyMODINIT_FUNC PyInit__gtkagg(void)\n+\n+#else\n+#define INITERROR return\n+\n+    PyMODINIT_FUNC init_gtkagg(void)\n+#endif\n \n+    {\n+        PyObject *m;\n \n-        //gdk_rgb_init();\n-        gdk_draw_rgb_32_image(drawable, gc, destx, desty,\n-                              destwidth,\n-                              destheight,\n-                              GDK_RGB_DITHER_NORMAL,\n-                              destbuffer,\n-                              deststride);\n+#if PY3K\n+        m = PyModule_Create(&moduledef);\n+#else\n+        m = Py_InitModule3(\"_gtkagg\", module_methods, NULL);\n+#endif\n \n-        gdk_gc_destroy(gc);\n-        if (needfree)\n-        {\n-            delete [] destbuffer;\n+        if (m == NULL) {\n+            INITERROR;\n         }\n \n-        return Py::Object();\n+        init_pygobject();\n+        init_pygtk();\n+        import_array();\n \n+#if PY3K\n+        return m;\n+#endif\n     }\n-};\n-\n-PyMODINIT_FUNC\n-init_gtkagg(void)\n-{\n-    init_pygobject();\n-    init_pygtk();\n-\n-    import_array();\n-    //suppress unused warning by creating in two lines\n-    static _gtkagg_module* _gtkagg = NULL;\n-    _gtkagg = new _gtkagg_module;\n }\n-\n-\n-\n-\n-\n-\n-"
            },
            {
                "sha": "df670397e37d47697c5c2bfd04c5bd3580998aa5",
                "filename": "src/_image.cpp",
                "status": "modified",
                "additions": 211,
                "deletions": 1662,
                "changes": 1873,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_image.cpp",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_image.cpp",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/src%2F_image.cpp?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787",
                "patch": "@@ -1,15 +1,8 @@\n /* -*- mode: c++; c-basic-offset: 4 -*- */\n \n-/* Python API mandates Python.h is included *first* */\n-#include \"Python.h\"\n-#include <string>\n+#define NO_IMPORT_ARRAY\n \n-#include <iostream>\n-#include <fstream>\n-#include <cmath>\n-#include <cstdio>\n-\n-#include \"numpy/arrayobject.h\"\n+#include <vector>\n \n #include \"agg_color_rgba.h\"\n #include \"agg_conv_transform.h\"\n@@ -18,6 +11,7 @@\n #include \"agg_pixfmt_rgb.h\"\n #include \"agg_pixfmt_rgba.h\"\n #include \"agg_rasterizer_scanline_aa.h\"\n+#include \"agg_rasterizer_sl_clip.h\"\n #include \"agg_renderer_scanline.h\"\n #include \"agg_rendering_buffer.h\"\n #include \"agg_scanline_bin.h\"\n@@ -27,369 +21,160 @@\n #include \"agg_span_image_filter_rgb.h\"\n #include \"agg_span_image_filter_rgba.h\"\n #include \"agg_span_interpolator_linear.h\"\n-#include \"agg_rasterizer_sl_clip.h\"\n #include \"util/agg_color_conv_rgb8.h\"\n+\n #include \"_image.h\"\n #include \"mplutils.h\"\n \n-\n typedef agg::pixfmt_rgba32_plain pixfmt;\n typedef agg::pixfmt_rgba32_pre pixfmt_pre;\n typedef agg::renderer_base<pixfmt> renderer_base;\n typedef agg::span_interpolator_linear<> interpolator_type;\n typedef agg::rasterizer_scanline_aa<agg::rasterizer_sl_clip_dbl> rasterizer;\n \n-\n-Image::Image() :\n-        bufferIn(NULL), rbufIn(NULL), colsIn(0), rowsIn(0),\n-        bufferOut(NULL), rbufOut(NULL), colsOut(0), rowsOut(0),  BPP(4),\n-        interpolation(BILINEAR), aspect(ASPECT_FREE), bg(1, 1, 1, 0), resample(true)\n-{\n-    _VERBOSE(\"Image::Image\");\n+Image::Image()\n+    : bufferIn(NULL),\n+      rbufIn(NULL),\n+      colsIn(0),\n+      rowsIn(0),\n+      bufferOut(NULL),\n+      rbufOut(NULL),\n+      colsOut(0),\n+      rowsOut(0),\n+      BPP(4),\n+      interpolation(BILINEAR),\n+      aspect(ASPECT_FREE),\n+      bg(1, 1, 1, 0),\n+      resample(true)\n+{\n+\n+}\n+\n+Image::Image(unsigned numrows, unsigned numcols, bool isoutput)\n+    : bufferIn(NULL),\n+      rbufIn(NULL),\n+      colsIn(0),\n+      rowsIn(0),\n+      bufferOut(NULL),\n+      rbufOut(NULL),\n+      colsOut(0),\n+      rowsOut(0),\n+      BPP(4),\n+      interpolation(BILINEAR),\n+      aspect(ASPECT_FREE),\n+      bg(1, 1, 1, 0),\n+      resample(true)\n+{\n+    if (isoutput) {\n+        rowsOut = numrows;\n+        colsOut = numcols;\n+        unsigned NUMBYTES(numrows * numcols * BPP);\n+        bufferOut = new agg::int8u[NUMBYTES];\n+        rbufOut = new agg::rendering_buffer;\n+        rbufOut->attach(bufferOut, colsOut, rowsOut, colsOut * BPP);\n+    } else {\n+        rowsIn = numrows;\n+        colsIn = numcols;\n+        unsigned NUMBYTES(numrows * numcols * BPP);\n+        bufferIn = new agg::int8u[NUMBYTES];\n+        rbufIn = new agg::rendering_buffer;\n+        rbufIn->attach(bufferIn, colsIn, rowsIn, colsIn * BPP);\n+    }\n }\n \n Image::~Image()\n {\n-    _VERBOSE(\"Image::~Image\");\n-    delete [] bufferIn;\n+    delete[] bufferIn;\n     bufferIn = NULL;\n     delete rbufIn;\n     rbufIn = NULL;\n     delete rbufOut;\n     rbufOut = NULL;\n-    delete [] bufferOut;\n+    delete[] bufferOut;\n     bufferOut = NULL;\n }\n \n-int\n-Image::setattr(const char * name, const Py::Object & value)\n+void Image::apply_rotation(double r)\n {\n-    _VERBOSE(\"Image::setattr\");\n-    __dict__[name] = value;\n-    return 0;\n-}\n-\n-Py::Object\n-Image::getattr(const char * name)\n-{\n-    _VERBOSE(\"Image::getattro\");\n-    if (__dict__.hasKey(name)) return __dict__[name];\n-    else return getattr_default(name);\n-}\n-\n-char Image::apply_rotation__doc__[] =\n-    \"apply_rotation(angle)\\n\"\n-    \"\\n\"\n-    \"Apply the rotation (degrees) to image\"\n-    ;\n-Py::Object\n-Image::apply_rotation(const Py::Tuple& args)\n-{\n-    _VERBOSE(\"Image::apply_rotation\");\n-\n-    args.verify_length(1);\n-    double r = Py::Float(args[0]);\n-\n-\n     agg::trans_affine M = agg::trans_affine_rotation(r * agg::pi / 180.0);\n     srcMatrix *= M;\n     imageMatrix *= M;\n-    return Py::Object();\n }\n \n-char Image::flipud_out__doc__[] =\n-    \"flipud()\\n\"\n-    \"\\n\"\n-    \"Flip the output image upside down\"\n-    ;\n-\n-char Image::flipud_in__doc__[] =\n-    \"flipud()\\n\"\n-    \"\\n\"\n-    \"Flip the input image upside down\"\n-    ;\n-Py::Object\n-Image::flipud_in(const Py::Tuple& args)\n+void Image::set_bg(double r, double g, double b, double a)\n {\n-    _VERBOSE(\"Image::flipud_in\");\n-\n-    args.verify_length(0);\n-    int stride = rbufIn->stride();\n-    rbufIn->attach(bufferIn, colsIn, rowsIn, -stride);\n-\n-    return Py::Object();\n+    bg.r = r;\n+    bg.g = g;\n+    bg.b = b;\n+    bg.a = a;\n }\n \n-char Image::set_bg__doc__[] =\n-    \"set_bg(r,g,b,a)\\n\"\n-    \"\\n\"\n-    \"Set the background color\"\n-    ;\n-\n-Py::Object\n-Image::set_bg(const Py::Tuple& args)\n+void Image::apply_scaling(double sx, double sy)\n {\n-    _VERBOSE(\"Image::set_bg\");\n-\n-    args.verify_length(4);\n-    bg.r = Py::Float(args[0]);\n-    bg.g = Py::Float(args[1]);\n-    bg.b = Py::Float(args[2]);\n-    bg.a = Py::Float(args[3]);\n-    return Py::Object();\n-}\n-\n-char Image::apply_scaling__doc__[] =\n-    \"apply_scaling(sx, sy)\\n\"\n-    \"\\n\"\n-    \"Apply the scale factors sx, sy to the transform matrix\"\n-    ;\n-\n-Py::Object\n-Image::apply_scaling(const Py::Tuple& args)\n-{\n-    _VERBOSE(\"Image::apply_scaling\");\n-\n-    args.verify_length(2);\n-    double sx = Py::Float(args[0]);\n-    double sy = Py::Float(args[1]);\n-\n-    //printf(\"applying scaling %1.2f, %1.2f\\n\", sx, sy);\n     agg::trans_affine M = agg::trans_affine_scaling(sx, sy);\n     srcMatrix *= M;\n     imageMatrix *= M;\n-\n-    return Py::Object();\n }\n \n-char Image::apply_translation__doc__[] =\n-    \"apply_translation(tx, ty)\\n\"\n-    \"\\n\"\n-    \"Apply the translation tx, ty to the transform matrix\"\n-    ;\n-\n-Py::Object\n-Image::apply_translation(const Py::Tuple& args)\n+void Image::apply_translation(double tx, double ty)\n {\n-    _VERBOSE(\"Image::apply_translation\");\n-\n-    args.verify_length(2);\n-    double tx = Py::Float(args[0]);\n-    double ty = Py::Float(args[1]);\n-\n-    //printf(\"applying translation %1.2f, %1.2f\\n\", tx, ty);\n     agg::trans_affine M = agg::trans_affine_translation(tx, ty);\n     srcMatrix *= M;\n     imageMatrix *= M;\n-\n-    return Py::Object();\n }\n \n-char Image::as_rgba_str__doc__[] =\n-    \"numrows, numcols, s = as_rgba_str()\"\n-    \"\\n\"\n-    \"Call this function after resize to get the data as string\\n\"\n-    \"The string is a numrows by numcols x 4 (RGBA) unsigned char buffer\\n\"\n-    ;\n-\n-Py::Object\n-Image::as_rgba_str(const Py::Tuple& args, const Py::Dict& kwargs)\n+void Image::as_rgba_str(agg::int8u *outbuf)\n {\n-    _VERBOSE(\"Image::as_rgba_str\");\n-\n-    args.verify_length(0);\n-\n-    std::pair<agg::int8u*, bool> bufpair = _get_output_buffer();\n-\n-    #if PY3K\n-    Py::Object ret =  Py::asObject(Py_BuildValue(\"nny#\", rowsOut, colsOut,\n-                                   bufpair.first, colsOut * rowsOut * 4));\n-    #else\n-    Py::Object ret =  Py::asObject(Py_BuildValue(\"nns#\", rowsOut, colsOut,\n-                                   bufpair.first, colsOut * rowsOut * 4));\n-    #endif\n-\n-    if (bufpair.second) delete [] bufpair.first;\n-    return ret;\n+    agg::rendering_buffer rb;\n+    rb.attach(outbuf, colsOut, rowsOut, colsOut * 4);\n+    rb.copy_from(*rbufOut);\n }\n \n-\n-char Image::color_conv__doc__[] =\n-    \"numrows, numcols, buffer = color_conv(format)\"\n-    \"\\n\"\n-    \"format 0(BGRA) or 1(ARGB)\\n\"\n-    \"Convert image to format and return in a writable buffer\\n\"\n-    ;\n-Py::Object\n-Image::color_conv(const Py::Tuple& args)\n+void Image::color_conv(int format, agg::int8u *outbuf)\n {\n-    _VERBOSE(\"Image::color_conv\");\n-\n-    args.verify_length(1);\n-    int format = Py::Int(args[0]);\n-    PyObject* py_buffer = NULL;\n     int row_len = colsOut * 4;\n-#if PY3K\n-    unsigned char* buf = (unsigned char *)malloc(row_len * rowsOut);\n-    if (buf == NULL)\n-        throw Py::MemoryError(\"Image::color_conv could not allocate memory\");\n-#else\n-    py_buffer = PyBuffer_New(row_len * rowsOut);\n-    if (py_buffer == NULL)\n-        throw Py::MemoryError(\"Image::color_conv could not allocate memory\");\n-\n-    void* buf;\n-    Py_ssize_t buffer_len;\n-    int ret = PyObject_AsWriteBuffer(py_buffer, &buf, &buffer_len);\n-    if (ret != 0)\n-    {\n-        Py_XDECREF(py_buffer);\n-        throw Py::MemoryError(\"Image::color_conv could not allocate memory\");\n-    }\n-#endif\n \n     agg::rendering_buffer rtmp;\n-    rtmp.attach(reinterpret_cast<unsigned char*>(buf), colsOut, rowsOut,\n-                row_len);\n+    rtmp.attach(outbuf, colsOut, rowsOut, row_len);\n \n-    switch (format)\n-    {\n+    switch (format) {\n     case 0:\n         agg::color_conv(&rtmp, rbufOut, agg::color_conv_rgba32_to_bgra32());\n         break;\n     case 1:\n         agg::color_conv(&rtmp, rbufOut, agg::color_conv_rgba32_to_argb32());\n         break;\n     default:\n-        Py_XDECREF(py_buffer);\n-        throw Py::ValueError(\"Image::color_conv unknown format\");\n-    }\n-\n-#if PY3K\n-    py_buffer = PyByteArray_FromStringAndSize((char *)buf, row_len * rowsOut);\n-    if (py_buffer == NULL) {\n-        free(buf);\n+        throw \"Image::color_conv unknown format\";\n     }\n-#endif\n-\n-    PyObject* o = Py_BuildValue(\"nnN\", rowsOut, colsOut, py_buffer);\n-    return Py::asObject(o);\n }\n \n-char Image::buffer_rgba__doc__[] =\n-    \"buffer = buffer_rgba()\"\n-    \"\\n\"\n-    \"Return the image buffer as rgba32\\n\"\n-    ;\n-Py::Object\n-Image::buffer_rgba(const Py::Tuple& args)\n+void Image::reset_matrix(void)\n {\n-    //\"Return the image object as rgba\";\n-\n-    _VERBOSE(\"RendererAgg::buffer_rgba\");\n-\n-    args.verify_length(0);\n-    int row_len = colsOut * 4;\n-    PyObject* o = Py_BuildValue(\"nns#\", rowsOut, colsOut,\n-                                rbufOut, row_len * rowsOut);\n-    return Py::asObject(o);\n-}\n-\n-char Image::reset_matrix__doc__[] =\n-    \"reset_matrix()\"\n-    \"\\n\"\n-    \"Reset the transformation matrix\"\n-    ;\n-\n-Py::Object\n-Image::reset_matrix(const Py::Tuple& args)\n-{\n-    _VERBOSE(\"Image::reset_matrix\");\n-\n-    args.verify_length(0);\n     srcMatrix.reset();\n     imageMatrix.reset();\n-\n-    return Py::Object();\n }\n \n-char Image::get_matrix__doc__[] =\n-    \"(m11,m21,m12,m22,m13,m23) = get_matrix()\\n\"\n-    \"\\n\"\n-    \"Get the affine transformation matrix\\n\"\n-    \"  /m11,m12,m13\\\\\\n\"\n-    \"  /m21,m22,m23|\\n\"\n-    \"  \\\\ 0 , 0 , 1 /\"\n-    ;\n-\n-Py::Object\n-Image::get_matrix(const Py::Tuple& args)\n+void Image::resize(int numcols, int numrows, int norm, double radius)\n {\n-    _VERBOSE(\"Image::get_matrix\");\n-\n-    args.verify_length(0);\n-\n-    double m[6];\n-    srcMatrix.store_to(m);\n-    Py::Tuple ret(6);\n-    for (int i = 0;i < 6;i++)\n-    {\n-        ret[i] = Py::Float(m[i]);\n+    if (bufferIn == NULL) {\n+        throw \"You must first load the image\";\n     }\n-    return ret;\n-}\n-\n-char Image::resize__doc__[] =\n-    \"resize(width, height, norm=1, radius=4.0)\\n\"\n-    \"\\n\"\n-    \"Resize the image to width, height using interpolation\\n\"\n-    \"norm and radius are optional args for some of the filters and must be\\n\"\n-    \"passed as kwargs\\n\"\n-    ;\n \n-Py::Object\n-Image::resize(const Py::Tuple& args, const Py::Dict& kwargs)\n-{\n-    _VERBOSE(\"Image::resize\");\n-\n-    args.verify_length(2);\n-\n-    int norm = 1;\n-    if (kwargs.hasKey(\"norm\"))\n-    {\n-        norm = Py::Int(kwargs[\"norm\"]);\n-    }\n-\n-    double radius = 4.0;\n-    if (kwargs.hasKey(\"radius\"))\n-    {\n-        radius = Py::Float(kwargs[\"radius\"]);\n-    }\n-\n-    if (bufferIn == NULL)\n-    {\n-        throw Py::RuntimeError(\"You must first load the image\");\n-    }\n-\n-    int numcols = Py::Int(args[0]);\n-    int numrows = Py::Int(args[1]);\n-\n-    if (numcols <= 0 || numrows <= 0)\n-    {\n-        throw Py::RuntimeError(\n-        \"Width and height must have positive values\");\n+    if (numcols <= 0 || numrows <= 0) {\n+        throw \"Width and height must have positive values\";\n     }\n \n     colsOut = numcols;\n     rowsOut = numrows;\n \n     size_t NUMBYTES(numrows * numcols * BPP);\n \n-    delete [] bufferOut;\n+    delete[] bufferOut;\n     bufferOut = new agg::int8u[NUMBYTES];\n-    if (bufferOut == NULL) //todo: also handle allocation throw\n+    if (bufferOut == NULL) // todo: also handle allocation throw\n     {\n-        throw Py::MemoryError(\"Image::resize could not allocate memory\");\n+        throw \"Image::resize could not allocate memory\";\n     }\n \n     delete rbufOut;\n@@ -405,8 +190,6 @@ Image::resize(const Py::Tuple& args, const Py::Dict& kwargs)\n \n     ras.clip_box(0, 0, numcols, numrows);\n \n-    //srcMatrix *= resizingMatrix;\n-    //imageMatrix *= resizingMatrix;\n     imageMatrix.invert();\n     interpolator_type interpolator(imageMatrix);\n \n@@ -437,26 +220,22 @@ Image::resize(const Py::Tuple& args, const Py::Dict& kwargs)\n \n     pixfmt_pre pixfmtin(*rbufIn);\n     img_accessor_type ia(pixfmtin);\n-    switch (interpolation)\n-    {\n+    switch (interpolation) {\n \n-    case NEAREST:\n-    {\n+    case NEAREST: {\n         typedef agg::span_image_filter_rgba_nn<img_accessor_type, interpolator_type> span_gen_type;\n-        typedef agg::renderer_scanline_aa<renderer_base, span_alloc_type, span_gen_type> renderer_type;\n+        typedef agg::renderer_scanline_aa<renderer_base, span_alloc_type, span_gen_type>\n+        renderer_type;\n         span_gen_type sg(ia, interpolator);\n         renderer_type ri(rb, sa, sg);\n         agg::render_scanlines(ras, sl, ri);\n-    }\n-    break;\n+    } break;\n \n     case HANNING:\n     case HAMMING:\n-    case HERMITE:\n-    {\n+    case HERMITE: {\n         agg::image_filter_lut filter;\n-        switch (interpolation)\n-        {\n+        switch (interpolation) {\n         case HANNING:\n             filter.calculate(agg::image_filter_hanning(), norm);\n             break;\n@@ -467,24 +246,23 @@ Image::resize(const Py::Tuple& args, const Py::Dict& kwargs)\n             filter.calculate(agg::image_filter_hermite(), norm);\n             break;\n         }\n-        if (resample)\n-        {\n+        if (resample) {\n             typedef agg::span_image_resample_rgba_affine<img_accessor_type> span_gen_type;\n-            typedef agg::renderer_scanline_aa<renderer_base, span_alloc_type, span_gen_type> renderer_type;\n+            typedef agg::renderer_scanline_aa<renderer_base, span_alloc_type, span_gen_type>\n+            renderer_type;\n             span_gen_type sg(ia, interpolator, filter);\n             renderer_type ri(rb, sa, sg);\n             agg::render_scanlines(ras, sl, ri);\n-        }\n-        else\n-        {\n-            typedef agg::span_image_filter_rgba_2x2<img_accessor_type, interpolator_type> span_gen_type;\n-            typedef agg::renderer_scanline_aa<renderer_base, span_alloc_type, span_gen_type> renderer_type;\n+        } else {\n+            typedef agg::span_image_filter_rgba_2x2<img_accessor_type, interpolator_type>\n+            span_gen_type;\n+            typedef agg::renderer_scanline_aa<renderer_base, span_alloc_type, span_gen_type>\n+            renderer_type;\n             span_gen_type sg(ia, interpolator, filter);\n             renderer_type ri(rb, sa, sg);\n             agg::render_scanlines(ras, sl, ri);\n         }\n-    }\n-    break;\n+    } break;\n     case BILINEAR:\n     case BICUBIC:\n     case SPLINE16:\n@@ -497,11 +275,9 @@ Image::resize(const Py::Tuple& args, const Py::Dict& kwargs)\n     case MITCHELL:\n     case SINC:\n     case LANCZOS:\n-    case BLACKMAN:\n-    {\n+    case BLACKMAN: {\n         agg::image_filter_lut filter;\n-        switch (interpolation)\n-        {\n+        switch (interpolation) {\n         case BILINEAR:\n             filter.calculate(agg::image_filter_bilinear(), norm);\n             break;\n@@ -542,801 +318,85 @@ Image::resize(const Py::Tuple& args, const Py::Dict& kwargs)\n             filter.calculate(agg::image_filter_blackman(radius), norm);\n             break;\n         }\n-        if (resample)\n-        {\n+        if (resample) {\n             typedef agg::span_image_resample_rgba_affine<img_accessor_type> span_gen_type;\n-            typedef agg::renderer_scanline_aa<renderer_base, span_alloc_type, span_gen_type> renderer_type;\n+            typedef agg::renderer_scanline_aa<renderer_base, span_alloc_type, span_gen_type>\n+            renderer_type;\n             span_gen_type sg(ia, interpolator, filter);\n             renderer_type ri(rb, sa, sg);\n             agg::render_scanlines(ras, sl, ri);\n-        }\n-        else\n-        {\n+        } else {\n             typedef agg::span_image_filter_rgba<img_accessor_type, interpolator_type> span_gen_type;\n-            typedef agg::renderer_scanline_aa<renderer_base, span_alloc_type, span_gen_type> renderer_type;\n+            typedef agg::renderer_scanline_aa<renderer_base, span_alloc_type, span_gen_type>\n+            renderer_type;\n             span_gen_type sg(ia, interpolator, filter);\n             renderer_type ri(rb, sa, sg);\n             agg::render_scanlines(ras, sl, ri);\n         }\n+    } break;\n     }\n-    break;\n-\n-    }\n-\n-    return Py::Object();\n }\n \n-\n-\n-char Image::get_interpolation__doc__[] =\n-    \"get_interpolation()\\n\"\n-    \"\\n\"\n-    \"Get the interpolation scheme to one of the module constants, \"\n-    \"one of image.NEAREST, image.BILINEAR, etc...\"\n-    ;\n-\n-Py::Object\n-Image::get_interpolation(const Py::Tuple& args)\n+void Image::clear()\n {\n-    _VERBOSE(\"Image::get_interpolation\");\n-\n-    args.verify_length(0);\n-    return Py::Int((int)interpolation);\n-}\n-\n-\n-char Image::get_aspect__doc__[] =\n-    \"get_aspect()\\n\"\n-    \"\\n\"\n-    \"Get the aspect constraint constants\"\n-    ;\n-\n-Py::Object\n-Image::get_aspect(const Py::Tuple& args)\n-{\n-    _VERBOSE(\"Image::get_aspect\");\n-\n-    args.verify_length(0);\n-    return Py::Int((int)aspect);\n-}\n-\n-char Image::get_size__doc__[] =\n-    \"numrows, numcols = get_size()\\n\"\n-    \"\\n\"\n-    \"Get the number or rows and columns of the input image\"\n-    ;\n-\n-Py::Object\n-Image::get_size(const Py::Tuple& args)\n-{\n-    _VERBOSE(\"Image::get_size\");\n-\n-    args.verify_length(0);\n-\n-    Py::Tuple ret(2);\n-    ret[0] = Py::Int((long)rowsIn);\n-    ret[1] = Py::Int((long)colsIn);\n-    return ret;\n-\n-}\n-\n-char Image::get_resample__doc__[] =\n-    \"get_resample()\\n\"\n-    \"\\n\"\n-    \"Get the resample flag.\"\n-    ;\n-\n-Py::Object\n-Image::get_resample(const Py::Tuple& args)\n-{\n-    _VERBOSE(\"Image::get_resample\");\n-\n-    args.verify_length(0);\n-    return Py::Int((int)resample);\n-}\n-\n-char Image::get_size_out__doc__[] =\n-    \"numrows, numcols = get_size()\\n\"\n-    \"\\n\"\n-    \"Get the number or rows and columns of the output image\"\n-    ;\n-\n-Py::Object\n-Image::get_size_out(const Py::Tuple& args)\n-{\n-    _VERBOSE(\"Image::get_size_out\");\n-\n-    args.verify_length(0);\n-\n-    Py::Tuple ret(2);\n-    ret[0] = Py::Int((long)rowsOut);\n-    ret[1] = Py::Int((long)colsOut);\n-    return ret;\n-}\n-\n-//get the output buffer, flipped if necessary.  The second element of\n-//the pair is a bool that indicates whether you need to free the\n-//memory\n-std::pair<agg::int8u*, bool>\n-Image::_get_output_buffer()\n-{\n-    _VERBOSE(\"Image::_get_output_buffer\");\n-    std::pair<agg::int8u*, bool> ret;\n-    bool flipy = rbufOut->stride() < 0;\n-    if (flipy)\n-    {\n-        agg::int8u* buffer = new agg::int8u[rowsOut*colsOut*4];\n-        agg::rendering_buffer rb;\n-        rb.attach(buffer, colsOut, rowsOut, colsOut*4);\n-        rb.copy_from(*rbufOut);\n-        ret.first = buffer;\n-        ret.second = true;\n-    }\n-    else\n-    {\n-        ret.first = bufferOut;\n-        ret.second = false;\n-    }\n-    return ret;\n-\n-}\n-\n-char Image::set_interpolation__doc__[] =\n-    \"set_interpolation(scheme)\\n\"\n-    \"\\n\"\n-    \"Set the interpolation scheme to one of the module constants, \"\n-    \"eg, image.NEAREST, image.BILINEAR, etc...\"\n-    ;\n-\n-Py::Object\n-Image::set_interpolation(const Py::Tuple& args)\n-{\n-    _VERBOSE(\"Image::set_interpolation\");\n-\n-    args.verify_length(1);\n-\n-    size_t method = (long)Py::Int(args[0]);\n-    interpolation = (unsigned)method;\n-    return Py::Object();\n-}\n-\n-char Image::set_resample__doc__[] =\n-    \"set_resample(boolean)\\n\"\n-    \"\\n\"\n-    \"Set the resample flag.\"\n-    ;\n-\n-Py::Object\n-Image::set_resample(const Py::Tuple& args)\n-{\n-    _VERBOSE(\"Image::set_resample\");\n-    args.verify_length(1);\n-    int flag = Py::Int(args[0]);\n-    resample = (bool)flag;\n-    return Py::Object();\n-}\n-\n-\n-char Image::set_aspect__doc__[] =\n-    \"set_aspect(scheme)\\n\"\n-    \"\\n\"\n-    \"Set the aspect ration to one of the image module constant.\"\n-    \"eg, one of image.ASPECT_PRESERVE, image.ASPECT_FREE\"\n-    ;\n-Py::Object\n-Image::set_aspect(const Py::Tuple& args)\n-{\n-    _VERBOSE(\"Image::set_aspect\");\n-\n-    args.verify_length(1);\n-    size_t method = (long)Py::Int(args[0]);\n-    aspect = (unsigned)method;\n-    return Py::Object();\n-\n-}\n-\n-void\n-Image::init_type()\n-{\n-    _VERBOSE(\"Image::init_type\");\n-\n-    behaviors().name(\"Image\");\n-    behaviors().doc(\"Image\");\n-    behaviors().supportGetattr();\n-    behaviors().supportSetattr();\n-\n-    add_varargs_method(\"apply_rotation\", &Image::apply_rotation, Image::apply_rotation__doc__);\n-    add_varargs_method(\"apply_scaling\",  &Image::apply_scaling, Image::apply_scaling__doc__);\n-    add_varargs_method(\"apply_translation\", &Image::apply_translation, Image::apply_translation__doc__);\n-    add_keyword_method(\"as_rgba_str\", &Image::as_rgba_str, Image::as_rgba_str__doc__);\n-    add_varargs_method(\"color_conv\", &Image::color_conv, Image::color_conv__doc__);\n-    add_varargs_method(\"buffer_rgba\", &Image::buffer_rgba, Image::buffer_rgba__doc__);\n-    add_varargs_method(\"get_aspect\", &Image::get_aspect, Image::get_aspect__doc__);\n-    add_varargs_method(\"get_interpolation\", &Image::get_interpolation, Image::get_interpolation__doc__);\n-    add_varargs_method(\"get_resample\", &Image::get_resample, Image::get_resample__doc__);\n-    add_varargs_method(\"get_size\", &Image::get_size, Image::get_size__doc__);\n-    add_varargs_method(\"get_size_out\", &Image::get_size_out, Image::get_size_out__doc__);\n-    add_varargs_method(\"reset_matrix\", &Image::reset_matrix, Image::reset_matrix__doc__);\n-    add_varargs_method(\"get_matrix\", &Image::get_matrix, Image::get_matrix__doc__);\n-    add_keyword_method(\"resize\", &Image::resize, Image::resize__doc__);\n-    add_varargs_method(\"set_interpolation\", &Image::set_interpolation, Image::set_interpolation__doc__);\n-    add_varargs_method(\"set_resample\", &Image::set_resample, Image::set_resample__doc__);\n-    add_varargs_method(\"set_aspect\", &Image::set_aspect, Image::set_aspect__doc__);\n-    add_varargs_method(\"set_bg\", &Image::set_bg, Image::set_bg__doc__);\n-    add_varargs_method(\"flipud_out\", &Image::flipud_out, Image::flipud_out__doc__);\n-    add_varargs_method(\"flipud_in\", &Image::flipud_in, Image::flipud_in__doc__);\n-}\n-\n-\n-\n-\n-char _image_module_from_images__doc__[] =\n-    \"from_images(numrows, numcols, seq)\\n\"\n-    \"\\n\"\n-    \"return an image instance with numrows, numcols from a seq of image\\n\"\n-    \"instances using alpha blending.  seq is a list of (Image, ox, oy)\"\n-    ;\n-Py::Object\n-_image_module::from_images(const Py::Tuple& args)\n-{\n-    _VERBOSE(\"_image_module::from_images\");\n-\n-    args.verify_length(3);\n-\n-    size_t numrows = (long)Py::Int(args[0]);\n-    size_t numcols = (long)Py::Int(args[1]);\n-\n-    if (numrows >= 32768 || numcols >= 32768)\n-    {\n-        throw Py::RuntimeError(\"numrows and numcols must both be less than 32768\");\n-    }\n-\n-    Py::SeqBase<Py::Object> tups = args[2];\n-    size_t N = tups.length();\n-\n-    if (N == 0)\n-    {\n-        throw Py::RuntimeError(\"Empty list of images\");\n-    }\n-\n-    Py::Tuple tup;\n-\n-    size_t ox(0), oy(0), thisx(0), thisy(0);\n-    float alpha;\n-    bool apply_alpha;\n-\n-    //copy image 0 output buffer into return images output buffer\n-    Image* imo = new Image;\n-    imo->rowsOut  = numrows;\n-    imo->colsOut  = numcols;\n-\n-    size_t NUMBYTES(numrows * numcols * imo->BPP);\n-    imo->bufferOut = new agg::int8u[NUMBYTES];\n-    if (imo->bufferOut == NULL) //todo: also handle allocation throw\n-    {\n-        throw Py::MemoryError(\"_image_module::from_images could not allocate memory\");\n-    }\n-\n-    delete imo->rbufOut;\n-    imo->rbufOut = new agg::rendering_buffer;\n-    imo->rbufOut->attach(imo->bufferOut, imo->colsOut, imo->rowsOut, imo->colsOut * imo->BPP);\n-\n-    pixfmt pixf(*imo->rbufOut);\n+    pixfmt pixf(*rbufOut);\n     renderer_base rb(pixf);\n-\n-    rb.clear(agg::rgba(0, 0, 0, 0));\n-    for (size_t imnum = 0; imnum < N; imnum++)\n-    {\n-        tup = Py::Tuple(tups[imnum]);\n-        Image* thisim = static_cast<Image*>(tup[0].ptr());\n-        ox = (long)Py::Int(tup[1]);\n-        oy = (long)Py::Int(tup[2]);\n-        if (tup.size() <= 3 || tup[3].ptr() == Py_None)\n-        {\n-            apply_alpha = false;\n-        }\n-        else\n-        {\n-            apply_alpha = true;\n-            alpha = Py::Float(tup[3]);\n-        }\n-\n-        bool isflip = (thisim->rbufOut->stride()) < 0;\n-        //std::cout << \"from images \" << isflip << \"; stride=\" << thisim->rbufOut->stride() << std::endl;\n-        size_t ind = 0;\n-        for (size_t j = 0; j < thisim->rowsOut; j++)\n-        {\n-            for (size_t i = 0; i < thisim->colsOut; i++)\n-            {\n-                thisx = i + ox;\n-\n-                if (isflip)\n-                {\n-                    thisy = thisim->rowsOut - j + oy;\n-                }\n-                else\n-                {\n-                    thisy = j + oy;\n-                }\n-\n-                if (thisx >= numcols || thisy >= numrows)\n-                {\n-                    ind += 4;\n-                    continue;\n-                }\n-\n-                pixfmt::color_type p;\n-                p.r = *(thisim->bufferOut + ind++);\n-                p.g = *(thisim->bufferOut + ind++);\n-                p.b = *(thisim->bufferOut + ind++);\n-                if (apply_alpha)\n-                {\n-                    p.a = (pixfmt::value_type) *(thisim->bufferOut + ind++) * alpha;\n-                }\n-                else\n-                {\n-                    p.a = *(thisim->bufferOut + ind++);\n-                }\n-                pixf.blend_pixel(thisx, thisy, p, 255);\n-            }\n-        }\n-    }\n-\n-    return Py::asObject(imo);\n-}\n-\n-\n-char _image_module_fromarray__doc__[] =\n-    \"fromarray(A, isoutput)\\n\"\n-    \"\\n\"\n-    \"Load the image from a numpy array\\n\"\n-    \"By default this function fills the input buffer, which can subsequently\\n\"\n-    \"be resampled using resize.  If isoutput=1, fill the output buffer.\\n\"\n-    \"This is used to support raw pixel images w/o resampling\"\n-    ;\n-Py::Object\n-_image_module::fromarray(const Py::Tuple& args)\n-{\n-    _VERBOSE(\"_image_module::fromarray\");\n-\n-    args.verify_length(2);\n-\n-    Py::Object x = args[0];\n-    int isoutput = Py::Int(args[1]);\n-    PyArrayObject *A = (PyArrayObject *) PyArray_FromObject(x.ptr(), NPY_DOUBLE, 2, 3);\n-    if (A == NULL)\n-    {\n-        throw Py::ValueError(\"Array must be rank 2 or 3 of doubles\");\n-    }\n-    Py::Object A_obj((PyObject *)A, true);\n-\n-    Image* imo = new Image;\n-\n-    imo->rowsIn  = PyArray_DIM(A, 0);\n-    imo->colsIn  = PyArray_DIM(A, 1);\n-\n-    size_t NUMBYTES(imo->colsIn * imo->rowsIn * imo->BPP);\n-    agg::int8u *buffer = new agg::int8u[NUMBYTES];\n-    if (buffer == NULL) //todo: also handle allocation throw\n-    {\n-        throw Py::MemoryError(\"_image_module::fromarray could not allocate memory\");\n-    }\n-\n-    if (isoutput)\n-    {\n-        // make the output buffer point to the input buffer\n-        imo->rowsOut  = imo->rowsIn;\n-        imo->colsOut  = imo->colsIn;\n-\n-        imo->rbufOut = new agg::rendering_buffer;\n-        imo->bufferOut = buffer;\n-        imo->rbufOut->attach(imo->bufferOut, imo->colsOut, imo->rowsOut, imo->colsOut * imo->BPP);\n-    }\n-    else\n-    {\n-        imo->bufferIn = buffer;\n-        imo->rbufIn = new agg::rendering_buffer;\n-        imo->rbufIn->attach(buffer, imo->colsIn, imo->rowsIn, imo->colsIn*imo->BPP);\n-    }\n-\n-    if (PyArray_NDIM(A) == 2)     //assume luminance for now;\n-    {\n-        agg::int8u gray;\n-        for (size_t rownum = 0; rownum < imo->rowsIn; rownum++)\n-        {\n-            for (size_t colnum = 0; colnum < imo->colsIn; colnum++)\n-            {\n-                double val = *(double *)PyArray_GETPTR2(A, rownum, colnum);\n-\n-                gray = int(255 * val);\n-                *buffer++ = gray;       // red\n-                *buffer++ = gray;       // green\n-                *buffer++ = gray;       // blue\n-                *buffer++   = 255;        // alpha\n-            }\n-        }\n-    }\n-    else if (PyArray_NDIM(A) == 3)     // assume RGB\n-    {\n-\n-        if (PyArray_DIM(A, 2) != 3 && PyArray_DIM(A, 2) != 4)\n-        {\n-            throw Py::ValueError(Printf(\"3rd dimension must be length 3 (RGB) or 4 (RGBA); found %d\",\n-                                        PyArray_DIM(A, 2)).str());\n-        }\n-\n-        int rgba = PyArray_DIM(A, 2) == 4;\n-        double r, g, b, alpha;\n-        size_t offset = 0;\n-\n-        for (size_t rownum = 0; rownum < imo->rowsIn; rownum++)\n-        {\n-            for (size_t colnum = 0; colnum < imo->colsIn; colnum++)\n-            {\n-                r = *(double*)PyArray_GETPTR3(A, rownum, colnum, 0);\n-                g = *(double*)PyArray_GETPTR3(A, rownum, colnum, 1);\n-                b = *(double*)PyArray_GETPTR3(A, rownum, colnum, 2);\n-\n-                if (rgba)\n-                {\n-                    alpha = *(double*)PyArray_GETPTR3(A, rownum, colnum, 3);\n-                }\n-                else\n-                {\n-                    alpha = 1.0;\n-                }\n-\n-                *buffer++ = int(255 * r);       // red\n-                *buffer++ = int(255 * g);       // green\n-                *buffer++ = int(255 * b);       // blue\n-                *buffer++ = int(255 * alpha);   // alpha\n-            }\n-        }\n-    }\n-    else     // error\n-    {\n-        throw Py::ValueError(\"Illegal array rank; must be rank; must 2 or 3\");\n-    }\n-\n-    return Py::asObject(imo);\n+    rb.clear(bg);\n }\n \n-char _image_module_fromarray2__doc__[] =\n-    \"fromarray2(A, isoutput)\\n\"\n-    \"\\n\"\n-    \"Load the image from a numpy array\\n\"\n-    \"By default this function fills the input buffer, which can subsequently\\n\"\n-    \"be resampled using resize.  If isoutput=1, fill the output buffer.\\n\"\n-    \"This is used to support raw pixel images w/o resampling\"\n-    ;\n-Py::Object\n-_image_module::fromarray2(const Py::Tuple& args)\n+void Image::blend_image(Image &im, unsigned ox, unsigned oy, bool apply_alpha, float alpha)\n {\n-    _VERBOSE(\"_image_module::fromarray2\");\n-\n-    args.verify_length(2);\n-\n-    Py::Object x = args[0];\n-    int isoutput = Py::Int(args[1]);\n-    PyArrayObject *A = (PyArrayObject *) PyArray_ContiguousFromObject(x.ptr(), NPY_DOUBLE, 2, 3);\n-    if (A == NULL)\n-    {\n-        throw Py::ValueError(\"Array must be rank 2 or 3 of doubles\");\n-    }\n-    Py::Object A_obj((PyObject*)A, true);\n-\n-    Image* imo = new Image;\n-\n-    imo->rowsIn  = PyArray_DIM(A, 0);\n-    imo->colsIn  = PyArray_DIM(A, 1);\n-\n-    size_t NUMBYTES(imo->colsIn * imo->rowsIn * imo->BPP);\n-    agg::int8u *buffer = new agg::int8u[NUMBYTES];\n-    if (buffer == NULL) //todo: also handle allocation throw\n-    {\n-        throw Py::MemoryError(\"_image_module::fromarray could not allocate memory\");\n-    }\n-\n-    if (isoutput)\n-    {\n-        // make the output buffer point to the input buffer\n-        imo->rowsOut  = imo->rowsIn;\n-        imo->colsOut  = imo->colsIn;\n+    unsigned thisx = 0, thisy = 0;\n \n-        imo->rbufOut = new agg::rendering_buffer;\n-        imo->bufferOut = buffer;\n-        imo->rbufOut->attach(imo->bufferOut, imo->colsOut, imo->rowsOut, imo->colsOut * imo->BPP);\n-    }\n-    else\n-    {\n-        imo->bufferIn = buffer;\n-        imo->rbufIn = new agg::rendering_buffer;\n-        imo->rbufIn->attach(buffer, imo->colsIn, imo->rowsIn, imo->colsIn*imo->BPP);\n-    }\n+    pixfmt pixf(*rbufOut);\n+    renderer_base rb(pixf);\n \n-    if (PyArray_NDIM(A) == 2)     //assume luminance for now;\n-    {\n-        agg::int8u gray;\n-        for (size_t row = 0; row < imo->rowsIn; row++) {\n-            for (size_t col = 0; col < imo->colsIn; col++) {\n-                const double val = *(double*)PyArray_GETPTR2(A, row, col);\n-                gray = int(255 * val);\n-                *buffer++ = gray;  // red\n-                *buffer++ = gray;  // green\n-                *buffer++ = gray;  // blue\n-                *buffer++ = 255;   // alpha\n-            }\n+    bool isflip = (im.rbufOut->stride()) < 0;\n+    size_t ind = 0;\n+    for (unsigned j = 0; j < im.rowsOut; j++) {\n+        if (isflip) {\n+            thisy = im.rowsOut - j + oy;\n+        } else {\n+            thisy = j + oy;\n         }\n-    }\n-    else if (PyArray_NDIM(A) == 3)     // assume RGB\n-    {\n-        if (PyArray_DIM(A, 2) != 3 && PyArray_DIM(A, 2) != 4)\n-        {\n-            throw Py::ValueError(Printf(\"3rd dimension must be length 3 (RGB) or 4 (RGBA); found %d\",\n-                                        PyArray_DIM(A, 2)).str());\n \n-        }\n+        for (unsigned i = 0; i < im.colsOut; i++) {\n+            thisx = i + ox;\n \n-        int rgba = PyArray_DIM(A, 2) == 4;\n-        double r, g, b, alpha;\n-        for (size_t row = 0; row < imo->rowsIn; row++) {\n-            for (size_t col = 0; col < imo->colsIn; col++) {\n-                r = *(double*)PyArray_GETPTR3(A, row, col, 0);\n-                g = *(double*)PyArray_GETPTR3(A, row, col, 1);\n-                b = *(double*)PyArray_GETPTR3(A, row, col, 2);\n-                if (rgba)\n-                    alpha = *(double*)PyArray_GETPTR3(A, row, col, 3);\n-                else\n-                    alpha = 1.0;\n-                *buffer++ = int(255 * r);       // red\n-                *buffer++ = int(255 * g);       // green\n-                *buffer++ = int(255 * b);       // blue\n-                *buffer++ = int(255 * alpha);   // alpha\n+            if (thisx >= colsOut || thisy >= rowsOut) {\n+                ind += 4;\n+                continue;\n             }\n-        }\n-    }\n-    else     // error\n-    {\n-        throw Py::ValueError(\"Illegal array rank; must be rank; must 2 or 3\");\n-    }\n-\n-    return Py::asObject(imo);\n-}\n-\n-char _image_module_frombyte__doc__[] =\n-    \"frombyte(A, isoutput)\\n\"\n-    \"\\n\"\n-    \"Load the image from a byte array.\\n\"\n-    \"By default this function fills the input buffer, which can subsequently\\n\"\n-    \"be resampled using resize.  If isoutput=1, fill the output buffer.\\n\"\n-    \"This is used to support raw pixel images w/o resampling.\"\n-    ;\n-Py::Object\n-_image_module::frombyte(const Py::Tuple& args)\n-{\n-    _VERBOSE(\"_image_module::frombyte\");\n-\n-    args.verify_length(2);\n-\n-    Py::Object x = args[0];\n-    int isoutput = Py::Int(args[1]);\n-\n-    PyArrayObject *A = (PyArrayObject *) PyArray_FromObject(x.ptr(), NPY_UBYTE, 3, 3);\n-    if (A == NULL)\n-    {\n-        throw Py::ValueError(\"Array must have 3 dimensions\");\n-    }\n-    Py::Object A_obj((PyObject*)A, true);\n-\n-    if (PyArray_DIM(A, 2) < 3 || PyArray_DIM(A, 2) > 4)\n-    {\n-        throw Py::ValueError(\"Array dimension 3 must have size 3 or 4\");\n-    }\n-\n-    Image* imo = new Image;\n-\n-    imo->rowsIn = PyArray_DIM(A, 0);\n-    imo->colsIn = PyArray_DIM(A, 1);\n-\n-    agg::int8u *arrbuf;\n-    agg::int8u *buffer;\n-    agg::int8u *dstbuf;\n-\n-    arrbuf = reinterpret_cast<agg::int8u *>(PyArray_DATA(A));\n-\n-    size_t NUMBYTES(imo->colsIn * imo->rowsIn * imo->BPP);\n-    buffer = dstbuf = new agg::int8u[NUMBYTES];\n \n-    if (buffer == NULL) //todo: also handle allocation throw\n-    {\n-        throw Py::MemoryError(\"_image_module::frombyte could not allocate memory\");\n-    }\n-\n-    if (PyArray_ISCONTIGUOUS(A))\n-    {\n-        if (PyArray_DIM(A, 2) == 4)\n-        {\n-            memmove(dstbuf, arrbuf, imo->rowsIn * imo->colsIn * 4);\n-        }\n-        else\n-        {\n-            size_t i = imo->rowsIn * imo->colsIn;\n-            while (i--)\n-            {\n-                *dstbuf++ = *arrbuf++;\n-                *dstbuf++ = *arrbuf++;\n-                *dstbuf++ = *arrbuf++;\n-                *dstbuf++ = 255;\n-            }\n-        }\n-    }\n-    else if ((PyArray_STRIDE(A, 1) == 4) && (PyArray_STRIDE(A, 2) == 1))\n-    {\n-        const size_t N = imo->colsIn * 4;\n-        const size_t stride = PyArray_STRIDE(A, 0);\n-        for (size_t rownum = 0; rownum < imo->rowsIn; rownum++)\n-        {\n-            memmove(dstbuf, arrbuf, N);\n-            arrbuf += stride;\n-            dstbuf += N;\n-        }\n-    }\n-    else if ((PyArray_STRIDE(A, 1) == 3) && (PyArray_STRIDE(A, 2) == 1))\n-    {\n-        const size_t stride = PyArray_STRIDE(A, 0) - imo->colsIn * 3;\n-        for (size_t rownum = 0; rownum < imo->rowsIn; rownum++)\n-        {\n-            for (size_t colnum = 0; colnum < imo->colsIn; colnum++)\n-            {\n-                *dstbuf++ = *arrbuf++;\n-                *dstbuf++ = *arrbuf++;\n-                *dstbuf++ = *arrbuf++;\n-                *dstbuf++ = 255;\n-            }\n-            arrbuf += stride;\n-        }\n-    }\n-    else\n-    {\n-        PyArrayIterObject *iter;\n-        iter = (PyArrayIterObject *)PyArray_IterNew((PyObject *)A);\n-        if (PyArray_DIM(A, 2) == 4)\n-        {\n-            while (iter->index < iter->size) {\n-                *dstbuf++ = *((unsigned char *)iter->dataptr);\n-                PyArray_ITER_NEXT(iter);\n-            }\n-        }\n-        else\n-        {\n-            while (iter->index < iter->size) {\n-                *dstbuf++ = *((unsigned char *)iter->dataptr);\n-                PyArray_ITER_NEXT(iter);\n-                *dstbuf++ = *((unsigned char *)iter->dataptr);\n-                PyArray_ITER_NEXT(iter);\n-                *dstbuf++ = *((unsigned char *)iter->dataptr);\n-                PyArray_ITER_NEXT(iter);\n-                *dstbuf++ = 255;\n+            pixfmt::color_type p;\n+            p.r = *(im.bufferOut + ind++);\n+            p.g = *(im.bufferOut + ind++);\n+            p.b = *(im.bufferOut + ind++);\n+            if (apply_alpha) {\n+                p.a = (pixfmt::value_type) * (im.bufferOut + ind++) * alpha;\n+            } else {\n+                p.a = *(im.bufferOut + ind++);\n             }\n+            pixf.blend_pixel(thisx, thisy, p, 255);\n         }\n-        Py_DECREF(iter);\n-    }\n-\n-    if (isoutput)\n-    {\n-        // make the output buffer point to the input buffer\n-\n-        imo->rowsOut  = imo->rowsIn;\n-        imo->colsOut  = imo->colsIn;\n-\n-        imo->rbufOut = new agg::rendering_buffer;\n-        imo->bufferOut = buffer;\n-        imo->rbufOut->attach(imo->bufferOut, imo->colsOut, imo->rowsOut, imo->colsOut * imo->BPP);\n-\n-    }\n-    else\n-    {\n-        imo->bufferIn = buffer;\n-        imo->rbufIn = new agg::rendering_buffer;\n-        imo->rbufIn->attach(buffer, imo->colsIn, imo->rowsIn, imo->colsIn*imo->BPP);\n     }\n-\n-    return Py::asObject(imo);\n-}\n-\n-char _image_module_frombuffer__doc__[] =\n-    \"frombuffer(buffer, width, height, isoutput)\\n\"\n-    \"\\n\"\n-    \"Load the image from a character buffer\\n\"\n-    \"By default this function fills the input buffer, which can subsequently\\n\"\n-    \"be resampled using resize.  If isoutput=1, fill the output buffer.\\n\"\n-    \"This is used to support raw pixel images w/o resampling.\"\n-    ;\n-Py::Object\n-_image_module::frombuffer(const Py::Tuple& args)\n-{\n-    _VERBOSE(\"_image_module::frombuffer\");\n-\n-    args.verify_length(4);\n-\n-    PyObject *bufin = args[0].ptr();\n-    size_t x = (long)Py::Int(args[1]);\n-    size_t y = (long)Py::Int(args[2]);\n-\n-    if (x >= 32768 || y >= 32768)\n-    {\n-        throw Py::ValueError(\"x and y must both be less than 32768\");\n-    }\n-\n-    int isoutput = Py::Int(args[3]);\n-\n-    if (PyObject_CheckReadBuffer(bufin) != 1)\n-        throw Py::ValueError(\"First argument must be a buffer.\");\n-\n-    Image* imo = new Image;\n-\n-    imo->rowsIn = y;\n-    imo->colsIn = x;\n-    Py_ssize_t NUMBYTES(imo->colsIn * imo->rowsIn * imo->BPP);\n-\n-    Py_ssize_t buflen;\n-    const agg::int8u *rawbuf;\n-    if (PyObject_AsReadBuffer(bufin, reinterpret_cast<const void**>(&rawbuf), &buflen) != 0)\n-    {\n-        throw Py::ValueError(\"Cannot get buffer from object.\");\n-    }\n-\n-    // Check buffer is required size.\n-    if (buflen != NUMBYTES)\n-    {\n-        throw Py::ValueError(\"Buffer length must be width * height * 4.\");\n-    }\n-\n-    // Copy from input buffer to new buffer for agg.\n-    agg::int8u* buffer = new agg::int8u[NUMBYTES];\n-    if (buffer == NULL) //todo: also handle allocation throw\n-    {\n-        throw Py::MemoryError(\"_image_module::frombuffer could not allocate memory\");\n-    }\n-    memmove(buffer, rawbuf, NUMBYTES);\n-\n-    if (isoutput)\n-    {\n-        // make the output buffer point to the input buffer\n-        imo->rowsOut  = imo->rowsIn;\n-        imo->colsOut  = imo->colsIn;\n-\n-        imo->rbufOut = new agg::rendering_buffer;\n-        imo->bufferOut = buffer;\n-        imo->rbufOut->attach(imo->bufferOut, imo->colsOut, imo->rowsOut, imo->colsOut * imo->BPP);\n-\n-    }\n-    else\n-    {\n-        imo->bufferIn = buffer;\n-        imo->rbufIn = new agg::rendering_buffer;\n-        imo->rbufIn->attach(buffer, imo->colsIn, imo->rowsIn, imo->colsIn*imo->BPP);\n-    }\n-\n-    return Py::asObject(imo);\n }\n \n // utilities for irregular grids\n-void _bin_indices_middle(unsigned int *irows, int nrows, float *ys1, int ny, float dy, float y_min)\n+void _bin_indices_middle(\n+    unsigned int *irows, int nrows, const float *ys1, unsigned long ny, float dy, float y_min)\n {\n-    int  i, j, j_last;\n-    unsigned  int * rowstart = irows;\n-    float *ys2 = ys1 + 1;\n-    float *yl = ys1 + ny ;\n+    int i, j, j_last;\n+    unsigned int *rowstart = irows;\n+    const float *ys2 = ys1 + 1;\n+    const float *yl = ys1 + ny;\n     float yo = y_min + dy / 2.0;\n     float ym = 0.5f * (*ys1 + *ys2);\n     // y/rows\n     j = 0;\n     j_last = j;\n-    for (i = 0;i < nrows;i++, yo += dy, rowstart++)\n-    {\n-        while (ys2 != yl && yo > ym)\n-        {\n+    for (i = 0; i < nrows; i++, yo += dy, rowstart++) {\n+        while (ys2 != yl && yo > ym) {\n             ys1 = ys2;\n             ys2 = ys1 + 1;\n             ym = 0.5f * (*ys1 + *ys2);\n@@ -1347,658 +407,147 @@ void _bin_indices_middle(unsigned int *irows, int nrows, float *ys1, int ny, flo\n     }\n }\n \n-void _bin_indices_middle_linear(float *arows, unsigned int *irows, int nrows, float *y, int ny, float dy, float y_min)\n+void _bin_indices_middle_linear(float *arows,\n+                                unsigned int *irows,\n+                                int nrows,\n+                                const float *y,\n+                                unsigned long ny,\n+                                float dy,\n+                                float y_min)\n {\n     int i;\n     int ii = 0;\n-    int iilast = ny - 1;\n+    int iilast = (int)ny - 1;\n     float sc = 1 / dy;\n-    int iy0 = (int)floor(sc * (y[ii]  - y_min));\n-    int iy1 = (int)floor(sc * (y[ii+1]  - y_min));\n+    int iy0 = (int)floor(sc * (y[ii] - y_min));\n+    int iy1 = (int)floor(sc * (y[ii + 1] - y_min));\n     float invgap = 1.0f / (iy1 - iy0);\n-    for (i = 0; i < nrows && i <= iy0; i++)\n-    {\n+    for (i = 0; i < nrows && i <= iy0; i++) {\n         irows[i] = 0;\n         arows[i] = 1.0;\n-        //std::cerr<<\"i=\"<<i<<\"  ii=\"<<0<<\" a=\"<< arows[i]<< std::endl;\n     }\n-    for (; i < nrows; i++)\n-    {\n-        while (i > iy1 && ii < iilast)\n-        {\n+    for (; i < nrows; i++) {\n+        while (i > iy1 && ii < iilast) {\n             ii++;\n             iy0 = iy1;\n-            iy1 = (int)floor(sc * (y[ii+1] - y_min));\n+            iy1 = (int)floor(sc * (y[ii + 1] - y_min));\n             invgap = 1.0f / (iy1 - iy0);\n         }\n-        if (i >= iy0 && i <= iy1)\n-        {\n+        if (i >= iy0 && i <= iy1) {\n             irows[i] = ii;\n             arows[i] = (iy1 - i) * invgap;\n-            //std::cerr<<\"i=\"<<i<<\"  ii=\"<<ii<<\" a=\"<< arows[i]<< std::endl;\n-        }\n-        else break;\n+        } else\n+            break;\n     }\n-    for (; i < nrows; i++)\n-    {\n+    for (; i < nrows; i++) {\n         irows[i] = iilast - 1;\n         arows[i] = 0.0;\n-        //std::cerr<<\"i=\"<<i<<\"  ii=\"<<iilast-1<<\" a=\"<< arows[i]<< std::endl;\n     }\n }\n \n-void _bin_indices(int *irows, int nrows, double *y, int ny,\n-                  double sc, double offs)\n+void _bin_indices(int *irows, int nrows, const double *y, unsigned long ny, double sc, double offs)\n {\n     int i;\n-    if (sc*(y[ny-1] - y[0]) > 0)\n-    {\n+    if (sc * (y[ny - 1] - y[0]) > 0) {\n         int ii = 0;\n-        int iilast = ny - 1;\n-        int iy0 = (int)floor(sc * (y[ii]  - offs));\n-        int iy1 = (int)floor(sc * (y[ii+1]  - offs));\n-        for (i = 0; i < nrows && i < iy0; i++)\n-        {\n+        int iilast = (int)ny - 1;\n+        int iy0 = (int)floor(sc * (y[ii] - offs));\n+        int iy1 = (int)floor(sc * (y[ii + 1] - offs));\n+        for (i = 0; i < nrows && i < iy0; i++) {\n             irows[i] = -1;\n         }\n-        for (; i < nrows; i++)\n-        {\n-            while (i > iy1 && ii < iilast)\n-            {\n+        for (; i < nrows; i++) {\n+            while (i > iy1 && ii < iilast) {\n                 ii++;\n                 iy0 = iy1;\n-                iy1 = (int)floor(sc * (y[ii+1] - offs));\n+                iy1 = (int)floor(sc * (y[ii + 1] - offs));\n             }\n-            if (i >= iy0 && i <= iy1) irows[i] = ii;\n-            else break;\n+            if (i >= iy0 && i <= iy1)\n+                irows[i] = ii;\n+            else\n+                break;\n         }\n-        for (; i < nrows; i++)\n-        {\n+        for (; i < nrows; i++) {\n             irows[i] = -1;\n         }\n-    }\n-    else\n-    {\n-        int iilast = ny - 1;\n+    } else {\n+        int iilast = (int)ny - 1;\n         int ii = iilast;\n-        int iy0 = (int)floor(sc * (y[ii]  - offs));\n-        int iy1 = (int)floor(sc * (y[ii-1]  - offs));\n-        for (i = 0; i < nrows && i < iy0; i++)\n-        {\n+        int iy0 = (int)floor(sc * (y[ii] - offs));\n+        int iy1 = (int)floor(sc * (y[ii - 1] - offs));\n+        for (i = 0; i < nrows && i < iy0; i++) {\n             irows[i] = -1;\n         }\n-        for (; i < nrows; i++)\n-        {\n-            while (i > iy1 && ii > 1)\n-            {\n+        for (; i < nrows; i++) {\n+            while (i > iy1 && ii > 1) {\n                 ii--;\n                 iy0 = iy1;\n-                iy1 = (int)floor(sc * (y[ii-1] - offs));\n+                iy1 = (int)floor(sc * (y[ii - 1] - offs));\n             }\n-            if (i >= iy0 && i <= iy1) irows[i] = ii - 1;\n-            else break;\n+            if (i >= iy0 && i <= iy1)\n+                irows[i] = ii - 1;\n+            else\n+                break;\n         }\n-        for (; i < nrows; i++)\n-        {\n+        for (; i < nrows; i++) {\n             irows[i] = -1;\n         }\n     }\n }\n \n-void _bin_indices_linear(float *arows, int *irows, int nrows, double *y, int ny,\n-                         double sc, double offs)\n+void _bin_indices_linear(\n+    float *arows, int *irows, int nrows, double *y, unsigned long ny, double sc, double offs)\n {\n     int i;\n-    if (sc*(y[ny-1] - y[0]) > 0)\n-    {\n+    if (sc * (y[ny - 1] - y[0]) > 0) {\n         int ii = 0;\n-        int iilast = ny - 1;\n-        int iy0 = (int)floor(sc * (y[ii]  - offs));\n-        int iy1 = (int)floor(sc * (y[ii+1]  - offs));\n+        int iilast = (int)ny - 1;\n+        int iy0 = (int)floor(sc * (y[ii] - offs));\n+        int iy1 = (int)floor(sc * (y[ii + 1] - offs));\n         float invgap = 1.0 / (iy1 - iy0);\n-        for (i = 0; i < nrows && i < iy0; i++)\n-        {\n+        for (i = 0; i < nrows && i < iy0; i++) {\n             irows[i] = -1;\n         }\n-        for (; i < nrows; i++)\n-        {\n-            while (i > iy1 && ii < iilast)\n-            {\n+        for (; i < nrows; i++) {\n+            while (i > iy1 && ii < iilast) {\n                 ii++;\n                 iy0 = iy1;\n-                iy1 = (int)floor(sc * (y[ii+1] - offs));\n+                iy1 = (int)floor(sc * (y[ii + 1] - offs));\n                 invgap = 1.0 / (iy1 - iy0);\n             }\n-            if (i >= iy0 && i <= iy1)\n-            {\n+            if (i >= iy0 && i <= iy1) {\n                 irows[i] = ii;\n                 arows[i] = (iy1 - i) * invgap;\n-            }\n-            else break;\n+            } else\n+                break;\n         }\n-        for (; i < nrows; i++)\n-        {\n+        for (; i < nrows; i++) {\n             irows[i] = -1;\n         }\n-    }\n-    else\n-    {\n-        int iilast = ny - 1;\n+    } else {\n+        int iilast = (int)ny - 1;\n         int ii = iilast;\n-        int iy0 = (int)floor(sc * (y[ii]  - offs));\n-        int iy1 = (int)floor(sc * (y[ii-1]  - offs));\n+        int iy0 = (int)floor(sc * (y[ii] - offs));\n+        int iy1 = (int)floor(sc * (y[ii - 1] - offs));\n         float invgap = 1.0 / (iy1 - iy0);\n-        for (i = 0; i < nrows && i < iy0; i++)\n-        {\n+        for (i = 0; i < nrows && i < iy0; i++) {\n             irows[i] = -1;\n         }\n-        for (; i < nrows; i++)\n-        {\n-            while (i > iy1 && ii > 1)\n-            {\n+        for (; i < nrows; i++) {\n+            while (i > iy1 && ii > 1) {\n                 ii--;\n                 iy0 = iy1;\n-                iy1 = (int)floor(sc * (y[ii-1] - offs));\n+                iy1 = (int)floor(sc * (y[ii - 1] - offs));\n                 invgap = 1.0 / (iy1 - iy0);\n             }\n-            if (i >= iy0 && i <= iy1)\n-            {\n+            if (i >= iy0 && i <= iy1) {\n                 irows[i] = ii - 1;\n                 arows[i] = (i - iy0) * invgap;\n-            }\n-            else break;\n+            } else\n+                break;\n         }\n-        for (; i < nrows; i++)\n-        {\n+        for (; i < nrows; i++) {\n             irows[i] = -1;\n         }\n     }\n }\n-\n-\n-\n-char __image_module_pcolor__doc__[] =\n-    \"pcolor(x, y, data, rows, cols, bounds)\\n\"\n-    \"\\n\"\n-    \"Generate a pseudo-color image from data on a non-uniform grid using\\n\"\n-    \"nearest neighbour or linear interpolation.\\n\"\n-    \"bounds = (x_min, x_max, y_min, y_max)\\n\"\n-    \"interpolation = NEAREST or BILINEAR \\n\"\n-    ;\n-\n-void _pcolor_cleanup(PyArrayObject* x, PyArrayObject* y,  PyArrayObject *d,\n-                     unsigned int * rowstarts , unsigned int*colstarts ,\n-                     float *acols , float *arows)\n-{\n-    Py_XDECREF(x);\n-    Py_XDECREF(y);\n-    Py_XDECREF(d);\n-    if (rowstarts)\n-    {\n-        PyMem_Free(rowstarts);\n-    }\n-    if (colstarts)\n-    {\n-        PyMem_Free(colstarts);\n-    }\n-    if (acols)\n-    {\n-        PyMem_Free(acols);\n-    }\n-    if (arows)\n-    {\n-        PyMem_Free(arows);\n-    }\n-    return;\n-}\n-\n-Py::Object\n-_image_module::pcolor(const Py::Tuple& args)\n-{\n-    _VERBOSE(\"_image_module::pcolor\");\n-\n-\n-    if (args.length() != 7)\n-    {\n-        throw Py::TypeError(\"Incorrect number of arguments (7 expected)\");\n-    }\n-\n-    Py::Object xp = args[0];\n-    Py::Object yp = args[1];\n-    Py::Object dp = args[2];\n-    unsigned int rows = (unsigned long)Py::Int(args[3]);\n-    unsigned int cols = (unsigned long)Py::Int(args[4]);\n-    Py::Tuple bounds = args[5];\n-    unsigned int interpolation = (unsigned long)Py::Int(args[6]);\n-\n-    if (rows >= 32768 || cols >= 32768)\n-    {\n-        throw Py::ValueError(\"rows and cols must both be less than 32768\");\n-    }\n-\n-    if (bounds.length() != 4)\n-    {\n-        throw Py::TypeError(\"Incorrect number of bounds (4 expected)\");\n-    }\n-\n-    float x_min = Py::Float(bounds[0]);\n-    float x_max = Py::Float(bounds[1]);\n-    float y_min = Py::Float(bounds[2]);\n-    float y_max = Py::Float(bounds[3]);\n-    float width = x_max - x_min;\n-    float height = y_max - y_min;\n-    float dx = width / ((float) cols);\n-    float dy = height / ((float) rows);\n-\n-    // Check we have something to output to\n-    if (rows == 0 || cols == 0)\n-    {\n-        throw Py::ValueError(\"Cannot scale to zero size\");\n-    }\n-\n-    PyArrayObject *x = NULL;\n-    PyArrayObject *y = NULL;\n-    PyArrayObject *d = NULL;\n-    unsigned int *rowstarts = NULL;\n-    unsigned int *colstarts = NULL;\n-    float *acols = NULL;\n-    float *arows = NULL;\n-\n-    // Get numpy arrays\n-    x = (PyArrayObject *) PyArray_ContiguousFromObject(xp.ptr(), NPY_FLOAT, 1, 1);\n-    if (x == NULL)\n-    {\n-        _pcolor_cleanup(x, y, d, rowstarts, colstarts, acols, arows);\n-        throw Py::ValueError(\"x is of incorrect type (wanted 1D float)\");\n-    }\n-    y = (PyArrayObject *) PyArray_ContiguousFromObject(yp.ptr(), NPY_FLOAT, 1, 1);\n-    if (y == NULL)\n-    {\n-        _pcolor_cleanup(x, y, d, rowstarts, colstarts, acols, arows);\n-        throw Py::ValueError(\"y is of incorrect type (wanted 1D float)\");\n-    }\n-    d = (PyArrayObject *) PyArray_ContiguousFromObject(dp.ptr(), NPY_UBYTE, 3, 3);\n-    if (d == NULL)\n-    {\n-        _pcolor_cleanup(x, y, d, rowstarts, colstarts, acols, arows);\n-        throw Py::ValueError(\"data is of incorrect type (wanted 3D UInt8)\");\n-    }\n-    if (PyArray_DIM(d, 2) != 4)\n-    {\n-        _pcolor_cleanup(x, y, d, rowstarts, colstarts, acols, arows);\n-        throw Py::ValueError(\"data must be in RGBA format\");\n-    }\n-\n-    // Check dimensions match\n-    int nx = PyArray_DIM(x, 0);\n-    int ny = PyArray_DIM(y, 0);\n-    if (nx != PyArray_DIM(d, 1) || ny != PyArray_DIM(d, 0))\n-    {\n-        _pcolor_cleanup(x, y, d, rowstarts, colstarts, acols, arows);\n-        throw Py::ValueError(\"data and axis dimensions do not match\");\n-    }\n-\n-    // Allocate memory for pointer arrays\n-    rowstarts = reinterpret_cast<unsigned int*>(PyMem_Malloc(sizeof(unsigned int) * rows));\n-    if (rowstarts == NULL)\n-    {\n-        _pcolor_cleanup(x, y, d, rowstarts, colstarts, acols, arows);\n-        throw Py::MemoryError(\"Cannot allocate memory for lookup table\");\n-    }\n-    colstarts = reinterpret_cast<unsigned int*>(PyMem_Malloc(sizeof(unsigned int) * cols));\n-    if (colstarts == NULL)\n-    {\n-        _pcolor_cleanup(x, y, d, rowstarts, colstarts, acols, arows);\n-        throw Py::MemoryError(\"Cannot allocate memory for lookup table\");\n-    }\n-\n-    // Create output\n-    Image* imo = new Image;\n-    imo->rowsIn = rows;\n-    imo->colsIn = cols;\n-    imo->rowsOut = rows;\n-    imo->colsOut = cols;\n-    size_t NUMBYTES(rows * cols * 4);\n-    agg::int8u *buffer = new agg::int8u[NUMBYTES];\n-    if (buffer == NULL)\n-    {\n-        _pcolor_cleanup(x, y, d, rowstarts, colstarts, acols, arows);\n-        throw Py::MemoryError(\"Could not allocate memory for image\");\n-    }\n-\n-\n-    // Calculate the pointer arrays to map input x to output x\n-    unsigned int i, j;\n-    unsigned int * colstart = colstarts;\n-    unsigned int * rowstart = rowstarts;\n-    float *xs1 = reinterpret_cast<float*>(PyArray_DATA(x));\n-    float *ys1 = reinterpret_cast<float*>(PyArray_DATA(y));\n-\n-\n-    // Copy data to output buffer\n-    unsigned char *start;\n-    unsigned char *inposition;\n-    size_t inrowsize(nx*4);\n-    size_t rowsize(cols*4);\n-    agg::int8u * position = buffer;\n-    agg::int8u * oldposition = NULL;\n-    start = reinterpret_cast<unsigned char*>(PyArray_DATA(d));\n-    int s0 = PyArray_STRIDE(d, 0);\n-    int s1 = PyArray_STRIDE(d, 1);\n-\n-    if (interpolation == Image::NEAREST)\n-    {\n-        _bin_indices_middle(colstart, cols, xs1,  nx, dx, x_min);\n-        _bin_indices_middle(rowstart, rows, ys1,  ny, dy, y_min);\n-        for (i = 0;i < rows;i++, rowstart++)\n-        {\n-            if (i > 0 && *rowstart == 0)\n-            {\n-                memcpy(position, oldposition, rowsize*sizeof(agg::int8u));\n-                oldposition = position;\n-                position += rowsize;\n-            }\n-            else\n-            {\n-                oldposition = position;\n-                start += *rowstart * inrowsize;\n-                inposition = start;\n-                for (j = 0, colstart = colstarts;j < cols;j++, position += 4, colstart++)\n-                {\n-                    inposition += *colstart * 4;\n-                    memcpy(position, inposition, 4*sizeof(agg::int8u));\n-                }\n-            }\n-        }\n-    }\n-    else if (interpolation == Image::BILINEAR)\n-    {\n-        arows = reinterpret_cast<float *>(PyMem_Malloc(sizeof(float) * rows));\n-        if (arows == NULL)\n-        {\n-            _pcolor_cleanup(x, y, d, rowstarts, colstarts, acols, arows);\n-            throw Py::MemoryError(\"Cannot allocate memory for lookup table\");\n-        }\n-        acols = reinterpret_cast<float*>(PyMem_Malloc(sizeof(float) * cols));\n-        if (acols == NULL)\n-        {\n-            _pcolor_cleanup(x, y, d, rowstarts, colstarts, acols, arows);\n-            throw Py::MemoryError(\"Cannot allocate memory for lookup table\");\n-        }\n-\n-        _bin_indices_middle_linear(acols, colstart, cols, xs1,  nx, dx, x_min);\n-        _bin_indices_middle_linear(arows, rowstart, rows, ys1,  ny, dy, y_min);\n-        double a00, a01, a10, a11, alpha, beta;\n-\n-\n-        agg::int8u * start00;\n-        agg::int8u * start01;\n-        agg::int8u * start10;\n-        agg::int8u * start11;\n-        // Copy data to output buffer\n-        for (i = 0; i < rows; i++)\n-        {\n-            for (j = 0; j < cols; j++)\n-            {\n-                alpha = arows[i];\n-                beta = acols[j];\n-\n-                a00 = alpha * beta;\n-                a01 = alpha * (1.0 - beta);\n-                a10 = (1.0 - alpha) * beta;\n-                a11 = 1.0 - a00 - a01 - a10;\n-\n-                start00 = (agg::int8u *)(start + s0 * rowstart[i] + s1 * colstart[j]);\n-                start01 = start00 + s1;\n-                start10 = start00 + s0;\n-                start11 = start10 + s1;\n-                position[0] = (agg::int8u)(start00[0] * a00 + start01[0] * a01 + start10[0] * a10 + start11[0] * a11);\n-                position[1] = (agg::int8u)(start00[1] * a00 + start01[1] * a01 + start10[1] * a10 + start11[1] * a11);\n-                position[2] = (agg::int8u)(start00[2] * a00 + start01[2] * a01 + start10[2] * a10 + start11[2] * a11);\n-                position[3] = (agg::int8u)(start00[3] * a00 + start01[3] * a01 + start10[3] * a10 + start11[3] * a11);\n-                position += 4;\n-            }\n-        }\n-\n-    }\n-\n-    // Attach output buffer to output buffer\n-    imo->rbufOut = new agg::rendering_buffer;\n-    imo->bufferOut = buffer;\n-    imo->rbufOut->attach(imo->bufferOut, imo->colsOut, imo->rowsOut, imo->colsOut * imo->BPP);\n-\n-    _pcolor_cleanup(x, y, d, rowstarts, colstarts, acols, arows);\n-\n-    return Py::asObject(imo);\n-\n-}\n-\n-void _pcolor2_cleanup(PyArrayObject* x, PyArrayObject* y, PyArrayObject *d,\n-                      PyArrayObject* bg, int *irows, int*jcols)\n-{\n-    Py_XDECREF(x);\n-    Py_XDECREF(y);\n-    Py_XDECREF(d);\n-    Py_XDECREF(bg);\n-    if (irows)\n-    {\n-        PyMem_Free(irows);\n-    }\n-    if (jcols)\n-    {\n-        PyMem_Free(jcols);\n-    }\n-}\n-\n-\n-char __image_module_pcolor2__doc__[] =\n-    \"pcolor2(x, y, data, rows, cols, bounds, bg)\\n\"\n-    \"\\n\"\n-    \"Generate a pseudo-color image from data on a non-uniform grid\\n\"\n-    \"specified by its cell boundaries.\\n\"\n-    \"bounds = (x_left, x_right, y_bot, y_top)\\n\"\n-    \"bg = ndarray of 4 uint8 representing background rgba\\n\"\n-    ;\n-Py::Object\n-_image_module::pcolor2(const Py::Tuple& args)\n-{\n-    _VERBOSE(\"_image_module::pcolor2\");\n-\n-    if (args.length() != 7)\n-    {\n-        throw Py::TypeError(\"Incorrect number of arguments (6 expected)\");\n-    }\n-\n-    Py::Object xp = args[0];\n-    Py::Object yp = args[1];\n-    Py::Object dp = args[2];\n-    int rows = Py::Int(args[3]);\n-    int cols = Py::Int(args[4]);\n-    Py::Tuple bounds = args[5];\n-    Py::Object bgp = args[6];\n-\n-    if (rows >= 32768 || cols >= 32768)\n-    {\n-        throw Py::ValueError(\"rows and cols must both be less than 32768\");\n-    }\n-\n-    if (bounds.length() != 4)\n-    {\n-        throw Py::TypeError(\"Incorrect number of bounds (4 expected)\");\n-    }\n-\n-    double x_left = Py::Float(bounds[0]);\n-    double x_right = Py::Float(bounds[1]);\n-    double y_bot = Py::Float(bounds[2]);\n-    double y_top = Py::Float(bounds[3]);\n-\n-    // Check we have something to output to\n-    if (rows == 0 || cols == 0)\n-    {\n-        throw Py::ValueError(\"rows or cols is zero; there are no pixels\");\n-    }\n-\n-    PyArrayObject* x = NULL;\n-    PyArrayObject* y = NULL;\n-    PyArrayObject* d = NULL;\n-    PyArrayObject* bg = NULL;\n-    int* irows = NULL;\n-    int* jcols = NULL;\n-\n-    // Get numpy arrays\n-    x = (PyArrayObject *) PyArray_ContiguousFromObject(xp.ptr(), NPY_DOUBLE, 1, 1);\n-    if (x == NULL)\n-    {\n-        _pcolor2_cleanup(x, y, d, bg, irows, jcols);\n-        throw Py::ValueError(\"x is of incorrect type (wanted 1D double)\");\n-    }\n-    y = (PyArrayObject *) PyArray_ContiguousFromObject(yp.ptr(), NPY_DOUBLE, 1, 1);\n-    if (y == NULL)\n-    {\n-        _pcolor2_cleanup(x, y, d, bg, irows, jcols);\n-        throw Py::ValueError(\"y is of incorrect type (wanted 1D double)\");\n-    }\n-    d = (PyArrayObject *) PyArray_ContiguousFromObject(dp.ptr(), NPY_UBYTE, 3, 3);\n-    if (d == NULL)\n-    {\n-        _pcolor2_cleanup(x, y, d, bg, irows, jcols);\n-        throw Py::ValueError(\"data is of incorrect type (wanted 3D uint8)\");\n-    }\n-    if (PyArray_DIM(d, 2) != 4)\n-    {\n-        _pcolor2_cleanup(x, y, d, bg, irows, jcols);\n-        throw Py::ValueError(\"data must be in RGBA format\");\n-    }\n-\n-    // Check dimensions match\n-    int nx = PyArray_DIM(x, 0);\n-    int ny = PyArray_DIM(y, 0);\n-    if (nx != PyArray_DIM(d, 1) + 1 || ny != PyArray_DIM(d, 0) + 1)\n-    {\n-        _pcolor2_cleanup(x, y, d, bg, irows, jcols);\n-        throw Py::ValueError(\"data and axis bin boundary dimensions are incompatible\");\n-    }\n-\n-    bg = (PyArrayObject *) PyArray_ContiguousFromObject(bgp.ptr(), NPY_UBYTE, 1, 1);\n-    if (bg == NULL)\n-    {\n-        _pcolor2_cleanup(x, y, d, bg, irows, jcols);\n-        throw Py::ValueError(\"bg is of incorrect type (wanted 1D uint8)\");\n-    }\n-    if (PyArray_DIM(bg, 0) != 4)\n-    {\n-        _pcolor2_cleanup(x, y, d, bg, irows, jcols);\n-        throw Py::ValueError(\"bg must be in RGBA format\");\n-    }\n-\n-    // Allocate memory for pointer arrays\n-    irows = reinterpret_cast<int*>(PyMem_Malloc(sizeof(int) * rows));\n-    if (irows == NULL)\n-    {\n-        _pcolor2_cleanup(x, y, d, bg, irows, jcols);\n-        throw Py::MemoryError(\"Cannot allocate memory for lookup table\");\n-    }\n-    jcols = reinterpret_cast<int*>(PyMem_Malloc(sizeof(int) * cols));\n-    if (jcols == NULL)\n-    {\n-        _pcolor2_cleanup(x, y, d, bg, irows, jcols);\n-        throw Py::MemoryError(\"Cannot allocate memory for lookup table\");\n-    }\n-\n-    // Create output\n-    Image* imo = new Image;\n-    imo->rowsIn = rows;\n-    imo->rowsOut = rows;\n-    imo->colsIn = cols;\n-    imo->colsOut = cols;\n-    size_t NUMBYTES(rows * cols * 4);\n-    agg::int8u *buffer = new agg::int8u[NUMBYTES];\n-    if (buffer == NULL)\n-    {\n-        _pcolor2_cleanup(x, y, d, bg, irows, jcols);\n-        throw Py::MemoryError(\"Could not allocate memory for image\");\n-    }\n-\n-    // Calculate the pointer arrays to map input x to output x\n-    int i, j;\n-    double *x0 = reinterpret_cast<double*>(PyArray_DATA(x));\n-    double *y0 = reinterpret_cast<double*>(PyArray_DATA(y));\n-    double sx = cols / (x_right - x_left);\n-    double sy = rows / (y_top - y_bot);\n-    _bin_indices(jcols, cols, x0, nx, sx, x_left);\n-    _bin_indices(irows, rows, y0, ny, sy, y_bot);\n-\n-    // Copy data to output buffer\n-    agg::int8u * position = buffer;\n-    unsigned char *start = reinterpret_cast<unsigned char*>(PyArray_DATA(d));\n-    unsigned char *bgptr = reinterpret_cast<unsigned char*>(PyArray_DATA(bg));\n-    int s0 = PyArray_STRIDE(d, 0);\n-    int s1 = PyArray_STRIDE(d, 1);\n-\n-    for (i = 0; i < rows; i++)\n-    {\n-        for (j = 0; j < cols; j++)\n-        {\n-            if (irows[i] == -1 || jcols[j] == -1)\n-            {\n-                memcpy(position, bgptr, 4*sizeof(agg::int8u));\n-            }\n-            else\n-            {\n-                memcpy(position, (start + s0*irows[i] + s1*jcols[j]),\n-                       4*sizeof(agg::int8u));\n-            }\n-            position += 4;\n-        }\n-    }\n-\n-    // Attach output buffer to output buffer\n-    imo->rbufOut = new agg::rendering_buffer;\n-    imo->bufferOut = buffer;\n-    imo->rbufOut->attach(imo->bufferOut, imo->colsOut, imo->rowsOut, imo->colsOut * imo->BPP);\n-\n-    _pcolor2_cleanup(x, y, d, bg, irows, jcols);\n-\n-    return Py::asObject(imo);\n-}\n-\n-#if PY3K\n-PyMODINIT_FUNC\n-PyInit__image(void)\n-#else\n-PyMODINIT_FUNC\n-init_image(void)\n-#endif\n-{\n-    _VERBOSE(\"init_image\");\n-\n-    static _image_module* _image = new _image_module;\n-\n-    import_array();\n-    Py::Dict d = _image->moduleDictionary();\n-\n-    d[\"NEAREST\"] = Py::Int(Image::NEAREST);\n-    d[\"BILINEAR\"] = Py::Int(Image::BILINEAR);\n-    d[\"BICUBIC\"] = Py::Int(Image::BICUBIC);\n-    d[\"SPLINE16\"] = Py::Int(Image::SPLINE16);\n-    d[\"SPLINE36\"] = Py::Int(Image::SPLINE36);\n-    d[\"HANNING\"] = Py::Int(Image::HANNING);\n-    d[\"HAMMING\"] = Py::Int(Image::HAMMING);\n-    d[\"HERMITE\"] = Py::Int(Image::HERMITE);\n-    d[\"KAISER\"]   = Py::Int(Image::KAISER);\n-    d[\"QUADRIC\"]   = Py::Int(Image::QUADRIC);\n-    d[\"CATROM\"]  = Py::Int(Image::CATROM);\n-    d[\"GAUSSIAN\"]  = Py::Int(Image::GAUSSIAN);\n-    d[\"BESSEL\"]  = Py::Int(Image::BESSEL);\n-    d[\"MITCHELL\"]  = Py::Int(Image::MITCHELL);\n-    d[\"SINC\"]  = Py::Int(Image::SINC);\n-    d[\"LANCZOS\"]  = Py::Int(Image::LANCZOS);\n-    d[\"BLACKMAN\"] = Py::Int(Image::BLACKMAN);\n-\n-    d[\"ASPECT_FREE\"] = Py::Int(Image::ASPECT_FREE);\n-    d[\"ASPECT_PRESERVE\"] = Py::Int(Image::ASPECT_PRESERVE);\n-\n-#if PY3K\n-    return _image->module().ptr();\n-#endif\n-}"
            },
            {
                "sha": "4a4a935f800f9728e84541dc5e4b47ed735c15bb",
                "filename": "src/_image.h",
                "status": "modified",
                "additions": 336,
                "deletions": 141,
                "changes": 477,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_image.h",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_image.h",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/src%2F_image.h?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787",
                "patch": "@@ -6,182 +6,377 @@\n \n #ifndef _IMAGE_H\n #define _IMAGE_H\n-#include <utility>\n-#include \"Python.h\"\n+\n+#include <vector>\n \n #include \"agg_trans_affine.h\"\n #include \"agg_rendering_buffer.h\"\n #include \"agg_color_rgba.h\"\n-#include \"CXX/Extensions.hxx\"\n-\n-\n \n-class Image : public Py::PythonExtension<Image>\n+class Image\n {\n-public:\n+  public:\n     Image();\n+    Image(unsigned numrows, unsigned numcols, bool isoutput);\n     virtual ~Image();\n \n     static void init_type(void);\n-    int setattr(const char*, const Py::Object &);\n-    Py::Object getattr(const char * name);\n-\n-    Py::Object apply_rotation(const Py::Tuple& args);\n-    Py::Object apply_scaling(const Py::Tuple& args);\n-    Py::Object apply_translation(const Py::Tuple& args);\n-    Py::Object as_rgba_str(const Py::Tuple& args, const Py::Dict& kwargs);\n-    Py::Object color_conv(const Py::Tuple& args);\n-    Py::Object buffer_rgba(const Py::Tuple& args);\n-    Py::Object reset_matrix(const Py::Tuple& args);\n-    Py::Object get_matrix(const Py::Tuple& args);\n-    Py::Object resize(const Py::Tuple& args, const Py::Dict& kwargs);\n-    Py::Object get_aspect(const Py::Tuple& args);\n-    Py::Object get_size(const Py::Tuple& args);\n-    Py::Object get_size_out(const Py::Tuple& args);\n-    Py::Object get_interpolation(const Py::Tuple& args);\n-    Py::Object set_interpolation(const Py::Tuple& args);\n-    Py::Object set_aspect(const Py::Tuple& args);\n-    Py::Object set_bg(const Py::Tuple& args);\n-    inline Py::Object flipud_out(const Py::Tuple& args)\n-    {\n-        args.verify_length(0);\n-        if (colsOut <= 0 || rowsOut <= 0)\n-        {\n-            throw Py::RuntimeError(\n-            \"Width and height must have positive values\");\n-        }\n \n-        int stride = rbufOut->stride();\n-        //std::cout << \"flip before: \" << rbufOut->stride() << std::endl;\n-        rbufOut->attach(bufferOut, colsOut, rowsOut, -stride);\n-        //std::cout << \"flip after: \" << rbufOut->stride() << std::endl;\n-        return Py::Object();\n-    }\n-\n-    Py::Object flipud_in(const Py::Tuple& args);\n-    Py::Object set_resample(const Py::Tuple& args);\n-    Py::Object get_resample(const Py::Tuple& args);\n-\n-\n-    std::pair<agg::int8u*, bool> _get_output_buffer();\n-    enum {NEAREST,\n-          BILINEAR,\n-          BICUBIC,\n-          SPLINE16,\n-          SPLINE36,\n-          HANNING,\n-          HAMMING,\n-          HERMITE,\n-          KAISER,\n-          QUADRIC,\n-          CATROM,\n-          GAUSSIAN,\n-          BESSEL,\n-          MITCHELL,\n-          SINC,\n-          LANCZOS,\n-          BLACKMAN\n-         };\n-\n-    //enum { BICUBIC=0, BILINEAR, BLACKMAN100, BLACKMAN256, BLACKMAN64,\n+    void apply_rotation(double r);\n+    void apply_scaling(double sx, double sy);\n+    void apply_translation(double tx, double ty);\n+    void as_rgba_str(agg::int8u *outbuf);\n+    void color_conv(int format, agg::int8u *outbuf);\n+    void reset_matrix();\n+    void clear();\n+    void resize(int numcols, int numrows, int norm, double radius);\n+    void blend_image(Image &im, unsigned ox, unsigned oy, bool apply_alpha, float alpha);\n+    void set_bg(double r, double g, double b, double a);\n+\n+    enum {\n+        NEAREST,\n+        BILINEAR,\n+        BICUBIC,\n+        SPLINE16,\n+        SPLINE36,\n+        HANNING,\n+        HAMMING,\n+        HERMITE,\n+        KAISER,\n+        QUADRIC,\n+        CATROM,\n+        GAUSSIAN,\n+        BESSEL,\n+        MITCHELL,\n+        SINC,\n+        LANCZOS,\n+        BLACKMAN\n+    };\n+\n+    // enum { BICUBIC=0, BILINEAR, BLACKMAN100, BLACKMAN256, BLACKMAN64,\n     //   NEAREST, SINC144, SINC256, SINC64, SPLINE16, SPLINE36};\n-    enum { ASPECT_PRESERVE = 0, ASPECT_FREE};\n+    enum {\n+        ASPECT_PRESERVE = 0,\n+        ASPECT_FREE\n+    };\n \n     agg::int8u *bufferIn;\n     agg::rendering_buffer *rbufIn;\n-    size_t colsIn, rowsIn;\n+    unsigned colsIn, rowsIn;\n \n     agg::int8u *bufferOut;\n     agg::rendering_buffer *rbufOut;\n-    size_t colsOut, rowsOut;\n+    unsigned colsOut, rowsOut;\n     unsigned BPP;\n \n     unsigned interpolation, aspect;\n     agg::rgba bg;\n     bool resample;\n-private:\n-    Py::Dict __dict__;\n     agg::trans_affine srcMatrix, imageMatrix;\n \n-    static char apply_rotation__doc__[];\n-    static char apply_scaling__doc__[];\n-    static char apply_translation__doc__[];\n-    static char as_rgba_str__doc__[];\n-    static char color_conv__doc__[];\n-    static char buffer_rgba__doc__[];\n-    static char reset_matrix__doc__[];\n-    static char get_matrix__doc__[];\n-    static char resize__doc__[];\n-    static char get_aspect__doc__[];\n-    static char get_size__doc__[];\n-    static char get_size_out__doc__[];\n-    static char get_interpolation__doc__[];\n-    static char set_interpolation__doc__[];\n-    static char set_aspect__doc__[];\n-    static char set_bg__doc__[];\n-    static char flipud_out__doc__[];\n-    static char flipud_in__doc__[];\n-    static char get_resample__doc__[];\n-    static char set_resample__doc__[];\n-\n+  private:\n     // prevent copying\n-    Image(const Image&);\n-    Image& operator=(const Image&);\n+    Image(const Image &);\n+    Image &operator=(const Image &);\n };\n \n+template <class ArrayType>\n+Image *from_grey_array(ArrayType &array, bool isoutput)\n+{\n+    Image *im = new Image((unsigned)array.dim(0), (unsigned)array.dim(1), isoutput);\n+\n+    agg::int8u *buffer;\n+    if (isoutput) {\n+        buffer = im->bufferOut;\n+    } else {\n+        buffer = im->bufferIn;\n+    }\n+\n+    agg::int8u gray;\n+    for (size_t rownum = 0; rownum < (size_t)array.dim(0); rownum++) {\n+        for (size_t colnum = 0; colnum < (size_t)array.dim(1); colnum++) {\n+            double val = array(rownum, colnum);\n \n-/*\n-class ImageComposite : public Py::PythonExtension<ImageComposite> {\n+            gray = int(255 * val);\n+            *buffer++ = gray; // red\n+            *buffer++ = gray; // green\n+            *buffer++ = gray; // blue\n+            *buffer++ = 255;  // alpha\n+        }\n+    }\n \n+    return im;\n }\n-*/\n \n+template <class ArrayType>\n+Image *from_color_array(ArrayType &array, bool isoutput)\n+{\n+    Image *im = new Image((unsigned)array.dim(0), (unsigned)array.dim(1), isoutput);\n+\n+    agg::int8u *buffer;\n+    if (isoutput) {\n+        buffer = im->bufferOut;\n+    } else {\n+        buffer = im->bufferIn;\n+    }\n+\n+    int rgba = array.dim(2) >= 4;\n+    double r, g, b;\n+    double alpha = 1.0;\n+\n+    for (size_t rownum = 0; rownum < (size_t)array.dim(0); rownum++) {\n+        for (size_t colnum = 0; colnum < (size_t)array.dim(1); colnum++) {\n+            typename ArrayType::sub_t::sub_t color = array[rownum][colnum];\n+\n+            r = color(0);\n+            g = color(1);\n+            b = color(2);\n+\n+            if (rgba) {\n+                alpha = color(3);\n+            }\n \n-// the extension module\n-class _image_module : public Py::ExtensionModule<_image_module>\n+            *buffer++ = int(255 * r);     // red\n+            *buffer++ = int(255 * g);     // green\n+            *buffer++ = int(255 * b);     // blue\n+            *buffer++ = int(255 * alpha); // alpha\n+        }\n+    }\n+\n+    return im;\n+}\n+\n+template <class ArrayType>\n+Image *frombyte(ArrayType &array, bool isoutput)\n {\n-public:\n-    _image_module() : Py::ExtensionModule<_image_module>(\"_image\")\n-    {\n-        Image::init_type();\n-\n-        add_varargs_method(\"fromarray\", &_image_module::fromarray,\n-                           \"fromarray\");\n-        add_varargs_method(\"fromarray2\", &_image_module::fromarray2,\n-                           \"fromarray2\");\n-        add_varargs_method(\"frombyte\", &_image_module::frombyte,\n-                           \"frombyte\");\n-        add_varargs_method(\"frombuffer\", &_image_module::frombuffer,\n-                           \"frombuffer\");\n-        add_varargs_method(\"from_images\", &_image_module::from_images,\n-                           \"from_images\");\n-        add_varargs_method(\"pcolor\", &_image_module::pcolor,\n-                           \"pcolor\");\n-        add_varargs_method(\"pcolor2\", &_image_module::pcolor2,\n-                           \"pcolor2\");\n-        initialize(\"The _image module\");\n-    }\n-\n-    ~_image_module() {}\n-\n-private:\n-    Py::Object frombyte(const Py::Tuple &args);\n-    Py::Object frombuffer(const Py::Tuple &args);\n-    Py::Object fromarray(const Py::Tuple &args);\n-    Py::Object fromarray2(const Py::Tuple &args);\n-    Py::Object pcolor(const Py::Tuple &args);\n-    Py::Object pcolor2(const Py::Tuple &args);\n-    Py::Object from_images(const Py::Tuple &args);\n-\n-    static char _image_module_fromarray__doc__[];\n-    static char _image_module_pcolor__doc__[];\n-    static char _image_module_pcolor2__doc__[];\n-    static char _image_module_fromarray2__doc__[];\n-    static char _image_module_frombyte__doc__[];\n-    static char _image_module_frombuffer__doc__[];\n-};\n+    Image *im = new Image((unsigned)array.dim(0), (unsigned)array.dim(1), isoutput);\n \n+    agg::int8u *buffer;\n+    if (isoutput) {\n+        buffer = im->bufferOut;\n+    } else {\n+        buffer = im->bufferIn;\n+    }\n \n+    int rgba = array.dim(2) >= 4;\n+    agg::int8u r, g, b;\n+    agg::int8u alpha = 255;\n \n-#endif\n+    for (size_t rownum = 0; rownum < (size_t)array.dim(0); rownum++) {\n+        for (size_t colnum = 0; colnum < (size_t)array.dim(1); colnum++) {\n+            typename ArrayType::sub_t::sub_t color = array[rownum][colnum];\n+            r = color(0);\n+            g = color(1);\n+            b = color(2);\n+\n+            if (rgba) {\n+                alpha = color(3);\n+            }\n+\n+            *buffer++ = r;     // red\n+            *buffer++ = g;     // green\n+            *buffer++ = b;     // blue\n+            *buffer++ = alpha; // alpha\n+        }\n+    }\n+\n+    return im;\n+}\n+\n+// utilities for irregular grids\n+void _bin_indices_middle(\n+    unsigned int *irows, int nrows, const float *ys1, unsigned long ny, float dy, float y_min);\n+void _bin_indices_middle_linear(float *arows,\n+                                unsigned int *irows,\n+                                int nrows,\n+                                const float *y,\n+                                unsigned long ny,\n+                                float dy,\n+                                float y_min);\n+void _bin_indices(int *irows, int nrows, const double *y, unsigned long ny, double sc, double offs);\n+void _bin_indices_linear(\n+    float *arows, int *irows, int nrows, double *y, unsigned long ny, double sc, double offs);\n \n+template <class CoordinateArray, class ColorArray>\n+Image *pcolor(CoordinateArray &x,\n+              CoordinateArray &y,\n+              ColorArray &d,\n+              unsigned int rows,\n+              unsigned int cols,\n+              float bounds[4],\n+              int interpolation)\n+{\n+    if (rows >= 32768 || cols >= 32768) {\n+        throw \"rows and cols must both be less than 32768\";\n+    }\n+\n+    float x_min = bounds[0];\n+    float x_max = bounds[1];\n+    float y_min = bounds[2];\n+    float y_max = bounds[3];\n+    float width = x_max - x_min;\n+    float height = y_max - y_min;\n+    float dx = width / ((float)cols);\n+    float dy = height / ((float)rows);\n+\n+    // Check we have something to output to\n+    if (rows == 0 || cols == 0) {\n+        throw \"Cannot scale to zero size\";\n+    }\n+\n+    if (d.dim(2) != 4) {\n+        throw \"data must be in RGBA format\";\n+    }\n+\n+    // Check dimensions match\n+    unsigned long nx = x.dim(0);\n+    unsigned long ny = y.dim(0);\n+    if (nx != d.dim(1) || ny != d.dim(0)) {\n+        throw \"data and axis dimensions do not match\";\n+    }\n+\n+    // Allocate memory for pointer arrays\n+    std::vector<unsigned int> rowstarts(rows);\n+    std::vector<unsigned int> colstarts(cols);\n+\n+    // Create output\n+    Image *imo = new Image(rows, cols, true);\n+\n+    // Calculate the pointer arrays to map input x to output x\n+    unsigned int i, j;\n+    unsigned int *colstart = &colstarts[0];\n+    unsigned int *rowstart = &rowstarts[0];\n+    const float *xs1 = x.data();\n+    const float *ys1 = y.data();\n+\n+    // Copy data to output buffer\n+    const unsigned char *start;\n+    const unsigned char *inposition;\n+    size_t inrowsize = nx * 4;\n+    size_t rowsize = cols * 4;\n+    agg::int8u *position = imo->bufferOut;\n+    agg::int8u *oldposition = NULL;\n+    start = d.data();\n+\n+    if (interpolation == Image::NEAREST) {\n+        _bin_indices_middle(colstart, cols, xs1, nx, dx, x_min);\n+        _bin_indices_middle(rowstart, rows, ys1, ny, dy, y_min);\n+        for (i = 0; i < rows; i++, rowstart++) {\n+            if (i > 0 && *rowstart == 0) {\n+                memcpy(position, oldposition, rowsize * sizeof(agg::int8u));\n+                oldposition = position;\n+                position += rowsize;\n+            } else {\n+                oldposition = position;\n+                start += *rowstart * inrowsize;\n+                inposition = start;\n+                for (j = 0, colstart = &colstarts[0]; j < cols; j++, position += 4, colstart++) {\n+                    inposition += *colstart * 4;\n+                    memcpy(position, inposition, 4 * sizeof(agg::int8u));\n+                }\n+            }\n+        }\n+    } else if (interpolation == Image::BILINEAR) {\n+        std::vector<float> acols(cols);\n+        std::vector<float> arows(rows);\n+\n+        _bin_indices_middle_linear(&acols[0], colstart, cols, xs1, nx, dx, x_min);\n+        _bin_indices_middle_linear(&arows[0], rowstart, rows, ys1, ny, dy, y_min);\n+        double a00, a01, a10, a11, alpha, beta;\n+\n+        // Copy data to output buffer\n+        for (i = 0; i < rows; i++) {\n+            for (j = 0; j < cols; j++) {\n+                alpha = arows[i];\n+                beta = acols[j];\n+\n+                a00 = alpha * beta;\n+                a01 = alpha * (1.0 - beta);\n+                a10 = (1.0 - alpha) * beta;\n+                a11 = 1.0 - a00 - a01 - a10;\n+\n+                typename ColorArray::sub_t::sub_t start00 = d[rowstart[i]][colstart[j]];\n+                typename ColorArray::sub_t::sub_t start01 = d[rowstart[i]][colstart[j] + 1];\n+                typename ColorArray::sub_t::sub_t start10 = d[rowstart[i] + 1][colstart[j]];\n+                typename ColorArray::sub_t::sub_t start11 = d[rowstart[i] + 1][colstart[j] + 1];\n+                for (size_t k = 0; k < 4; ++k) {\n+                    position[k] =\n+                        start00(k) * a00 + start01(k) * a01 + start10(k) * a10 + start11(k) * a11;\n+                }\n+                position += 4;\n+            }\n+        }\n+    }\n+\n+    return imo;\n+}\n+\n+template <class CoordinateArray, class ColorArray, class Color>\n+Image *pcolor2(CoordinateArray &x,\n+               CoordinateArray &y,\n+               ColorArray &d,\n+               unsigned int rows,\n+               unsigned int cols,\n+               float bounds[4],\n+               Color &bg)\n+{\n+    double x_left = bounds[0];\n+    double x_right = bounds[1];\n+    double y_bot = bounds[2];\n+    double y_top = bounds[3];\n+\n+    // Check we have something to output to\n+    if (rows == 0 || cols == 0) {\n+        throw \"rows or cols is zero; there are no pixels\";\n+    }\n+\n+    if (d.dim(2) != 4) {\n+        throw \"data must be in RGBA format\";\n+    }\n+\n+    // Check dimensions match\n+    unsigned long nx = x.dim(0);\n+    unsigned long ny = y.dim(0);\n+    if (nx != d.dim(1) + 1 || ny != d.dim(0) + 1) {\n+        throw \"data and axis bin boundary dimensions are incompatible\";\n+    }\n+\n+    if (bg.dim(0) != 4) {\n+        throw \"bg must be in RGBA format\";\n+    }\n+\n+    std::vector<int> irows(rows);\n+    std::vector<int> jcols(cols);\n+\n+    // Create output\n+    Image *imo = new Image(rows, cols, true);\n+\n+    // Calculate the pointer arrays to map input x to output x\n+    size_t i, j;\n+    const double *x0 = x.data();\n+    const double *y0 = y.data();\n+    double sx = cols / (x_right - x_left);\n+    double sy = rows / (y_top - y_bot);\n+    _bin_indices(&jcols[0], cols, x0, nx, sx, x_left);\n+    _bin_indices(&irows[0], rows, y0, ny, sy, y_bot);\n+\n+    // Copy data to output buffer\n+    agg::int8u *position = imo->bufferOut;\n+\n+    for (i = 0; i < rows; i++) {\n+        for (j = 0; j < cols; j++) {\n+            if (irows[i] == -1 || jcols[j] == -1) {\n+                memcpy(position, (const agg::int8u *)bg.data(), 4 * sizeof(agg::int8u));\n+            } else {\n+                for (size_t k = 0; k < 4; ++k) {\n+                    position[k] = d(irows[i], jcols[j], k);\n+                }\n+            }\n+            position += 4;\n+        }\n+    }\n+\n+    return imo;\n+}\n+\n+#endif"
            },
            {
                "sha": "6491b993bf657ad3a89f719b8ddaa0205df17097",
                "filename": "src/_image_wrapper.cpp",
                "status": "added",
                "additions": 805,
                "deletions": 0,
                "changes": 805,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_image_wrapper.cpp",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_image_wrapper.cpp",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/src%2F_image_wrapper.cpp?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787",
                "patch": "@@ -0,0 +1,805 @@\n+#include \"mplutils.h\"\n+#include \"_image.h\"\n+#include \"py_converters.h\"\n+\n+/**********************************************************************\n+ * Image\n+ * */\n+\n+typedef struct\n+{\n+    PyObject_HEAD;\n+    Image *x;\n+    Py_ssize_t shape[3];\n+    Py_ssize_t strides[3];\n+    Py_ssize_t suboffsets[3];\n+    PyObject *dict;\n+} PyImage;\n+\n+static PyTypeObject PyImageType;\n+\n+static PyObject *PyImage_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n+{\n+    PyImage *self;\n+    self = (PyImage *)type->tp_alloc(type, 0);\n+    memset(self, 0, sizeof(PyImage));\n+    self->x = NULL;\n+    self->dict = PyDict_New();\n+    return (PyObject *)self;\n+}\n+\n+static PyObject *PyImage_cnew(Image *im)\n+{\n+    PyImage *self;\n+    self = (PyImage *)PyImageType.tp_alloc(&PyImageType, 0);\n+    self->x = im;\n+    self->dict = PyDict_New();\n+    return (PyObject *)self;\n+}\n+\n+static int PyImage_init(PyImage *self, PyObject *args, PyObject *kwds)\n+{\n+    if (!PyArg_ParseTuple(args, \"\")) {\n+        return -1;\n+    }\n+\n+    CALL_CPP_INIT(\"Image\", (self->x = new Image()));\n+\n+    return 0;\n+}\n+\n+static void PyImage_dealloc(PyImage *self)\n+{\n+    delete self->x;\n+    Py_DECREF(self->dict);\n+    Py_TYPE(self)->tp_free((PyObject *)self);\n+}\n+\n+const char *PyImage_apply_rotation__doc__ =\n+    \"apply_rotation(angle)\\n\"\n+    \"\\n\"\n+    \"Apply the rotation (degrees) to image\";\n+\n+static PyObject *PyImage_apply_rotation(PyImage *self, PyObject *args, PyObject *kwds)\n+{\n+    double r;\n+\n+    if (!PyArg_ParseTuple(args, \"d:apply_rotation\", &r)) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP(\"apply_rotation\", (self->x->apply_rotation(r)));\n+\n+    Py_RETURN_NONE;\n+}\n+\n+const char *PyImage_set_bg__doc__ =\n+    \"set_bg(r,g,b,a)\\n\"\n+    \"\\n\"\n+    \"Set the background color\";\n+\n+static PyObject *PyImage_set_bg(PyImage *self, PyObject *args, PyObject *kwds)\n+{\n+    double r, g, b, a;\n+\n+    if (!PyArg_ParseTuple(args, \"dddd:set_bg\", &r, &g, &b, &a)) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP(\"set_bg\", (self->x->set_bg(r, g, b, a)));\n+\n+    Py_RETURN_NONE;\n+}\n+\n+const char *PyImage_apply_scaling__doc__ =\n+    \"apply_scaling(sx, sy)\\n\"\n+    \"\\n\"\n+    \"Apply the scale factors sx, sy to the transform matrix\";\n+\n+static PyObject *PyImage_apply_scaling(PyImage *self, PyObject *args, PyObject *kwds)\n+{\n+    double sx, sy;\n+\n+    if (!PyArg_ParseTuple(args, \"dd:apply_scaling\", &sx, &sy)) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP(\"apply_scaling\", (self->x->apply_scaling(sx, sy)));\n+\n+    Py_RETURN_NONE;\n+}\n+\n+const char *PyImage_apply_translation__doc__ =\n+    \"apply_translation(tx, ty)\\n\"\n+    \"\\n\"\n+    \"Apply the translation tx, ty to the transform matrix\";\n+\n+static PyObject *PyImage_apply_translation(PyImage *self, PyObject *args, PyObject *kwds)\n+{\n+    double tx, ty;\n+    if (!PyArg_ParseTuple(args, \"dd:apply_translation\", &tx, &ty)) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP(\"apply_translation\", self->x->apply_translation(tx, ty));\n+\n+    Py_RETURN_NONE;\n+}\n+\n+const char *PyImage_as_rgba_str__doc__ =\n+    \"numrows, numcols, s = as_rgba_str()\"\n+    \"\\n\"\n+    \"Call this function after resize to get the data as string\\n\"\n+    \"The string is a numrows by numcols x 4 (RGBA) unsigned char buffer\\n\";\n+\n+static PyObject *PyImage_as_rgba_str(PyImage *self, PyObject *args, PyObject *kwds)\n+{\n+    // TODO: This performs a copy.  Use buffer interface when possible\n+\n+    PyObject *result = PyBytes_FromStringAndSize(NULL, self->x->rowsOut * self->x->colsOut * 4);\n+    if (result == NULL) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP_CLEANUP(\"as_rgba_str\",\n+                     (self->x->as_rgba_str((agg::int8u *)PyBytes_AsString(result))),\n+                     Py_DECREF(result));\n+\n+    return Py_BuildValue(\"nnN\", self->x->rowsOut, self->x->colsOut, result);\n+}\n+\n+const char *PyImage_color_conv__doc__ =\n+    \"numrows, numcols, buffer = color_conv(format)\"\n+    \"\\n\"\n+    \"format 0(BGRA) or 1(ARGB)\\n\"\n+    \"Convert image to format and return in a writable buffer\\n\";\n+\n+// TODO: This function is a terrible interface.  Change/remove?  Only\n+// used by Cairo backend.\n+\n+static PyObject *PyImage_color_conv(PyImage *self, PyObject *args, PyObject *kwds)\n+{\n+    int format;\n+\n+    if (!PyArg_ParseTuple(args, \"i:color_conv\", &format)) {\n+        return NULL;\n+    }\n+\n+    PyObject *result = PyBytes_FromStringAndSize(NULL, self->x->rowsOut * self->x->colsOut * 4);\n+    if (result == NULL) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP_CLEANUP(\"color_conv\",\n+                     (self->x->color_conv(format, (agg::int8u *)PyBytes_AsString(result))),\n+                     Py_DECREF(result));\n+\n+    return Py_BuildValue(\"nnN\", self->x->rowsOut, self->x->colsOut, result);\n+}\n+\n+const char *PyImage_buffer_rgba__doc__ =\n+    \"buffer = buffer_rgba()\"\n+    \"\\n\"\n+    \"Return the image buffer as rgba32\\n\";\n+\n+static PyObject *PyImage_buffer_rgba(PyImage *self, PyObject *args, PyObject *kwds)\n+{\n+#if PY3K\n+    return Py_BuildValue(\"nny#\",\n+                         self->x->rowsOut,\n+                         self->x->colsOut,\n+                         self->x->rbufOut,\n+                         self->x->rowsOut * self->x->colsOut * 4);\n+#else\n+    PyObject *buffer =\n+        PyBuffer_FromReadWriteMemory(self->x->rbufOut, self->x->rowsOut * self->x->colsOut * 4);\n+    if (buffer == NULL) {\n+        return NULL;\n+    }\n+\n+    return Py_BuildValue(\"nnN\", self->x->rowsOut, self->x->colsOut, buffer);\n+#endif\n+}\n+\n+const char *PyImage_reset_matrix__doc__ =\n+    \"reset_matrix()\"\n+    \"\\n\"\n+    \"Reset the transformation matrix\";\n+\n+static PyObject *PyImage_reset_matrix(PyImage *self, PyObject *args, PyObject *kwds)\n+{\n+    CALL_CPP(\"reset_matrix\", self->x->reset_matrix());\n+\n+    Py_RETURN_NONE;\n+}\n+\n+const char *PyImage_get_matrix__doc__ =\n+    \"(m11,m21,m12,m22,m13,m23) = get_matrix()\\n\"\n+    \"\\n\"\n+    \"Get the affine transformation matrix\\n\"\n+    \"  /m11,m12,m13\\\\\\n\"\n+    \"  /m21,m22,m23|\\n\"\n+    \"  \\\\ 0 , 0 , 1 /\";\n+\n+static PyObject *PyImage_get_matrix(PyImage *self, PyObject *args, PyObject *kwds)\n+{\n+    double m[6];\n+    self->x->srcMatrix.store_to(m);\n+\n+    return Py_BuildValue(\"dddddd\", m[0], m[1], m[2], m[3], m[4], m[5]);\n+}\n+\n+const char *PyImage_resize__doc__ =\n+    \"resize(width, height, norm=1, radius=4.0)\\n\"\n+    \"\\n\"\n+    \"Resize the image to width, height using interpolation\\n\"\n+    \"norm and radius are optional args for some of the filters\\n\";\n+\n+static PyObject *PyImage_resize(PyImage *self, PyObject *args, PyObject *kwds)\n+{\n+    double width;\n+    double height;\n+    double norm;\n+    double radius;\n+    const char *names[] = { \"width\", \"height\", \"norm\", \"radius\", NULL };\n+\n+    if (!PyArg_ParseTupleAndKeywords(\n+             args, kwds, \"dd|dd:resize\", (char **)names, &width, &height, &norm, &radius)) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP(\"resize\", (self->x->resize(width, height, norm, radius)));\n+\n+    Py_RETURN_NONE;\n+}\n+\n+const char *PyImage_get_interpolation__doc__ =\n+    \"get_interpolation()\\n\"\n+    \"\\n\"\n+    \"Get the interpolation scheme to one of the module constants, \"\n+    \"one of image.NEAREST, image.BILINEAR, etc...\";\n+\n+static PyObject *PyImage_get_interpolation(PyImage *self, PyObject *args, PyObject *kwds)\n+{\n+    return PyLong_FromLong(self->x->interpolation);\n+}\n+\n+const char *PyImage_set_interpolation__doc__ =\n+    \"set_interpolation(scheme)\\n\"\n+    \"\\n\"\n+    \"Set the interpolation scheme to one of the module constants, \"\n+    \"eg, image.NEAREST, image.BILINEAR, etc...\";\n+\n+static PyObject *PyImage_set_interpolation(PyImage *self, PyObject *args, PyObject *kwds)\n+{\n+    int method;\n+\n+    if (!PyArg_ParseTuple(args, \"i:set_interpolation\", &method)) {\n+        return NULL;\n+    }\n+\n+    self->x->interpolation = method;\n+\n+    Py_RETURN_NONE;\n+}\n+\n+const char *PyImage_get_aspect__doc__ =\n+    \"get_aspect()\\n\"\n+    \"\\n\"\n+    \"Get the aspect constraint constants\";\n+\n+static PyObject *PyImage_get_aspect(PyImage *self, PyObject *args, PyObject *kwds)\n+{\n+    return PyLong_FromLong(self->x->aspect);\n+}\n+\n+const char *PyImage_set_aspect__doc__ =\n+    \"set_aspect(scheme)\\n\"\n+    \"\\n\"\n+    \"Set the aspect ratio to one of the image module constant.\"\n+    \"eg, one of image.ASPECT_PRESERVE, image.ASPECT_FREE\";\n+\n+static PyObject *PyImage_set_aspect(PyImage *self, PyObject *args, PyObject *kwds)\n+{\n+    int scheme;\n+    if (!PyArg_ParseTuple(args, \"i:set_aspect\", &scheme)) {\n+        return NULL;\n+    }\n+\n+    self->x->aspect = scheme;\n+\n+    Py_RETURN_NONE;\n+}\n+\n+const char *PyImage_get_size__doc__ =\n+    \"numrows, numcols = get_size()\\n\"\n+    \"\\n\"\n+    \"Get the number or rows and columns of the input image\";\n+\n+static PyObject *PyImage_get_size(PyImage *self, PyObject *args, PyObject *kwds)\n+{\n+    return Py_BuildValue(\"ii\", self->x->rowsIn, self->x->colsIn);\n+}\n+\n+const char *PyImage_get_resample__doc__ =\n+    \"get_resample()\\n\"\n+    \"\\n\"\n+    \"Get the resample flag.\";\n+\n+static PyObject *PyImage_get_resample(PyImage *self, PyObject *args, PyObject *kwds)\n+{\n+    if (self->x->resample) {\n+        Py_RETURN_TRUE;\n+    }\n+    Py_RETURN_FALSE;\n+}\n+\n+const char *PyImage_set_resample__doc__ =\n+    \"set_resample(boolean)\\n\"\n+    \"\\n\"\n+    \"Set the resample flag.\";\n+\n+static PyObject *PyImage_set_resample(PyImage *self, PyObject *args, PyObject *kwds)\n+{\n+    int resample;\n+\n+    if (!PyArg_ParseTuple(args, \"i:set_resample\", &resample)) {\n+        return NULL;\n+    }\n+\n+    self->x->resample = resample;\n+\n+    Py_RETURN_NONE;\n+}\n+\n+const char *PyImage_get_size_out__doc__ =\n+    \"numrows, numcols = get_size_out()\\n\"\n+    \"\\n\"\n+    \"Get the number or rows and columns of the output image\";\n+\n+static PyObject *PyImage_get_size_out(PyImage *self, PyObject *args, PyObject *kwds)\n+{\n+    return Py_BuildValue(\"ii\", self->x->rowsOut, self->x->colsOut);\n+}\n+\n+static int PyImage_get_buffer(PyImage *self, Py_buffer *buf, int flags)\n+{\n+    Image *im = self->x;\n+\n+    Py_INCREF(self);\n+    buf->obj = (PyObject *)self;\n+    buf->buf = im->bufferOut;\n+    buf->len = im->colsOut * im->rowsOut * 4;\n+    buf->readonly = 0;\n+    buf->format = (char *)\"B\";\n+    buf->ndim = 3;\n+    self->shape[0] = im->rowsOut;\n+    self->shape[1] = im->colsOut;\n+    self->shape[2] = 4;\n+    buf->shape = self->shape;\n+    self->strides[0] = im->colsOut * 4;\n+    self->strides[1] = 4;\n+    self->strides[2] = 1;\n+    buf->strides = self->strides;\n+    buf->suboffsets = NULL;\n+    buf->itemsize = 1;\n+    buf->internal = NULL;\n+\n+    return 1;\n+}\n+\n+static PyTypeObject *PyImage_init_type(PyObject *m, PyTypeObject *type)\n+{\n+    static PyMethodDef methods[] = {\n+        {\"apply_rotation\", (PyCFunction)PyImage_apply_rotation, METH_VARARGS, PyImage_apply_rotation__doc__},\n+        {\"set_bg\", (PyCFunction)PyImage_set_bg, METH_VARARGS, PyImage_set_bg__doc__},\n+        {\"apply_scaling\", (PyCFunction)PyImage_apply_scaling, METH_VARARGS, PyImage_apply_scaling__doc__},\n+        {\"apply_translation\", (PyCFunction)PyImage_apply_translation, METH_VARARGS, PyImage_apply_translation__doc__},\n+        {\"as_rgba_str\", (PyCFunction)PyImage_as_rgba_str, METH_NOARGS, PyImage_as_rgba_str__doc__},\n+        {\"color_conv\", (PyCFunction)PyImage_color_conv, METH_VARARGS, PyImage_color_conv__doc__},\n+        {\"buffer_rgba\", (PyCFunction)PyImage_buffer_rgba, METH_NOARGS, PyImage_buffer_rgba__doc__},\n+        {\"reset_matrix\", (PyCFunction)PyImage_reset_matrix, METH_NOARGS, PyImage_reset_matrix__doc__},\n+        {\"get_matrix\", (PyCFunction)PyImage_get_matrix, METH_NOARGS, PyImage_get_matrix__doc__},\n+        {\"resize\", (PyCFunction)PyImage_resize, METH_VARARGS|METH_KEYWORDS, PyImage_resize__doc__},\n+        {\"get_interpolation\", (PyCFunction)PyImage_get_interpolation, METH_NOARGS, PyImage_get_interpolation__doc__},\n+        {\"set_interpolation\", (PyCFunction)PyImage_set_interpolation, METH_VARARGS, PyImage_set_interpolation__doc__},\n+        {\"get_aspect\", (PyCFunction)PyImage_get_aspect, METH_NOARGS, PyImage_get_aspect__doc__},\n+        {\"set_aspect\", (PyCFunction)PyImage_set_aspect, METH_VARARGS, PyImage_set_aspect__doc__},\n+        {\"get_size\", (PyCFunction)PyImage_get_size, METH_NOARGS, PyImage_get_size__doc__},\n+        {\"get_resample\", (PyCFunction)PyImage_get_resample, METH_VARARGS, PyImage_get_resample__doc__},\n+        {\"set_resample\", (PyCFunction)PyImage_set_resample, METH_VARARGS, PyImage_set_resample__doc__},\n+        {\"get_size_out\", (PyCFunction)PyImage_get_size_out, METH_VARARGS, PyImage_get_size_out__doc__},\n+        {NULL}\n+    };\n+\n+    static PyBufferProcs buffer_procs;\n+    memset(&buffer_procs, 0, sizeof(PyBufferProcs));\n+    buffer_procs.bf_getbuffer = (getbufferproc)PyImage_get_buffer;\n+\n+    memset(type, 0, sizeof(PyTypeObject));\n+    type->tp_name = \"matplotlib._image.Image\";\n+    type->tp_basicsize = sizeof(PyImage);\n+    type->tp_dealloc = (destructor)PyImage_dealloc;\n+    type->tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_NEWBUFFER;\n+    type->tp_methods = methods;\n+    type->tp_new = PyImage_new;\n+    type->tp_init = (initproc)PyImage_init;\n+    type->tp_as_buffer = &buffer_procs;\n+    type->tp_dictoffset = offsetof(PyImage, dict);\n+\n+    if (PyType_Ready(type) < 0) {\n+        return NULL;\n+    }\n+\n+    if (PyModule_AddObject(m, \"Image\", (PyObject *)type)) {\n+        return NULL;\n+    }\n+\n+    return type;\n+}\n+\n+/**********************************************************************\n+ * Free functions\n+ * */\n+\n+const char *image_from_images__doc__ =\n+    \"from_images(numrows, numcols, seq)\\n\"\n+    \"\\n\"\n+    \"return an image instance with numrows, numcols from a seq of image\\n\"\n+    \"instances using alpha blending.  seq is a list of (Image, ox, oy)\";\n+\n+static PyObject *image_from_images(PyObject *self, PyObject *args, PyObject *kwds)\n+{\n+    unsigned int numrows;\n+    unsigned int numcols;\n+    PyObject *images;\n+    size_t numimages;\n+\n+    if (!PyArg_ParseTuple(args, \"IIO:from_images\", &numrows, &numcols, &images)) {\n+        return NULL;\n+    }\n+\n+    if (!PySequence_Check(images)) {\n+        return NULL;\n+    }\n+\n+    Image *im = new Image(numrows, numcols, true);\n+    im->clear();\n+\n+    numimages = PySequence_Size(images);\n+\n+    for (size_t i = 0; i < numimages; ++i) {\n+        PyObject *entry = PySequence_GetItem(images, i);\n+        if (entry == NULL) {\n+            delete im;\n+            return NULL;\n+        }\n+\n+        PyObject *subimage;\n+        unsigned int x;\n+        unsigned int y;\n+        PyObject *alphaobj = NULL;\n+        double alpha = 0.0;\n+\n+        if (!PyArg_ParseTuple(entry, \"O!II|O\", &PyImageType, &subimage, &x, &y, &alphaobj)) {\n+            Py_DECREF(entry);\n+            delete im;\n+            return NULL;\n+        }\n+\n+        bool has_alpha = false;\n+        if (alphaobj != NULL && alphaobj != Py_None) {\n+            has_alpha = true;\n+            alpha = PyFloat_AsDouble(alphaobj);\n+            if (PyErr_Occurred()) {\n+                Py_DECREF(entry);\n+                delete im;\n+                return NULL;\n+            }\n+        }\n+\n+        CALL_CPP(\"from_images\",\n+                 (im->blend_image(*((PyImage *)subimage)->x, x, y, has_alpha, alpha)));\n+\n+        Py_DECREF(entry);\n+    }\n+\n+    return PyImage_cnew(im);\n+}\n+\n+const char *image_fromarray__doc__ =\n+    \"fromarray(A, isoutput)\\n\"\n+    \"\\n\"\n+    \"Load the image from a numpy array\\n\"\n+    \"By default this function fills the input buffer, which can subsequently\\n\"\n+    \"be resampled using resize.  If isoutput=1, fill the output buffer.\\n\"\n+    \"This is used to support raw pixel images w/o resampling\\n\";\n+\n+static PyObject *image_fromarray(PyObject *self, PyObject *args, PyObject *kwds)\n+{\n+    PyObject *array;\n+    int isoutput;\n+    const char *names[] = { \"array\", \"isoutput\", NULL };\n+\n+    if (!PyArg_ParseTupleAndKeywords(\n+             args, kwds, \"O|i:fromarray\", (char **)names, &array, &isoutput)) {\n+        return NULL;\n+    }\n+\n+    numpy::array_view<const double, 3> color_array;\n+    numpy::array_view<const double, 2> grey_array;\n+    Image *result = NULL;\n+\n+    if (numpy::convert_array<const double, 3>(array, &color_array)) {\n+        CALL_CPP(\"fromarray\", result = from_color_array(color_array, isoutput));\n+    } else if (numpy::convert_array<const double, 2>(array, &grey_array)) {\n+        CALL_CPP(\"fromarray\", result = from_grey_array(grey_array, isoutput));\n+    } else {\n+        PyErr_SetString(PyExc_ValueError, \"invalid array\");\n+        return NULL;\n+    }\n+\n+    return PyImage_cnew(result);\n+}\n+\n+const char *image_frombyte__doc__ =\n+    \"frombyte(A, isoutput)\\n\"\n+    \"\\n\"\n+    \"Load the image from a byte array.\\n\"\n+    \"By default this function fills the input buffer, which can subsequently\\n\"\n+    \"be resampled using resize.  If isoutput=1, fill the output buffer.\\n\"\n+    \"This is used to support raw pixel images w/o resampling.\";\n+\n+static PyObject *image_frombyte(PyObject *self, PyObject *args, PyObject *kwds)\n+{\n+    numpy::array_view<const uint8_t, 3> array;\n+    int isoutput;\n+    const char *names[] = { \"array\", \"isoutput\", NULL };\n+    Image *result;\n+\n+    if (!PyArg_ParseTupleAndKeywords(args,\n+                                     kwds,\n+                                     \"O&|i:frombyte\",\n+                                     (char **)names,\n+                                     &numpy::convert_array_contiguous<const uint8_t, 3>,\n+                                     &array,\n+                                     &isoutput)) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP(\"frombyte\", (result = frombyte(array, isoutput)));\n+\n+    return PyImage_cnew(result);\n+}\n+\n+const char *image_frombuffer__doc__ =\n+    \"frombuffer(buffer, width, height, isoutput)\\n\"\n+    \"\\n\"\n+    \"Load the image from a character buffer\\n\"\n+    \"By default this function fills the input buffer, which can subsequently\\n\"\n+    \"be resampled using resize.  If isoutput=1, fill the output buffer.\\n\"\n+    \"This is used to support raw pixel images w/o resampling.\";\n+\n+static PyObject *image_frombuffer(PyObject *self, PyObject *args, PyObject *kwds)\n+{\n+    PyObject *buffer;\n+    unsigned x;\n+    unsigned y;\n+    int isoutput;\n+    const char *names[] = { \"buffer\", \"x\", \"y\", \"isoutput\", NULL };\n+\n+    if (!PyArg_ParseTupleAndKeywords(\n+             args, kwds, \"OII|i:frombuffer\", (char **)names, &buffer, &x, &y, &isoutput)) {\n+        return NULL;\n+    }\n+\n+    const void *rawbuf;\n+    Py_ssize_t buflen;\n+    if (PyObject_AsReadBuffer(buffer, &rawbuf, &buflen) != 0) {\n+        return NULL;\n+    }\n+\n+    if (buflen != (Py_ssize_t)(y * x * 4)) {\n+        PyErr_SetString(PyExc_ValueError, \"Buffer is incorrect length\");\n+        return NULL;\n+    }\n+\n+    Image *im;\n+    CALL_CPP(\"frombuffer\", (im = new Image(y, x, isoutput)));\n+\n+    agg::int8u *inbuf = (agg::int8u *)rawbuf;\n+    agg::int8u *outbuf;\n+    if (isoutput) {\n+        outbuf = im->bufferOut;\n+    } else {\n+        outbuf = im->bufferIn;\n+    }\n+\n+    for (int i = (x * 4) * (y - 1); i >= 0; i -= (x * 4)) {\n+        memmove(outbuf, &inbuf[i], (x * 4));\n+        outbuf += x * 4;\n+    }\n+\n+    return PyImage_cnew(im);\n+}\n+\n+const char *image_pcolor__doc__ =\n+    \"pcolor(x, y, data, rows, cols, bounds)\\n\"\n+    \"\\n\"\n+    \"Generate a pseudo-color image from data on a non-uniform grid using\\n\"\n+    \"nearest neighbour or linear interpolation.\\n\"\n+    \"bounds = (x_min, x_max, y_min, y_max)\\n\"\n+    \"interpolation = NEAREST or BILINEAR \\n\";\n+\n+static PyObject *image_pcolor(PyObject *self, PyObject *args, PyObject *kwds)\n+{\n+    numpy::array_view<const float, 1> x;\n+    numpy::array_view<const float, 1> y;\n+    numpy::array_view<const agg::int8u, 3> d;\n+    unsigned int rows;\n+    unsigned int cols;\n+    float bounds[4];\n+    int interpolation;\n+    Image *result;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"O&O&O&II(ffff)i:pcolor\",\n+                          &numpy::convert_array_contiguous<const float, 1>,\n+                          &x,\n+                          &numpy::convert_array_contiguous<const float, 1>,\n+                          &y,\n+                          &numpy::convert_array_contiguous<const agg::int8u, 3>,\n+                          &d,\n+                          &rows,\n+                          &cols,\n+                          &bounds[0],\n+                          &bounds[1],\n+                          &bounds[2],\n+                          &bounds[3],\n+                          &interpolation)) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP(\"pcolor\", (result = pcolor(x, y, d, rows, cols, bounds, interpolation)));\n+\n+    return PyImage_cnew(result);\n+}\n+\n+const char *image_pcolor2__doc__ =\n+    \"pcolor2(x, y, data, rows, cols, bounds, bg)\\n\"\n+    \"\\n\"\n+    \"Generate a pseudo-color image from data on a non-uniform grid\\n\"\n+    \"specified by its cell boundaries.\\n\"\n+    \"bounds = (x_left, x_right, y_bot, y_top)\\n\"\n+    \"bg = ndarray of 4 uint8 representing background rgba\\n\";\n+\n+static PyObject *image_pcolor2(PyObject *self, PyObject *args, PyObject *kwds)\n+{\n+    numpy::array_view<const double, 1> x;\n+    numpy::array_view<const double, 1> y;\n+    numpy::array_view<const agg::int8u, 3> d;\n+    unsigned int rows;\n+    unsigned int cols;\n+    float bounds[4];\n+    numpy::array_view<const agg::int8u, 1> bg;\n+    Image *result;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"O&O&O&II(ffff)O&:pcolor2\",\n+                          &numpy::convert_array_contiguous<const double, 1>,\n+                          &x,\n+                          &numpy::convert_array_contiguous<const double, 1>,\n+                          &y,\n+                          &numpy::convert_array<const agg::int8u, 3>,\n+                          &d,\n+                          &rows,\n+                          &cols,\n+                          &bounds[0],\n+                          &bounds[1],\n+                          &bounds[2],\n+                          &bounds[3],\n+                          &numpy::convert_array<const agg::int8u, 1>,\n+                          &bg)) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP(\"pcolor2\", (result = pcolor2(x, y, d, rows, cols, bounds, bg)));\n+\n+    return PyImage_cnew(result);\n+}\n+\n+static PyMethodDef module_functions[] = {\n+    {\"from_images\", (PyCFunction)image_from_images, METH_VARARGS, image_from_images__doc__},\n+    {\"fromarray\", (PyCFunction)image_fromarray, METH_VARARGS|METH_KEYWORDS, image_fromarray__doc__},\n+    {\"frombyte\", (PyCFunction)image_frombyte, METH_VARARGS|METH_KEYWORDS, image_frombyte__doc__},\n+    {\"frombuffer\", (PyCFunction)image_frombuffer, METH_VARARGS|METH_KEYWORDS, image_frombuffer__doc__},\n+    {\"pcolor\", (PyCFunction)image_pcolor, METH_VARARGS, image_pcolor__doc__},\n+    {\"pcolor2\", (PyCFunction)image_pcolor2, METH_VARARGS, image_pcolor2__doc__},\n+    {NULL}\n+};\n+\n+extern \"C\" {\n+\n+struct module_state\n+{\n+/* The Sun compiler can't handle empty structs */\n+#if defined(__SUNPRO_C) || defined(_MSC_VER)\n+    int _dummy;\n+#endif\n+};\n+\n+#if PY3K\n+static struct PyModuleDef moduledef = {\n+    PyModuleDef_HEAD_INIT,\n+    \"_image\",\n+    NULL,\n+    sizeof(struct module_state),\n+    module_functions,\n+    NULL,\n+    NULL,\n+    NULL,\n+    NULL\n+};\n+\n+#define INITERROR return NULL\n+\n+PyMODINIT_FUNC PyInit__image(void)\n+\n+#else\n+#define INITERROR return\n+\n+PyMODINIT_FUNC init_image(void)\n+#endif\n+\n+{\n+    PyObject *m;\n+\n+#if PY3K\n+    m = PyModule_Create(&moduledef);\n+#else\n+    m = Py_InitModule3(\"_image\", module_functions, NULL);\n+#endif\n+\n+    if (m == NULL) {\n+        INITERROR;\n+    }\n+\n+    import_array();\n+\n+    if (!PyImage_init_type(m, &PyImageType)) {\n+        INITERROR;\n+    }\n+\n+    PyObject *d = PyModule_GetDict(m);\n+\n+    if (add_dict_int(d, \"NEAREST\", Image::NEAREST) ||\n+        add_dict_int(d, \"BILINEAR\", Image::BILINEAR) ||\n+        add_dict_int(d, \"BICUBIC\", Image::BICUBIC) ||\n+        add_dict_int(d, \"SPLINE16\", Image::SPLINE16) ||\n+        add_dict_int(d, \"SPLINE36\", Image::SPLINE36) ||\n+        add_dict_int(d, \"HANNING\", Image::HANNING) ||\n+        add_dict_int(d, \"HAMMING\", Image::HAMMING) ||\n+        add_dict_int(d, \"HERMITE\", Image::HERMITE) ||\n+        add_dict_int(d, \"KAISER\", Image::KAISER) ||\n+        add_dict_int(d, \"QUADRIC\", Image::QUADRIC) ||\n+        add_dict_int(d, \"CATROM\", Image::CATROM) ||\n+        add_dict_int(d, \"GAUSSIAN\", Image::GAUSSIAN) ||\n+        add_dict_int(d, \"BESSEL\", Image::BESSEL) ||\n+        add_dict_int(d, \"MITCHELL\", Image::MITCHELL) ||\n+        add_dict_int(d, \"SINC\", Image::SINC) ||\n+        add_dict_int(d, \"LANCZOS\", Image::LANCZOS) ||\n+        add_dict_int(d, \"BLACKMAN\", Image::BLACKMAN) ||\n+\n+        add_dict_int(d, \"ASPECT_FREE\", Image::ASPECT_FREE) ||\n+        add_dict_int(d, \"ASPECT_PRESERVE\", Image::ASPECT_PRESERVE)) {\n+        INITERROR;\n+    }\n+\n+    import_array();\n+\n+#if PY3K\n+    return m;\n+#endif\n+}\n+\n+} // extern \"C\""
            },
            {
                "sha": "a5775789e173c6d84da9906cb18390acc417f53b",
                "filename": "src/_macosx.m",
                "status": "modified",
                "additions": 0,
                "deletions": 4,
                "changes": 4,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_macosx.m",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_macosx.m",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/src%2F_macosx.m?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787",
                "patch": "@@ -4546,11 +4546,7 @@ -(void)save_figure:(id)sender\n     {\n         if(states[i]==1)\n         {\n-#if PY3K\n             PyList_SET_ITEM(list, j, PyLong_FromLong(i));\n-#else\n-            PyList_SET_ITEM(list, j, PyInt_FromLong(i));\n-#endif\n             j++;\n         }\n     }"
            },
            {
                "sha": "32eb73601b81c2241da0bc8dff32eaff8c9e2964",
                "filename": "src/_path.cpp",
                "status": "removed",
                "additions": 0,
                "deletions": 1813,
                "changes": 1813,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/dbeed94d578c458d31842cd13c04f665155986cb/src%2F_path.cpp",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/dbeed94d578c458d31842cd13c04f665155986cb/src%2F_path.cpp",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/src%2F_path.cpp?ref=dbeed94d578c458d31842cd13c04f665155986cb",
                "patch": "@@ -1,1813 +0,0 @@\n-/* -*- mode: c++; c-basic-offset: 4 -*- */\n-\n-#include \"agg_py_path_iterator.h\"\n-#include \"agg_py_transforms.h\"\n-#include \"path_converters.h\"\n-\n-#include <limits>\n-#include <math.h>\n-\n-#include \"CXX/Extensions.hxx\"\n-\n-#include \"agg_conv_contour.h\"\n-#include \"agg_conv_curve.h\"\n-#include \"agg_conv_stroke.h\"\n-#include \"agg_conv_transform.h\"\n-#include \"agg_path_storage.h\"\n-#include \"agg_trans_affine.h\"\n-\n-struct XY\n-{\n-    double x;\n-    double y;\n-\n-    XY(double x_, double y_) : x(x_), y(y_) {}\n-};\n-\n-// the extension module\n-class _path_module : public Py::ExtensionModule<_path_module>\n-{\n-public:\n-    _path_module()\n-            : Py::ExtensionModule<_path_module>(\"_path\")\n-    {\n-        add_varargs_method(\"point_in_path\", &_path_module::point_in_path,\n-                           \"point_in_path(x, y, path, trans)\");\n-        add_varargs_method(\"points_in_path\", &_path_module::points_in_path,\n-                           \"points_in_path(points, path, trans)\");\n-        add_varargs_method(\"point_on_path\", &_path_module::point_on_path,\n-                           \"point_on_path(x, y, r, path, trans)\");\n-        add_varargs_method(\"get_path_extents\", &_path_module::get_path_extents,\n-                           \"get_path_extents(path, trans)\");\n-        add_varargs_method(\"update_path_extents\", &_path_module::update_path_extents,\n-                           \"update_path_extents(path, trans, bbox, minpos)\");\n-        add_varargs_method(\"get_path_collection_extents\", &_path_module::get_path_collection_extents,\n-                           \"get_path_collection_extents(trans, paths, transforms, offsets, offsetTrans)\");\n-        add_varargs_method(\"point_in_path_collection\", &_path_module::point_in_path_collection,\n-                           \"point_in_path_collection(x, y, r, trans, paths, transforms, offsets, offsetTrans, filled)\");\n-        add_varargs_method(\"path_in_path\", &_path_module::path_in_path,\n-                           \"path_in_path(a, atrans, b, btrans)\");\n-        add_varargs_method(\"clip_path_to_rect\", &_path_module::clip_path_to_rect,\n-                           \"clip_path_to_rect(path, bbox, inside)\");\n-        add_varargs_method(\"affine_transform\", &_path_module::affine_transform,\n-                           \"affine_transform(vertices, transform)\");\n-        add_varargs_method(\"count_bboxes_overlapping_bbox\", &_path_module::count_bboxes_overlapping_bbox,\n-                           \"count_bboxes_overlapping_bbox(bbox, bboxes)\");\n-        add_varargs_method(\"path_intersects_path\", &_path_module::path_intersects_path,\n-                           \"path_intersects_path(p1, p2)\");\n-        add_varargs_method(\"convert_path_to_polygons\", &_path_module::convert_path_to_polygons,\n-                           \"convert_path_to_polygons(path, trans, width, height)\");\n-        add_varargs_method(\"cleanup_path\", &_path_module::cleanup_path,\n-                           \"cleanup_path(path, trans, remove_nans, clip, snap, simplify, curves, sketch_params)\");\n-        add_varargs_method(\"convert_to_svg\", &_path_module::convert_to_svg,\n-                           \"convert_to_svg(path, trans, clip, simplify, precision)\");\n-        initialize(\"Helper functions for paths\");\n-    }\n-\n-    virtual ~_path_module() {}\n-\n-private:\n-    Py::Object point_in_path(const Py::Tuple& args);\n-    Py::Object points_in_path(const Py::Tuple& args);\n-    Py::Object point_on_path(const Py::Tuple& args);\n-    Py::Object get_path_extents(const Py::Tuple& args);\n-    Py::Object update_path_extents(const Py::Tuple& args);\n-    Py::Object get_path_collection_extents(const Py::Tuple& args);\n-    Py::Object point_in_path_collection(const Py::Tuple& args);\n-    Py::Object path_in_path(const Py::Tuple& args);\n-    Py::Object clip_path_to_rect(const Py::Tuple& args);\n-    Py::Object affine_transform(const Py::Tuple& args);\n-    Py::Object count_bboxes_overlapping_bbox(const Py::Tuple& args);\n-    Py::Object path_intersects_path(const Py::Tuple& args);\n-    Py::Object convert_path_to_polygons(const Py::Tuple& args);\n-    Py::Object cleanup_path(const Py::Tuple& args);\n-    Py::Object convert_to_svg(const Py::Tuple& args);\n-};\n-\n-//\n-// The following function was found in the Agg 2.3 examples (interactive_polygon.cpp).\n-// It has been generalized to work on (possibly curved) polylines, rather than\n-// just polygons.  The original comments have been kept intact.\n-//  -- Michael Droettboom 2007-10-02\n-//\n-//======= Crossings Multiply algorithm of InsideTest ========================\n-//\n-// By Eric Haines, 3D/Eye Inc, erich@eye.com\n-//\n-// This version is usually somewhat faster than the original published in\n-// Graphics Gems IV; by turning the division for testing the X axis crossing\n-// into a tricky multiplication test this part of the test became faster,\n-// which had the additional effect of making the test for \"both to left or\n-// both to right\" a bit slower for triangles than simply computing the\n-// intersection each time.  The main increase is in triangle testing speed,\n-// which was about 15% faster; all other polygon complexities were pretty much\n-// the same as before.  On machines where division is very expensive (not the\n-// case on the HP 9000 series on which I tested) this test should be much\n-// faster overall than the old code.  Your mileage may (in fact, will) vary,\n-// depending on the machine and the test data, but in general I believe this\n-// code is both shorter and faster.  This test was inspired by unpublished\n-// Graphics Gems submitted by Joseph Samosky and Mark Haigh-Hutchinson.\n-// Related work by Samosky is in:\n-//\n-// Samosky, Joseph, \"SectionView: A system for interactively specifying and\n-// visualizing sections through three-dimensional medical image data\",\n-// M.S. Thesis, Department of Electrical Engineering and Computer Science,\n-// Massachusetts Institute of Technology, 1993.\n-//\n-// Shoot a test ray along +X axis.  The strategy is to compare vertex Y values\n-// to the testing point's Y and quickly discard edges which are entirely to one\n-// side of the test ray.  Note that CONVEX and WINDING code can be added as\n-// for the CrossingsTest() code; it is left out here for clarity.\n-//\n-// Input 2D polygon _pgon_ with _numverts_ number of vertices and test point\n-// _point_, returns 1 if inside, 0 if outside.\n-template<class T>\n-static void\n-point_in_path_impl(const void* const points_, const size_t s0,\n-                   const size_t s1, const size_t n, T& path,\n-                   npy_bool* const inside_flag)\n-{\n-    int *yflag0;\n-    int *subpath_flag;\n-    int yflag1;\n-    double vtx0, vty0, vtx1, vty1;\n-    double tx, ty;\n-    double sx, sy;\n-    double x, y;\n-    size_t i;\n-    int all_done;\n-    const char *const points = (const char * const)points_;\n-\n-    yflag0 = (int *)malloc(n * sizeof(int));\n-    subpath_flag = (int *)malloc(n * sizeof(int));\n-\n-    path.rewind(0);\n-\n-    for (i = 0; i < n; ++i) {\n-        inside_flag[i] = 0;\n-    }\n-\n-    unsigned code = 0;\n-    do\n-    {\n-        if (code != agg::path_cmd_move_to)\n-        {\n-            code = path.vertex(&x, &y);\n-            if (code == agg::path_cmd_stop ||\n-                (code & agg::path_cmd_end_poly) == agg::path_cmd_end_poly) {\n-                continue;\n-            }\n-        }\n-\n-        sx = vtx0 = vtx1 = x;\n-        sy = vty0 = vty1 = y;\n-\n-        for (i = 0; i < n; ++i) {\n-            ty = *(double *)(points + s0 * i + s1);\n-\n-            // get test bit for above/below X axis\n-            yflag0[i] = (vty0 >= ty);\n-\n-            subpath_flag[i] = 0;\n-        }\n-\n-        do\n-        {\n-            code = path.vertex(&x, &y);\n-\n-            // The following cases denote the beginning on a new subpath\n-            if (code == agg::path_cmd_stop ||\n-                (code & agg::path_cmd_end_poly) == agg::path_cmd_end_poly)\n-            {\n-                x = sx;\n-                y = sy;\n-            }\n-            else if (code == agg::path_cmd_move_to)\n-            {\n-                break;\n-            }\n-\n-            for (i = 0; i < n; ++i) {\n-                tx = *(double *)(points + s0 * i);\n-                ty = *(double *)(points + s0 * i + s1);\n-\n-                yflag1 = (vty1 >= ty);\n-                // Check if endpoints straddle (are on opposite sides) of\n-                // X axis (i.e. the Y's differ); if so, +X ray could\n-                // intersect this edge.  The old test also checked whether\n-                // the endpoints are both to the right or to the left of\n-                // the test point.  However, given the faster intersection\n-                // point computation used below, this test was found to be\n-                // a break-even proposition for most polygons and a loser\n-                // for triangles (where 50% or more of the edges which\n-                // survive this test will cross quadrants and so have to\n-                // have the X intersection computed anyway).  I credit\n-                // Joseph Samosky with inspiring me to try dropping the\n-                // \"both left or both right\" part of my code.\n-                if (yflag0[i] != yflag1) {\n-                    // Check intersection of pgon segment with +X ray.\n-                    // Note if >= point's X; if so, the ray hits it.  The\n-                    // division operation is avoided for the \">=\" test by\n-                    // checking the sign of the first vertex wrto the test\n-                    // point; idea inspired by Joseph Samosky's and Mark\n-                    // Haigh-Hutchinson's different polygon inclusion\n-                    // tests.\n-                    if (((vty1 - ty) * (vtx0 - vtx1) >=\n-                         (vtx1 - tx) * (vty0 - vty1)) == yflag1) {\n-                        subpath_flag[i] ^= 1;\n-                    }\n-                }\n-\n-                // Move to the next pair of vertices, retaining info as\n-                // possible.\n-                yflag0[i] = yflag1;\n-            }\n-\n-            vtx0 = vtx1;\n-            vty0 = vty1;\n-\n-            vtx1 = x;\n-            vty1 = y;\n-        }\n-        while (code != agg::path_cmd_stop &&\n-               (code & agg::path_cmd_end_poly) != agg::path_cmd_end_poly);\n-\n-        all_done = 1;\n-        for (i = 0; i < n; ++i) {\n-            tx = *(double *)(points + s0 * i);\n-            ty = *(double *)(points + s0 * i + s1);\n-\n-            yflag1 = (vty1 >= ty);\n-            if (yflag0[i] != yflag1) {\n-                if (((vty1 - ty) * (vtx0 - vtx1) >=\n-                     (vtx1 - tx) * (vty0 - vty1)) == yflag1) {\n-                    subpath_flag[i] ^= 1;\n-                }\n-            }\n-            inside_flag[i] |= subpath_flag[i];\n-            if (inside_flag[i] == 0) {\n-                all_done = 0;\n-            }\n-        }\n-\n-        if (all_done) {\n-            goto exit;\n-        }\n-    }\n-    while (code != agg::path_cmd_stop);\n-\n- exit:\n-\n-    free(yflag0);\n-    free(subpath_flag);\n-}\n-\n-inline void\n-points_in_path(const void* const points, const size_t s0,\n-               const size_t s1, const size_t n,\n-               const double r, PathIterator& path,\n-               const agg::trans_affine& trans,\n-               npy_bool* result)\n-{\n-    typedef agg::conv_transform<PathIterator> transformed_path_t;\n-    typedef PathNanRemover<transformed_path_t> no_nans_t;\n-    typedef agg::conv_curve<no_nans_t> curve_t;\n-    typedef agg::conv_contour<curve_t> contour_t;\n-\n-    size_t i;\n-    for (i = 0; i < n; ++i) {\n-        result[i] = 0;\n-    }\n-\n-    if (path.total_vertices() < 3)\n-    {\n-        return;\n-    }\n-\n-    transformed_path_t trans_path(path, trans);\n-    no_nans_t no_nans_path(trans_path, true, path.has_curves());\n-    curve_t curved_path(no_nans_path);\n-    contour_t contoured_path(curved_path);\n-    contoured_path.width(r);\n-    point_in_path_impl(points, s0, s1, n, contoured_path, result);\n-}\n-\n-inline bool\n-point_in_path(const double x, const double y, const double r,\n-              PathIterator& path, const agg::trans_affine& trans)\n-{\n-    double points[2];\n-    npy_bool result;\n-\n-    points[0] = x;\n-    points[1] = y;\n-\n-    points_in_path(points, 0, sizeof(double), 1, r, path, trans, &result);\n-    return result;\n-}\n-\n-inline void\n-points_on_path(const void* const points, const size_t s0,\n-               const size_t s1, const size_t n,\n-               const double r, PathIterator& path,\n-               const agg::trans_affine& trans,\n-               npy_bool* result)\n-{\n-    typedef agg::conv_transform<PathIterator> transformed_path_t;\n-    typedef PathNanRemover<transformed_path_t> no_nans_t;\n-    typedef agg::conv_curve<no_nans_t> curve_t;\n-    typedef agg::conv_stroke<curve_t> stroke_t;\n-\n-    transformed_path_t trans_path(path, trans);\n-    no_nans_t nan_removed_path(trans_path, true, path.has_curves());\n-    curve_t curved_path(nan_removed_path);\n-    stroke_t stroked_path(curved_path);\n-    stroked_path.width(r * 2.0);\n-    point_in_path_impl(points, s0, s1, n, stroked_path, result);\n-}\n-\n-inline bool\n-point_on_path(const double x, const double y, const double r,\n-              PathIterator& path, const agg::trans_affine& trans)\n-{\n-    double points[2];\n-    npy_bool result;\n-\n-    points[0] = x;\n-    points[1] = y;\n-\n-    points_on_path(points, 0, sizeof(double), 1, r, path, trans, &result);\n-    return result;\n-}\n-\n-Py::Object\n-_path_module::point_in_path(const Py::Tuple& args)\n-{\n-    double x = Py::Float(args[0]);\n-    double y = Py::Float(args[1]);\n-    double r = Py::Float(args[2]);\n-    PathIterator path(args[3]);\n-    agg::trans_affine trans = py_to_agg_transformation_matrix(args[4].ptr(), false);\n-\n-    if (::point_in_path(x, y, r, path, trans)) {\n-        return Py::Int(1);\n-    }\n-    return Py::Int(0);\n-}\n-\n-Py::Object\n-_path_module::points_in_path(const Py::Tuple& args)\n-{\n-    args.verify_length(4);\n-\n-    npy_intp n;\n-    PyArrayObject* points_array;\n-    points_array = (PyArrayObject*)PyArray_FromObject(args[0].ptr(), NPY_DOUBLE, 2, 2);\n-    if (points_array == NULL || PyArray_DIM(points_array, 1) != 2) {\n-        throw Py::TypeError(\n-            \"Argument 0 to points_in_path must be an Nx2 numpy array\");\n-\n-    }\n-    double r = Py::Float(args[1]);\n-    PathIterator path(args[2]);\n-    agg::trans_affine trans = py_to_agg_transformation_matrix(args[3].ptr(), false);\n-\n-    n = PyArray_DIM(points_array, 0);\n-    PyObject* result = PyArray_ZEROS(1, &n, NPY_BOOL, 0);\n-    if (result == NULL) {\n-        throw Py::MemoryError(\"Could not allocate memory for result\");\n-    }\n-\n-    ::points_in_path(PyArray_DATA(points_array),\n-                     PyArray_STRIDE(points_array, 0),\n-                     PyArray_STRIDE(points_array, 1),\n-                     n, r, path, trans,\n-                     (npy_bool *)PyArray_DATA((PyArrayObject*)result));\n-    Py_DECREF(points_array);\n-\n-    return Py::Object(result, true);;\n-}\n-\n-Py::Object\n-_path_module::point_on_path(const Py::Tuple& args)\n-{\n-    double x = Py::Float(args[0]);\n-    double y = Py::Float(args[1]);\n-    double r = Py::Float(args[2]);\n-    PathIterator path(args[3]);\n-    agg::trans_affine trans = py_to_agg_transformation_matrix(args[4].ptr());\n-\n-    if (::point_on_path(x, y, r, path, trans))\n-    {\n-        return Py::Int(1);\n-    }\n-    return Py::Int(0);\n-}\n-\n-void\n-update_limits(double x, double y,\n-              double* x0, double* y0, double* x1, double* y1,\n-              double* xm, double* ym)\n-{\n-    if (x < *x0) *x0 = x;\n-    if (y < *y0) *y0 = y;\n-    if (x > *x1) *x1 = x;\n-    if (y > *y1) *y1 = y;\n-    /* xm and ym are the minimum positive values in the data, used\n-       by log scaling */\n-    if (x > 0.0 && x < *xm) *xm = x;\n-    if (y > 0.0 && y < *ym) *ym = y;\n-}\n-\n-void\n-get_path_extents(PathIterator& path, const agg::trans_affine& trans,\n-                 double* x0, double* y0, double* x1, double* y1,\n-                 double* xm, double* ym)\n-{\n-    typedef agg::conv_transform<PathIterator> transformed_path_t;\n-    typedef PathNanRemover<transformed_path_t> nan_removed_t;\n-    typedef agg::conv_curve<nan_removed_t> curve_t;\n-    double x, y;\n-    unsigned code;\n-\n-    transformed_path_t tpath(path, trans);\n-    nan_removed_t nan_removed(tpath, true, path.has_curves());\n-\n-    nan_removed.rewind(0);\n-\n-    while ((code = nan_removed.vertex(&x, &y)) != agg::path_cmd_stop)\n-    {\n-        if ((code & agg::path_cmd_end_poly) == agg::path_cmd_end_poly)\n-        {\n-            continue;\n-        }\n-        update_limits(x, y, x0, y0, x1, y1, xm, ym);\n-    }\n-}\n-\n-Py::Object\n-_path_module::get_path_extents(const Py::Tuple& args)\n-{\n-    args.verify_length(2);\n-\n-    PathIterator path(args[0]);\n-    agg::trans_affine trans = py_to_agg_transformation_matrix(args[1].ptr(), false);\n-\n-    npy_intp extent_dims[] = { 2, 2, 0 };\n-    double* extents_data = NULL;\n-    double xm, ym;\n-    PyArrayObject* extents = NULL;\n-    try\n-    {\n-        extents = (PyArrayObject*)PyArray_SimpleNew\n-                  (2, extent_dims, NPY_DOUBLE);\n-        if (extents == NULL)\n-        {\n-            throw Py::MemoryError(\"Could not allocate result array\");\n-        }\n-        extents_data = (double*)PyArray_DATA(extents);\n-\n-        extents_data[0] = std::numeric_limits<double>::infinity();\n-        extents_data[1] = std::numeric_limits<double>::infinity();\n-        extents_data[2] = -std::numeric_limits<double>::infinity();\n-        extents_data[3] = -std::numeric_limits<double>::infinity();\n-        /* xm and ym are the minimum positive values in the data, used\n-           by log scaling */\n-        xm = std::numeric_limits<double>::infinity();\n-        ym = std::numeric_limits<double>::infinity();\n-\n-        ::get_path_extents(path, trans, &extents_data[0], &extents_data[1],\n-                           &extents_data[2], &extents_data[3], &xm, &ym);\n-    }\n-    catch (...)\n-    {\n-        Py_XDECREF(extents);\n-        throw;\n-    }\n-\n-    return Py::Object((PyObject*)extents, true);\n-}\n-\n-Py::Object\n-_path_module::update_path_extents(const Py::Tuple& args)\n-{\n-    args.verify_length(5);\n-\n-    double x0, y0, x1, y1;\n-    PathIterator path(args[0]);\n-    agg::trans_affine trans = py_to_agg_transformation_matrix(\n-        args[1].ptr(), false);\n-\n-    if (!py_convert_bbox(args[2].ptr(), x0, y0, x1, y1))\n-    {\n-        throw Py::ValueError(\n-            \"Must pass Bbox object as arg 3 of update_path_extents\");\n-    }\n-    Py::Object minpos_obj = args[3];\n-    bool ignore = Py::Boolean(args[4]);\n-\n-    double xm, ym;\n-    PyArrayObject* input_minpos = NULL;\n-    try\n-    {\n-        input_minpos = (PyArrayObject*)PyArray_FromObject(\n-            minpos_obj.ptr(), NPY_DOUBLE, 1, 1);\n-        if (!input_minpos || PyArray_DIM(input_minpos, 0) != 2)\n-        {\n-            throw Py::TypeError(\n-                \"Argument 4 to update_path_extents must be a length-2 numpy array.\");\n-        }\n-        xm = *(double*)PyArray_GETPTR1(input_minpos, 0);\n-        ym = *(double*)PyArray_GETPTR1(input_minpos, 1);\n-    }\n-    catch (...)\n-    {\n-        Py_XDECREF(input_minpos);\n-        throw;\n-    }\n-    Py_XDECREF(input_minpos);\n-\n-    npy_intp extent_dims[] = { 2, 2, 0 };\n-    double* extents_data = NULL;\n-    npy_intp minpos_dims[] = { 2, 0 };\n-    double* minpos_data = NULL;\n-    PyArrayObject* extents = NULL;\n-    PyArrayObject* minpos = NULL;\n-    bool changed = false;\n-\n-    try\n-    {\n-        extents = (PyArrayObject*)PyArray_SimpleNew\n-                  (2, extent_dims, NPY_DOUBLE);\n-        if (extents == NULL)\n-        {\n-            throw Py::MemoryError(\"Could not allocate result array\");\n-        }\n-        minpos = (PyArrayObject*)PyArray_SimpleNew\n-                 (1, minpos_dims, NPY_DOUBLE);\n-        if (minpos == NULL)\n-        {\n-            throw Py::MemoryError(\"Could not allocate result array\");\n-        }\n-\n-        extents_data = (double*)PyArray_DATA(extents);\n-        minpos_data = (double*)PyArray_DATA(minpos);\n-\n-        if (ignore)\n-        {\n-            extents_data[0] = std::numeric_limits<double>::infinity();\n-            extents_data[1] = std::numeric_limits<double>::infinity();\n-            extents_data[2] = -std::numeric_limits<double>::infinity();\n-            extents_data[3] = -std::numeric_limits<double>::infinity();\n-            minpos_data[0] = std::numeric_limits<double>::infinity();\n-            minpos_data[1] = std::numeric_limits<double>::infinity();\n-        }\n-        else\n-        {\n-            if (x0 > x1)\n-            {\n-                extents_data[0] = std::numeric_limits<double>::infinity();\n-                extents_data[2] = -std::numeric_limits<double>::infinity();\n-            }\n-            else\n-            {\n-                extents_data[0] = x0;\n-                extents_data[2] = x1;\n-            }\n-            if (y0 > y1)\n-            {\n-                extents_data[1] = std::numeric_limits<double>::infinity();\n-                extents_data[3] = -std::numeric_limits<double>::infinity();\n-            }\n-            else\n-            {\n-                extents_data[1] = y0;\n-                extents_data[3] = y1;\n-            }\n-            minpos_data[0] = xm;\n-            minpos_data[1] = ym;\n-        }\n-\n-        ::get_path_extents(path, trans, &extents_data[0], &extents_data[1],\n-                           &extents_data[2], &extents_data[3], &minpos_data[0],\n-                           &minpos_data[1]);\n-\n-        changed = (extents_data[0] != x0 ||\n-                   extents_data[1] != y0 ||\n-                   extents_data[2] != x1 ||\n-                   extents_data[3] != y1 ||\n-                   minpos_data[0]  != xm ||\n-                   minpos_data[1]  != ym);\n-\n-    }\n-    catch (...)\n-    {\n-        Py_XDECREF(extents);\n-        Py_XDECREF(minpos);\n-        throw;\n-    }\n-\n-    Py::Tuple result(3);\n-    result[0] = Py::Object((PyObject*) extents);\n-    result[1] = Py::Object((PyObject*) minpos);\n-    result[2] = Py::Int(changed ? 1 : 0);\n-\n-    Py_XDECREF(extents);\n-    Py_XDECREF(minpos);\n-\n-    return result;\n-}\n-\n-Py::Object\n-_path_module::get_path_collection_extents(const Py::Tuple& args)\n-{\n-    args.verify_length(5);\n-\n-    //segments, trans, clipbox, colors, linewidths, antialiaseds\n-    agg::trans_affine       master_transform = py_to_agg_transformation_matrix(args[0].ptr());\n-    Py::SeqBase<Py::Object> paths            = args[1];\n-    Py::SeqBase<Py::Object> transforms_obj   = args[2];\n-    Py::Object              offsets_obj      = args[3];\n-    agg::trans_affine       offset_trans     = py_to_agg_transformation_matrix(args[4].ptr(), false);\n-\n-    PyArrayObject* offsets = NULL;\n-    double x0, y0, x1, y1, xm, ym;\n-\n-    try\n-    {\n-        offsets = (PyArrayObject*)PyArray_FromObject(\n-            offsets_obj.ptr(), NPY_DOUBLE, 0, 2);\n-        if (!offsets ||\n-            (PyArray_NDIM(offsets) == 2 && PyArray_DIM(offsets, 1) != 2) ||\n-            (PyArray_NDIM(offsets) == 1 && PyArray_DIM(offsets, 0) != 0))\n-        {\n-            throw Py::ValueError(\"Offsets array must be Nx2\");\n-        }\n-\n-        size_t Npaths      = paths.length();\n-        size_t Noffsets    = PyArray_DIM(offsets, 0);\n-        size_t N           = std::max(Npaths, Noffsets);\n-        size_t Ntransforms = std::min(transforms_obj.length(), N);\n-        size_t i;\n-\n-        // Convert all of the transforms up front\n-        typedef std::vector<agg::trans_affine> transforms_t;\n-        transforms_t transforms;\n-        transforms.reserve(Ntransforms);\n-        for (i = 0; i < Ntransforms; ++i)\n-        {\n-            agg::trans_affine trans = py_to_agg_transformation_matrix\n-                (transforms_obj[i].ptr(), false);\n-            trans *= master_transform;\n-            transforms.push_back(trans);\n-        }\n-\n-        // The offset each of those and collect the mins/maxs\n-        x0 = std::numeric_limits<double>::infinity();\n-        y0 = std::numeric_limits<double>::infinity();\n-        x1 = -std::numeric_limits<double>::infinity();\n-        y1 = -std::numeric_limits<double>::infinity();\n-        xm = std::numeric_limits<double>::infinity();\n-        ym = std::numeric_limits<double>::infinity();\n-        agg::trans_affine trans;\n-\n-        if (transforms.size() <= 1 && paths.size() == 1)\n-        {\n-            PathIterator path(paths[0]);\n-            if (Ntransforms)\n-            {\n-                trans = transforms[0];\n-            }\n-            else\n-            {\n-                trans = master_transform;\n-            }\n-\n-            double bx0 = std::numeric_limits<double>::infinity();\n-            double by0 = std::numeric_limits<double>::infinity();\n-            double bx1 = -std::numeric_limits<double>::infinity();\n-            double by1 = -std::numeric_limits<double>::infinity();\n-            double bxm = std::numeric_limits<double>::infinity();\n-            double bym = std::numeric_limits<double>::infinity();\n-\n-            ::get_path_extents(path, trans, &bx0, &by0, &bx1, &by1, &bxm, &bym);\n-\n-            for (i = 0; i < Noffsets; ++i)\n-            {\n-                double xo = *(double*)PyArray_GETPTR2(offsets, i % Noffsets, 0);\n-                double yo = *(double*)PyArray_GETPTR2(offsets, i % Noffsets, 1);\n-                offset_trans.transform(&xo, &yo);\n-                update_limits(xo + bx0, yo + by0, &x0, &y0, &x1, &y1, &xm, &ym);\n-                update_limits(xo + bx1, yo + by1, &x0, &y0, &x1, &y1, &xm, &ym);\n-            }\n-        } else {\n-            for (i = 0; i < N; ++i)\n-            {\n-                PathIterator path(paths[i % Npaths]);\n-                if (Ntransforms)\n-                {\n-                    trans = transforms[i % Ntransforms];\n-                }\n-                else\n-                {\n-                    trans = master_transform;\n-                }\n-\n-                if (Noffsets)\n-                {\n-                    double xo = *(double*)PyArray_GETPTR2(offsets, i % Noffsets, 0);\n-                    double yo = *(double*)PyArray_GETPTR2(offsets, i % Noffsets, 1);\n-                    offset_trans.transform(&xo, &yo);\n-                    trans *= agg::trans_affine_translation(xo, yo);\n-                }\n-\n-                ::get_path_extents(path, trans, &x0, &y0, &x1, &y1, &xm, &ym);\n-            }\n-        }\n-    }\n-    catch (...)\n-    {\n-        Py_XDECREF(offsets);\n-        throw;\n-    }\n-\n-    Py_XDECREF(offsets);\n-\n-    Py::Tuple result(4);\n-    result[0] = Py::Float(x0);\n-    result[1] = Py::Float(y0);\n-    result[2] = Py::Float(x1);\n-    result[3] = Py::Float(y1);\n-    return result;\n-}\n-\n-Py::Object\n-_path_module::point_in_path_collection(const Py::Tuple& args)\n-{\n-    args.verify_length(10);\n-\n-    //segments, trans, clipbox, colors, linewidths, antialiaseds\n-    double                  x                = Py::Float(args[0]);\n-    double                  y                = Py::Float(args[1]);\n-    double                  radius           = Py::Float(args[2]);\n-    agg::trans_affine       master_transform = py_to_agg_transformation_matrix(args[3].ptr());\n-    Py::SeqBase<Py::Object> paths            = args[4];\n-    Py::SeqBase<Py::Object> transforms_obj   = args[5];\n-    Py::SeqBase<Py::Object> offsets_obj      = args[6];\n-    agg::trans_affine       offset_trans     = py_to_agg_transformation_matrix(args[7].ptr());\n-    bool                    filled           = Py::Boolean(args[8]);\n-    std::string             offset_position  = Py::String(args[9]).encode(\"utf-8\");\n-\n-    bool data_offsets = (offset_position == \"data\");\n-\n-    PyArrayObject* offsets = (PyArrayObject*)PyArray_FromObject(\n-        offsets_obj.ptr(), NPY_DOUBLE, 0, 2);\n-    if (!offsets ||\n-            (PyArray_NDIM(offsets) == 2 && PyArray_DIM(offsets, 1) != 2) ||\n-            (PyArray_NDIM(offsets) == 1 && PyArray_DIM(offsets, 0) != 0))\n-    {\n-        Py_XDECREF(offsets);\n-        throw Py::ValueError(\"Offsets array must be Nx2\");\n-    }\n-\n-    Py::List result;\n-\n-    size_t Npaths      = paths.length();\n-\n-    if (Npaths == 0) {\n-        return result;\n-    }\n-\n-    size_t Noffsets    = PyArray_DIM(offsets, 0);\n-\n-    size_t N           = std::max(Npaths, Noffsets);\n-    size_t Ntransforms = std::min(transforms_obj.length(), N);\n-    size_t i;\n-\n-    // Convert all of the transforms up front\n-    typedef std::vector<agg::trans_affine> transforms_t;\n-    transforms_t transforms;\n-    transforms.reserve(Ntransforms);\n-    for (i = 0; i < Ntransforms; ++i)\n-    {\n-        agg::trans_affine trans = py_to_agg_transformation_matrix\n-                                  (transforms_obj[i].ptr(), false);\n-        trans *= master_transform;\n-        transforms.push_back(trans);\n-    }\n-\n-    agg::trans_affine trans;\n-\n-    for (i = 0; i < N; ++i)\n-    {\n-        PathIterator path(paths[i % Npaths]);\n-\n-        if (Ntransforms)\n-        {\n-            trans = transforms[i % Ntransforms];\n-        }\n-        else\n-        {\n-            trans = master_transform;\n-        }\n-\n-        if (Noffsets)\n-        {\n-            double xo = *(double*)PyArray_GETPTR2(offsets, i % Noffsets, 0);\n-            double yo = *(double*)PyArray_GETPTR2(offsets, i % Noffsets, 1);\n-            offset_trans.transform(&xo, &yo);\n-            if (data_offsets) {\n-                trans = agg::trans_affine_translation(xo, yo) * trans;\n-            } else {\n-                trans *= agg::trans_affine_translation(xo, yo);\n-            }\n-        }\n-\n-        if (filled)\n-        {\n-            if (::point_in_path(x, y, radius, path, trans))\n-                result.append(Py::Int((int)i));\n-        }\n-        else\n-        {\n-            if (::point_on_path(x, y, radius, path, trans))\n-                result.append(Py::Int((int)i));\n-        }\n-    }\n-\n-    return result;\n-}\n-\n-bool\n-path_in_path(PathIterator& a, const agg::trans_affine& atrans,\n-             PathIterator& b, const agg::trans_affine& btrans)\n-{\n-    typedef agg::conv_transform<PathIterator> transformed_path_t;\n-    typedef PathNanRemover<transformed_path_t> no_nans_t;\n-    typedef agg::conv_curve<no_nans_t> curve_t;\n-\n-    if (a.total_vertices() < 3)\n-        return false;\n-\n-    transformed_path_t b_path_trans(b, btrans);\n-    no_nans_t b_no_nans(b_path_trans, true, b.has_curves());\n-    curve_t b_curved(b_no_nans);\n-\n-    double x, y;\n-    b_curved.rewind(0);\n-    while (b_curved.vertex(&x, &y) != agg::path_cmd_stop)\n-    {\n-        if (!::point_in_path(x, y, 0.0, a, atrans))\n-            return false;\n-    }\n-\n-    return true;\n-}\n-\n-Py::Object\n-_path_module::path_in_path(const Py::Tuple& args)\n-{\n-    args.verify_length(4);\n-\n-    PathIterator a(args[0]);\n-    agg::trans_affine atrans = py_to_agg_transformation_matrix(\n-        args[1].ptr(), false);\n-    PathIterator b(args[2]);\n-    agg::trans_affine btrans = py_to_agg_transformation_matrix(\n-        args[3].ptr(), false);\n-\n-    return Py::Int(::path_in_path(a, atrans, b, btrans));\n-}\n-\n-/** The clip_path_to_rect code here is a clean-room implementation of\n-    the Sutherland-Hodgman clipping algorithm described here:\n-\n-  http://en.wikipedia.org/wiki/Sutherland-Hodgman_clipping_algorithm\n-*/\n-\n-typedef std::vector<XY> Polygon;\n-\n-namespace clip_to_rect_filters\n-{\n-    /* There are four different passes needed to create/remove\n-       vertices (one for each side of the rectangle).  The differences\n-       between those passes are encapsulated in these functor classes.\n-    */\n-    struct bisectx\n-    {\n-        double m_x;\n-\n-        bisectx(double x) : m_x(x) {}\n-\n-        inline void\n-        bisect(double sx, double sy, double px, double py, double* bx,\n-               double* by) const\n-        {\n-            *bx = m_x;\n-            double dx = px - sx;\n-            double dy = py - sy;\n-            *by = sy + dy * ((m_x - sx) / dx);\n-        }\n-    };\n-\n-    struct xlt : public bisectx\n-    {\n-        xlt(double x) : bisectx(x) {}\n-\n-        inline bool\n-        is_inside(double x, double y) const\n-        {\n-            return x <= m_x;\n-        }\n-    };\n-\n-    struct xgt : public bisectx\n-    {\n-        xgt(double x) : bisectx(x) {}\n-\n-        inline bool\n-        is_inside(double x, double y) const\n-        {\n-            return x >= m_x;\n-        }\n-    };\n-\n-    struct bisecty\n-    {\n-        double m_y;\n-\n-        bisecty(double y) : m_y(y) {}\n-\n-        inline void\n-        bisect(double sx, double sy, double px, double py, double* bx,\n-               double* by) const\n-        {\n-            *by = m_y;\n-            double dx = px - sx;\n-            double dy = py - sy;\n-            *bx = sx + dx * ((m_y - sy) / dy);\n-        }\n-    };\n-\n-    struct ylt : public bisecty\n-    {\n-        ylt(double y) : bisecty(y) {}\n-\n-        inline bool\n-        is_inside(double x, double y) const\n-        {\n-            return y <= m_y;\n-        }\n-    };\n-\n-    struct ygt : public bisecty\n-    {\n-        ygt(double y) : bisecty(y) {}\n-\n-        inline bool\n-        is_inside(double x, double y) const\n-        {\n-            return y >= m_y;\n-        }\n-    };\n-}\n-\n-template<class Filter>\n-inline void\n-clip_to_rect_one_step(const Polygon& polygon, Polygon& result, const Filter& filter)\n-{\n-    double sx, sy, px, py, bx, by;\n-    bool sinside, pinside;\n-    result.clear();\n-\n-    if (polygon.size() == 0)\n-    {\n-        return;\n-    }\n-\n-    sx = polygon.back().x;\n-    sy = polygon.back().y;\n-    for (Polygon::const_iterator i = polygon.begin(); i != polygon.end(); ++i)\n-    {\n-        px = i->x;\n-        py = i->y;\n-\n-        sinside = filter.is_inside(sx, sy);\n-        pinside = filter.is_inside(px, py);\n-\n-        if (sinside ^ pinside)\n-        {\n-            filter.bisect(sx, sy, px, py, &bx, &by);\n-            result.push_back(XY(bx, by));\n-        }\n-\n-        if (pinside)\n-        {\n-            result.push_back(XY(px, py));\n-        }\n-\n-        sx = px;\n-        sy = py;\n-    }\n-}\n-\n-template<class Path>\n-void\n-clip_to_rect(Path& path,\n-             double x0, double y0, double x1, double y1,\n-             bool inside, std::vector<Polygon>& results)\n-{\n-    double xmin, ymin, xmax, ymax;\n-    if (x0 < x1)\n-    {\n-        xmin = x0;\n-        xmax = x1;\n-    }\n-    else\n-    {\n-        xmin = x1;\n-        xmax = x0;\n-    }\n-\n-    if (y0 < y1)\n-    {\n-        ymin = y0;\n-        ymax = y1;\n-    }\n-    else\n-    {\n-        ymin = y1;\n-        ymax = y0;\n-    }\n-\n-    if (!inside)\n-    {\n-        std::swap(xmin, xmax);\n-        std::swap(ymin, ymax);\n-    }\n-\n-    Polygon polygon1, polygon2;\n-    double x = 0, y = 0;\n-    unsigned code = 0;\n-    path.rewind(0);\n-\n-    do\n-    {\n-        // Grab the next subpath and store it in polygon1\n-        polygon1.clear();\n-        do\n-        {\n-            if (code == agg::path_cmd_move_to)\n-            {\n-                polygon1.push_back(XY(x, y));\n-            }\n-\n-            code = path.vertex(&x, &y);\n-\n-            if (code == agg::path_cmd_stop)\n-            {\n-                break;\n-            }\n-\n-            if (code != agg::path_cmd_move_to)\n-            {\n-                polygon1.push_back(XY(x, y));\n-            }\n-        }\n-        while ((code & agg::path_cmd_end_poly) != agg::path_cmd_end_poly);\n-\n-        // The result of each step is fed into the next (note the\n-        // swapping of polygon1 and polygon2 at each step).\n-        clip_to_rect_one_step(polygon1, polygon2, clip_to_rect_filters::xlt(xmax));\n-        clip_to_rect_one_step(polygon2, polygon1, clip_to_rect_filters::xgt(xmin));\n-        clip_to_rect_one_step(polygon1, polygon2, clip_to_rect_filters::ylt(ymax));\n-        clip_to_rect_one_step(polygon2, polygon1, clip_to_rect_filters::ygt(ymin));\n-\n-        // Empty polygons aren't very useful, so skip them\n-        if (polygon1.size())\n-        {\n-            results.push_back(polygon1);\n-        }\n-    }\n-    while (code != agg::path_cmd_stop);\n-}\n-\n-Py::Object\n-_path_module::clip_path_to_rect(const Py::Tuple &args)\n-{\n-    args.verify_length(3);\n-\n-    PathIterator path(args[0]);\n-    Py::Object bbox_obj = args[1];\n-    bool inside = Py::Boolean(args[2]);\n-\n-    double x0, y0, x1, y1;\n-    if (!py_convert_bbox(bbox_obj.ptr(), x0, y0, x1, y1))\n-    {\n-        throw Py::TypeError(\"Argument 2 to clip_to_rect must be a Bbox object.\");\n-    }\n-\n-    std::vector<Polygon> results;\n-    typedef agg::conv_curve<PathIterator> curve_t;\n-    curve_t curve(path);\n-\n-    ::clip_to_rect(curve, x0, y0, x1, y1, inside, results);\n-\n-    npy_intp dims[2];\n-    dims[1] = 2;\n-    PyObject* py_results = PyList_New(results.size());\n-    if (!py_results)\n-    {\n-        throw Py::RuntimeError(\"Error creating results list\");\n-    }\n-\n-    try\n-    {\n-        for (std::vector<Polygon>::const_iterator p = results.begin(); p != results.end(); ++p)\n-        {\n-            size_t size = p->size();\n-            dims[0] = (npy_intp)size + 1;\n-            PyArrayObject* pyarray = (PyArrayObject*)PyArray_SimpleNew(2, dims, NPY_DOUBLE);\n-            if (pyarray == NULL)\n-            {\n-                throw Py::MemoryError(\"Could not allocate result array\");\n-            }\n-            double* const data = (double*)PyArray_DATA(pyarray);\n-            for (size_t i = 0; i < size; ++i)\n-            {\n-                data[2*i]   = (*p)[i].x;\n-                data[2*i+1] = (*p)[i].y;\n-            }\n-            data[2*size]   = (*p)[0].x;\n-            data[2*size+1] = (*p)[0].y;\n-\n-            if (PyList_SetItem(py_results, p - results.begin(), (PyObject *)pyarray) == -1)\n-            {\n-                throw Py::RuntimeError(\"Error creating results list\");\n-            }\n-        }\n-    }\n-    catch (...)\n-    {\n-        Py_XDECREF(py_results);\n-        throw;\n-    }\n-\n-    return Py::Object(py_results, true);\n-}\n-\n-Py::Object\n-_path_module::affine_transform(const Py::Tuple& args)\n-{\n-    args.verify_length(2);\n-\n-    Py::Object vertices_obj = args[0];\n-    Py::Object transform_obj = args[1];\n-\n-    PyArrayObject* vertices = NULL;\n-    PyArrayObject* transform = NULL;\n-    PyArrayObject* result = NULL;\n-\n-    try\n-    {\n-        vertices = (PyArrayObject*)PyArray_FromObject\n-                   (vertices_obj.ptr(), NPY_DOUBLE, 1, 2);\n-        if (!vertices ||\n-            (PyArray_NDIM(vertices) == 2 && PyArray_DIM(vertices, 0) != 0 &&\n-             PyArray_DIM(vertices, 1) != 2) ||\n-            (PyArray_NDIM(vertices) == 1 &&\n-             PyArray_DIM(vertices, 0) != 2 && PyArray_DIM(vertices, 0) != 0))\n-        {\n-            throw Py::ValueError(\"Invalid vertices array.\");\n-        }\n-\n-        transform = (PyArrayObject*) PyArray_FromObject\n-                    (transform_obj.ptr(), NPY_DOUBLE, 2, 2);\n-        if (!transform ||\n-            PyArray_DIM(transform, 0) != 3 ||\n-            PyArray_DIM(transform, 1) != 3)\n-        {\n-            throw Py::ValueError(\"Invalid transform.\");\n-        }\n-\n-        double a, b, c, d, e, f;\n-        {\n-            size_t stride0 = PyArray_STRIDE(transform, 0);\n-            size_t stride1 = PyArray_STRIDE(transform, 1);\n-            char* row0 = PyArray_BYTES(transform);\n-            char* row1 = row0 + stride0;\n-\n-            a = *(double*)(row0);\n-            row0 += stride1;\n-            c = *(double*)(row0);\n-            row0 += stride1;\n-            e = *(double*)(row0);\n-\n-            b = *(double*)(row1);\n-            row1 += stride1;\n-            d = *(double*)(row1);\n-            row1 += stride1;\n-            f = *(double*)(row1);\n-        }\n-\n-        result = (PyArrayObject*)PyArray_SimpleNew\n-                 (PyArray_NDIM(vertices), PyArray_DIMS(vertices), NPY_DOUBLE);\n-        if (result == NULL)\n-        {\n-            throw Py::MemoryError(\"Could not allocate memory for path\");\n-        }\n-        if (PyArray_NDIM(vertices) == 2)\n-        {\n-            size_t n = PyArray_DIM(vertices, 0);\n-            char* vertex_in = PyArray_BYTES(vertices);\n-            double* vertex_out = (double*)PyArray_DATA(result);\n-            size_t stride0 = PyArray_STRIDE(vertices, 0);\n-            size_t stride1 = PyArray_STRIDE(vertices, 1);\n-            double x;\n-            double y;\n-            volatile double t0;\n-\t    volatile double t1;\n-\t    volatile double t;\n-\n-            for (size_t i = 0; i < n; ++i)\n-            {\n-                x = *(double*)(vertex_in);\n-                y = *(double*)(vertex_in + stride1);\n-\n-\t\tt0 = a * x;\n-\t\tt1 = c * y;\n-                t = t0 + t1 + e;\n-                *(vertex_out++) = t;\n-\n-\t\tt0 = b * x;\n-\t\tt1 = d * y;\n-                t = t0 + t1 + f;\n-                *(vertex_out++) = t;\n-\n-                vertex_in += stride0;\n-            }\n-        }\n-        else if (PyArray_DIM(vertices, 0) != 0)\n-        {\n-            char* vertex_in = PyArray_BYTES(vertices);\n-            double* vertex_out = (double*)PyArray_DATA(result);\n-            size_t stride0 = PyArray_STRIDE(vertices, 0);\n-            double x;\n-            double y;\n-            x = *(double*)(vertex_in);\n-            y = *(double*)(vertex_in + stride0);\n-            *vertex_out++ = a * x + c * y + e;\n-            *vertex_out++ = b * x + d * y + f;\n-        }\n-    }\n-    catch (...)\n-    {\n-        Py_XDECREF(vertices);\n-        Py_XDECREF(transform);\n-        Py_XDECREF(result);\n-        throw;\n-    }\n-\n-    Py_XDECREF(vertices);\n-    Py_XDECREF(transform);\n-\n-    return Py::Object((PyObject*)result, true);\n-}\n-\n-Py::Object\n-_path_module::count_bboxes_overlapping_bbox(const Py::Tuple& args)\n-{\n-    args.verify_length(2);\n-\n-    Py::Object              bbox   = args[0];\n-    Py::SeqBase<Py::Object> bboxes = args[1];\n-\n-    double ax0, ay0, ax1, ay1;\n-    double bx0, by0, bx1, by1;\n-    long count = 0;\n-\n-    if (py_convert_bbox(bbox.ptr(), ax0, ay0, ax1, ay1))\n-    {\n-        if (ax1 < ax0)\n-        {\n-            std::swap(ax0, ax1);\n-        }\n-        if (ay1 < ay0)\n-        {\n-            std::swap(ay0, ay1);\n-        }\n-\n-        size_t num_bboxes = bboxes.size();\n-        for (size_t i = 0; i < num_bboxes; ++i)\n-        {\n-            Py::Object bbox_b = bboxes[i];\n-            if (py_convert_bbox(bbox_b.ptr(), bx0, by0, bx1, by1))\n-            {\n-                if (bx1 < bx0)\n-                {\n-                    std::swap(bx0, bx1);\n-                }\n-                if (by1 < by0)\n-                {\n-                    std::swap(by0, by1);\n-                }\n-                if (!((bx1 <= ax0) ||\n-                      (by1 <= ay0) ||\n-                      (bx0 >= ax1) ||\n-                      (by0 >= ay1)))\n-                {\n-                    ++count;\n-                }\n-            }\n-            else\n-            {\n-                throw Py::ValueError(\"Non-bbox object in bboxes list\");\n-            }\n-        }\n-    }\n-    else\n-    {\n-        throw Py::ValueError(\"First argument to count_bboxes_overlapping_bbox must be a Bbox object.\");\n-    }\n-\n-    return Py::Int(count);\n-}\n-\n-inline bool\n-segments_intersect(const double& x1, const double& y1,\n-                   const double& x2, const double& y2,\n-                   const double& x3, const double& y3,\n-                   const double& x4, const double& y4)\n-{\n-    double den = ((y4 - y3) * (x2 - x1)) - ((x4 - x3) * (y2 - y1));\n-    if (den == 0.0)\n-    {\n-        return false;\n-    }\n-\n-    double n1 = ((x4 - x3) * (y1 - y3)) - ((y4 - y3) * (x1 - x3));\n-    double n2 = ((x2 - x1) * (y1 - y3)) - ((y2 - y1) * (x1 - x3));\n-\n-    double u1 = n1 / den;\n-    double u2 = n2 / den;\n-\n-    return (u1 >= 0.0 && u1 <= 1.0 &&\n-            u2 >= 0.0 && u2 <= 1.0);\n-}\n-\n-bool\n-path_intersects_path(PathIterator& p1, PathIterator& p2)\n-{\n-    typedef PathNanRemover<PathIterator> no_nans_t;\n-    typedef agg::conv_curve<no_nans_t> curve_t;\n-\n-    if (p1.total_vertices() < 2 || p2.total_vertices() < 2)\n-    {\n-        return false;\n-    }\n-\n-    no_nans_t n1(p1, true, p1.has_curves());\n-    no_nans_t n2(p2, true, p2.has_curves());\n-\n-    curve_t c1(n1);\n-    curve_t c2(n2);\n-\n-    double x11, y11, x12, y12;\n-    double x21, y21, x22, y22;\n-\n-    c1.vertex(&x11, &y11);\n-    while (c1.vertex(&x12, &y12) != agg::path_cmd_stop)\n-    {\n-        c2.rewind(0);\n-        c2.vertex(&x21, &y21);\n-        while (c2.vertex(&x22, &y22) != agg::path_cmd_stop)\n-        {\n-            if (segments_intersect(x11, y11, x12, y12, x21, y21, x22, y22))\n-            {\n-                return true;\n-            }\n-            x21 = x22;\n-            y21 = y22;\n-        }\n-        x11 = x12;\n-        y11 = y12;\n-    }\n-\n-    return false;\n-}\n-\n-Py::Object\n-_path_module::path_intersects_path(const Py::Tuple& args)\n-{\n-    args.verify_length(2, 3);\n-\n-    PathIterator p1(args[0]);\n-    PathIterator p2(args[1]);\n-    bool filled = false;\n-\n-    if (args.size() == 3)\n-    {\n-        filled = args[2].isTrue();\n-    }\n-\n-    if (!filled)\n-    {\n-        return Py::Int(::path_intersects_path(p1, p2));\n-    }\n-    else\n-    {\n-        return Py::Int(::path_intersects_path(p1, p2)\n-                       || ::path_in_path(p1, agg::trans_affine(), p2, agg::trans_affine())\n-                       || ::path_in_path(p2, agg::trans_affine(), p1, agg::trans_affine()));\n-    }\n-}\n-\n-void\n-_add_polygon(Py::List& polygons, const std::vector<double>& polygon)\n-{\n-    if (polygon.size() == 0)\n-    {\n-        return;\n-    }\n-    npy_intp polygon_dims[] = { static_cast<npy_intp>(polygon.size() / 2), 2, 0 };\n-    PyArrayObject* polygon_array = NULL;\n-    polygon_array = (PyArrayObject*)PyArray_SimpleNew\n-                    (2, polygon_dims, NPY_DOUBLE);\n-    if (!polygon_array)\n-    {\n-        throw Py::MemoryError(\"Error creating polygon array\");\n-    }\n-    double* polygon_data = (double*)PyArray_DATA(polygon_array);\n-    memcpy(polygon_data, &polygon[0], polygon.size() * sizeof(double));\n-    polygons.append(Py::Object((PyObject*)polygon_array, true));\n-}\n-\n-Py::Object\n-_path_module::convert_path_to_polygons(const Py::Tuple& args)\n-{\n-    typedef agg::conv_transform<PathIterator>  transformed_path_t;\n-    typedef PathNanRemover<transformed_path_t> nan_removal_t;\n-    typedef PathClipper<nan_removal_t>         clipped_t;\n-    typedef PathSimplifier<clipped_t>          simplify_t;\n-    typedef agg::conv_curve<simplify_t>        curve_t;\n-\n-    typedef std::vector<double> vertices_t;\n-\n-    args.verify_length(4);\n-\n-    PathIterator path(args[0]);\n-    agg::trans_affine trans = py_to_agg_transformation_matrix(args[1].ptr(), false);\n-    double width = Py::Float(args[2]);\n-    double height = Py::Float(args[3]);\n-\n-    bool do_clip = width != 0.0 && height != 0.0;\n-\n-    bool simplify = path.should_simplify();\n-\n-    transformed_path_t tpath(path, trans);\n-    nan_removal_t      nan_removed(tpath, true, path.has_curves());\n-    clipped_t          clipped(nan_removed, do_clip, width, height);\n-    simplify_t         simplified(clipped, simplify, path.simplify_threshold());\n-    curve_t            curve(simplified);\n-\n-    Py::List polygons;\n-    vertices_t polygon;\n-    double x, y;\n-    unsigned code;\n-\n-    polygon.reserve(path.total_vertices() * 2);\n-\n-    while ((code = curve.vertex(&x, &y)) != agg::path_cmd_stop)\n-    {\n-        if ((code & agg::path_cmd_end_poly) == agg::path_cmd_end_poly)\n-        {\n-            if (polygon.size() >= 2)\n-            {\n-                polygon.push_back(polygon[0]);\n-                polygon.push_back(polygon[1]);\n-                _add_polygon(polygons, polygon);\n-            }\n-            polygon.clear();\n-        }\n-        else\n-        {\n-            if (code == agg::path_cmd_move_to)\n-            {\n-                _add_polygon(polygons, polygon);\n-                polygon.clear();\n-            }\n-            polygon.push_back(x);\n-            polygon.push_back(y);\n-        }\n-    }\n-\n-    _add_polygon(polygons, polygon);\n-\n-    return polygons;\n-}\n-\n-template<class VertexSource>\n-void\n-__cleanup_path(VertexSource& source,\n-               std::vector<double>& vertices,\n-               std::vector<npy_uint8>& codes)\n-{\n-    unsigned code;\n-    double x, y;\n-    do\n-    {\n-        code = source.vertex(&x, &y);\n-        vertices.push_back(x);\n-        vertices.push_back(y);\n-        codes.push_back((npy_uint8)code);\n-    }\n-    while (code != agg::path_cmd_stop);\n-}\n-\n-void\n-_cleanup_path(PathIterator& path, const agg::trans_affine& trans,\n-              bool remove_nans, bool do_clip,\n-              const agg::rect_base<double>& rect,\n-              e_snap_mode snap_mode, double stroke_width,\n-              bool do_simplify, bool return_curves,\n-              double sketch_scale, double sketch_length,\n-              double sketch_randomness,\n-              std::vector<double>& vertices,\n-              std::vector<npy_uint8>& codes)\n-{\n-    typedef agg::conv_transform<PathIterator>  transformed_path_t;\n-    typedef PathNanRemover<transformed_path_t> nan_removal_t;\n-    typedef PathClipper<nan_removal_t>         clipped_t;\n-    typedef PathSnapper<clipped_t>             snapped_t;\n-    typedef PathSimplifier<snapped_t>          simplify_t;\n-    typedef agg::conv_curve<simplify_t>        curve_t;\n-    typedef Sketch<curve_t>                    sketch_t;\n-\n-    transformed_path_t tpath(path, trans);\n-    nan_removal_t      nan_removed(tpath, remove_nans, path.has_curves());\n-    clipped_t          clipped(nan_removed, do_clip, rect);\n-    snapped_t          snapped(clipped, snap_mode, path.total_vertices(), stroke_width);\n-    simplify_t         simplified(snapped, do_simplify, path.simplify_threshold());\n-\n-    vertices.reserve(path.total_vertices() * 2);\n-    codes.reserve(path.total_vertices());\n-\n-    if (return_curves && sketch_scale == 0.0)\n-    {\n-        __cleanup_path(simplified, vertices, codes);\n-    }\n-    else\n-    {\n-        curve_t curve(simplified);\n-        sketch_t sketch(curve, sketch_scale, sketch_length, sketch_randomness);\n-        __cleanup_path(sketch, vertices, codes);\n-    }\n-}\n-\n-Py::Object\n-_path_module::cleanup_path(const Py::Tuple& args)\n-{\n-    args.verify_length(9);\n-\n-    PathIterator path(args[0]);\n-    agg::trans_affine trans = py_to_agg_transformation_matrix(args[1].ptr(), false);\n-    bool remove_nans = args[2].isTrue();\n-\n-    Py::Object clip_obj = args[3];\n-    bool do_clip;\n-    agg::rect_base<double> clip_rect;\n-    if (clip_obj.isNone())\n-    {\n-        do_clip = false;\n-    }\n-    else\n-    {\n-        double x1, y1, x2, y2;\n-        Py::Tuple clip_tuple(clip_obj);\n-        x1 = Py::Float(clip_tuple[0]);\n-        y1 = Py::Float(clip_tuple[1]);\n-        x2 = Py::Float(clip_tuple[2]);\n-        y2 = Py::Float(clip_tuple[3]);\n-        clip_rect.init(x1, y1, x2, y2);\n-        do_clip = true;\n-    }\n-\n-    Py::Object snap_obj = args[4];\n-    e_snap_mode snap_mode;\n-    if (snap_obj.isNone())\n-    {\n-        snap_mode = SNAP_AUTO;\n-    }\n-    else if (snap_obj.isTrue())\n-    {\n-        snap_mode = SNAP_TRUE;\n-    }\n-    else\n-    {\n-        snap_mode = SNAP_FALSE;\n-    }\n-\n-    double stroke_width = Py::Float(args[5]);\n-\n-    bool simplify;\n-    Py::Object simplify_obj = args[6];\n-    if (simplify_obj.isNone())\n-    {\n-        simplify = path.should_simplify();\n-    }\n-    else\n-    {\n-        simplify = simplify_obj.isTrue();\n-    }\n-\n-    bool return_curves = args[7].isTrue();\n-\n-    Py::Object sketch_params = args[8];\n-    double sketch_scale = 0.0;\n-    double sketch_length = 0.0;\n-    double sketch_randomness = 0.0;\n-    if (sketch_params.ptr() != Py_None) {\n-        Py::Tuple sketch(sketch_params);\n-        sketch_scale = Py::Float(sketch[0]);\n-        sketch_length = Py::Float(sketch[1]);\n-        sketch_randomness = Py::Float(sketch[2]);\n-    }\n-\n-    std::vector<double> vertices;\n-    std::vector<npy_uint8> codes;\n-\n-    _cleanup_path(path, trans, remove_nans, do_clip, clip_rect, snap_mode,\n-                  stroke_width, simplify, return_curves, sketch_scale,\n-                  sketch_length, sketch_randomness, vertices, codes);\n-\n-    npy_intp length = codes.size();\n-    npy_intp dims[] = { length, 2, 0 };\n-\n-    PyArrayObject* vertices_obj = NULL;\n-    PyArrayObject* codes_obj = NULL;\n-    Py::Tuple result(2);\n-    try\n-    {\n-        vertices_obj = (PyArrayObject*)PyArray_SimpleNew\n-                       (2, dims, NPY_DOUBLE);\n-        if (vertices_obj == NULL)\n-        {\n-            throw Py::MemoryError(\"Could not allocate result array\");\n-        }\n-\n-        codes_obj = (PyArrayObject*)PyArray_SimpleNew\n-                    (1, dims, NPY_UINT8);\n-        if (codes_obj == NULL)\n-        {\n-            throw Py::MemoryError(\"Could not allocate result array\");\n-        }\n-\n-        memcpy(PyArray_DATA(vertices_obj), &vertices[0], sizeof(double) * 2 * length);\n-        memcpy(PyArray_DATA(codes_obj), &codes[0], sizeof(npy_uint8) * length);\n-\n-        result[0] = Py::Object((PyObject*)vertices_obj, true);\n-        result[1] = Py::Object((PyObject*)codes_obj, true);\n-    }\n-    catch (...)\n-    {\n-        Py_XDECREF(vertices_obj);\n-        Py_XDECREF(codes_obj);\n-        throw;\n-    }\n-\n-    return result;\n-}\n-\n-Py::Object\n-_path_module::convert_to_svg(const Py::Tuple& args)\n-{\n-    args.verify_length(5);\n-\n-    PathIterator path(args[0]);\n-    agg::trans_affine trans = py_to_agg_transformation_matrix(args[1].ptr(), false);\n-\n-    Py::Object clip_obj = args[2];\n-    bool do_clip;\n-    agg::rect_base<double> clip_rect(0, 0, 0, 0);\n-    if (clip_obj.isNone() || !clip_obj.isTrue())\n-    {\n-        do_clip = false;\n-    }\n-    else\n-    {\n-        double x1, y1, x2, y2;\n-        Py::Tuple clip_tuple(clip_obj);\n-        x1 = Py::Float(clip_tuple[0]);\n-        y1 = Py::Float(clip_tuple[1]);\n-        x2 = Py::Float(clip_tuple[2]);\n-        y2 = Py::Float(clip_tuple[3]);\n-        clip_rect.init(x1, y1, x2, y2);\n-        do_clip = true;\n-    }\n-\n-    bool simplify;\n-    Py::Object simplify_obj = args[3];\n-    if (simplify_obj.isNone())\n-    {\n-        simplify = path.should_simplify();\n-    }\n-    else\n-    {\n-        simplify = simplify_obj.isTrue();\n-    }\n-\n-    int precision = Py::Int(args[4]);\n-\n-    #if PY_VERSION_HEX < 0x02070000\n-    char format[64];\n-    snprintf(format, 64, \"%s.%dg\", \"%\", precision);\n-    #endif\n-\n-    typedef agg::conv_transform<PathIterator>  transformed_path_t;\n-    typedef PathNanRemover<transformed_path_t> nan_removal_t;\n-    typedef PathClipper<nan_removal_t>         clipped_t;\n-    typedef PathSimplifier<clipped_t>          simplify_t;\n-\n-    transformed_path_t tpath(path, trans);\n-    nan_removal_t      nan_removed(tpath, true, path.has_curves());\n-    clipped_t          clipped(nan_removed, do_clip, clip_rect);\n-    simplify_t         simplified(clipped, simplify, path.simplify_threshold());\n-\n-    size_t buffersize = path.total_vertices() * (precision + 5) * 4;\n-    char* buffer = (char *)malloc(buffersize);\n-    char* p = buffer;\n-\n-    const char codes[] = {'M', 'L', 'Q', 'C'};\n-    const int  waits[] = {  1,   1,   2,   3};\n-\n-    int wait = 0;\n-    unsigned code;\n-    double x = 0, y = 0;\n-    while ((code = simplified.vertex(&x, &y)) != agg::path_cmd_stop)\n-    {\n-        if (wait == 0)\n-        {\n-            *p++ = '\\n';\n-\n-            if (code == 0x4f)\n-            {\n-                *p++ = 'z';\n-                *p++ = '\\n';\n-                continue;\n-            }\n-\n-            *p++ = codes[code-1];\n-            wait = waits[code-1];\n-        }\n-        else\n-        {\n-            *p++ = ' ';\n-        }\n-\n-        #if PY_VERSION_HEX >= 0x02070000\n-        char* str;\n-        str = PyOS_double_to_string(x, 'g', precision, 0, NULL);\n-        p += snprintf(p, buffersize - (p - buffer), \"%s\", str);\n-        PyMem_Free(str);\n-        *p++ = ' ';\n-        str = PyOS_double_to_string(y, 'g', precision, 0, NULL);\n-        p += snprintf(p, buffersize - (p - buffer), \"%s\", str);\n-        PyMem_Free(str);\n-        #else\n-        char str[64];\n-        PyOS_ascii_formatd(str, 64, format, x);\n-        p += snprintf(p, buffersize - (p - buffer), \"%s\", str);\n-        *p++ = ' ';\n-        PyOS_ascii_formatd(str, 64, format, y);\n-        p += snprintf(p, buffersize - (p - buffer), \"%s\", str);\n-        #endif\n-\n-        --wait;\n-    }\n-\n-    #if PY3K\n-    PyObject* result = PyUnicode_FromStringAndSize(buffer, p - buffer);\n-    #else\n-    PyObject* result = PyString_FromStringAndSize(buffer, p - buffer);\n-    #endif\n-    free(buffer);\n-\n-    return Py::Object(result, true);\n-}\n-\n-PyMODINIT_FUNC\n-#if PY3K\n-PyInit__path(void)\n-#else\n-init_path(void)\n-#endif\n-{\n-    static _path_module* _path = NULL;\n-    _path = new _path_module;\n-\n-    import_array();\n-\n-    #if PY3K\n-    return _path->module().ptr();\n-    #endif\n-}"
            },
            {
                "sha": "77ab85eb52f99b3ce6debbbaaaa3798ab29122d8",
                "filename": "src/_path.h",
                "status": "added",
                "additions": 978,
                "deletions": 0,
                "changes": 978,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_path.h",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_path.h",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/src%2F_path.h?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787",
                "patch": "@@ -0,0 +1,978 @@\n+/* -*- mode: c++; c-basic-offset: 4 -*- */\n+\n+#ifndef __PATH_H__\n+#define __PATH_H__\n+\n+#include <limits>\n+#include <math.h>\n+#include <vector>\n+\n+#include \"agg_conv_contour.h\"\n+#include \"agg_conv_curve.h\"\n+#include \"agg_conv_stroke.h\"\n+#include \"agg_conv_transform.h\"\n+#include \"agg_path_storage.h\"\n+#include \"agg_trans_affine.h\"\n+\n+#include \"path_converters.h\"\n+#include \"_backend_agg_basic_types.h\"\n+\n+struct XY\n+{\n+    double x;\n+    double y;\n+\n+    XY(double x_, double y_) : x(x_), y(y_)\n+    {\n+    }\n+};\n+\n+//\n+// The following function was found in the Agg 2.3 examples (interactive_polygon.cpp).\n+// It has been generalized to work on (possibly curved) polylines, rather than\n+// just polygons.  The original comments have been kept intact.\n+//  -- Michael Droettboom 2007-10-02\n+//\n+//======= Crossings Multiply algorithm of InsideTest ========================\n+//\n+// By Eric Haines, 3D/Eye Inc, erich@eye.com\n+//\n+// This version is usually somewhat faster than the original published in\n+// Graphics Gems IV; by turning the division for testing the X axis crossing\n+// into a tricky multiplication test this part of the test became faster,\n+// which had the additional effect of making the test for \"both to left or\n+// both to right\" a bit slower for triangles than simply computing the\n+// intersection each time.  The main increase is in triangle testing speed,\n+// which was about 15% faster; all other polygon complexities were pretty much\n+// the same as before.  On machines where division is very expensive (not the\n+// case on the HP 9000 series on which I tested) this test should be much\n+// faster overall than the old code.  Your mileage may (in fact, will) vary,\n+// depending on the machine and the test data, but in general I believe this\n+// code is both shorter and faster.  This test was inspired by unpublished\n+// Graphics Gems submitted by Joseph Samosky and Mark Haigh-Hutchinson.\n+// Related work by Samosky is in:\n+//\n+// Samosky, Joseph, \"SectionView: A system for interactively specifying and\n+// visualizing sections through three-dimensional medical image data\",\n+// M.S. Thesis, Department of Electrical Engineering and Computer Science,\n+// Massachusetts Institute of Technology, 1993.\n+//\n+// Shoot a test ray along +X axis.  The strategy is to compare vertex Y values\n+// to the testing point's Y and quickly discard edges which are entirely to one\n+// side of the test ray.  Note that CONVEX and WINDING code can be added as\n+// for the CrossingsTest() code; it is left out here for clarity.\n+//\n+// Input 2D polygon _pgon_ with _numverts_ number of vertices and test point\n+// _point_, returns 1 if inside, 0 if outside.\n+template <class PathIterator, class PointArray, class ResultArray>\n+void point_in_path_impl(PointArray &points, PathIterator &path, ResultArray &inside_flag)\n+{\n+    int yflag1;\n+    double vtx0, vty0, vtx1, vty1;\n+    double tx, ty;\n+    double sx, sy;\n+    double x, y;\n+    size_t i;\n+    bool all_done;\n+\n+    size_t n = points.size();\n+\n+    std::vector<int> yflag0(n);\n+    std::vector<int> subpath_flag(n);\n+\n+    path.rewind(0);\n+\n+    for (i = 0; i < n; ++i) {\n+        inside_flag[i] = 0;\n+    }\n+\n+    unsigned code = 0;\n+    do {\n+        if (code != agg::path_cmd_move_to) {\n+            code = path.vertex(&x, &y);\n+            if (code == agg::path_cmd_stop ||\n+                (code & agg::path_cmd_end_poly) == agg::path_cmd_end_poly) {\n+                continue;\n+            }\n+        }\n+\n+        sx = vtx0 = vtx1 = x;\n+        sy = vty0 = vty1 = y;\n+\n+        for (i = 0; i < n; ++i) {\n+            ty = points[i][1];\n+\n+            // get test bit for above/below X axis\n+            yflag0[i] = (vty0 >= ty);\n+\n+            subpath_flag[i] = 0;\n+        }\n+\n+        do {\n+            code = path.vertex(&x, &y);\n+\n+            // The following cases denote the beginning on a new subpath\n+            if (code == agg::path_cmd_stop ||\n+                (code & agg::path_cmd_end_poly) == agg::path_cmd_end_poly) {\n+                x = sx;\n+                y = sy;\n+            } else if (code == agg::path_cmd_move_to) {\n+                break;\n+            }\n+\n+            for (i = 0; i < n; ++i) {\n+                tx = points[i][0];\n+                ty = points[i][1];\n+\n+                yflag1 = (vty1 >= ty);\n+                // Check if endpoints straddle (are on opposite sides) of\n+                // X axis (i.e. the Y's differ); if so, +X ray could\n+                // intersect this edge.  The old test also checked whether\n+                // the endpoints are both to the right or to the left of\n+                // the test point.  However, given the faster intersection\n+                // point computation used below, this test was found to be\n+                // a break-even proposition for most polygons and a loser\n+                // for triangles (where 50% or more of the edges which\n+                // survive this test will cross quadrants and so have to\n+                // have the X intersection computed anyway).  I credit\n+                // Joseph Samosky with inspiring me to try dropping the\n+                // \"both left or both right\" part of my code.\n+                if (yflag0[i] != yflag1) {\n+                    // Check intersection of pgon segment with +X ray.\n+                    // Note if >= point's X; if so, the ray hits it.  The\n+                    // division operation is avoided for the \">=\" test by\n+                    // checking the sign of the first vertex wrto the test\n+                    // point; idea inspired by Joseph Samosky's and Mark\n+                    // Haigh-Hutchinson's different polygon inclusion\n+                    // tests.\n+                    if (((vty1 - ty) * (vtx0 - vtx1) >= (vtx1 - tx) * (vty0 - vty1)) == yflag1) {\n+                        subpath_flag[i] ^= 1;\n+                    }\n+                }\n+\n+                // Move to the next pair of vertices, retaining info as\n+                // possible.\n+                yflag0[i] = yflag1;\n+            }\n+\n+            vtx0 = vtx1;\n+            vty0 = vty1;\n+\n+            vtx1 = x;\n+            vty1 = y;\n+        } while (code != agg::path_cmd_stop &&\n+                 (code & agg::path_cmd_end_poly) != agg::path_cmd_end_poly);\n+\n+        all_done = true;\n+        for (i = 0; i < n; ++i) {\n+            tx = points[i][0];\n+            ty = points[i][1];\n+\n+            yflag1 = (vty1 >= ty);\n+            if (yflag0[i] != yflag1) {\n+                if (((vty1 - ty) * (vtx0 - vtx1) >= (vtx1 - tx) * (vty0 - vty1)) == yflag1) {\n+                    subpath_flag[i] ^= 1;\n+                }\n+            }\n+            inside_flag[i] |= subpath_flag[i];\n+            if (inside_flag[i] == 0) {\n+                all_done = false;\n+            }\n+        }\n+\n+        if (all_done) {\n+            break;\n+        }\n+    } while (code != agg::path_cmd_stop);\n+}\n+\n+template <class PathIterator, class PointArray, class ResultArray>\n+inline void points_in_path(PointArray &points,\n+                           const double r,\n+                           PathIterator &path,\n+                           const agg::trans_affine &trans,\n+                           ResultArray &result)\n+{\n+    typedef agg::conv_transform<PathIterator> transformed_path_t;\n+    typedef PathNanRemover<transformed_path_t> no_nans_t;\n+    typedef agg::conv_curve<no_nans_t> curve_t;\n+    typedef agg::conv_contour<curve_t> contour_t;\n+\n+    size_t i;\n+    for (i = 0; i < result.size(); ++i) {\n+        result[i] = 0;\n+    }\n+\n+    if (path.total_vertices() < 3) {\n+        return;\n+    }\n+\n+    transformed_path_t trans_path(path, trans);\n+    no_nans_t no_nans_path(trans_path, true, path.has_curves());\n+    curve_t curved_path(no_nans_path);\n+    contour_t contoured_path(curved_path);\n+    contoured_path.width(r);\n+\n+    point_in_path_impl(points, contoured_path, result);\n+}\n+\n+template <class PathIterator>\n+inline bool point_in_path(\n+    double x, double y, const double r, PathIterator &path, const agg::trans_affine &trans)\n+{\n+    std::vector<double> point;\n+    std::vector<std::vector<double> > points;\n+    point.push_back(x);\n+    point.push_back(y);\n+    points.push_back(point);\n+\n+    std::vector<uint8_t> result(1);\n+    result[0] = 0;\n+\n+    points_in_path(points, r, path, trans, result);\n+\n+    return (bool)result[0];\n+}\n+\n+template <class PathIterator, class PointArray, class ResultArray>\n+void points_on_path(PointArray &points,\n+                    const double r,\n+                    PathIterator &path,\n+                    const agg::trans_affine &trans,\n+                    ResultArray result)\n+{\n+    typedef agg::conv_transform<PathIterator> transformed_path_t;\n+    typedef PathNanRemover<transformed_path_t> no_nans_t;\n+    typedef agg::conv_curve<no_nans_t> curve_t;\n+    typedef agg::conv_stroke<curve_t> stroke_t;\n+\n+    size_t i;\n+    for (i = 0; i < result.size(); ++i) {\n+        result[i] = 0;\n+    }\n+\n+    transformed_path_t trans_path(path, trans);\n+    no_nans_t nan_removed_path(trans_path, true, path.has_curves());\n+    curve_t curved_path(nan_removed_path);\n+    stroke_t stroked_path(curved_path);\n+    stroked_path.width(r * 2.0);\n+    point_in_path_impl(points, stroked_path, result);\n+}\n+\n+template <class PathIterator>\n+inline bool point_on_path(\n+    double x, double y, const double r, PathIterator &path, const agg::trans_affine &trans)\n+{\n+    std::vector<double> point;\n+    std::vector<std::vector<double> > points;\n+    point.push_back(x);\n+    point.push_back(y);\n+    points.push_back(point);\n+\n+    std::vector<uint8_t> result(1);\n+    result[0] = 0;\n+\n+    points_on_path(points, r, path, trans, result);\n+\n+    return (bool)result[0];\n+}\n+\n+struct extent_limits\n+{\n+    double x0;\n+    double y0;\n+    double x1;\n+    double y1;\n+    double xm;\n+    double ym;\n+};\n+\n+void reset_limits(extent_limits &e)\n+{\n+    e.x0 = std::numeric_limits<double>::infinity();\n+    e.y0 = std::numeric_limits<double>::infinity();\n+    e.x1 = -std::numeric_limits<double>::infinity();\n+    e.y1 = -std::numeric_limits<double>::infinity();\n+    /* xm and ym are the minimum positive values in the data, used\n+       by log scaling */\n+    e.xm = std::numeric_limits<double>::infinity();\n+    e.ym = std::numeric_limits<double>::infinity();\n+}\n+\n+inline void update_limits(double x, double y, extent_limits &e)\n+{\n+    if (x < e.x0)\n+        e.x0 = x;\n+    if (y < e.y0)\n+        e.y0 = y;\n+    if (x > e.x1)\n+        e.x1 = x;\n+    if (y > e.y1)\n+        e.y1 = y;\n+    /* xm and ym are the minimum positive values in the data, used\n+       by log scaling */\n+    if (x > 0.0 && x < e.xm)\n+        e.xm = x;\n+    if (y > 0.0 && y < e.ym)\n+        e.ym = y;\n+}\n+\n+template <class PathIterator>\n+void update_path_extents(PathIterator &path, const agg::trans_affine &trans, extent_limits &extents)\n+{\n+    typedef agg::conv_transform<PathIterator> transformed_path_t;\n+    typedef PathNanRemover<transformed_path_t> nan_removed_t;\n+    double x, y;\n+    unsigned code;\n+\n+    transformed_path_t tpath(path, trans);\n+    nan_removed_t nan_removed(tpath, true, path.has_curves());\n+\n+    nan_removed.rewind(0);\n+\n+    while ((code = nan_removed.vertex(&x, &y)) != agg::path_cmd_stop) {\n+        if ((code & agg::path_cmd_end_poly) == agg::path_cmd_end_poly) {\n+            continue;\n+        }\n+        update_limits(x, y, extents);\n+    }\n+}\n+\n+template <class PathGenerator, class TransformArray, class OffsetArray>\n+void get_path_collection_extents(agg::trans_affine &master_transform,\n+                                 PathGenerator &paths,\n+                                 TransformArray &transforms,\n+                                 OffsetArray &offsets,\n+                                 agg::trans_affine &offset_trans,\n+                                 extent_limits &extent)\n+{\n+    if (offsets.dim(0) != 0 && offsets.dim(1) != 2) {\n+        throw \"Offsets array must be Nx2\";\n+    }\n+\n+    size_t Npaths = paths.size();\n+    size_t Noffsets = offsets.size();\n+    size_t N = std::max(Npaths, Noffsets);\n+    size_t Ntransforms = std::min(transforms.size(), N);\n+    size_t i;\n+\n+    agg::trans_affine trans;\n+\n+    reset_limits(extent);\n+\n+    for (i = 0; i < N; ++i) {\n+        typename PathGenerator::path_iterator path(paths(i % Npaths));\n+        if (Ntransforms) {\n+            typename TransformArray::sub_t subtrans = transforms[i % Ntransforms];\n+            trans = agg::trans_affine(subtrans(0, 0),\n+                                      subtrans(1, 0),\n+                                      subtrans(0, 1),\n+                                      subtrans(1, 1),\n+                                      subtrans(0, 2),\n+                                      subtrans(1, 2));\n+        } else {\n+            trans = master_transform;\n+        }\n+\n+        if (Noffsets) {\n+            double xo = offsets(i % Noffsets, 0);\n+            double yo = offsets(i % Noffsets, 1);\n+            offset_trans.transform(&xo, &yo);\n+            trans *= agg::trans_affine_translation(xo, yo);\n+        }\n+\n+        update_path_extents(path, trans, extent);\n+    }\n+}\n+\n+template <class PathGenerator, class TransformArray, class OffsetArray>\n+void point_in_path_collection(double x,\n+                              double y,\n+                              double radius,\n+                              agg::trans_affine &master_transform,\n+                              PathGenerator &paths,\n+                              TransformArray &transforms,\n+                              OffsetArray &offsets,\n+                              agg::trans_affine &offset_trans,\n+                              bool filled,\n+                              e_offset_position offset_position,\n+                              std::vector<size_t> &result)\n+{\n+    size_t Npaths = paths.size();\n+\n+    if (Npaths == 0) {\n+        return;\n+    }\n+\n+    size_t Noffsets = offsets.dim(0);\n+    size_t N = std::max(Npaths, Noffsets);\n+    size_t Ntransforms = std::min(transforms.size(), N);\n+    size_t i;\n+\n+    agg::trans_affine trans;\n+\n+    for (i = 0; i < N; ++i) {\n+        typename PathGenerator::path_iterator path = paths(i % Npaths);\n+\n+        if (Ntransforms) {\n+            typename TransformArray::sub_t subtrans = transforms[i % Ntransforms];\n+            trans = agg::trans_affine(subtrans(0, 0),\n+                                      subtrans(1, 0),\n+                                      subtrans(0, 1),\n+                                      subtrans(1, 1),\n+                                      subtrans(0, 2),\n+                                      subtrans(1, 2));\n+        } else {\n+            trans = master_transform;\n+        }\n+\n+        if (Noffsets) {\n+            double xo = offsets(i % Noffsets, 0);\n+            double yo = offsets(i % Noffsets, 1);\n+            offset_trans.transform(&xo, &yo);\n+            if (offset_position == OFFSET_POSITION_DATA) {\n+                trans = agg::trans_affine_translation(xo, yo) * trans;\n+            } else {\n+                trans *= agg::trans_affine_translation(xo, yo);\n+            }\n+        }\n+\n+        if (filled) {\n+            if (point_in_path(x, y, radius, path, trans)) {\n+                result.push_back(i);\n+            }\n+        } else {\n+            if (point_on_path(x, y, radius, path, trans))\n+                result.push_back(i);\n+        }\n+    }\n+}\n+\n+template <class PathIterator1, class PathIterator2>\n+bool path_in_path(PathIterator1 &a,\n+                  const agg::trans_affine &atrans,\n+                  PathIterator2 &b,\n+                  const agg::trans_affine &btrans)\n+{\n+    typedef agg::conv_transform<PathIterator2> transformed_path_t;\n+    typedef PathNanRemover<transformed_path_t> no_nans_t;\n+    typedef agg::conv_curve<no_nans_t> curve_t;\n+\n+    if (a.total_vertices() < 3) {\n+        return false;\n+    }\n+\n+    transformed_path_t b_path_trans(b, btrans);\n+    no_nans_t b_no_nans(b_path_trans, true, b.has_curves());\n+    curve_t b_curved(b_no_nans);\n+\n+    double x, y;\n+    b_curved.rewind(0);\n+    while (b_curved.vertex(&x, &y) != agg::path_cmd_stop) {\n+        if (!point_in_path(x, y, 0.0, a, atrans)) {\n+            return false;\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+/** The clip_path_to_rect code here is a clean-room implementation of\n+    the Sutherland-Hodgman clipping algorithm described here:\n+\n+  http://en.wikipedia.org/wiki/Sutherland-Hodgman_clipping_algorithm\n+*/\n+\n+typedef std::vector<XY> Polygon;\n+\n+namespace clip_to_rect_filters\n+{\n+/* There are four different passes needed to create/remove\n+   vertices (one for each side of the rectangle).  The differences\n+   between those passes are encapsulated in these functor classes.\n+*/\n+struct bisectx\n+{\n+    double m_x;\n+\n+    bisectx(double x) : m_x(x)\n+    {\n+    }\n+\n+    inline void bisect(double sx, double sy, double px, double py, double *bx, double *by) const\n+    {\n+        *bx = m_x;\n+        double dx = px - sx;\n+        double dy = py - sy;\n+        *by = sy + dy * ((m_x - sx) / dx);\n+    }\n+};\n+\n+struct xlt : public bisectx\n+{\n+    xlt(double x) : bisectx(x)\n+    {\n+    }\n+\n+    inline bool is_inside(double x, double y) const\n+    {\n+        return x <= m_x;\n+    }\n+};\n+\n+struct xgt : public bisectx\n+{\n+    xgt(double x) : bisectx(x)\n+    {\n+    }\n+\n+    inline bool is_inside(double x, double y) const\n+    {\n+        return x >= m_x;\n+    }\n+};\n+\n+struct bisecty\n+{\n+    double m_y;\n+\n+    bisecty(double y) : m_y(y)\n+    {\n+    }\n+\n+    inline void bisect(double sx, double sy, double px, double py, double *bx, double *by) const\n+    {\n+        *by = m_y;\n+        double dx = px - sx;\n+        double dy = py - sy;\n+        *bx = sx + dx * ((m_y - sy) / dy);\n+    }\n+};\n+\n+struct ylt : public bisecty\n+{\n+    ylt(double y) : bisecty(y)\n+    {\n+    }\n+\n+    inline bool is_inside(double x, double y) const\n+    {\n+        return y <= m_y;\n+    }\n+};\n+\n+struct ygt : public bisecty\n+{\n+    ygt(double y) : bisecty(y)\n+    {\n+    }\n+\n+    inline bool is_inside(double x, double y) const\n+    {\n+        return y >= m_y;\n+    }\n+};\n+}\n+\n+template <class Filter>\n+inline void clip_to_rect_one_step(const Polygon &polygon, Polygon &result, const Filter &filter)\n+{\n+    double sx, sy, px, py, bx, by;\n+    bool sinside, pinside;\n+    result.clear();\n+\n+    if (polygon.size() == 0) {\n+        return;\n+    }\n+\n+    sx = polygon.back().x;\n+    sy = polygon.back().y;\n+    for (Polygon::const_iterator i = polygon.begin(); i != polygon.end(); ++i) {\n+        px = i->x;\n+        py = i->y;\n+\n+        sinside = filter.is_inside(sx, sy);\n+        pinside = filter.is_inside(px, py);\n+\n+        if (sinside ^ pinside) {\n+            filter.bisect(sx, sy, px, py, &bx, &by);\n+            result.push_back(XY(bx, by));\n+        }\n+\n+        if (pinside) {\n+            result.push_back(XY(px, py));\n+        }\n+\n+        sx = px;\n+        sy = py;\n+    }\n+}\n+\n+template <class PathIterator>\n+void\n+clip_path_to_rect(PathIterator &path, agg::rect_d &rect, bool inside, std::vector<Polygon> &results)\n+{\n+    double xmin, ymin, xmax, ymax;\n+    if (rect.x1 < rect.x2) {\n+        xmin = rect.x1;\n+        xmax = rect.x2;\n+    } else {\n+        xmin = rect.x2;\n+        xmax = rect.x1;\n+    }\n+\n+    if (rect.y1 < rect.y2) {\n+        ymin = rect.y1;\n+        ymax = rect.y2;\n+    } else {\n+        ymin = rect.y2;\n+        ymax = rect.y1;\n+    }\n+\n+    if (!inside) {\n+        std::swap(xmin, xmax);\n+        std::swap(ymin, ymax);\n+    }\n+\n+    typedef agg::conv_curve<PathIterator> curve_t;\n+    curve_t curve(path);\n+\n+    Polygon polygon1, polygon2;\n+    double x = 0, y = 0;\n+    unsigned code = 0;\n+    curve.rewind(0);\n+\n+    do {\n+        // Grab the next subpath and store it in polygon1\n+        polygon1.clear();\n+        do {\n+            if (code == agg::path_cmd_move_to) {\n+                polygon1.push_back(XY(x, y));\n+            }\n+\n+            code = curve.vertex(&x, &y);\n+\n+            if (code == agg::path_cmd_stop) {\n+                break;\n+            }\n+\n+            if (code != agg::path_cmd_move_to) {\n+                polygon1.push_back(XY(x, y));\n+            }\n+        } while ((code & agg::path_cmd_end_poly) != agg::path_cmd_end_poly);\n+\n+        // The result of each step is fed into the next (note the\n+        // swapping of polygon1 and polygon2 at each step).\n+        clip_to_rect_one_step(polygon1, polygon2, clip_to_rect_filters::xlt(xmax));\n+        clip_to_rect_one_step(polygon2, polygon1, clip_to_rect_filters::xgt(xmin));\n+        clip_to_rect_one_step(polygon1, polygon2, clip_to_rect_filters::ylt(ymax));\n+        clip_to_rect_one_step(polygon2, polygon1, clip_to_rect_filters::ygt(ymin));\n+\n+        // Empty polygons aren't very useful, so skip them\n+        if (polygon1.size()) {\n+            results.push_back(polygon1);\n+        }\n+    } while (code != agg::path_cmd_stop);\n+}\n+\n+template <class VerticesArray, class ResultArray>\n+void affine_transform(VerticesArray &vertices, agg::trans_affine &trans, ResultArray &result)\n+{\n+    if (vertices.dim(0) != 0 && vertices.dim(1) != 2) {\n+        throw \"Invalid vertices array.\";\n+    }\n+\n+    size_t n = vertices.dim(0);\n+    double x;\n+    double y;\n+    double t0;\n+    double t1;\n+    double t;\n+\n+    for (size_t i = 0; i < n; ++i) {\n+        x = vertices(i, 0);\n+        y = vertices(i, 1);\n+\n+        t0 = trans.sx * x;\n+        t1 = trans.shx * y;\n+        t = t0 + t1 + trans.tx;\n+        result(i, 0) = t;\n+\n+        t0 = trans.shy * x;\n+        t1 = trans.sy * y;\n+        t = t0 + t1 + trans.ty;\n+        result(i, 1) = t;\n+    }\n+}\n+\n+template <class BBoxArray>\n+int count_bboxes_overlapping_bbox(agg::rect_d &a, BBoxArray &bboxes)\n+{\n+    agg::rect_d b;\n+    int count = 0;\n+\n+    if (a.x2 < a.x1) {\n+        std::swap(a.x1, a.x2);\n+    }\n+    if (a.y2 < a.y1) {\n+        std::swap(a.y1, a.y2);\n+    }\n+\n+    size_t num_bboxes = bboxes.size();\n+    for (size_t i = 0; i < num_bboxes; ++i) {\n+        typename BBoxArray::sub_t bbox_b = bboxes[i];\n+        b = agg::rect_d(bbox_b(0, 0), bbox_b(0, 1), bbox_b(1, 0), bbox_b(1, 1));\n+\n+        if (b.x2 < b.x1) {\n+            std::swap(b.x1, b.x2);\n+        }\n+        if (b.y2 < b.y1) {\n+            std::swap(b.y1, b.y2);\n+        }\n+        if (!((b.x2 <= a.x1) || (b.y2 <= a.y1) || (b.x1 >= a.x2) || (b.y1 >= a.y2))) {\n+            ++count;\n+        }\n+    }\n+\n+    return count;\n+}\n+\n+inline bool segments_intersect(const double &x1,\n+                               const double &y1,\n+                               const double &x2,\n+                               const double &y2,\n+                               const double &x3,\n+                               const double &y3,\n+                               const double &x4,\n+                               const double &y4)\n+{\n+    double den = ((y4 - y3) * (x2 - x1)) - ((x4 - x3) * (y2 - y1));\n+    if (den == 0.0) {\n+        return false;\n+    }\n+\n+    double n1 = ((x4 - x3) * (y1 - y3)) - ((y4 - y3) * (x1 - x3));\n+    double n2 = ((x2 - x1) * (y1 - y3)) - ((y2 - y1) * (x1 - x3));\n+\n+    double u1 = n1 / den;\n+    double u2 = n2 / den;\n+\n+    return (u1 >= 0.0 && u1 <= 1.0 && u2 >= 0.0 && u2 <= 1.0);\n+}\n+\n+template <class PathIterator1, class PathIterator2>\n+bool path_intersects_path(PathIterator1 &p1, PathIterator2 &p2)\n+{\n+    typedef PathNanRemover<py::PathIterator> no_nans_t;\n+    typedef agg::conv_curve<no_nans_t> curve_t;\n+\n+    if (p1.total_vertices() < 2 || p2.total_vertices() < 2) {\n+        return false;\n+    }\n+\n+    no_nans_t n1(p1, true, p1.has_curves());\n+    no_nans_t n2(p2, true, p2.has_curves());\n+\n+    curve_t c1(n1);\n+    curve_t c2(n2);\n+\n+    double x11, y11, x12, y12;\n+    double x21, y21, x22, y22;\n+\n+    c1.vertex(&x11, &y11);\n+    while (c1.vertex(&x12, &y12) != agg::path_cmd_stop) {\n+        c2.rewind(0);\n+        c2.vertex(&x21, &y21);\n+        while (c2.vertex(&x22, &y22) != agg::path_cmd_stop) {\n+            if (segments_intersect(x11, y11, x12, y12, x21, y21, x22, y22)) {\n+                return true;\n+            }\n+            x21 = x22;\n+            y21 = y22;\n+        }\n+        x11 = x12;\n+        y11 = y12;\n+    }\n+\n+    return false;\n+}\n+\n+template <class PathIterator>\n+void convert_path_to_polygons(PathIterator &path,\n+                              agg::trans_affine &trans,\n+                              double width,\n+                              double height,\n+                              std::vector<Polygon> &result)\n+{\n+    typedef agg::conv_transform<py::PathIterator> transformed_path_t;\n+    typedef PathNanRemover<transformed_path_t> nan_removal_t;\n+    typedef PathClipper<nan_removal_t> clipped_t;\n+    typedef PathSimplifier<clipped_t> simplify_t;\n+    typedef agg::conv_curve<simplify_t> curve_t;\n+\n+    bool do_clip = width != 0.0 && height != 0.0;\n+    bool simplify = path.should_simplify();\n+\n+    transformed_path_t tpath(path, trans);\n+    nan_removal_t nan_removed(tpath, true, path.has_curves());\n+    clipped_t clipped(nan_removed, do_clip, width, height);\n+    simplify_t simplified(clipped, simplify, path.simplify_threshold());\n+    curve_t curve(simplified);\n+\n+    result.push_back(Polygon());\n+    Polygon *polygon = &result.back();\n+    double x, y;\n+    unsigned code;\n+\n+    while ((code = curve.vertex(&x, &y)) != agg::path_cmd_stop) {\n+        if ((code & agg::path_cmd_end_poly) == agg::path_cmd_end_poly) {\n+            if (polygon->size() >= 1) {\n+                polygon->push_back((*polygon)[0]);\n+                result.push_back(Polygon());\n+                polygon = &result.back();\n+            }\n+        } else {\n+            if (code == agg::path_cmd_move_to && polygon->size() >= 1) {\n+                polygon->push_back((*polygon)[0]);\n+                result.push_back(Polygon());\n+                polygon = &result.back();\n+            }\n+            polygon->push_back(XY(x, y));\n+        }\n+    }\n+\n+    if (polygon->size() == 0) {\n+        result.pop_back();\n+    }\n+}\n+\n+template <class VertexSource>\n+void\n+__cleanup_path(VertexSource &source, std::vector<double> &vertices, std::vector<npy_uint8> &codes)\n+{\n+    unsigned code;\n+    double x, y;\n+    do {\n+        code = source.vertex(&x, &y);\n+        vertices.push_back(x);\n+        vertices.push_back(y);\n+        codes.push_back((npy_uint8)code);\n+    } while (code != agg::path_cmd_stop);\n+}\n+\n+template <class PathIterator>\n+void cleanup_path(PathIterator &path,\n+                  const agg::trans_affine &trans,\n+                  bool remove_nans,\n+                  bool do_clip,\n+                  const agg::rect_base<double> &rect,\n+                  e_snap_mode snap_mode,\n+                  double stroke_width,\n+                  bool do_simplify,\n+                  bool return_curves,\n+                  SketchParams sketch_params,\n+                  std::vector<double> &vertices,\n+                  std::vector<unsigned char> &codes)\n+{\n+    typedef agg::conv_transform<py::PathIterator> transformed_path_t;\n+    typedef PathNanRemover<transformed_path_t> nan_removal_t;\n+    typedef PathClipper<nan_removal_t> clipped_t;\n+    typedef PathSnapper<clipped_t> snapped_t;\n+    typedef PathSimplifier<snapped_t> simplify_t;\n+    typedef agg::conv_curve<simplify_t> curve_t;\n+    typedef Sketch<curve_t> sketch_t;\n+\n+    transformed_path_t tpath(path, trans);\n+    nan_removal_t nan_removed(tpath, remove_nans, path.has_curves());\n+    clipped_t clipped(nan_removed, do_clip, rect);\n+    snapped_t snapped(clipped, snap_mode, path.total_vertices(), stroke_width);\n+    simplify_t simplified(snapped, do_simplify, path.simplify_threshold());\n+\n+    vertices.reserve(path.total_vertices() * 2);\n+    codes.reserve(path.total_vertices());\n+\n+    if (return_curves && sketch_params.scale == 0.0) {\n+        __cleanup_path(simplified, vertices, codes);\n+    } else {\n+        curve_t curve(simplified);\n+        sketch_t sketch(curve, sketch_params.scale, sketch_params.length, sketch_params.randomness);\n+        __cleanup_path(sketch, vertices, codes);\n+    }\n+}\n+\n+template <class PathIterator>\n+void convert_to_svg(PathIterator &path,\n+                    agg::trans_affine &trans,\n+                    agg::rect_d &clip_rect,\n+                    bool simplify,\n+                    int precision,\n+                    char *buffer,\n+                    size_t *buffersize)\n+{\n+#if PY_VERSION_HEX < 0x02070000\n+    char format[64];\n+    snprintf(format, 64, \"%s.%dg\", \"%\", precision);\n+#endif\n+\n+    typedef agg::conv_transform<py::PathIterator> transformed_path_t;\n+    typedef PathNanRemover<transformed_path_t> nan_removal_t;\n+    typedef PathClipper<nan_removal_t> clipped_t;\n+    typedef PathSimplifier<clipped_t> simplify_t;\n+\n+    bool do_clip = (clip_rect.x1 < clip_rect.x2 && clip_rect.y1 < clip_rect.y2);\n+\n+    transformed_path_t tpath(path, trans);\n+    nan_removal_t nan_removed(tpath, true, path.has_curves());\n+    clipped_t clipped(nan_removed, do_clip, clip_rect);\n+    simplify_t simplified(clipped, simplify, path.simplify_threshold());\n+\n+    char *p = buffer;\n+\n+    const char codes[] = { 'M', 'L', 'Q', 'C' };\n+    const int waits[] = { 1, 1, 2, 3 };\n+\n+    int wait = 0;\n+    unsigned code;\n+    double x = 0, y = 0;\n+    while ((code = simplified.vertex(&x, &y)) != agg::path_cmd_stop) {\n+        if (wait == 0) {\n+            *p++ = '\\n';\n+\n+            if (code == 0x4f) {\n+                *p++ = 'z';\n+                *p++ = '\\n';\n+                continue;\n+            }\n+\n+            *p++ = codes[code - 1];\n+            wait = waits[code - 1];\n+        } else {\n+            *p++ = ' ';\n+        }\n+\n+#if PY_VERSION_HEX >= 0x02070000\n+        char *str;\n+        str = PyOS_double_to_string(x, 'g', precision, 0, NULL);\n+        p += snprintf(p, *buffersize - (p - buffer), \"%s\", str);\n+        PyMem_Free(str);\n+        *p++ = ' ';\n+        str = PyOS_double_to_string(y, 'g', precision, 0, NULL);\n+        p += snprintf(p, *buffersize - (p - buffer), \"%s\", str);\n+        PyMem_Free(str);\n+#else\n+        char str[64];\n+        PyOS_ascii_formatd(str, 64, format, x);\n+        p += snprintf(p, *buffersize - (p - buffer), \"%s\", str);\n+        *p++ = ' ';\n+        PyOS_ascii_formatd(str, 64, format, y);\n+        p += snprintf(p, *buffersize - (p - buffer), \"%s\", str);\n+#endif\n+\n+        --wait;\n+    }\n+\n+    *p = '\\0';\n+    *buffersize = p - buffer;\n+}\n+\n+#endif"
            },
            {
                "sha": "d898a1684c828e986c65d5a07880ab71527f8fe8",
                "filename": "src/_path_wrapper.cpp",
                "status": "added",
                "additions": 713,
                "deletions": 0,
                "changes": 713,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_path_wrapper.cpp",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_path_wrapper.cpp",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/src%2F_path_wrapper.cpp?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787",
                "patch": "@@ -0,0 +1,713 @@\n+#include \"_path.h\"\n+\n+#include \"py_converters.h\"\n+#include \"py_adaptors.h\"\n+\n+PyObject *convert_polygon_vector(std::vector<Polygon> &polygons)\n+{\n+    PyObject *pyresult = PyList_New(polygons.size());\n+\n+    for (size_t i = 0; i < polygons.size(); ++i) {\n+        Polygon poly = polygons[i];\n+        npy_intp dims[] = {(npy_intp)poly.size() + 1, 2 };\n+        numpy::array_view<double, 2> subresult(dims);\n+\n+        /* Make last point same as first. */\n+        memcpy(subresult.data(), &poly[0], sizeof(double) * poly.size() * 2);\n+        subresult(poly.size(), 0) = poly[0].x;\n+        subresult(poly.size(), 1) = poly[0].y;\n+\n+        if (PyList_SetItem(pyresult, i, subresult.pyobj())) {\n+            Py_DECREF(pyresult);\n+            return NULL;\n+        }\n+    }\n+\n+    return pyresult;\n+}\n+\n+const char *Py_point_in_path__doc__ = \"point_in_path(x, y, radius, path, trans)\";\n+\n+static PyObject *Py_point_in_path(PyObject *self, PyObject *args, PyObject *kwds)\n+{\n+    double x, y, r;\n+    py::PathIterator path;\n+    agg::trans_affine trans;\n+    bool result;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"dddO&O&:point_in_path\",\n+                          &x,\n+                          &y,\n+                          &r,\n+                          &convert_path,\n+                          &path,\n+                          &convert_trans_affine,\n+                          &trans)) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP(\"point_in_path\", (result = point_in_path(x, y, r, path, trans)));\n+\n+    if (result) {\n+        Py_RETURN_TRUE;\n+    } else {\n+        Py_RETURN_FALSE;\n+    }\n+}\n+\n+const char *Py_points_in_path__doc__ = \"points_in_path(points, radius, path, trans)\";\n+\n+static PyObject *Py_points_in_path(PyObject *self, PyObject *args, PyObject *kwds)\n+{\n+    numpy::array_view<const double, 2> points;\n+    double r;\n+    py::PathIterator path;\n+    agg::trans_affine trans;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"O&dO&O&:points_in_path\",\n+                          &numpy::convert_array<const double, 2>,\n+                          &points,\n+                          &r,\n+                          &convert_path,\n+                          &path,\n+                          &convert_trans_affine,\n+                          &trans)) {\n+        return NULL;\n+    }\n+\n+    npy_intp dims[] = { points.dim(0) };\n+    numpy::array_view<uint8_t, 1> results(dims);\n+\n+    CALL_CPP(\"points_in_path\", (points_in_path(points, r, path, trans, results)));\n+\n+    return results.pyobj();\n+}\n+\n+const char *Py_point_on_path__doc__ = \"point_on_path(x, y, radius, path, trans)\";\n+\n+static PyObject *Py_point_on_path(PyObject *self, PyObject *args, PyObject *kwds)\n+{\n+    double x, y, r;\n+    py::PathIterator path;\n+    agg::trans_affine trans;\n+    bool result;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"dddO&O&:point_on_path\",\n+                          &x,\n+                          &y,\n+                          &r,\n+                          &convert_path,\n+                          &path,\n+                          &convert_trans_affine,\n+                          &trans)) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP(\"point_on_path\", (result = point_on_path(x, y, r, path, trans)));\n+\n+    if (result) {\n+        Py_RETURN_TRUE;\n+    } else {\n+        Py_RETURN_FALSE;\n+    }\n+}\n+\n+const char *Py_points_on_path__doc__ = \"points_on_path(points, radius, path, trans)\";\n+\n+static PyObject *Py_points_on_path(PyObject *self, PyObject *args, PyObject *kwds)\n+{\n+    numpy::array_view<const double, 2> points;\n+    double r;\n+    py::PathIterator path;\n+    agg::trans_affine trans;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"O&dO&O&:points_on_path\",\n+                          &numpy::convert_array<const double, 2>,\n+                          &points,\n+                          &r,\n+                          &convert_path,\n+                          &path,\n+                          &convert_trans_affine,\n+                          &trans)) {\n+        return NULL;\n+    }\n+\n+    npy_intp dims[] = { points.dim(0) };\n+    numpy::array_view<uint8_t, 1> results(dims);\n+\n+    CALL_CPP(\"points_on_path\", (points_on_path(points, r, path, trans, results)));\n+\n+    return results.pyobj();\n+}\n+\n+const char *Py_get_path_extents__doc__ = \"get_path_extents(path, trans)\";\n+\n+static PyObject *Py_get_path_extents(PyObject *self, PyObject *args, PyObject *kwds)\n+{\n+    py::PathIterator path;\n+    agg::trans_affine trans;\n+\n+    if (!PyArg_ParseTuple(\n+             args, \"O&O&:get_path_extents\", &convert_path, &path, &convert_trans_affine, &trans)) {\n+        return NULL;\n+    }\n+\n+    extent_limits e;\n+\n+    CALL_CPP(\"get_path_extents\", (reset_limits(e)));\n+    CALL_CPP(\"get_path_extents\", (update_path_extents(path, trans, e)));\n+\n+    npy_intp dims[] = { 2, 2 };\n+    numpy::array_view<double, 2> extents(dims);\n+    extents(0, 0) = e.x0;\n+    extents(0, 1) = e.y0;\n+    extents(1, 0) = e.x1;\n+    extents(1, 1) = e.y1;\n+\n+    return extents.pyobj();\n+}\n+\n+const char *Py_update_path_extents__doc__ =\n+    \"update_path_extents(path, trans, rect, minpos, ignore)\";\n+\n+static PyObject *Py_update_path_extents(PyObject *self, PyObject *args, PyObject *kwds)\n+{\n+    py::PathIterator path;\n+    agg::trans_affine trans;\n+    agg::rect_d rect;\n+    numpy::array_view<double, 1> minpos;\n+    bool ignore;\n+    bool changed;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"O&O&O&O&i:update_path_extents\",\n+                          &convert_path,\n+                          &path,\n+                          &convert_trans_affine,\n+                          &trans,\n+                          &convert_rect,\n+                          &rect,\n+                          &numpy::convert_array<double, 1>,\n+                          &minpos,\n+                          &ignore)) {\n+        return NULL;\n+    }\n+\n+    if (minpos.dim(0) != 2) {\n+        PyErr_SetString(PyExc_ValueError, \"minpos must be of length 2\");\n+    }\n+\n+    extent_limits e;\n+\n+    if (ignore) {\n+        CALL_CPP(\"update_path_extents\", reset_limits(e));\n+    } else {\n+        if (rect.x1 > rect.x2) {\n+            e.x0 = std::numeric_limits<double>::infinity();\n+            e.x1 = -std::numeric_limits<double>::infinity();\n+        } else {\n+            e.x0 = rect.x1;\n+            e.x1 = rect.x2;\n+        }\n+        if (rect.y1 > rect.y2) {\n+            e.y0 = std::numeric_limits<double>::infinity();\n+            e.y1 = -std::numeric_limits<double>::infinity();\n+        } else {\n+            e.y0 = rect.y1;\n+            e.y1 = rect.y2;\n+        }\n+        e.xm = minpos(0);\n+        e.ym = minpos(1);\n+    }\n+\n+    CALL_CPP(\"update_path_extents\", (update_path_extents(path, trans, e)));\n+\n+    changed = (e.x0 != rect.x1 || e.y0 != rect.y1 || e.x1 != rect.x2 || e.y1 != rect.y2 ||\n+               e.xm != minpos(0) || e.ym != minpos(1));\n+\n+    npy_intp extentsdims[] = { 2, 2 };\n+    numpy::array_view<double, 2> outextents(extentsdims);\n+    outextents(0, 0) = e.x0;\n+    outextents(0, 1) = e.y0;\n+    outextents(1, 0) = e.x1;\n+    outextents(1, 1) = e.y1;\n+\n+    npy_intp minposdims[] = { 2 };\n+    numpy::array_view<double, 1> outminpos(minposdims);\n+    outminpos(0) = e.xm;\n+    outminpos(1) = e.ym;\n+\n+    return Py_BuildValue(\n+        \"NNO\", outextents.pyobj(), outminpos.pyobj(), changed ? Py_True : Py_False);\n+}\n+\n+const char *Py_get_path_collection_extents__doc__ = \"get_path_collection_extents(\";\n+\n+static PyObject *Py_get_path_collection_extents(PyObject *self, PyObject *args, PyObject *kwds)\n+{\n+    agg::trans_affine master_transform;\n+    PyObject *pathsobj;\n+    numpy::array_view<const double, 3> transforms;\n+    numpy::array_view<const double, 2> offsets;\n+    agg::trans_affine offset_trans;\n+    extent_limits e;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"O&OO&O&O&:get_path_collection_extents\",\n+                          &convert_trans_affine,\n+                          &master_transform,\n+                          &pathsobj,\n+                          &numpy::convert_array<const double, 3>,\n+                          &transforms,\n+                          &numpy::convert_array<const double, 2>,\n+                          &offsets,\n+                          &convert_trans_affine,\n+                          &offset_trans)) {\n+        return NULL;\n+    }\n+\n+    try\n+    {\n+        py::PathGenerator paths(pathsobj);\n+\n+        CALL_CPP(\"get_path_collection_extents\",\n+                 (get_path_collection_extents(\n+                     master_transform, paths, transforms, offsets, offset_trans, e)));\n+    }\n+    catch (py::exception &e)\n+    {\n+        return NULL;\n+    }\n+\n+    npy_intp dims[] = { 2, 2 };\n+    numpy::array_view<double, 2> extents(dims);\n+    extents(0, 0) = e.x0;\n+    extents(0, 1) = e.y0;\n+    extents(1, 0) = e.x1;\n+    extents(1, 1) = e.y1;\n+\n+    return extents.pyobj();\n+}\n+\n+const char *Py_point_in_path_collection__doc__ =\n+    \"point_in_path_collection(x, y, radius, master_transform, paths, transforms, offsets, \"\n+    \"offset_trans, filled, offset_position)\";\n+\n+static PyObject *Py_point_in_path_collection(PyObject *self, PyObject *args, PyObject *kwds)\n+{\n+    double x, y, radius;\n+    agg::trans_affine master_transform;\n+    PyObject *pathsobj;\n+    numpy::array_view<const double, 3> transforms;\n+    numpy::array_view<const double, 2> offsets;\n+    agg::trans_affine offset_trans;\n+    int filled;\n+    e_offset_position offset_position;\n+    std::vector<size_t> result;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"dddO&OO&O&O&iO&:point_in_path_collection\",\n+                          &x,\n+                          &y,\n+                          &radius,\n+                          &convert_trans_affine,\n+                          &master_transform,\n+                          &pathsobj,\n+                          &numpy::convert_array<const double, 3>,\n+                          &transforms,\n+                          &numpy::convert_array<const double, 2>,\n+                          &offsets,\n+                          &convert_trans_affine,\n+                          &offset_trans,\n+                          &filled,\n+                          &convert_offset_position,\n+                          &offset_position)) {\n+        return NULL;\n+    }\n+\n+    try\n+    {\n+        py::PathGenerator paths(pathsobj);\n+\n+        CALL_CPP(\"point_in_path_collection\",\n+                 (point_in_path_collection(x,\n+                                           y,\n+                                           radius,\n+                                           master_transform,\n+                                           paths,\n+                                           transforms,\n+                                           offsets,\n+                                           offset_trans,\n+                                           filled,\n+                                           offset_position,\n+                                           result)));\n+    }\n+    catch (py::exception &e)\n+    {\n+        return NULL;\n+    }\n+\n+    npy_intp dims[] = {(npy_intp)result.size() };\n+    numpy::array_view<size_t, 1> pyresult(dims);\n+    memcpy(pyresult.data(), &result[0], result.size() * sizeof(size_t));\n+    return pyresult.pyobj();\n+}\n+\n+const char *Py_path_in_path__doc__ = \"path_in_path(path_a, trans_a, path_b, trans_b)\";\n+\n+static PyObject *Py_path_in_path(PyObject *self, PyObject *args, PyObject *kwds)\n+{\n+    py::PathIterator a;\n+    agg::trans_affine atrans;\n+    py::PathIterator b;\n+    agg::trans_affine btrans;\n+    bool result;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"O&O&O&O&:path_in_path\",\n+                          &convert_path,\n+                          &a,\n+                          &convert_trans_affine,\n+                          &atrans,\n+                          &convert_path,\n+                          &b,\n+                          &convert_trans_affine,\n+                          &btrans)) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP(\"path_in_path\", (result = path_in_path(a, atrans, b, btrans)));\n+\n+    if (result) {\n+        Py_RETURN_TRUE;\n+    } else {\n+        Py_RETURN_FALSE;\n+    }\n+}\n+\n+const char *Py_clip_path_to_rect__doc__ = \"clip_path_to_rect(path, rect, inside)\";\n+\n+static PyObject *Py_clip_path_to_rect(PyObject *self, PyObject *args, PyObject *kwds)\n+{\n+    py::PathIterator path;\n+    agg::rect_d rect;\n+    int inside;\n+    std::vector<Polygon> result;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"O&O&i:clip_path_to_rect\",\n+                          &convert_path,\n+                          &path,\n+                          &convert_rect,\n+                          &rect,\n+                          &inside)) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP(\"clip_path_to_rect\", (clip_path_to_rect(path, rect, inside, result)));\n+\n+    return convert_polygon_vector(result);\n+}\n+\n+const char *Py_affine_transform__doc__ = \"affine_transform(points, trans)\";\n+\n+static PyObject *Py_affine_transform(PyObject *self, PyObject *args, PyObject *kwds)\n+{\n+    numpy::array_view<const double, 2> vertices;\n+    agg::trans_affine trans;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"O&O&:affine_transform\",\n+                          &numpy::convert_array<const double, 2>,\n+                          &vertices,\n+                          &convert_trans_affine,\n+                          &trans)) {\n+        return NULL;\n+    }\n+\n+    npy_intp dims[] = { vertices.dim(0), 2 };\n+    numpy::array_view<double, 2> result(dims);\n+\n+    CALL_CPP(\"affine_transform\", (affine_transform(vertices, trans, result)));\n+\n+    return result.pyobj();\n+}\n+\n+const char *Py_count_bboxes_overlapping_bbox__doc__ = \"count_bboxes_overlapping_bbox(bbox, bboxes)\";\n+\n+static PyObject *Py_count_bboxes_overlapping_bbox(PyObject *self, PyObject *args, PyObject *kwds)\n+{\n+    agg::rect_d bbox;\n+    numpy::array_view<const double, 3> bboxes;\n+    int result;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"O&O&:count_bboxes_overlapping_bbox\",\n+                          &convert_rect,\n+                          &bbox,\n+                          &numpy::convert_array<const double, 3>,\n+                          &bboxes)) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP(\"count_bboxes_overlapping_bbox\",\n+             (result = count_bboxes_overlapping_bbox(bbox, bboxes)));\n+\n+    return PyLong_FromLong(result);\n+}\n+\n+const char *Py_path_intersects_path__doc__ = \"path_intersects_path(path1, path2, filled=False)\";\n+\n+static PyObject *Py_path_intersects_path(PyObject *self, PyObject *args, PyObject *kwds)\n+{\n+    py::PathIterator p1;\n+    py::PathIterator p2;\n+    bool filled = false;\n+    const char *names[] = { \"p1\", \"p2\", \"filled\", NULL };\n+    bool result;\n+\n+    if (!PyArg_ParseTupleAndKeywords(args,\n+                                     kwds,\n+                                     \"O&O&i:path_intersects_path\",\n+                                     (char **)names,\n+                                     &convert_path,\n+                                     &p1,\n+                                     &convert_path,\n+                                     &p2,\n+                                     &filled)) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP(\"path_intersects_path\", (result = path_intersects_path(p1, p2)));\n+    if (filled) {\n+        if (!result) {\n+            CALL_CPP(\"path_intersects_path\",\n+                     (result = path_in_path(p1, agg::trans_affine(), p2, agg::trans_affine())));\n+        }\n+        if (!result) {\n+            CALL_CPP(\"path_intersects_path\",\n+                     (result = path_in_path(p2, agg::trans_affine(), p1, agg::trans_affine())));\n+        }\n+    }\n+\n+    if (result) {\n+        Py_RETURN_TRUE;\n+    } else {\n+        Py_RETURN_FALSE;\n+    }\n+}\n+\n+const char *Py_convert_path_to_polygons__doc__ =\n+    \"convert_path_to_polygons(path, trans, width=0, height=0)\";\n+\n+static PyObject *Py_convert_path_to_polygons(PyObject *self, PyObject *args, PyObject *kwds)\n+{\n+    py::PathIterator path;\n+    agg::trans_affine trans;\n+    double width = 0.0, height = 0.0;\n+    std::vector<Polygon> result;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"O&O&|dd:convert_path_to_polygons\",\n+                          &convert_path,\n+                          &path,\n+                          &convert_trans_affine,\n+                          &trans,\n+                          &width,\n+                          &height)) {\n+        return NULL;\n+    }\n+\n+    CALL_CPP(\"convert_path_to_polygons\",\n+             (convert_path_to_polygons(path, trans, width, height, result)));\n+\n+    return convert_polygon_vector(result);\n+}\n+\n+const char *Py_cleanup_path__doc__ =\n+    \"cleanup_path(path, trans, remove_nans, clip_rect, snap_mode, stroke_width, simplify, \"\n+    \"return_curves, sketch)\";\n+\n+static PyObject *Py_cleanup_path(PyObject *self, PyObject *args, PyObject *kwds)\n+{\n+    py::PathIterator path;\n+    agg::trans_affine trans;\n+    int remove_nans;\n+    agg::rect_d clip_rect;\n+    e_snap_mode snap_mode;\n+    double stroke_width;\n+    PyObject *simplifyobj;\n+    bool simplify = false;\n+    int return_curves;\n+    SketchParams sketch;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"O&O&iO&O&dOiO&:cleanup_path\",\n+                          &convert_path,\n+                          &path,\n+                          &convert_trans_affine,\n+                          &trans,\n+                          &remove_nans,\n+                          &convert_rect,\n+                          &clip_rect,\n+                          &convert_snap,\n+                          &snap_mode,\n+                          &stroke_width,\n+                          &simplifyobj,\n+                          &return_curves,\n+                          &convert_sketch_params,\n+                          &sketch)) {\n+        return NULL;\n+    }\n+\n+    if (simplifyobj == Py_None) {\n+        simplify = path.should_simplify();\n+    } else if (PyObject_IsTrue(simplifyobj)) {\n+        simplify = true;\n+    }\n+\n+    bool do_clip = (clip_rect.x1 < clip_rect.x2 && clip_rect.y1 < clip_rect.y2);\n+\n+    std::vector<double> vertices;\n+    std::vector<npy_uint8> codes;\n+\n+    CALL_CPP(\"cleanup_path\",\n+             (cleanup_path(path,\n+                           trans,\n+                           remove_nans,\n+                           do_clip,\n+                           clip_rect,\n+                           snap_mode,\n+                           stroke_width,\n+                           simplify,\n+                           return_curves,\n+                           sketch,\n+                           vertices,\n+                           codes)));\n+\n+    size_t length = codes.size();\n+\n+    npy_intp vertices_dims[] = {(npy_intp)length, 2 };\n+    numpy::array_view<double, 2> pyvertices(vertices_dims);\n+\n+    npy_intp codes_dims[] = {(npy_intp)length };\n+    numpy::array_view<unsigned char, 1> pycodes(codes_dims);\n+\n+    memcpy(pyvertices.data(), &vertices[0], sizeof(double) * 2 * length);\n+    memcpy(pycodes.data(), &codes[0], sizeof(unsigned char) * length);\n+\n+    return Py_BuildValue(\"NN\", pyvertices.pyobj(), pycodes.pyobj());\n+}\n+\n+const char *Py_convert_to_svg__doc__ = \"convert_to_svg(path, trans, cliprect, simplify, precision)\";\n+\n+static PyObject *Py_convert_to_svg(PyObject *self, PyObject *args, PyObject *kwds)\n+{\n+    py::PathIterator path;\n+    agg::trans_affine trans;\n+    agg::rect_d cliprect;\n+    PyObject *simplifyobj;\n+    bool simplify = false;\n+    int precision;\n+\n+    if (!PyArg_ParseTuple(args,\n+                          \"O&O&O&Oi:convert_to_svg\",\n+                          &convert_path,\n+                          &path,\n+                          &convert_trans_affine,\n+                          &trans,\n+                          &convert_rect,\n+                          &cliprect,\n+                          &simplifyobj,\n+                          &precision)) {\n+        return NULL;\n+    }\n+\n+    if (simplifyobj == Py_None) {\n+        simplify = path.should_simplify();\n+    } else if (PyObject_IsTrue(simplifyobj)) {\n+        simplify = true;\n+    }\n+\n+    size_t buffersize = path.total_vertices() * (precision + 5) * 4;\n+    std::string buffer;\n+    buffer.reserve(buffersize);\n+\n+    CALL_CPP(\"convert_to_svg\",\n+             (convert_to_svg(path, trans, cliprect, simplify, precision, &buffer[0], &buffersize)));\n+\n+    return PyUnicode_DecodeASCII(&buffer[0], buffersize, \"\");\n+}\n+\n+extern \"C\" {\n+\n+    static PyMethodDef module_functions[] = {\n+        {\"point_in_path\", (PyCFunction)Py_point_in_path, METH_VARARGS, Py_point_in_path__doc__},\n+        {\"points_in_path\", (PyCFunction)Py_points_in_path, METH_VARARGS, Py_points_in_path__doc__},\n+        {\"point_on_path\", (PyCFunction)Py_point_on_path, METH_VARARGS, Py_point_on_path__doc__},\n+        {\"points_on_path\", (PyCFunction)Py_points_on_path, METH_VARARGS, Py_points_on_path__doc__},\n+        {\"get_path_extents\", (PyCFunction)Py_get_path_extents, METH_VARARGS, Py_get_path_extents__doc__},\n+        {\"update_path_extents\", (PyCFunction)Py_update_path_extents, METH_VARARGS, Py_update_path_extents__doc__},\n+        {\"get_path_collection_extents\", (PyCFunction)Py_get_path_collection_extents, METH_VARARGS, Py_get_path_collection_extents__doc__},\n+        {\"point_in_path_collection\", (PyCFunction)Py_point_in_path_collection, METH_VARARGS, Py_point_in_path_collection__doc__},\n+        {\"path_in_path\", (PyCFunction)Py_path_in_path, METH_VARARGS, Py_path_in_path__doc__},\n+        {\"clip_path_to_rect\", (PyCFunction)Py_clip_path_to_rect, METH_VARARGS, Py_clip_path_to_rect__doc__},\n+        {\"affine_transform\", (PyCFunction)Py_affine_transform, METH_VARARGS, Py_affine_transform__doc__},\n+        {\"count_bboxes_overlapping_bbox\", (PyCFunction)Py_count_bboxes_overlapping_bbox, METH_VARARGS, Py_count_bboxes_overlapping_bbox__doc__},\n+        {\"path_intersects_path\", (PyCFunction)Py_path_intersects_path, METH_VARARGS|METH_KEYWORDS, Py_path_intersects_path__doc__},\n+        {\"convert_path_to_polygons\", (PyCFunction)Py_convert_path_to_polygons, METH_VARARGS, Py_convert_path_to_polygons__doc__},\n+        {\"cleanup_path\", (PyCFunction)Py_cleanup_path, METH_VARARGS, Py_cleanup_path__doc__},\n+        {\"convert_to_svg\", (PyCFunction)Py_convert_to_svg, METH_VARARGS, Py_convert_to_svg__doc__},\n+        {NULL, NULL, NULL, NULL}\n+    };\n+\n+    struct module_state\n+    {\n+        /* The Sun compiler can't handle empty structs */\n+#if defined(__SUNPRO_C) || defined(_MSC_VER)\n+        int _dummy;\n+#endif\n+    };\n+\n+#if PY3K\n+    static struct PyModuleDef moduledef = {\n+        PyModuleDef_HEAD_INIT,\n+        \"_path\",\n+        NULL,\n+        sizeof(struct module_state),\n+        module_functions,\n+        NULL,\n+        NULL,\n+        NULL,\n+        NULL\n+    };\n+\n+#define INITERROR return NULL\n+    PyMODINIT_FUNC PyInit__path(void)\n+#else\n+#define INITERROR return\n+    PyMODINIT_FUNC init_path(void)\n+#endif\n+    {\n+        PyObject *m;\n+#if PY3K\n+        m = PyModule_Create(&moduledef);\n+#else\n+        m = Py_InitModule3(\"_path\", module_functions, NULL);\n+#endif\n+\n+        if (m == NULL) {\n+            INITERROR;\n+        }\n+\n+        import_array();\n+\n+#if PY3K\n+        return m;\n+#endif\n+    }\n+}"
            },
            {
                "sha": "6d76f5d05e1006891af2bba564e4aa83ee0213a3",
                "filename": "src/_png.cpp",
                "status": "modified",
                "additions": 317,
                "deletions": 412,
                "changes": 729,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_png.cpp",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_png.cpp",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/src%2F_png.cpp?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787",
                "patch": "@@ -1,11 +1,17 @@\n /* -*- mode: c++; c-basic-offset: 4 -*- */\n \n+// this code is heavily adapted from the paint license, which is in\n+// the file paint.license (BSD compatible) included in this\n+// distribution.  TODO, add license file to MANIFEST.in and CVS\n+\n /* For linux, png.h must be imported before Python.h because\n    png.h needs to be the one to define setjmp.\n    Undefining _POSIX_C_SOURCE and _XOPEN_SOURCE stops a couple\n    of harmless warnings.\n */\n \n+#include <vector>\n+\n #ifdef __linux__\n #   include <png.h>\n #   ifdef _POSIX_C_SOURCE\n@@ -23,277 +29,193 @@\n #   include <png.h>\n #endif\n \n-// TODO: Un CXX-ify this module\n-#include \"CXX/Extensions.hxx\"\n-#include \"numpy/arrayobject.h\"\n-#include \"mplutils.h\"\n-\n #include \"file_compat.h\"\n+#include \"numpy_cpp.h\"\n+#include \"mplutils.h\"\n \n // As reported in [3082058] build _png.so on aix\n #ifdef _AIX\n #undef jmpbuf\n #endif\n \n-// the extension module\n-class _png_module : public Py::ExtensionModule<_png_module>\n-{\n-public:\n-    _png_module()\n-            : Py::ExtensionModule<_png_module>(\"_png\")\n-    {\n-        add_varargs_method(\"write_png\", &_png_module::write_png,\n-                           \"write_png(buffer, width, height, fileobj, dpi=None)\");\n-        add_varargs_method(\"read_png\", &_png_module::read_png_float,\n-                           \"read_png(fileobj)\");\n-        add_varargs_method(\"read_png_float\", &_png_module::read_png_float,\n-                           \"read_png_float(fileobj)\");\n-        add_varargs_method(\"read_png_uint8\", &_png_module::read_png_uint8,\n-                           \"read_png_uint8(fileobj)\");\n-        add_varargs_method(\"read_png_int\", &_png_module::read_png_int,\n-                           \"read_png_int(fileobj)\");\n-        initialize(\"Module to write PNG files\");\n-    }\n-\n-    virtual ~_png_module() {}\n-\n-private:\n-    Py::Object write_png(const Py::Tuple& args);\n-    Py::Object read_png_uint8(const Py::Tuple& args);\n-    Py::Object read_png_float(const Py::Tuple& args);\n-    Py::Object read_png_int(const Py::Tuple& args);\n-    PyObject* _read_png(const Py::Object& py_fileobj, const bool float_result, int result_bit_depth = -1);\n-};\n-\n static void write_png_data(png_structp png_ptr, png_bytep data, png_size_t length)\n {\n-    PyObject* py_file_obj = (PyObject*)png_get_io_ptr(png_ptr);\n-    PyObject* write_method = PyObject_GetAttrString(py_file_obj, \"write\");\n-    PyObject* result = NULL;\n-    if (write_method)\n-    {\n-        #if PY3K\n-        result = PyObject_CallFunction(write_method, (char *)\"y#\", data,\n-                                       length);\n-        #else\n-        result = PyObject_CallFunction(write_method, (char *)\"s#\", data,\n-                                       length);\n-        #endif\n+    PyObject *py_file_obj = (PyObject *)png_get_io_ptr(png_ptr);\n+    PyObject *write_method = PyObject_GetAttrString(py_file_obj, \"write\");\n+    PyObject *result = NULL;\n+    if (write_method) {\n+#if PY3K\n+        result = PyObject_CallFunction(write_method, (char *)\"y#\", data, length);\n+#else\n+        result = PyObject_CallFunction(write_method, (char *)\"s#\", data, length);\n+#endif\n     }\n     Py_XDECREF(write_method);\n     Py_XDECREF(result);\n }\n \n static void flush_png_data(png_structp png_ptr)\n {\n-    PyObject* py_file_obj = (PyObject*)png_get_io_ptr(png_ptr);\n-    PyObject* flush_method = PyObject_GetAttrString(py_file_obj, \"flush\");\n-    PyObject* result = NULL;\n-    if (flush_method)\n-    {\n+    PyObject *py_file_obj = (PyObject *)png_get_io_ptr(png_ptr);\n+    PyObject *flush_method = PyObject_GetAttrString(py_file_obj, \"flush\");\n+    PyObject *result = NULL;\n+    if (flush_method) {\n         result = PyObject_CallFunction(flush_method, (char *)\"\");\n     }\n     Py_XDECREF(flush_method);\n     Py_XDECREF(result);\n }\n \n-// this code is heavily adapted from the paint license, which is in\n-// the file paint.license (BSD compatible) included in this\n-// distribution.  TODO, add license file to MANIFEST.in and CVS\n-Py::Object _png_module::write_png(const Py::Tuple& args)\n+const char *Py_write_png__doc__ = \"write_png(buffer, file, dpi=0)\";\n+\n+static PyObject *Py_write_png(PyObject *self, PyObject *args, PyObject *kwds)\n {\n-    args.verify_length(4, 5);\n+    numpy::array_view<unsigned char, 3> buffer;\n+    PyObject *filein;\n+    double dpi = 0;\n+    const char *names[] = { \"buffer\", \"file\", \"dpi\", NULL };\n+\n+    if (!PyArg_ParseTupleAndKeywords(args,\n+                                     kwds,\n+                                     \"O&O|d:write_png\",\n+                                     (char **)names,\n+                                     &numpy::convert_array<unsigned char, 3>,\n+                                     &buffer,\n+                                     &filein,\n+                                     &dpi)) {\n+        return NULL;\n+    }\n+\n+    png_uint_32 width = (png_uint_32)buffer.dim(1);\n+    png_uint_32 height = (png_uint_32)buffer.dim(0);\n+    std::vector<png_bytep> row_pointers(height);\n+    for (png_uint_32 row = 0; row < (png_uint_32)height; ++row) {\n+        row_pointers[row] = (png_bytep)buffer[row].data();\n+    }\n \n     FILE *fp = NULL;\n-    mpl_off_t offset;\n+    mpl_off_t offset = 0;\n     bool close_file = false;\n     bool close_dup_file = false;\n-    Py::Object buffer_obj = Py::Object(args[0]);\n-    PyObject* buffer = buffer_obj.ptr();\n-    if (!PyObject_CheckReadBuffer(buffer))\n-    {\n-        throw Py::TypeError(\"First argument must be an rgba buffer.\");\n-    }\n-\n-    const void* pixBufferPtr = NULL;\n-    Py_ssize_t pixBufferLength = 0;\n-    if (PyObject_AsReadBuffer(buffer, &pixBufferPtr, &pixBufferLength))\n-    {\n-        throw Py::ValueError(\"Couldn't get data from read buffer.\");\n-    }\n+    PyObject *py_file = NULL;\n \n-    png_byte* pixBuffer = (png_byte*)pixBufferPtr;\n-    int width = (int)Py::Int(args[1]);\n-    int height = (int)Py::Int(args[2]);\n+    png_structp png_ptr = NULL;\n+    png_infop info_ptr = NULL;\n+    struct png_color_8_struct sig_bit;\n \n-    if (pixBufferLength < width * height * 4)\n-    {\n-        throw Py::ValueError(\"Buffer and width, height don't seem to match.\");\n+    if (buffer.dim(2) != 4) {\n+        PyErr_SetString(PyExc_ValueError, \"Buffer must be RGBA NxMx4 array\");\n+        goto exit;\n     }\n \n-    Py::Object py_fileobj = Py::Object(args[3]);\n-    PyObject* py_file = NULL;\n-    if (py_fileobj.isString())\n-    {\n-        if ((py_file = mpl_PyFile_OpenFile(py_fileobj.ptr(), (char *)\"wb\")) == NULL) {\n-            throw Py::Exception();\n+    if (PyBytes_Check(filein) || PyUnicode_Check(filein)) {\n+        if ((py_file = mpl_PyFile_OpenFile(filein, (char *)\"wb\")) == NULL) {\n+            goto exit;\n         }\n         close_file = true;\n-    }\n-    else\n-    {\n-        py_file = py_fileobj.ptr();\n+    } else {\n+        py_file = filein;\n     }\n \n-    if ((fp = mpl_PyFile_Dup(py_file, (char *)\"wb\", &offset)))\n-    {\n+    if ((fp = mpl_PyFile_Dup(py_file, (char *)\"wb\", &offset))) {\n         close_dup_file = true;\n-    }\n-    else\n-    {\n+    } else {\n         PyErr_Clear();\n-        PyObject* write_method = PyObject_GetAttrString(\n-                py_file, \"write\");\n-        if (!(write_method && PyCallable_Check(write_method)))\n-        {\n+        PyObject *write_method = PyObject_GetAttrString(py_file, \"write\");\n+        if (!(write_method && PyCallable_Check(write_method))) {\n             Py_XDECREF(write_method);\n-            throw Py::TypeError(\n-                    \"Object does not appear to be a 8-bit string path or \"\n-                    \"a Python file-like object\");\n+            PyErr_SetString(PyExc_TypeError,\n+                            \"Object does not appear to be a 8-bit string path or \"\n+                            \"a Python file-like object\");\n+            goto exit;\n         }\n         Py_XDECREF(write_method);\n     }\n \n-    png_bytep *row_pointers = NULL;\n-    png_structp png_ptr = NULL;\n-    png_infop info_ptr = NULL;\n-\n-    try\n-    {\n-        struct png_color_8_struct sig_bit;\n-        png_uint_32 row;\n-\n-        row_pointers = new png_bytep[height];\n-        for (row = 0; row < (png_uint_32)height; ++row)\n-        {\n-            row_pointers[row] = pixBuffer + row * width * 4;\n-        }\n+    png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);\n+    if (png_ptr == NULL) {\n+        PyErr_SetString(PyExc_RuntimeError, \"Could not create write struct\");\n+        goto exit;\n+    }\n \n-        png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);\n-        if (png_ptr == NULL)\n-        {\n-            throw Py::RuntimeError(\"Could not create write struct\");\n-        }\n+    info_ptr = png_create_info_struct(png_ptr);\n+    if (info_ptr == NULL) {\n+        PyErr_SetString(PyExc_RuntimeError, \"Could not create info struct\");\n+        goto exit;\n+    }\n \n-        info_ptr = png_create_info_struct(png_ptr);\n-        if (info_ptr == NULL)\n-        {\n-            throw Py::RuntimeError(\"Could not create info struct\");\n-        }\n+    if (setjmp(png_jmpbuf(png_ptr))) {\n+        PyErr_SetString(PyExc_RuntimeError, \"Error setting jumps\");\n+        goto exit;\n+    }\n \n-        if (setjmp(png_jmpbuf(png_ptr)))\n-        {\n-            throw Py::RuntimeError(\"Error building image\");\n-        }\n+    if (fp) {\n+        png_init_io(png_ptr, fp);\n+    } else {\n+        png_set_write_fn(png_ptr, (void *)py_file, &write_png_data, &flush_png_data);\n+    }\n+    png_set_IHDR(png_ptr,\n+                 info_ptr,\n+                 width,\n+                 height,\n+                 8,\n+                 PNG_COLOR_TYPE_RGB_ALPHA,\n+                 PNG_INTERLACE_NONE,\n+                 PNG_COMPRESSION_TYPE_BASE,\n+                 PNG_FILTER_TYPE_BASE);\n \n-        if (fp)\n-        {\n-            png_init_io(png_ptr, fp);\n-        }\n-        else\n-        {\n-            png_set_write_fn(png_ptr, (void*)py_file,\n-                             &write_png_data, &flush_png_data);\n-        }\n-        png_set_IHDR(png_ptr, info_ptr,\n-                     width, height, 8,\n-                     PNG_COLOR_TYPE_RGB_ALPHA, PNG_INTERLACE_NONE,\n-                     PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);\n-\n-        // Save the dpi of the image in the file\n-        if (args.size() == 5)\n-        {\n-            double dpi = Py::Float(args[4]);\n-            size_t dots_per_meter = (size_t)(dpi / (2.54 / 100.0));\n-            png_set_pHYs(png_ptr, info_ptr, dots_per_meter, dots_per_meter, PNG_RESOLUTION_METER);\n-        }\n+    // Save the dpi of the image in the file\n+    if (dpi > 0.0) {\n+        png_uint_32 dots_per_meter = (png_uint_32)(dpi / (2.54 / 100.0));\n+        png_set_pHYs(png_ptr, info_ptr, dots_per_meter, dots_per_meter, PNG_RESOLUTION_METER);\n+    }\n \n-        // this a a color image!\n-        sig_bit.gray = 0;\n-        sig_bit.red = 8;\n-        sig_bit.green = 8;\n-        sig_bit.blue = 8;\n-        /* if the image has an alpha channel then */\n-        sig_bit.alpha = 8;\n-        png_set_sBIT(png_ptr, info_ptr, &sig_bit);\n+    // this a a color image!\n+    sig_bit.gray = 0;\n+    sig_bit.red = 8;\n+    sig_bit.green = 8;\n+    sig_bit.blue = 8;\n+    /* if the image has an alpha channel then */\n+    sig_bit.alpha = 8;\n+    png_set_sBIT(png_ptr, info_ptr, &sig_bit);\n \n-        png_write_info(png_ptr, info_ptr);\n-        png_write_image(png_ptr, row_pointers);\n-        png_write_end(png_ptr, info_ptr);\n-    }\n-    catch (...)\n-    {\n-        if (png_ptr && info_ptr)\n-        {\n-            png_destroy_write_struct(&png_ptr, &info_ptr);\n-        }\n-        delete [] row_pointers;\n+    png_write_info(png_ptr, info_ptr);\n+    png_write_image(png_ptr, &row_pointers[0]);\n+    png_write_end(png_ptr, info_ptr);\n \n-        if (close_dup_file)\n-        {\n-            if (mpl_PyFile_DupClose(py_file, fp, offset)) {\n-              throw Py::RuntimeError(\"Error closing dupe file handle\");\n-            }\n-        }\n+exit:\n \n-        if (close_file)\n-        {\n-            mpl_PyFile_CloseFile(py_file);\n-            Py_DECREF(py_file);\n-        }\n-        /* Changed calls to png_destroy_write_struct to follow\n-           http://www.libpng.org/pub/png/libpng-manual.txt.\n-           This ensures the info_ptr memory is released.\n-        */\n-        throw;\n+    if (png_ptr && info_ptr) {\n+        png_destroy_write_struct(&png_ptr, &info_ptr);\n     }\n \n-    png_destroy_write_struct(&png_ptr, &info_ptr);\n-    delete [] row_pointers;\n-    if (close_dup_file)\n-    {\n-        if (mpl_PyFile_DupClose(py_file, fp, offset)) {\n-          throw Py::RuntimeError(\"Error closing dupe file handle\");\n-        }\n+    if (close_dup_file) {\n+        mpl_PyFile_DupClose(py_file, fp, offset);\n     }\n \n-    if (close_file)\n-    {\n+    if (close_file) {\n         mpl_PyFile_CloseFile(py_file);\n         Py_DECREF(py_file);\n     }\n \n     if (PyErr_Occurred()) {\n-        throw Py::Exception();\n+        return NULL;\n     } else {\n-        return Py::Object();\n+        Py_RETURN_NONE;\n     }\n }\n \n-static void _read_png_data(PyObject* py_file_obj, png_bytep data, png_size_t length)\n+static void _read_png_data(PyObject *py_file_obj, png_bytep data, png_size_t length)\n {\n-    PyObject* read_method = PyObject_GetAttrString(py_file_obj, \"read\");\n-    PyObject* result = NULL;\n+    PyObject *read_method = PyObject_GetAttrString(py_file_obj, \"read\");\n+    PyObject *result = NULL;\n     char *buffer;\n     Py_ssize_t bufflen;\n-    if (read_method)\n-    {\n+    if (read_method) {\n         result = PyObject_CallFunction(read_method, (char *)\"i\", length);\n     }\n-    if (PyBytes_AsStringAndSize(result, &buffer, &bufflen) == 0)\n-    {\n-        if (bufflen == (Py_ssize_t)length)\n-        {\n+    if (PyBytes_AsStringAndSize(result, &buffer, &bufflen) == 0) {\n+        if (bufflen == (Py_ssize_t)length) {\n             memcpy(data, buffer, length);\n         }\n     }\n@@ -303,345 +225,328 @@ static void _read_png_data(PyObject* py_file_obj, png_bytep data, png_size_t len\n \n static void read_png_data(png_structp png_ptr, png_bytep data, png_size_t length)\n {\n-    PyObject* py_file_obj = (PyObject*)png_get_io_ptr(png_ptr);\n+    PyObject *py_file_obj = (PyObject *)png_get_io_ptr(png_ptr);\n     _read_png_data(py_file_obj, data, length);\n }\n \n-PyObject*\n-_png_module::_read_png(const Py::Object& py_fileobj, const bool float_result,\n-                       int result_bit_depth)\n+static PyObject *_read_png(PyObject *filein, bool float_result)\n {\n-    png_byte header[8];   // 8 is the maximum size that can be checked\n-    FILE* fp = NULL;\n-    mpl_off_t offset;\n+    png_byte header[8]; // 8 is the maximum size that can be checked\n+    FILE *fp = NULL;\n+    mpl_off_t offset = 0;\n     bool close_file = false;\n     bool close_dup_file = false;\n     PyObject *py_file = NULL;\n-\n-    if (py_fileobj.isString())\n-    {\n-        if ((py_file = mpl_PyFile_OpenFile(py_fileobj.ptr(), (char *)\"rb\")) == NULL) {\n-            throw Py::Exception();\n+    PyArrayObject *A = NULL;\n+    png_structp png_ptr = NULL;\n+    png_infop info_ptr = NULL;\n+    int num_dims;\n+    std::vector<png_bytep> row_pointers;\n+    png_uint_32 width = 0;\n+    png_uint_32 height = 0;\n+    int bit_depth;\n+\n+    if (PyBytes_Check(filein) || PyUnicode_Check(filein)) {\n+        if ((py_file = mpl_PyFile_OpenFile(filein, (char *)\"rb\")) == NULL) {\n+            goto exit;\n         }\n         close_file = true;\n     } else {\n-        py_file = py_fileobj.ptr();\n+        py_file = filein;\n     }\n \n-    if ((fp = mpl_PyFile_Dup(py_file, \"rb\", &offset)))\n-    {\n+    if ((fp = mpl_PyFile_Dup(py_file, (char *)\"rb\", &offset))) {\n         close_dup_file = true;\n-    }\n-    else\n-    {\n+    } else {\n         PyErr_Clear();\n-        PyObject* read_method = PyObject_GetAttrString(py_file, \"read\");\n-        if (!(read_method && PyCallable_Check(read_method)))\n-        {\n+        PyObject *read_method = PyObject_GetAttrString(py_file, \"read\");\n+        if (!(read_method && PyCallable_Check(read_method))) {\n             Py_XDECREF(read_method);\n-            throw Py::TypeError(\n-                \"Object does not appear to be a 8-bit string path or a Python \"\n-                \"file-like object\");\n+            PyErr_SetString(PyExc_TypeError,\n+                            \"Object does not appear to be a 8-bit string path or \"\n+                            \"a Python file-like object\");\n+            goto exit;\n         }\n         Py_XDECREF(read_method);\n     }\n \n-    if (fp)\n-    {\n-        if (fread(header, 1, 8, fp) != 8)\n-        {\n-            throw Py::RuntimeError(\n-                \"_image_module::readpng: error reading PNG header\");\n+    if (fp) {\n+        if (fread(header, 1, 8, fp) != 8) {\n+            PyErr_SetString(PyExc_IOError, \"error reading PNG header\");\n+            goto exit;\n         }\n-    }\n-    else\n-    {\n+    } else {\n         _read_png_data(py_file, header, 8);\n     }\n-    if (png_sig_cmp(header, 0, 8))\n-    {\n-        throw Py::RuntimeError(\n-            \"_image_module::readpng: file not recognized as a PNG file\");\n+\n+    if (png_sig_cmp(header, 0, 8)) {\n+        PyErr_SetString(PyExc_ValueError, \"invalid PNG header\");\n+        goto exit;\n     }\n \n     /* initialize stuff */\n-    png_structp png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);\n+    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);\n \n-    if (!png_ptr)\n-    {\n-        throw Py::RuntimeError(\n-            \"_image_module::readpng:  png_create_read_struct failed\");\n+    if (!png_ptr) {\n+        PyErr_SetString(PyExc_RuntimeError, \"png_create_read_struct failed\");\n+        goto exit;\n     }\n \n-    png_infop info_ptr = png_create_info_struct(png_ptr);\n-    if (!info_ptr)\n-    {\n-        throw Py::RuntimeError(\n-            \"_image_module::readpng:  png_create_info_struct failed\");\n+    info_ptr = png_create_info_struct(png_ptr);\n+    if (!info_ptr) {\n+        PyErr_SetString(PyExc_RuntimeError, \"png_create_info_struct failed\");\n+        goto exit;\n     }\n \n-    if (setjmp(png_jmpbuf(png_ptr)))\n-    {\n-        throw Py::RuntimeError(\n-            \"_image_module::readpng:  error during init_io\");\n+    if (setjmp(png_jmpbuf(png_ptr))) {\n+        PyErr_SetString(PyExc_RuntimeError, \"Error setting jump\");\n+        goto exit;\n     }\n \n-    if (fp)\n-    {\n+    if (fp) {\n         png_init_io(png_ptr, fp);\n-    }\n-    else\n-    {\n-        png_set_read_fn(png_ptr, (void*)py_file, &read_png_data);\n+    } else {\n+        png_set_read_fn(png_ptr, (void *)py_file, &read_png_data);\n     }\n     png_set_sig_bytes(png_ptr, 8);\n     png_read_info(png_ptr, info_ptr);\n \n-    png_uint_32 width = png_get_image_width(png_ptr, info_ptr);\n-    png_uint_32 height = png_get_image_height(png_ptr, info_ptr);\n+    width = png_get_image_width(png_ptr, info_ptr);\n+    height = png_get_image_height(png_ptr, info_ptr);\n \n-    int bit_depth = png_get_bit_depth(png_ptr, info_ptr);\n+    bit_depth = png_get_bit_depth(png_ptr, info_ptr);\n \n     // Unpack 1, 2, and 4-bit images\n-    if (bit_depth < 8)\n+    if (bit_depth < 8) {\n         png_set_packing(png_ptr);\n+    }\n \n     // If sig bits are set, shift data\n     png_color_8p sig_bit;\n     if ((png_get_color_type(png_ptr, info_ptr) != PNG_COLOR_TYPE_PALETTE) &&\n-        png_get_sBIT(png_ptr, info_ptr, &sig_bit))\n-    {\n+        png_get_sBIT(png_ptr, info_ptr, &sig_bit)) {\n         png_set_shift(png_ptr, sig_bit);\n     }\n \n     // Convert big endian to little\n-    if (bit_depth == 16)\n-    {\n+    if (bit_depth == 16) {\n         png_set_swap(png_ptr);\n     }\n \n     // Convert palletes to full RGB\n-    if (png_get_color_type(png_ptr, info_ptr) == PNG_COLOR_TYPE_PALETTE)\n-    {\n+    if (png_get_color_type(png_ptr, info_ptr) == PNG_COLOR_TYPE_PALETTE) {\n         png_set_palette_to_rgb(png_ptr);\n         bit_depth = 8;\n     }\n \n     // If there's an alpha channel convert gray to RGB\n-    if (png_get_color_type(png_ptr, info_ptr) == PNG_COLOR_TYPE_GRAY_ALPHA)\n-    {\n+    if (png_get_color_type(png_ptr, info_ptr) == PNG_COLOR_TYPE_GRAY_ALPHA) {\n         png_set_gray_to_rgb(png_ptr);\n     }\n \n     png_set_interlace_handling(png_ptr);\n     png_read_update_info(png_ptr, info_ptr);\n \n-    /* read file */\n-    if (setjmp(png_jmpbuf(png_ptr)))\n-    {\n-        throw Py::RuntimeError(\n-            \"_image_module::readpng: error during read_image\");\n-    }\n-\n-    png_bytep *row_pointers = new png_bytep[height];\n-    png_uint_32 row;\n-\n-    for (row = 0; row < height; row++)\n-    {\n-        row_pointers[row] = new png_byte[png_get_rowbytes(png_ptr,info_ptr)];\n+    row_pointers.resize(height);\n+    for (png_uint_32 row = 0; row < height; row++) {\n+        row_pointers[row] = new png_byte[png_get_rowbytes(png_ptr, info_ptr)];\n     }\n \n-    png_read_image(png_ptr, row_pointers);\n+    png_read_image(png_ptr, &row_pointers[0]);\n \n     npy_intp dimensions[3];\n-    dimensions[0] = height;  //numrows\n-    dimensions[1] = width;   //numcols\n-    if (png_get_color_type(png_ptr, info_ptr) & PNG_COLOR_MASK_ALPHA)\n-    {\n-        dimensions[2] = 4;     //RGBA images\n-    }\n-    else if (png_get_color_type(png_ptr, info_ptr) & PNG_COLOR_MASK_COLOR)\n-    {\n-        dimensions[2] = 3;     //RGB images\n-    }\n-    else\n-    {\n-        dimensions[2] = 1;     //Greyscale images\n+    dimensions[0] = height; // numrows\n+    dimensions[1] = width; // numcols\n+    if (png_get_color_type(png_ptr, info_ptr) & PNG_COLOR_MASK_ALPHA) {\n+        dimensions[2] = 4; // RGBA images\n+    } else if (png_get_color_type(png_ptr, info_ptr) & PNG_COLOR_MASK_COLOR) {\n+        dimensions[2] = 3; // RGB images\n+    } else {\n+        dimensions[2] = 1; // Greyscale images\n     }\n-    //For gray, return an x by y array, not an x by y by 1\n-    int num_dims  = (png_get_color_type(png_ptr, info_ptr)\n-                                & PNG_COLOR_MASK_COLOR) ? 3 : 2;\n+    // For gray, return an x by y array, not an x by y by 1\n+    num_dims = (png_get_color_type(png_ptr, info_ptr) & PNG_COLOR_MASK_COLOR) ? 3 : 2;\n \n-    PyArrayObject *A = NULL;\n     if (float_result) {\n         double max_value = (1 << bit_depth) - 1;\n \n-        A = (PyArrayObject *) PyArray_SimpleNew(num_dims, dimensions, NPY_FLOAT);\n-\n-        if (A == NULL)\n-        {\n-            throw Py::MemoryError(\"Could not allocate image array\");\n+        A = (PyArrayObject *)PyArray_SimpleNew(num_dims, dimensions, NPY_FLOAT);\n+        if (A == NULL) {\n+            goto exit;\n         }\n \n-        const npy_intp ystride = PyArray_STRIDE(A, 0);\n-        const npy_intp xstride = PyArray_STRIDE(A, 1);\n-        const npy_intp pstride = PyArray_STRIDE(A, 2);\n-        char* target_row = PyArray_BYTES(A);\n-        for (png_uint_32 y = 0; y < height; y++, target_row += ystride)\n-        {\n-            png_byte* row = row_pointers[y];\n-            char* target_pixel = target_row;\n-            for (png_uint_32 x = 0; x < width; x++, target_pixel += xstride)\n-            {\n-                if (bit_depth == 16)\n-                {\n-                    png_uint_16* ptr = &reinterpret_cast<png_uint_16*>(row)[x * dimensions[2]];\n-                    for (png_uint_32 p = 0; p < (png_uint_32)dimensions[2]; p++)\n-                    {\n-                        *(float*)(target_pixel + p * pstride) = (float)(ptr[p]) / max_value;\n+        for (png_uint_32 y = 0; y < height; y++) {\n+            png_byte *row = row_pointers[y];\n+            for (png_uint_32 x = 0; x < width; x++) {\n+                size_t offset = y * A->strides[0] + x * A->strides[1];\n+                if (bit_depth == 16) {\n+                    png_uint_16 *ptr = &reinterpret_cast<png_uint_16 *>(row)[x * dimensions[2]];\n+                    for (png_uint_32 p = 0; p < (png_uint_32)dimensions[2]; p++) {\n+                        *(float *)(A->data + offset + p *A->strides[2]) =\n+                            (float)(ptr[p]) / max_value;\n                     }\n-                }\n-                else\n-                {\n-                    png_byte* ptr = &(row[x * dimensions[2]]);\n-                    for (png_uint_32 p = 0; p < (png_uint_32)dimensions[2]; p++)\n-                    {\n-                        *(float*)(target_pixel + p * pstride) = (float)(ptr[p]) / max_value;\n+                } else {\n+                    png_byte *ptr = &(row[x * dimensions[2]]);\n+                    for (png_uint_32 p = 0; p < (png_uint_32)dimensions[2]; p++) {\n+                        *(float *)(A->data + offset + p *A->strides[2]) =\n+                            (float)(ptr[p]) / max_value;\n                     }\n                 }\n             }\n         }\n     } else {\n-        if (result_bit_depth < 0) {\n-            result_bit_depth = bit_depth;\n-        }\n-\n-        if (result_bit_depth == 8) {\n-            A = (PyArrayObject *) PyArray_SimpleNew(num_dims, dimensions, NPY_UBYTE);\n-        } else if (result_bit_depth == 16) {\n-            A = (PyArrayObject *) PyArray_SimpleNew(num_dims, dimensions, NPY_UINT16);\n+        if (bit_depth == 8) {\n+            A = (PyArrayObject *)PyArray_SimpleNew(num_dims, dimensions, NPY_UBYTE);\n+        } else if (bit_depth == 16) {\n+            A = (PyArrayObject *)PyArray_SimpleNew(num_dims, dimensions, NPY_UINT16);\n         } else {\n-            throw Py::RuntimeError(\n-                \"_image_module::readpng: image has unknown bit depth\");\n+            PyErr_SetString(PyExc_RuntimeError, \"image has unknown bit depth\");\n+            goto exit;\n         }\n \n-        if (A == NULL)\n-        {\n-            throw Py::MemoryError(\"Could not allocate image array\");\n+        if (A == NULL) {\n+            goto exit;\n         }\n \n-        const npy_intp ystride = PyArray_STRIDE(A, 0);\n-        const npy_intp xstride = PyArray_STRIDE(A, 1);\n-        const npy_intp pstride = PyArray_STRIDE(A, 2);\n-        char* target_row = PyArray_BYTES(A);\n-        for (png_uint_32 y = 0; y < height; y++, target_row += ystride)\n-        {\n-            png_byte* row = row_pointers[y];\n-            char* target_pixel = target_row;\n-            for (png_uint_32 x = 0; x < width; x++, target_pixel += xstride)\n-            {\n-                if (bit_depth == 16)\n-                {\n-                    png_uint_16* ptr = &reinterpret_cast<png_uint_16*>(row)[x * dimensions[2]];\n-\n-                    if (result_bit_depth == 16) {\n-                        for (png_uint_32 p = 0; p < (png_uint_32)dimensions[2]; p++)\n-                        {\n-                            *(png_uint_16*)(target_pixel + p*pstride) = ptr[p];\n+        for (png_uint_32 y = 0; y < height; y++) {\n+            png_byte *row = row_pointers[y];\n+            for (png_uint_32 x = 0; x < width; x++) {\n+                size_t offset = y * A->strides[0] + x * A->strides[1];\n+                if (bit_depth == 16) {\n+                    png_uint_16 *ptr = &reinterpret_cast<png_uint_16 *>(row)[x * dimensions[2]];\n+\n+                    if (bit_depth == 16) {\n+                        for (png_uint_32 p = 0; p < (png_uint_32)dimensions[2]; p++) {\n+                            *(png_uint_16 *)(A->data + offset + p *A->strides[2]) = ptr[p];\n                         }\n                     } else {\n-                        for (png_uint_32 p = 0; p < (png_uint_32)dimensions[2]; p++)\n-                        {\n-                            *(png_byte*)(target_pixel + p*pstride) = ptr[p] >> 8;\n+                        for (png_uint_32 p = 0; p < (png_uint_32)dimensions[2]; p++) {\n+                            *(png_byte *)(A->data + offset + p *A->strides[2]) = ptr[p] >> 8;\n                         }\n                     }\n-                }\n-                else\n-                {\n-                    png_byte* ptr = &(row[x * dimensions[2]]);\n-                    if (result_bit_depth == 16) {\n-                        for (png_uint_32 p = 0; p < (png_uint_32)dimensions[2]; p++)\n-                        {\n-                            *(png_uint_16*)(target_pixel + p*pstride) = ptr[p];\n+                } else {\n+                    png_byte *ptr = &(row[x * dimensions[2]]);\n+                    if (bit_depth == 16) {\n+                        for (png_uint_32 p = 0; p < (png_uint_32)dimensions[2]; p++) {\n+                            *(png_uint_16 *)(A->data + offset + p *A->strides[2]) = ptr[p];\n                         }\n                     } else {\n-                        for (png_uint_32 p = 0; p < (png_uint_32)dimensions[2]; p++)\n-                        {\n-                            *(png_byte*)(target_pixel + p*pstride) = ptr[p];\n+                        for (png_uint_32 p = 0; p < (png_uint_32)dimensions[2]; p++) {\n+                            *(png_byte *)(A->data + offset + p *A->strides[2]) = ptr[p];\n                         }\n                     }\n                 }\n             }\n         }\n     }\n \n-    //free the png memory\n+    // free the png memory\n     png_read_end(png_ptr, info_ptr);\n+\n+exit:\n+    if (png_ptr && info_ptr) {\n #ifndef png_infopp_NULL\n-    png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n+        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n #else\n-    png_destroy_read_struct(&png_ptr, &info_ptr, png_infopp_NULL);\n+        png_destroy_read_struct(&png_ptr, &info_ptr, png_infopp_NULL);\n #endif\n-    if (close_dup_file)\n-    {\n-        if (mpl_PyFile_DupClose(py_file, fp, offset)) {\n-          throw Py::RuntimeError(\"Error closing dupe file handle\");\n-        }\n     }\n \n-    if (close_file)\n-    {\n+    if (close_dup_file) {\n+        mpl_PyFile_DupClose(py_file, fp, offset);\n+    }\n+\n+    if (close_file) {\n         mpl_PyFile_CloseFile(py_file);\n         Py_DECREF(py_file);\n     }\n \n-    for (row = 0; row < height; row++)\n-    {\n-        delete [] row_pointers[row];\n+    for (png_uint_32 row = 0; row < height; row++) {\n+        delete[] row_pointers[row];\n     }\n-    delete [] row_pointers;\n \n     if (PyErr_Occurred()) {\n-        Py_DECREF((PyObject *)A);\n+        Py_XDECREF((PyObject *)A);\n         return NULL;\n     } else {\n         return (PyObject *)A;\n     }\n }\n \n-Py::Object\n-_png_module::read_png_float(const Py::Tuple& args)\n-{\n-    args.verify_length(1);\n-    return Py::asObject(_read_png(args[0], true));\n-}\n+const char *Py_read_png_float__doc__ = \"read_png_float(file)\";\n \n-Py::Object\n-_png_module::read_png_uint8(const Py::Tuple& args)\n+static PyObject *Py_read_png_float(PyObject *self, PyObject *args, PyObject *kwds)\n {\n-    throw Py::RuntimeError(\"read_png_uint8 is deprecated.  Use read_png_int instead.\");\n+    return _read_png(args, true);\n }\n \n-Py::Object\n-_png_module::read_png_int(const Py::Tuple& args)\n+const char *Py_read_png_int__doc__ = \"read_png_int(file)\";\n+\n+static PyObject *Py_read_png_int(PyObject *self, PyObject *args, PyObject *kwds)\n {\n-    args.verify_length(1);\n-    return Py::asObject(_read_png(args[0], false));\n+    return _read_png(args, false);\n }\n \n-PyMODINIT_FUNC\n+const char *Py_read_png__doc__ = \"read_png(file)\";\n+\n+static PyMethodDef module_methods[] = {\n+    {\"write_png\", (PyCFunction)Py_write_png, METH_VARARGS|METH_KEYWORDS, Py_write_png__doc__},\n+    {\"read_png\", (PyCFunction)Py_read_png_float, METH_O, Py_read_png__doc__},\n+    {\"read_png_float\", (PyCFunction)Py_read_png_float, METH_O, Py_read_png_float__doc__},\n+    {\"read_png_int\", (PyCFunction)Py_read_png_int, METH_O, Py_read_png_int__doc__},\n+    {NULL}\n+};\n+\n+extern \"C\" {\n+\n+    struct module_state\n+    {\n+        /* The Sun compiler can't handle empty structs */\n+#if defined(__SUNPRO_C) || defined(_MSC_VER)\n+        int _dummy;\n+#endif\n+    };\n+\n #if PY3K\n-PyInit__png(void)\n+    static struct PyModuleDef moduledef = {\n+        PyModuleDef_HEAD_INIT,\n+        \"_png\",\n+        NULL,\n+        sizeof(struct module_state),\n+        module_methods,\n+        NULL,\n+        NULL,\n+        NULL,\n+        NULL\n+    };\n+\n+#define INITERROR return NULL\n+\n+    PyMODINIT_FUNC PyInit__png(void)\n+\n #else\n-init_png(void)\n+#define INITERROR return\n+\n+    PyMODINIT_FUNC init_png(void)\n #endif\n-{\n-    import_array();\n \n-    static _png_module* _png = NULL;\n-    _png = new _png_module;\n+    {\n+        PyObject *m;\n \n #if PY3K\n-    return _png->module().ptr();\n+        m = PyModule_Create(&moduledef);\n+#else\n+        m = Py_InitModule3(\"_png\", module_methods, NULL);\n #endif\n+\n+        if (m == NULL) {\n+            INITERROR;\n+        }\n+\n+        import_array();\n+\n+#if PY3K\n+        return m;\n+#endif\n+    }\n }"
            },
            {
                "sha": "827e0db0deb0fdef9416332c34b03bb11884bd39",
                "filename": "src/_tkagg.cpp",
                "status": "modified",
                "additions": 77,
                "deletions": 120,
                "changes": 197,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_tkagg.cpp",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_tkagg.cpp",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/src%2F_tkagg.cpp?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787",
                "patch": "@@ -17,8 +17,8 @@\n #include <sstream>\n \n #include \"agg_basics.h\"\n-#include \"_backend_agg.h\"\n-#include \"agg_py_transforms.h\"\n+#include \"_backend_agg_wrapper.h\"\n+#include \"py_converters.h\"\n \n extern \"C\"\n {\n@@ -42,164 +42,138 @@ extern \"C\"\n \n typedef struct\n {\n-    PyObject_HEAD\n-    Tcl_Interp* interp;\n+    PyObject_HEAD;\n+    Tcl_Interp *interp;\n } TkappObject;\n \n-static int\n-PyAggImagePhoto(ClientData clientdata, Tcl_Interp* interp,\n-                int argc, char **argv)\n+static int PyAggImagePhoto(ClientData clientdata, Tcl_Interp *interp, int argc, char **argv)\n {\n     Tk_PhotoHandle photo;\n     Tk_PhotoImageBlock block;\n-    PyObject* aggo;\n+    PyObject *aggo;\n \n     // vars for blitting\n-    PyObject* bboxo;\n+    PyObject *bboxo;\n \n     size_t aggl, bboxl;\n     bool has_bbox;\n     agg::int8u *destbuffer;\n-    double l, b, r, t;\n     int destx, desty, destwidth, destheight, deststride;\n     //unsigned long tmp_ptr;\n \n     long mode;\n     long nval;\n-    if (Tk_MainWindow(interp) == NULL)\n-    {\n+    if (Tk_MainWindow(interp) == NULL) {\n         // Will throw a _tkinter.TclError with \"this isn't a Tk application\"\n         return TCL_ERROR;\n     }\n \n-    if (argc != 5)\n-    {\n-        Tcl_AppendResult(interp, \"usage: \", argv[0],\n-                         \" destPhoto srcImage\", (char *) NULL);\n+    if (argc != 5) {\n+        Tcl_AppendResult(interp, \"usage: \", argv[0], \" destPhoto srcImage\", (char *)NULL);\n         return TCL_ERROR;\n     }\n \n     /* get Tcl PhotoImage handle */\n     photo = Tk_FindPhoto(interp, argv[1]);\n-    if (photo == NULL)\n-    {\n-        Tcl_AppendResult(interp, \"destination photo must exist\", (char *) NULL);\n+    if (photo == NULL) {\n+        Tcl_AppendResult(interp, \"destination photo must exist\", (char *)NULL);\n         return TCL_ERROR;\n     }\n     /* get array (or object that can be converted to array) pointer */\n-    if (sscanf(argv[2], SIZE_T_FORMAT, &aggl) != 1)\n-    {\n-        Tcl_AppendResult(interp, \"error casting pointer\", (char *) NULL);\n+    if (sscanf(argv[2], SIZE_T_FORMAT, &aggl) != 1) {\n+        Tcl_AppendResult(interp, \"error casting pointer\", (char *)NULL);\n         return TCL_ERROR;\n     }\n-    aggo = (PyObject*)aggl;\n-    //aggo = (PyObject*)atol(argv[2]);\n-\n-    //std::stringstream agg_ptr_ss;\n-    //agg_ptr_ss.str(argv[2]);\n-    //agg_ptr_ss >> tmp_ptr;\n-    //aggo = (PyObject*)tmp_ptr;\n-    RendererAgg *aggRenderer = (RendererAgg *)aggo;\n+    aggo = (PyObject *)aggl;\n+\n+    // TODO: This is really brittle and will break when RendererAgg\n+    // comes in multiple flavors\n+    RendererAgg *aggRenderer = ((PyRendererAgg *)(aggo))->x;\n     int srcheight = (int)aggRenderer->get_height();\n \n     /* XXX insert aggRenderer type check */\n \n     /* get array mode (0=mono, 1=rgb, 2=rgba) */\n     mode = atol(argv[3]);\n-    if ((mode != 0) && (mode != 1) && (mode != 2))\n-    {\n-        Tcl_AppendResult(interp, \"illegal image mode\", (char *) NULL);\n+    if ((mode != 0) && (mode != 1) && (mode != 2)) {\n+        Tcl_AppendResult(interp, \"illegal image mode\", (char *)NULL);\n         return TCL_ERROR;\n     }\n \n     /* check for bbox/blitting */\n-    if (sscanf(argv[4], SIZE_T_FORMAT, &bboxl) != 1)\n-    {\n-        Tcl_AppendResult(interp, \"error casting pointer\", (char *) NULL);\n+    if (sscanf(argv[4], SIZE_T_FORMAT, &bboxl) != 1) {\n+        Tcl_AppendResult(interp, \"error casting pointer\", (char *)NULL);\n         return TCL_ERROR;\n     }\n-    bboxo = (PyObject*)bboxl;\n-\n-    //bboxo = (PyObject*)atol(argv[4]);\n-    //std::stringstream bbox_ptr_ss;\n-    //bbox_ptr_ss.str(argv[4]);\n-    //bbox_ptr_ss >> tmp_ptr;\n-    //bboxo = (PyObject*)tmp_ptr;\n-    if (py_convert_bbox(bboxo, l, b, r, t))\n-    {\n+    bboxo = (PyObject *)bboxl;\n+\n+    if (bboxo != NULL && bboxo != Py_None) {\n+        agg::rect_d rect;\n+        if (!convert_rect(bboxo, &rect)) {\n+            return TCL_ERROR;\n+        }\n+\n         has_bbox = true;\n \n-        destx = (int)l;\n-        desty = srcheight - (int)t;\n-        destwidth = (int)(r - l);\n-        destheight = (int)(t - b);\n+        destx = (int)rect.x1;\n+        desty = srcheight - (int)rect.y2;\n+        destwidth = (int)(rect.x2 - rect.x1);\n+        destheight = (int)(rect.y2 - rect.y1);\n         deststride = 4 * destwidth;\n \n-        destbuffer = new agg::int8u[deststride*destheight];\n-        if (destbuffer == NULL)\n-        {\n-            throw Py::MemoryError(\"_tkagg could not allocate memory for destbuffer\");\n+        destbuffer = new agg::int8u[deststride * destheight];\n+        if (destbuffer == NULL) {\n+            Tcl_AppendResult(interp, \"could not allocate memory\", (char *)NULL);\n+            return TCL_ERROR;\n         }\n \n         agg::rendering_buffer destrbuf;\n         destrbuf.attach(destbuffer, destwidth, destheight, deststride);\n         pixfmt destpf(destrbuf);\n         renderer_base destrb(destpf);\n \n-        agg::rect_base<int> region(destx, desty, (int)r, srcheight - (int)b);\n-        destrb.copy_from(aggRenderer->renderingBuffer, &region,\n-                         -destx, -desty);\n-    }\n-    else\n-    {\n+        agg::rect_base<int> region(destx, desty, (int)rect.x2, srcheight - (int)rect.y1);\n+        destrb.copy_from(aggRenderer->renderingBuffer, &region, -destx, -desty);\n+    } else {\n         has_bbox = false;\n         destbuffer = NULL;\n         destx = desty = destwidth = destheight = deststride = 0;\n     }\n \n     /* setup tkblock */\n     block.pixelSize = 1;\n-    if (mode == 0)\n-    {\n+    if (mode == 0) {\n         block.offset[0] = block.offset[1] = block.offset[2] = 0;\n         nval = 1;\n-    }\n-    else\n-    {\n+    } else {\n         block.offset[0] = 0;\n         block.offset[1] = 1;\n         block.offset[2] = 2;\n-        if (mode == 1)\n-        {\n+        if (mode == 1) {\n             block.offset[3] = 0;\n             block.pixelSize = 3;\n             nval = 3;\n-        }\n-        else\n-        {\n+        } else {\n             block.offset[3] = 3;\n             block.pixelSize = 4;\n             nval = 4;\n         }\n     }\n \n-    if (has_bbox)\n-    {\n-        block.width  = destwidth;\n+    if (has_bbox) {\n+        block.width = destwidth;\n         block.height = destheight;\n         block.pitch = deststride;\n         block.pixelPtr = destbuffer;\n \n         Tk_PhotoPutBlock(photo, &block, destx, desty, destwidth, destheight);\n-        delete [] destbuffer;\n+        delete[] destbuffer;\n \n-    }\n-    else\n-    {\n-        block.width  = aggRenderer->get_width();\n+    } else {\n+        block.width = aggRenderer->get_width();\n         block.height = aggRenderer->get_height();\n-        block.pitch = block.width * nval;\n-        block.pixelPtr =  aggRenderer->pixBuffer;\n+        block.pitch = (int)block.width * nval;\n+        block.pixelPtr = aggRenderer->pixBuffer;\n \n         /* Clear current contents */\n         Tk_PhotoBlank(photo);\n@@ -210,75 +184,60 @@ PyAggImagePhoto(ClientData clientdata, Tcl_Interp* interp,\n     return TCL_OK;\n }\n \n-\n-static PyObject *\n-_pyobj_addr(PyObject* self, PyObject* args)\n+static PyObject *_pyobj_addr(PyObject *self, PyObject *args)\n {\n     PyObject *pyobj;\n-    if (!PyArg_ParseTuple(args, \"O\", &pyobj))\n-    {\n+    if (!PyArg_ParseTuple(args, \"O\", &pyobj)) {\n         return NULL;\n     }\n-    return Py_BuildValue(\"n\", (Py_ssize_t) pyobj);\n+    return Py_BuildValue(\"n\", (Py_ssize_t)pyobj);\n }\n \n-static PyObject*\n-_tkinit(PyObject* self, PyObject* args)\n+static PyObject *_tkinit(PyObject *self, PyObject *args)\n {\n-    Tcl_Interp* interp;\n-    TkappObject* app;\n+    Tcl_Interp *interp;\n+    TkappObject *app;\n \n     Py_ssize_t arg;\n     int is_interp;\n-    if (!PyArg_ParseTuple(args, \"ni\", &arg, &is_interp))\n-    {\n+    if (!PyArg_ParseTuple(args, \"ni\", &arg, &is_interp)) {\n         return NULL;\n     }\n \n-    if (is_interp)\n-    {\n-        interp = (Tcl_Interp*) arg;\n-    }\n-    else\n-    {\n+    if (is_interp) {\n+        interp = (Tcl_Interp *)arg;\n+    } else {\n         /* Do it the hard way.  This will break if the TkappObject\n            layout changes */\n-        app = (TkappObject*) arg;\n+        app = (TkappObject *)arg;\n         interp = app->interp;\n     }\n \n     /* This will bomb if interp is invalid... */\n \n-    Tcl_CreateCommand(interp, \"PyAggImagePhoto\",\n-                      (Tcl_CmdProc *) PyAggImagePhoto,\n-                      (ClientData) 0, (Tcl_CmdDeleteProc*) NULL);\n+    Tcl_CreateCommand(interp,\n+                      \"PyAggImagePhoto\",\n+                      (Tcl_CmdProc *)PyAggImagePhoto,\n+                      (ClientData)0,\n+                      (Tcl_CmdDeleteProc *)NULL);\n \n     Py_INCREF(Py_None);\n     return Py_None;\n }\n \n-static PyMethodDef functions[] =\n-{\n+static PyMethodDef functions[] = {\n     /* Tkinter interface stuff */\n-    {\"_pyobj_addr\", (PyCFunction)_pyobj_addr, 1},\n-    {\"tkinit\", (PyCFunction)_tkinit, 1},\n-    {NULL, NULL} /* sentinel */\n+    { \"_pyobj_addr\", (PyCFunction)_pyobj_addr, 1 }, { \"tkinit\", (PyCFunction)_tkinit, 1 },\n+    { NULL, NULL } /* sentinel */\n };\n \n #if PY3K\n-static PyModuleDef _tkagg_module = {\n-    PyModuleDef_HEAD_INIT,\n-    \"_tkagg\",\n-    \"\",\n-    -1,\n-    functions,\n-    NULL, NULL, NULL, NULL\n-};\n+static PyModuleDef _tkagg_module = { PyModuleDef_HEAD_INIT, \"_tkagg\", \"\",   -1,  functions,\n+                                     NULL,                  NULL,     NULL, NULL };\n \n-PyMODINIT_FUNC\n-PyInit__tkagg(void)\n+PyMODINIT_FUNC PyInit__tkagg(void)\n {\n-    PyObject* m;\n+    PyObject *m;\n \n     m = PyModule_Create(&_tkagg_module);\n \n@@ -287,12 +246,10 @@ PyInit__tkagg(void)\n     return m;\n }\n #else\n-PyMODINIT_FUNC\n-init_tkagg(void)\n+PyMODINIT_FUNC init_tkagg(void)\n {\n     import_array();\n \n     Py_InitModule(\"_tkagg\", functions);\n }\n #endif\n-"
            },
            {
                "sha": "e0aa4611d28d681454082f7436f028fc91aa56c0",
                "filename": "src/_ttconv.cpp",
                "status": "modified",
                "additions": 79,
                "deletions": 100,
                "changes": 179,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_ttconv.cpp",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2F_ttconv.cpp",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/src%2F_ttconv.cpp?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787",
                "patch": "@@ -10,23 +10,19 @@\n \n #include <Python.h>\n #include \"ttconv/pprdrv.h\"\n+#include \"py_exceptions.h\"\n #include <vector>\n #include <cassert>\n \n-class PythonExceptionOccurred\n-{\n-\n-};\n-\n /**\n  * An implementation of TTStreamWriter that writes to a Python\n  * file-like object.\n  */\n class PythonFileWriter : public TTStreamWriter\n {\n-    PyObject* _write_method;\n+    PyObject *_write_method;\n \n-public:\n+  public:\n     PythonFileWriter()\n     {\n         _write_method = NULL;\n@@ -37,41 +33,38 @@ class PythonFileWriter : public TTStreamWriter\n         Py_XDECREF(_write_method);\n     }\n \n-    void set(PyObject* write_method)\n+    void set(PyObject *write_method)\n     {\n         Py_XDECREF(_write_method);\n         _write_method = write_method;\n         Py_XINCREF(_write_method);\n     }\n \n-    virtual void write(const char* a)\n+    virtual void write(const char *a)\n     {\n-        PyObject* result = NULL;\n-        if (_write_method)\n-        {\n-            PyObject* decoded = NULL;\n+        PyObject *result = NULL;\n+        if (_write_method) {\n+            PyObject *decoded = NULL;\n             decoded = PyUnicode_DecodeLatin1(a, strlen(a), \"\");\n             if (decoded == NULL) {\n-                throw PythonExceptionOccurred();\n+                throw py::exception();\n             }\n-            result = PyObject_CallFunction(_write_method, \"O\", decoded);\n+            result = PyObject_CallFunction(_write_method, (char *)\"O\", decoded);\n             Py_DECREF(decoded);\n-            if (! result)\n-            {\n-                throw PythonExceptionOccurred();\n+            if (!result) {\n+                throw py::exception();\n             }\n             Py_DECREF(result);\n         }\n     }\n };\n \n-int fileobject_to_PythonFileWriter(PyObject* object, void* address)\n+int fileobject_to_PythonFileWriter(PyObject *object, void *address)\n {\n-    PythonFileWriter* file_writer = (PythonFileWriter*)address;\n+    PythonFileWriter *file_writer = (PythonFileWriter *)address;\n \n-    PyObject* write_method = PyObject_GetAttrString(object, \"write\");\n-    if (write_method == NULL || ! PyCallable_Check(write_method))\n-    {\n+    PyObject *write_method = PyObject_GetAttrString(object, \"write\");\n+    if (write_method == NULL || !PyCallable_Check(write_method)) {\n         PyErr_SetString(PyExc_TypeError, \"Expected a file-like object with a write method.\");\n         return 0;\n     }\n@@ -82,69 +75,60 @@ int fileobject_to_PythonFileWriter(PyObject* object, void* address)\n     return 1;\n }\n \n-int pyiterable_to_vector_int(PyObject* object, void* address)\n+int pyiterable_to_vector_int(PyObject *object, void *address)\n {\n-    std::vector<int>* result = (std::vector<int>*)address;\n+    std::vector<int> *result = (std::vector<int> *)address;\n \n-    PyObject* iterator = PyObject_GetIter(object);\n-    if (! iterator)\n-    {\n+    PyObject *iterator = PyObject_GetIter(object);\n+    if (!iterator) {\n         return 0;\n     }\n \n-    PyObject* item;\n-    while ((item = PyIter_Next(iterator)))\n-    {\n-        #if PY3K\n+    PyObject *item;\n+    while ((item = PyIter_Next(iterator))) {\n+#if PY3K\n         long value = PyLong_AsLong(item);\n-        #else\n+#else\n         long value = PyInt_AsLong(item);\n-        #endif\n+#endif\n         Py_DECREF(item);\n-        if (value == -1 && PyErr_Occurred())\n-        {\n+        if (value == -1 && PyErr_Occurred()) {\n             return 0;\n         }\n-        result->push_back(value);\n+        result->push_back((int)value);\n     }\n \n     Py_DECREF(iterator);\n \n     return 1;\n }\n \n-static PyObject*\n-convert_ttf_to_ps(PyObject* self, PyObject* args, PyObject* kwds)\n+static PyObject *convert_ttf_to_ps(PyObject *self, PyObject *args, PyObject *kwds)\n {\n-    const char*         filename;\n-    PythonFileWriter    output;\n-    int                 fonttype;\n-    std::vector<int>    glyph_ids;\n-\n-    static const char *kwlist[] =\n-    {\n-        \"filename\", \"output\", \"fonttype\", \"glyph_ids\", NULL\n-    };\n-    if (! PyArg_ParseTupleAndKeywords\n-        (args, kwds,\n-         #if PY_MAJOR_VERSION == 3\n-         \"yO&i|O&:convert_ttf_to_ps\",\n-         #else\n-         \"sO&i|O&:convert_ttf_to_ps\",\n-         #endif\n-         (char**)kwlist,\n-         &filename,\n-         fileobject_to_PythonFileWriter,\n-         &output,\n-         &fonttype,\n-         pyiterable_to_vector_int,\n-         &glyph_ids))\n-    {\n+    const char *filename;\n+    PythonFileWriter output;\n+    int fonttype;\n+    std::vector<int> glyph_ids;\n+\n+    static const char *kwlist[] = { \"filename\", \"output\", \"fonttype\", \"glyph_ids\", NULL };\n+    if (!PyArg_ParseTupleAndKeywords(args,\n+                                     kwds,\n+#if PY_MAJOR_VERSION == 3\n+                                     \"yO&i|O&:convert_ttf_to_ps\",\n+#else\n+                                     \"sO&i|O&:convert_ttf_to_ps\",\n+#endif\n+                                     (char **)kwlist,\n+                                     &filename,\n+                                     fileobject_to_PythonFileWriter,\n+                                     &output,\n+                                     &fonttype,\n+                                     pyiterable_to_vector_int,\n+                                     &glyph_ids)) {\n         return NULL;\n     }\n \n-    if (fonttype != 3 && fonttype != 42)\n-    {\n+    if (fonttype != 3 && fonttype != 42) {\n         PyErr_SetString(PyExc_ValueError,\n                         \"fonttype must be either 3 (raw Postscript) or 42 \"\n                         \"(embedded Truetype)\");\n@@ -155,12 +139,12 @@ convert_ttf_to_ps(PyObject* self, PyObject* args, PyObject* kwds)\n     {\n         insert_ttfont(filename, output, (font_type_enum)fonttype, glyph_ids);\n     }\n-    catch (TTException& e)\n+    catch (TTException &e)\n     {\n         PyErr_SetString(PyExc_RuntimeError, e.getMessage());\n         return NULL;\n     }\n-    catch (PythonExceptionOccurred&)\n+    catch (const py::exception &)\n     {\n         return NULL;\n     }\n@@ -176,58 +160,53 @@ convert_ttf_to_ps(PyObject* self, PyObject* args, PyObject* kwds)\n \n class PythonDictionaryCallback : public TTDictionaryCallback\n {\n-    PyObject* _dict;\n+    PyObject *_dict;\n \n-public:\n-    PythonDictionaryCallback(PyObject* dict)\n+  public:\n+    PythonDictionaryCallback(PyObject *dict)\n     {\n         _dict = dict;\n     }\n \n-    virtual void add_pair(const char* a, const char* b)\n+    virtual void add_pair(const char *a, const char *b)\n     {\n         assert(a != NULL);\n         assert(b != NULL);\n-        PyObject* value = PyBytes_FromString(b);\n-        if (!value)\n-        {\n-            throw PythonExceptionOccurred();\n+        PyObject *value = PyBytes_FromString(b);\n+        if (!value) {\n+            throw py::exception();\n         }\n-        if (PyDict_SetItemString(_dict, a, value))\n-        {\n+        if (PyDict_SetItemString(_dict, a, value)) {\n             Py_DECREF(value);\n-            throw PythonExceptionOccurred();\n+            throw py::exception();\n         }\n         Py_DECREF(value);\n     }\n };\n \n-static PyObject*\n-py_get_pdf_charprocs(PyObject* self, PyObject* args, PyObject* kwds)\n+static PyObject *py_get_pdf_charprocs(PyObject *self, PyObject *args, PyObject *kwds)\n {\n-    const char*         filename;\n-    std::vector<int>    glyph_ids;\n-    PyObject*             result;\n+    const char *filename;\n+    std::vector<int> glyph_ids;\n+    PyObject *result;\n \n     static const char *kwlist[] = { \"filename\", \"glyph_ids\", NULL };\n-    if (! PyArg_ParseTupleAndKeywords\n-            (args, kwds,\n-             #if PY_MAJOR_VERSION == 3\n-             \"y|O&:get_pdf_charprocs\",\n-             #else\n-             \"s|O&:get_pdf_charprocs\",\n-             #endif\n-             (char **)kwlist,\n-             &filename,\n-             pyiterable_to_vector_int,\n-             &glyph_ids))\n-    {\n+    if (!PyArg_ParseTupleAndKeywords(args,\n+                                     kwds,\n+#if PY_MAJOR_VERSION == 3\n+                                     \"y|O&:get_pdf_charprocs\",\n+#else\n+                                     \"s|O&:get_pdf_charprocs\",\n+#endif\n+                                     (char **)kwlist,\n+                                     &filename,\n+                                     pyiterable_to_vector_int,\n+                                     &glyph_ids)) {\n         return NULL;\n     }\n \n     result = PyDict_New();\n-    if (!result)\n-    {\n+    if (!result) {\n         return NULL;\n     }\n \n@@ -237,13 +216,13 @@ py_get_pdf_charprocs(PyObject* self, PyObject* args, PyObject* kwds)\n     {\n         ::get_pdf_charprocs(filename, glyph_ids, dict);\n     }\n-    catch (TTException& e)\n+    catch (TTException &e)\n     {\n         Py_DECREF(result);\n         PyErr_SetString(PyExc_RuntimeError, e.getMessage());\n         return NULL;\n     }\n-    catch (PythonExceptionOccurred&)\n+    catch (const py::exception &)\n     {\n         Py_DECREF(result);\n         return NULL;\n@@ -295,7 +274,7 @@ static PyMethodDef ttconv_methods[] =\n     {0, 0, 0, 0}  /* Sentinel */\n };\n \n-static const char* module_docstring =\n+static const char *module_docstring =\n     \"Module to handle converting and subsetting TrueType \"\n     \"fonts to Postscript Type 3, Postscript Type 42 and \"\n     \"Pdf Type 3 fonts.\";"
            },
            {
                "sha": "07aeb4325cc04483645c6795fa0fa552259f0e1b",
                "filename": "src/agg_py_path_iterator.h",
                "status": "removed",
                "additions": 0,
                "deletions": 137,
                "changes": 137,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/dbeed94d578c458d31842cd13c04f665155986cb/src%2Fagg_py_path_iterator.h",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/dbeed94d578c458d31842cd13c04f665155986cb/src%2Fagg_py_path_iterator.h",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/src%2Fagg_py_path_iterator.h?ref=dbeed94d578c458d31842cd13c04f665155986cb",
                "patch": "@@ -1,137 +0,0 @@\n-/* -*- mode: c++; c-basic-offset: 4 -*- */\n-\n-#ifndef __AGG_PY_PATH_ITERATOR_H__\n-#define __AGG_PY_PATH_ITERATOR_H__\n-\n-#include \"CXX/Objects.hxx\"\n-#include \"numpy/arrayobject.h\"\n-#include \"agg_path_storage.h\"\n-\n-/*\n- This file contains a vertex source to adapt Python Numpy arrays to\n- Agg paths.  It works as an iterator, and converts on-the-fly without\n- the need for a full copy of the data.\n- */\n-\n-/************************************************************\n- PathIterator acts as a bridge between Numpy and Agg.  Given a pair of\n- Numpy arrays, vertices and codes, it iterates over those vertices and\n- codes, using the standard Agg vertex source interface:\n-\n-    unsigned vertex(double* x, double* y)\n- */\n-class PathIterator\n-{\n-    /* We hold references to the Python objects, not just the\n-       underlying data arrays, so that Python reference counting can\n-       work.\n-    */\n-    Py::Object m_vertices;\n-    Py::Object m_codes;\n-\n-    size_t m_iterator;\n-    size_t m_total_vertices;\n-\n-    /* This class doesn't actually do any simplification, but we\n-       store the value here, since it is obtained from the Python object.\n-    */\n-    bool m_should_simplify;\n-    double m_simplify_threshold;\n-\n-public:\n-    /* path_obj is an instance of the class Path as defined in path.py */\n-    inline PathIterator(const Py::Object& path_obj) :\n-            m_vertices(), m_codes(), m_iterator(0), m_should_simplify(false),\n-            m_simplify_threshold(1.0 / 9.0)\n-    {\n-        Py::Object vertices_obj           = path_obj.getAttr(\"vertices\");\n-        Py::Object codes_obj              = path_obj.getAttr(\"codes\");\n-        Py::Object should_simplify_obj    = path_obj.getAttr(\"should_simplify\");\n-        Py::Object simplify_threshold_obj = path_obj.getAttr(\"simplify_threshold\");\n-\n-        PyObject* vertices_arr = PyArray_FromObject(vertices_obj.ptr(), NPY_DOUBLE, 2, 2);\n-        if (!vertices_arr)\n-        {\n-            throw Py::ValueError(\"Invalid vertices array.\");\n-        }\n-\n-        m_vertices = Py::Object(vertices_arr, true);\n-        if (PyArray_DIM((PyArrayObject*)m_vertices.ptr(), 1) != 2)\n-        {\n-            throw Py::ValueError(\"Invalid vertices array.\");\n-        }\n-\n-        if (codes_obj.ptr() != Py_None)\n-        {\n-            PyObject* codes_arr = PyArray_FromObject(codes_obj.ptr(), NPY_UINT8, 1, 1);\n-\n-            if (!codes_arr)\n-            {\n-                throw Py::ValueError(\"Invalid codes array.\");\n-            }\n-\n-            m_codes = Py::Object(codes_arr, true);\n-            if (PyArray_DIM((PyArrayObject*)m_codes.ptr(), 0) !=\n-                PyArray_DIM((PyArrayObject*)m_vertices.ptr(), 0))\n-            {\n-                throw Py::ValueError(\"Codes array is wrong length\");\n-            }\n-        }\n-\n-        m_should_simplify    = should_simplify_obj.isTrue();\n-        m_total_vertices     = PyArray_DIM((PyArrayObject*)m_vertices.ptr(), 0);\n-        m_simplify_threshold = Py::Float(simplify_threshold_obj);\n-    }\n-\n-    ~PathIterator()\n-    {\n-\n-    }\n-\n-    inline unsigned vertex(double* x, double* y)\n-    {\n-        if (m_iterator >= m_total_vertices) return agg::path_cmd_stop;\n-\n-        const size_t idx = m_iterator++;\n-\n-        char* pair = (char*)PyArray_GETPTR2((PyArrayObject*)m_vertices.ptr(), idx, 0);\n-        *x = *(double*)pair;\n-        *y = *(double*)(pair + PyArray_STRIDE((PyArrayObject*)m_vertices.ptr(), 1));\n-\n-        if (!m_codes.isNone())\n-        {\n-            return (unsigned)(*(char *)PyArray_GETPTR1((PyArrayObject*)m_codes.ptr(), idx));\n-        }\n-        else\n-        {\n-            return idx == 0 ? agg::path_cmd_move_to : agg::path_cmd_line_to;\n-        }\n-    }\n-\n-    inline void rewind(unsigned path_id)\n-    {\n-        m_iterator = path_id;\n-    }\n-\n-    inline unsigned total_vertices()\n-    {\n-        return m_total_vertices;\n-    }\n-\n-    inline bool should_simplify()\n-    {\n-        return m_should_simplify;\n-    }\n-\n-    inline double simplify_threshold()\n-    {\n-        return m_simplify_threshold;\n-    }\n-\n-    inline bool has_curves()\n-    {\n-        return !m_codes.isNone();\n-    }\n-};\n-\n-#endif // __AGG_PY_PATH_ITERATOR_H__"
            },
            {
                "sha": "c9a1b501a7df8e7aaef012a320624d4d6602d922",
                "filename": "src/agg_py_transforms.cpp",
                "status": "removed",
                "additions": 0,
                "deletions": 127,
                "changes": 127,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/dbeed94d578c458d31842cd13c04f665155986cb/src%2Fagg_py_transforms.cpp",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/dbeed94d578c458d31842cd13c04f665155986cb/src%2Fagg_py_transforms.cpp",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/src%2Fagg_py_transforms.cpp?ref=dbeed94d578c458d31842cd13c04f665155986cb",
                "patch": "@@ -1,127 +0,0 @@\n-/* -*- mode: c++; c-basic-offset: 4 -*- */\n-\n-#include <Python.h>\n-\n-#define NO_IMPORT_ARRAY\n-#include \"numpy/arrayobject.h\"\n-\n-#include \"CXX/Objects.hxx\"\n-#include \"agg_trans_affine.h\"\n-\n-/** A helper function to convert from a Numpy affine transformation matrix\n- *  to an agg::trans_affine. If errors = false then an Identity transform is returned.\n- */\n-agg::trans_affine\n-py_to_agg_transformation_matrix(PyObject* obj, bool errors = true)\n-{\n-    PyArrayObject* matrix = NULL;\n-\n-    /** If None either raise a TypeError or return an agg identity transform. */\n-    if (obj == Py_None)\n-    {\n-        if (errors)\n-        {\n-            throw Py::TypeError(\"Cannot convert None to an affine transform.\");\n-        }\n-\n-        return agg::trans_affine();\n-    }\n-\n-    /** Try turning the object into an affine transform matrix. */\n-    try\n-    {\n-        matrix = (PyArrayObject*) PyArray_FromObject(obj, NPY_DOUBLE, 2, 2);\n-        if (!matrix) {\n-            PyErr_Clear();\n-            throw std::exception();\n-        }\n-    }\n-    catch (...)\n-    {\n-        Py_XDECREF(matrix);\n-        if (errors)\n-        {\n-            throw Py::TypeError(\"Unable to get an affine transform matrix from the given object.\");\n-        }\n-\n-        return agg::trans_affine();\n-    }\n-\n-    /** Try turning the matrix into an agg transform. */\n-    try\n-    {\n-        if (PyArray_NDIM(matrix) == 2 || PyArray_DIM(matrix, 0) == 3 || PyArray_DIM(matrix, 1) == 3)\n-        {\n-            size_t stride0 = PyArray_STRIDE(matrix, 0);\n-            size_t stride1 = PyArray_STRIDE(matrix, 1);\n-            char* row0 = PyArray_BYTES(matrix);\n-            char* row1 = row0 + stride0;\n-\n-            double a = *(double*)(row0);\n-            row0 += stride1;\n-            double c = *(double*)(row0);\n-            row0 += stride1;\n-            double e = *(double*)(row0);\n-\n-            double b = *(double*)(row1);\n-            row1 += stride1;\n-            double d = *(double*)(row1);\n-            row1 += stride1;\n-            double f = *(double*)(row1);\n-\n-            Py_XDECREF(matrix);\n-\n-            return agg::trans_affine(a, b, c, d, e, f);\n-        }\n-\n-        throw std::exception();\n-    }\n-    catch (...)\n-    {\n-        if (errors)\n-        {\n-            Py_XDECREF(matrix);\n-            throw Py::TypeError(\"Invalid affine transformation matrix.\");\n-        }\n-    }\n-\n-    Py_XDECREF(matrix);\n-    return agg::trans_affine();\n-}\n-\n-bool\n-py_convert_bbox(PyObject* bbox_obj, double& l, double& b, double& r, double& t)\n-{\n-    PyArrayObject* bbox = NULL;\n-\n-    if (bbox_obj == Py_None)\n-        return false;\n-\n-    try\n-    {\n-        bbox = (PyArrayObject*) PyArray_FromObject(bbox_obj, NPY_DOUBLE, 2, 2);\n-\n-        if (!bbox || PyArray_NDIM(bbox) != 2 || PyArray_DIM(bbox, 0) != 2 || PyArray_DIM(bbox, 1) != 2)\n-        {\n-            throw Py::TypeError\n-            (\"Expected a bbox array\");\n-        }\n-\n-        l = *(double*)PyArray_GETPTR2(bbox, 0, 0);\n-        b = *(double*)PyArray_GETPTR2(bbox, 0, 1);\n-        r = *(double*)PyArray_GETPTR2(bbox, 1, 0);\n-        t = *(double*)PyArray_GETPTR2(bbox, 1, 1);\n-\n-        Py_XDECREF(bbox);\n-        bbox = NULL;\n-        return true;\n-    }\n-    catch (...)\n-    {\n-        Py_XDECREF(bbox);\n-        bbox = NULL;\n-        throw;\n-    }\n-\n-    return false;\n-}"
            },
            {
                "sha": "db66a2ff4d7913a0ad1be60ff4697a44e2a7a7a2",
                "filename": "src/agg_py_transforms.h",
                "status": "removed",
                "additions": 0,
                "deletions": 17,
                "changes": 17,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/dbeed94d578c458d31842cd13c04f665155986cb/src%2Fagg_py_transforms.h",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/dbeed94d578c458d31842cd13c04f665155986cb/src%2Fagg_py_transforms.h",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/src%2Fagg_py_transforms.h?ref=dbeed94d578c458d31842cd13c04f665155986cb",
                "patch": "@@ -1,17 +0,0 @@\n-/* -*- mode: c++; c-basic-offset: 4 -*- */\n-\n-#ifndef __AGG_PY_TRANSFORMS_H__\n-#define __AGG_PY_TRANSFORMS_H__\n-\n-#include \"agg_trans_affine.h\"\n-\n-/** A helper function to convert from a Numpy affine transformation matrix\n- *  to an agg::trans_affine.\n- */\n-agg::trans_affine\n-py_to_agg_transformation_matrix(PyObject* obj, bool errors = true);\n-\n-bool\n-py_convert_bbox(PyObject* bbox_obj, double& l, double& b, double& r, double& t);\n-\n-#endif // __AGG_PY_TRANSFORMS_H__"
            },
            {
                "sha": "349b900066abed3adb1a644c23facb8a228e60f0",
                "filename": "src/array.h",
                "status": "added",
                "additions": 80,
                "deletions": 0,
                "changes": 80,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2Farray.h",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2Farray.h",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/src%2Farray.h?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787",
                "patch": "@@ -0,0 +1,80 @@\n+/* -*- mode: c++; c-basic-offset: 4 -*- */\n+\n+/* Utilities to create scalars and empty arrays that behave like the\n+   Numpy array wrappers in numpy_cpp.h */\n+\n+#ifndef _SCALAR_H_\n+#define _SCALAR_H_\n+\n+namespace array\n+{\n+\n+template <typename T, int ND>\n+class scalar\n+{\n+  public:\n+    T m_value;\n+\n+    scalar(const T value) : m_value(value)\n+    {\n+    }\n+\n+    T &operator()(int i, int j = 0, int k = 0)\n+    {\n+        return m_value;\n+    }\n+\n+    const T &operator()(int i, int j = 0, int k = 0) const\n+    {\n+        return m_value;\n+    }\n+\n+    int dim(size_t i)\n+    {\n+        return 1;\n+    }\n+\n+    size_t size()\n+    {\n+        return 1;\n+    }\n+};\n+\n+template <typename T>\n+class empty\n+{\n+  public:\n+    typedef empty<T> sub_t;\n+\n+    empty()\n+    {\n+    }\n+\n+    T &operator()(int i, int j = 0, int k = 0)\n+    {\n+        throw \"Accessed empty array\";\n+    }\n+\n+    const T &operator()(int i, int j = 0, int k = 0) const\n+    {\n+        throw \"Accessed empty array\";\n+    }\n+\n+    sub_t operator[](int i) const\n+    {\n+        return empty<T>();\n+    }\n+\n+    int dim(size_t i) const\n+    {\n+        return 0;\n+    }\n+\n+    size_t size() const\n+    {\n+        return 0;\n+    }\n+};\n+}\n+\n+#endif"
            },
            {
                "sha": "a8f04eaeddca8884ca2c67896dc224c0650ba735",
                "filename": "src/file_compat.h",
                "status": "modified",
                "additions": 38,
                "deletions": 33,
                "changes": 71,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2Ffile_compat.h",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2Ffile_compat.h",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/src%2Ffile_compat.h?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787",
                "patch": "@@ -10,12 +10,11 @@\n #ifdef __cplusplus\n extern \"C\" {\n #endif\n-\n #if defined(_MSC_VER) && defined(_WIN64) && (_MSC_VER > 1400)\n     #include <io.h>\n-    #define npy_fseek _fseeki64\n-    #define npy_ftell _ftelli64\n-    #define npy_lseek _lseeki64\n+    #define mpl_fseek _fseeki64\n+    #define mpl_ftell _ftelli64\n+    #define mpl_lseek _lseeki64\n     #define mpl_off_t npy_int64\n \n     #if NPY_SIZEOF_INT == 8\n@@ -28,9 +27,9 @@ extern \"C\" {\n         #error Unsupported size for type off_t\n     #endif\n #else\n-    #define npy_fseek fseek\n-    #define npy_ftell ftell\n-    #define npy_lseek lseek\n+    #define mpl_fseek fseek\n+    #define mpl_ftell ftell\n+    #define mpl_lseek lseek\n     #define mpl_off_t off_t\n \n     #if NPY_SIZEOF_INT == NPY_SIZEOF_SHORT\n@@ -54,16 +53,15 @@ extern \"C\" {\n /*\n  * Get a FILE* handle to the file represented by the Python object\n  */\n-static NPY_INLINE FILE*\n-mpl_PyFile_Dup(PyObject *file, char *mode, mpl_off_t *orig_pos)\n+static NPY_INLINE FILE *mpl_PyFile_Dup(PyObject *file, char *mode, mpl_off_t *orig_pos)\n {\n     int fd, fd2;\n     PyObject *ret, *os;\n     mpl_off_t pos;\n     FILE *handle;\n \n     /* Flush first to ensure things end up in the file in the correct order */\n-    ret = PyObject_CallMethod(file, \"flush\", \"\");\n+    ret = PyObject_CallMethod(file, (char *)\"flush\", (char *)\"\");\n     if (ret == NULL) {\n         return NULL;\n     }\n@@ -79,34 +77,33 @@ mpl_PyFile_Dup(PyObject *file, char *mode, mpl_off_t *orig_pos)\n     if (os == NULL) {\n         return NULL;\n     }\n-    ret = PyObject_CallMethod(os, \"dup\", \"i\", fd);\n+    ret = PyObject_CallMethod(os, (char *)\"dup\", (char *)\"i\", fd);\n     Py_DECREF(os);\n     if (ret == NULL) {\n         return NULL;\n     }\n     fd2 = PyNumber_AsSsize_t(ret, NULL);\n     Py_DECREF(ret);\n \n-    /* Convert to FILE* handle */\n+/* Convert to FILE* handle */\n #ifdef _WIN32\n     handle = _fdopen(fd2, mode);\n #else\n     handle = fdopen(fd2, mode);\n #endif\n     if (handle == NULL) {\n-        PyErr_SetString(PyExc_IOError,\n-                        \"Getting a FILE* from a Python file object failed\");\n+        PyErr_SetString(PyExc_IOError, \"Getting a FILE* from a Python file object failed\");\n     }\n \n     /* Record the original raw file handle position */\n-    *orig_pos = npy_ftell(handle);\n+    *orig_pos = mpl_ftell(handle);\n     if (*orig_pos == -1) {\n         // handle is a stream, so we don't have to worry about this\n         return handle;\n     }\n \n     /* Seek raw handle to the Python-side position */\n-    ret = PyObject_CallMethod(file, \"tell\", \"\");\n+    ret = PyObject_CallMethod(file, (char *)\"tell\", (char *)\"\");\n     if (ret == NULL) {\n         fclose(handle);\n         return NULL;\n@@ -117,7 +114,7 @@ mpl_PyFile_Dup(PyObject *file, char *mode, mpl_off_t *orig_pos)\n         fclose(handle);\n         return NULL;\n     }\n-    if (npy_fseek(handle, pos, SEEK_SET) == -1) {\n+    if (mpl_fseek(handle, pos, SEEK_SET) == -1) {\n         PyErr_SetString(PyExc_IOError, \"seeking file failed\");\n         return NULL;\n     }\n@@ -127,14 +124,13 @@ mpl_PyFile_Dup(PyObject *file, char *mode, mpl_off_t *orig_pos)\n /*\n  * Close the dup-ed file handle, and seek the Python one to the current position\n  */\n-static NPY_INLINE int\n-mpl_PyFile_DupClose(PyObject *file, FILE* handle, mpl_off_t orig_pos)\n+static NPY_INLINE int mpl_PyFile_DupClose(PyObject *file, FILE *handle, mpl_off_t orig_pos)\n {\n     int fd;\n     PyObject *ret;\n     mpl_off_t position;\n \n-    position = npy_ftell(handle);\n+    position = mpl_ftell(handle);\n \n     /* Close the FILE* handle */\n     fclose(handle);\n@@ -145,14 +141,14 @@ mpl_PyFile_DupClose(PyObject *file, FILE* handle, mpl_off_t orig_pos)\n     if (fd == -1) {\n         return -1;\n     }\n-    if (npy_lseek(fd, orig_pos, SEEK_SET) != -1) {\n+    if (mpl_lseek(fd, orig_pos, SEEK_SET) != -1) {\n         if (position == -1) {\n             PyErr_SetString(PyExc_IOError, \"obtaining file position failed\");\n             return -1;\n         }\n \n         /* Seek Python-side handle to the FILE* handle position */\n-        ret = PyObject_CallMethod(file, \"seek\", MPL_OFF_T_PYFMT \"i\", position, 0);\n+        ret = PyObject_CallMethod(file, (char *)\"seek\", (char *)(MPL_OFF_T_PYFMT \"i\"), position, 0);\n         if (ret == NULL) {\n             return -1;\n         }\n@@ -161,8 +157,7 @@ mpl_PyFile_DupClose(PyObject *file, FILE* handle, mpl_off_t orig_pos)\n     return 0;\n }\n \n-static NPY_INLINE int\n-mpl_PyFile_Check(PyObject *file)\n+static NPY_INLINE int mpl_PyFile_Check(PyObject *file)\n {\n     int fd;\n     fd = PyObject_AsFileDescriptor(file);\n@@ -175,29 +170,39 @@ mpl_PyFile_Check(PyObject *file)\n \n #else\n \n-#define mpl_PyFile_Dup(file, mode, orig_pos_p) PyFile_AsFile(file)\n-#define mpl_PyFile_DupClose(file, handle, orig_pos) (0)\n-#define mpl_PyFile_Check PyFile_Check\n+static NPY_INLINE FILE *mpl_PyFile_Dup(PyObject *file, const char *mode, mpl_off_t *orig_pos)\n+{\n+    return PyFile_AsFile(file);\n+}\n+\n+static NPY_INLINE int mpl_PyFile_DupClose(PyObject *file, FILE *handle, mpl_off_t orig_pos)\n+{\n+    // deliberately nothing\n+    return 0;\n+}\n+\n+static NPY_INLINE int mpl_PyFile_Check(PyObject *file)\n+{\n+    return PyFile_Check(file);\n+}\n \n #endif\n \n-static NPY_INLINE PyObject*\n-mpl_PyFile_OpenFile(PyObject *filename, const char *mode)\n+static NPY_INLINE PyObject *mpl_PyFile_OpenFile(PyObject *filename, const char *mode)\n {\n     PyObject *open;\n     open = PyDict_GetItemString(PyEval_GetBuiltins(), \"open\");\n     if (open == NULL) {\n         return NULL;\n     }\n-    return PyObject_CallFunction(open, (char*)\"Os\", filename, mode);\n+    return PyObject_CallFunction(open, (char *)\"Os\", filename, mode);\n }\n \n-static NPY_INLINE int\n-mpl_PyFile_CloseFile(PyObject *file)\n+static NPY_INLINE int mpl_PyFile_CloseFile(PyObject *file)\n {\n     PyObject *ret;\n \n-    ret = PyObject_CallMethod(file, (char*)\"close\", NULL);\n+    ret = PyObject_CallMethod(file, (char *)\"close\", NULL);\n     if (ret == NULL) {\n         return -1;\n     }"
            },
            {
                "sha": "e7cebfaa6864a504091cba1120a3d76f0812f39c",
                "filename": "src/ft2font.cpp",
                "status": "modified",
                "additions": 254,
                "deletions": 1934,
                "changes": 2188,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2Fft2font.cpp",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2Fft2font.cpp",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/src%2Fft2font.cpp?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787",
                "patch": "@@ -1,19 +1,9 @@\n /* -*- mode: c++; c-basic-offset: 4 -*- */\n \n+#define NO_IMPORT_ARRAY\n+\n #include \"ft2font.h\"\n #include \"mplutils.h\"\n-#include <sstream>\n-\n-#include \"file_compat.h\"\n-\n-#include \"numpy/arrayobject.h\"\n-\n-/*\n- By definition, FT_FIXED as 2 16bit values stored in a single long.\n- We cast to long to ensure the correct Py::Int convertor is called\n- */\n-#define FIXED_MAJOR(val) (long) ((val & 0xffff000) >> 16)\n-#define FIXED_MINOR(val) (long) (val & 0xffff)\n \n /**\n  To improve the hinting of the fonts, this code uses a hack\n@@ -40,80 +30,56 @@\n       you have disabled hints).\n  */\n \n-\n FT_Library _ft2Library;\n \n-FT2Image::FT2Image(Py::PythonClassInstance *self, Py::Tuple &args, Py::Dict &kwds) :\n-    Py::PythonClass< FT2Image >(self, args, kwds),\n-    _isDirty(true),\n-    _buffer(NULL),\n-    _width(0), _height(0)\n+FT2Image::FT2Image() : m_dirty(true), m_buffer(NULL), m_width(0), m_height(0)\n {\n-    _VERBOSE(\"FT2Image::FT2Image\");\n-\n-    args.verify_length(2);\n-    int width = Py::Int(args[0]);\n-    int height = Py::Int(args[1]);\n-\n-    resize(width, height);\n }\n \n-FT2Image::~FT2Image() {\n-    delete [] _buffer;\n-    _buffer = NULL;\n+FT2Image::FT2Image(unsigned long width, unsigned long height)\n+    : m_dirty(true), m_buffer(NULL), m_width(0), m_height(0)\n+{\n+    resize(width, height);\n }\n \n-Py::PythonClassObject<FT2Image> FT2Image::factory(int width, int height)\n+FT2Image::~FT2Image()\n {\n-    Py::Callable class_type(type());\n-    Py::Tuple args(2);\n-    args[0] = Py::Int(width);\n-    args[1] = Py::Int(height);\n-    Py::PythonClassObject<FT2Image> o = Py::PythonClassObject<FT2Image>(\n-        class_type.apply(args, Py::Dict()));\n-    return o;\n+    delete[] m_buffer;\n }\n \n-void\n-FT2Image::resize(long width, long height)\n+void FT2Image::resize(long width, long height)\n {\n-    if (width < 0)\n-    {\n+    if (width < 0) {\n         width = 1;\n     }\n-    if (height < 0)\n-    {\n+    if (height < 0) {\n         height = 1;\n     }\n     size_t numBytes = width * height;\n \n-    if ((unsigned long)width != _width || (unsigned long)height != _height)\n-    {\n-        if (numBytes > _width*_height)\n-        {\n-            delete [] _buffer;\n-            _buffer = NULL;\n-            _buffer = new unsigned char [numBytes];\n+    if ((unsigned long)width != m_width || (unsigned long)height != m_height) {\n+        if (numBytes > m_width * m_height) {\n+            delete[] m_buffer;\n+            m_buffer = NULL;\n+            m_buffer = new unsigned char[numBytes];\n         }\n \n-        _width = (unsigned long)width;\n-        _height = (unsigned long)height;\n+        m_width = (unsigned long)width;\n+        m_height = (unsigned long)height;\n     }\n \n-    memset(_buffer, 0, numBytes);\n+    if (numBytes) {\n+        memset(m_buffer, 0, numBytes);\n+    }\n \n-    _isDirty = true;\n+    m_dirty = true;\n }\n \n-void\n-FT2Image::draw_bitmap(FT_Bitmap*  bitmap,\n-                      FT_Int      x,\n-                      FT_Int      y)\n+void FT2Image::draw_bitmap(FT_Bitmap *bitmap, FT_Int x, FT_Int y)\n {\n-    _VERBOSE(\"FT2Image::draw_bitmap\");\n-    FT_Int image_width = (FT_Int)_width;\n-    FT_Int image_height = (FT_Int)_height;\n-    FT_Int char_width =  bitmap->width;\n+    FT_Int image_width = (FT_Int)m_width;\n+    FT_Int image_height = (FT_Int)m_height;\n+    FT_Int char_width = bitmap->width;\n     FT_Int char_height = bitmap->rows;\n \n     FT_Int x1 = CLAMP(x, 0, image_width);\n@@ -125,470 +91,155 @@ FT2Image::draw_bitmap(FT_Bitmap*  bitmap,\n     FT_Int y_offset = y1 - MAX(0, -y);\n \n     if (bitmap->pixel_mode == FT_PIXEL_MODE_GRAY) {\n-        for (FT_Int i = y1; i < y2; ++i)\n-        {\n-            unsigned char* dst = _buffer + (i * image_width + x1);\n-            unsigned char* src = bitmap->buffer + (((i - y_offset) * bitmap->pitch) + x_start);\n+        for (FT_Int i = y1; i < y2; ++i) {\n+            unsigned char *dst = m_buffer + (i * image_width + x1);\n+            unsigned char *src = bitmap->buffer + (((i - y_offset) * bitmap->pitch) + x_start);\n             for (FT_Int j = x1; j < x2; ++j, ++dst, ++src)\n                 *dst |= *src;\n         }\n     } else if (bitmap->pixel_mode == FT_PIXEL_MODE_MONO) {\n-        for (FT_Int i = y1; i < y2; ++i)\n-        {\n-            unsigned char* dst = _buffer + (i * image_width + x1);\n-            unsigned char* src = bitmap->buffer + ((i - y_offset) * bitmap->pitch);\n+        for (FT_Int i = y1; i < y2; ++i) {\n+            unsigned char *dst = m_buffer + (i * image_width + x1);\n+            unsigned char *src = bitmap->buffer + ((i - y_offset) * bitmap->pitch);\n             for (FT_Int j = x1; j < x2; ++j, ++dst) {\n                 int x = (j - x1 + x_start);\n                 int val = *(src + (x >> 3)) & (1 << (7 - (x & 0x7)));\n                 *dst = val ? 255 : *dst;\n             }\n         }\n     } else {\n-        throw Py::Exception(\"Unknown pixel mode\");\n+        throw \"Unknown pixel mode\";\n     }\n \n-    _isDirty = true;\n+    m_dirty = true;\n }\n \n-void\n-FT2Image::write_bitmap(FILE *fh) const\n+void FT2Image::draw_rect(unsigned long x0, unsigned long y0, unsigned long x1, unsigned long y1)\n {\n-    for (size_t i = 0; i < _height; i++)\n-    {\n-        for (size_t j = 0; j < _width; ++j)\n-        {\n-            if (_buffer[j + i*_width])\n-            {\n-                fputc('#', fh);\n-            }\n-            else\n-            {\n-                fputc(' ', fh);\n-            }\n-        }\n-        fputc('\\n', fh);\n+    if (x0 > m_width || x1 > m_width || y0 > m_height || y1 > m_height) {\n+        throw \"Rect coords outside image bounds\";\n     }\n-}\n \n-char FT2Image::write_bitmap__doc__[] =\n-    \"write_bitmap(fname)\\n\"\n-    \"\\n\"\n-    \"Write the bitmap to file fname\\n\"\n-    ;\n-Py::Object\n-FT2Image::py_write_bitmap(const Py::Tuple & args)\n-{\n-    _VERBOSE(\"FT2Image::write_bitmap\");\n-    PyObject *py_file;\n-    FILE *fh;\n-    mpl_off_t offset;\n-\n-    args.verify_length(1);\n-\n-    if ((py_file = mpl_PyFile_OpenFile(args[0].ptr(), (char *)\"wb\")) == NULL) {\n-        throw Py::Exception();\n+    size_t top = y0 * m_width;\n+    size_t bottom = y1 * m_width;\n+    for (size_t i = x0; i < x1 + 1; ++i) {\n+        m_buffer[i + top] = 255;\n+        m_buffer[i + bottom] = 255;\n     }\n \n-    fh = mpl_PyFile_Dup(py_file, (char *)\"wb\", &offset);\n-\n-    write_bitmap(fh);\n-\n-    if (mpl_PyFile_DupClose(py_file, fh, offset))\n-    {\n-        throw Py::Exception();\n+    for (size_t j = y0 + 1; j < y1; ++j) {\n+        m_buffer[x0 + j * m_width] = 255;\n+        m_buffer[x1 + j * m_width] = 255;\n     }\n-    mpl_PyFile_CloseFile(py_file);\n-    Py_DECREF(py_file);\n \n-    return Py::Object();\n+    m_dirty = true;\n }\n-PYCXX_VARARGS_METHOD_DECL(FT2Image, py_write_bitmap)\n \n void\n-FT2Image::draw_rect(unsigned long x0, unsigned long y0,\n-                    unsigned long x1, unsigned long y1)\n-{\n-    if (x0 > _width || x1 > _width ||\n-        y0 > _height || y1 > _height)\n-    {\n-        throw Py::ValueError(\"Rect coords outside image bounds\");\n-    }\n-\n-    size_t top = y0 * _width;\n-    size_t bottom = y1 * _width;\n-    for (size_t i = x0; i < x1 + 1; ++i)\n-    {\n-        _buffer[i + top] = 255;\n-        _buffer[i + bottom] = 255;\n-    }\n-\n-    for (size_t j = y0 + 1; j < y1; ++j)\n-    {\n-        _buffer[x0 + j*_width] = 255;\n-        _buffer[x1 + j*_width] = 255;\n-    }\n-\n-    _isDirty = true;\n-}\n-\n-char FT2Image::draw_rect__doc__[] =\n-    \"draw_rect(x0, y0, x1, y1)\\n\"\n-    \"\\n\"\n-    \"Draw a rect to the image.\\n\"\n-    \"\\n\"\n-    ;\n-Py::Object\n-FT2Image::py_draw_rect(const Py::Tuple & args)\n+FT2Image::draw_rect_filled(unsigned long x0, unsigned long y0, unsigned long x1, unsigned long y1)\n {\n-    _VERBOSE(\"FT2Image::draw_rect\");\n-\n-    args.verify_length(4);\n+    x0 = std::min(x0, m_width);\n+    y0 = std::min(y0, m_height);\n+    x1 = std::min(x1, m_width);\n+    y1 = std::min(y1, m_height);\n \n-    long x0 = Py::Int(args[0]);\n-    long y0 = Py::Int(args[1]);\n-    long x1 = Py::Int(args[2]);\n-    long y1 = Py::Int(args[3]);\n-\n-    draw_rect(x0, y0, x1, y1);\n-\n-    return Py::Object();\n-}\n-PYCXX_VARARGS_METHOD_DECL(FT2Image, py_draw_rect)\n-\n-void\n-FT2Image::draw_rect_filled(unsigned long x0, unsigned long y0,\n-                           unsigned long x1, unsigned long y1)\n-{\n-    x0 = std::min(x0, _width);\n-    y0 = std::min(y0, _height);\n-    x1 = std::min(x1, _width);\n-    y1 = std::min(y1, _height);\n-\n-    for (size_t j = y0; j < y1 + 1; j++)\n-    {\n-        for (size_t i = x0; i < x1 + 1; i++)\n-        {\n-            _buffer[i + j*_width] = 255;\n+    for (size_t j = y0; j < y1 + 1; j++) {\n+        for (size_t i = x0; i < x1 + 1; i++) {\n+            m_buffer[i + j * m_width] = 255;\n         }\n     }\n \n-    _isDirty = true;\n-}\n-\n-char FT2Image::draw_rect_filled__doc__[] =\n-    \"draw_rect_filled(x0, y0, x1, y1)\\n\"\n-    \"\\n\"\n-    \"Draw a filled rect to the image.\\n\"\n-    \"\\n\"\n-    ;\n-Py::Object\n-FT2Image::py_draw_rect_filled(const Py::Tuple & args)\n-{\n-    _VERBOSE(\"FT2Image::draw_rect_filled\");\n-\n-    args.verify_length(4);\n-\n-    long x0 = Py::Int(args[0]);\n-    long y0 = Py::Int(args[1]);\n-    long x1 = Py::Int(args[2]);\n-    long y1 = Py::Int(args[3]);\n-\n-    draw_rect_filled(x0, y0, x1, y1);\n-\n-    return Py::Object();\n-}\n-PYCXX_VARARGS_METHOD_DECL(FT2Image, py_draw_rect_filled)\n-\n-char FT2Image::as_str__doc__[] =\n-    \"s = image.as_str()\\n\"\n-    \"\\n\"\n-    \"Return the image buffer as a string\\n\"\n-    \"\\n\"\n-    ;\n-Py::Object\n-FT2Image::py_as_str(const Py::Tuple & args)\n-{\n-    _VERBOSE(\"FT2Image::as_str\");\n-    args.verify_length(0);\n-\n-    return Py::asObject\n-      (PyBytes_FromStringAndSize((const char *)_buffer, _width*_height));\n-}\n-PYCXX_VARARGS_METHOD_DECL(FT2Image, py_as_str)\n-\n-char FT2Image::as_rgba_str__doc__[] =\n-    \"s = image.as_rgba_str()\\n\"\n-    \"\\n\"\n-    \"Return the image buffer as a RGBA string\\n\"\n-    \"\\n\"\n-    ;\n-Py::Object\n-FT2Image::py_as_rgba_str(const Py::Tuple & args)\n-{\n-    _VERBOSE(\"FT2Image::as_str\");\n-    args.verify_length(0);\n-\n-    Py_ssize_t size = _width*_height*4;\n-    PyObject* result = PyBytes_FromStringAndSize(NULL, size);\n-\n-    unsigned char *src     = _buffer;\n-    unsigned char *src_end = src + (_width * _height);\n-    unsigned char *dst     = (unsigned char *)PyBytes_AS_STRING(result);\n-\n-    while (src != src_end)\n-    {\n-        *dst++ = 0;\n-        *dst++ = 0;\n-        *dst++ = 0;\n-        *dst++ = *src++;\n-    }\n-\n-    return Py::asObject(result);\n-}\n-PYCXX_VARARGS_METHOD_DECL(FT2Image, py_as_rgba_str)\n-\n-/* TODO: This could take a color as an argument, but for\n-   now it defaults to black on white background */\n-char FT2Image::as_rgb_str__doc__[] =\n-    \"s = image.as_rgb_str()\\n\"\n-    \"\\n\"\n-    \"Return the image buffer as a RGB string\\n\"\n-    \"\\n\"\n-    ;\n-Py::Object\n-FT2Image::py_as_rgb_str(const Py::Tuple & args)\n-{\n-    _VERBOSE(\"FT2Image::as_str\");\n-    args.verify_length(0);\n-\n-    Py_ssize_t size = _width*_height*3;\n-    PyObject* result = PyBytes_FromStringAndSize(NULL, size);\n-\n-    unsigned char *src     = _buffer;\n-    unsigned char *src_end = src + (_width * _height);\n-    unsigned char *dst     = (unsigned char *)PyBytes_AS_STRING(result);\n-\n-    while (src != src_end)\n-    {\n-        unsigned char tmp = 255 - *src++;\n-        *dst++ = tmp;\n-        *dst++ = tmp;\n-        *dst++ = tmp;\n-    }\n-\n-    return Py::asObject(result);\n-}\n-PYCXX_VARARGS_METHOD_DECL(FT2Image, py_as_rgb_str)\n-\n-char FT2Image::as_array__doc__[] =\n-    \"x = image.as_array()\\n\"\n-    \"\\n\"\n-    \"Return the image buffer as a width x height numpy array of ubyte \\n\"\n-    \"\\n\"\n-    ;\n-Py::Object\n-FT2Image::py_as_array(const Py::Tuple & args)\n-{\n-    _VERBOSE(\"FT2Image::as_array\");\n-    args.verify_length(0);\n-\n-    npy_intp dimensions[2];\n-    dimensions[0] = get_height();  //numrows\n-    dimensions[1] = get_width();   //numcols\n-\n-\n-    PyArrayObject *A = (PyArrayObject *) PyArray_SimpleNewFromData(2, dimensions, NPY_UBYTE, _buffer);\n-\n-    return Py::asObject((PyObject*)A);\n-}\n-PYCXX_VARARGS_METHOD_DECL(FT2Image, py_as_array)\n-\n-Py::Object\n-FT2Image::py_get_width(const Py::Tuple & args)\n-{\n-    _VERBOSE(\"FT2Image::get_width\");\n-    args.verify_length(0);\n-\n-    return Py::Int((long)get_width());\n-}\n-PYCXX_VARARGS_METHOD_DECL(FT2Image, py_get_width)\n-\n-Py::Object\n-FT2Image::py_get_height(const Py::Tuple & args)\n-{\n-    _VERBOSE(\"FT2Image::get_height\");\n-    args.verify_length(0);\n-\n-    return Py::Int((long)get_height());\n-}\n-PYCXX_VARARGS_METHOD_DECL(FT2Image, py_get_height)\n-\n-Py::PythonClassObject<Glyph> Glyph::factory(\n-        const FT_Face& face, const FT_Glyph& glyph, size_t ind, long hinting_factor)\n-{\n-    Py::Callable class_type(type());\n-    Py::PythonClassObject<Glyph> obj = Py::PythonClassObject<Glyph>(\n-        class_type.apply(Py::Tuple(), Py::Dict()));\n-    Glyph* o = obj.getCxxObject();\n-\n-    o->glyphInd = ind;\n-    FT_BBox bbox;\n-    FT_Glyph_Get_CBox(glyph, ft_glyph_bbox_subpixels, &bbox);\n-\n-    o->setattro(\"width\",        Py::Int(face->glyph->metrics.width / hinting_factor));\n-    o->setattro(\"height\",       Py::Int(face->glyph->metrics.height));\n-    o->setattro(\"horiBearingX\", Py::Int(face->glyph->metrics.horiBearingX / hinting_factor));\n-    o->setattro(\"horiBearingY\", Py::Int(face->glyph->metrics.horiBearingY));\n-    o->setattro(\"horiAdvance\",  Py::Int(face->glyph->metrics.horiAdvance));\n-    o->setattro(\"linearHoriAdvance\",  Py::Int(face->glyph->linearHoriAdvance / hinting_factor));\n-    o->setattro(\"vertBearingX\", Py::Int(face->glyph->metrics.vertBearingX));\n-\n-    o->setattro(\"vertBearingY\", Py::Int(face->glyph->metrics.vertBearingY));\n-    o->setattro(\"vertAdvance\",  Py::Int(face->glyph->metrics.vertAdvance));\n-\n-    Py::Tuple abbox(4);\n-\n-    abbox[0] = Py::Int(bbox.xMin);\n-    abbox[1] = Py::Int(bbox.yMin);\n-    abbox[2] = Py::Int(bbox.xMax);\n-    abbox[3] = Py::Int(bbox.yMax);\n-    o->setattro(\"bbox\", abbox);\n-\n-    return obj;\n-}\n-\n-Glyph::~Glyph()\n-{\n-    _VERBOSE(\"Glyph::~Glyph\");\n+    m_dirty = true;\n }\n \n-int\n-Glyph::setattro(const Py::String &name, const Py::Object &value)\n-{\n-    _VERBOSE(\"Glyph::setattr\");\n-    __dict__[name] = value;\n-    return 0;\n-}\n-\n-Py::Object\n-Glyph::getattro(const Py::String &name)\n-{\n-    _VERBOSE(\"Glyph::getattr\");\n-    if (__dict__.hasKey(name)) return __dict__[name];\n-    else return genericGetAttro(name);\n-}\n-\n-inline double conv(int v)\n+inline double conv(long v)\n {\n     return double(v) / 64.0;\n }\n \n-\n-char FT2Font::get_path__doc__[] =\n-    \"get_path()\\n\"\n-    \"\\n\"\n-    \"Get the path data from the currently loaded glyph as a tuple of vertices, codes.\\n\"\n-    ;\n-Py::Object\n-FT2Font::get_path()\n+int FT2Font::get_path_count()\n {\n-    //get the glyph as a path, a list of (COMMAND, *args) as desribed in matplotlib.path\n+    // get the glyph as a path, a list of (COMMAND, *args) as desribed in matplotlib.path\n     // this code is from agg's decompose_ft_outline with minor modifications\n \n     if (!face->glyph) {\n-        throw Py::ValueError(\"No glyph loaded\");\n+        throw \"No glyph loaded\";\n     }\n \n-    enum {STOP = 0,\n-          MOVETO = 1,\n-          LINETO = 2,\n-          CURVE3 = 3,\n-          CURVE4 = 4,\n-          ENDPOLY = 0x4f};\n-    FT_Outline& outline = face->glyph->outline;\n-    bool flip_y = false; //todo, pass me as kwarg\n+    FT_Outline &outline = face->glyph->outline;\n \n-    FT_Vector   v_last;\n-    FT_Vector   v_control;\n-    FT_Vector   v_start;\n+    FT_Vector v_last;\n+    FT_Vector v_control;\n+    FT_Vector v_start;\n \n-    FT_Vector*  point;\n-    FT_Vector*  limit;\n-    char*       tags;\n+    FT_Vector *point;\n+    FT_Vector *limit;\n+    char *tags;\n \n-    int   n;         // index of contour in outline\n-    int   first;     // index of first point in contour\n-    char  tag;       // current point's state\n-    int   count;\n+    int n;     // index of contour in outline\n+    int first; // index of first point in contour\n+    char tag;  // current point's state\n+    int count;\n \n     count = 0;\n     first = 0;\n-    for (n = 0; n < outline.n_contours; n++)\n-    {\n-        int  last;  // index of last point in contour\n+    for (n = 0; n < outline.n_contours; n++) {\n+        int last; // index of last point in contour\n         bool starts_with_last;\n \n-        last  = outline.contours[n];\n+        last = outline.contours[n];\n         limit = outline.points + last;\n \n         v_start = outline.points[first];\n-        v_last  = outline.points[last];\n+        v_last = outline.points[last];\n \n         v_control = v_start;\n \n         point = outline.points + first;\n-        tags  = outline.tags  + first;\n-        tag   = FT_CURVE_TAG(tags[0]);\n+        tags = outline.tags + first;\n+        tag = FT_CURVE_TAG(tags[0]);\n \n         // A contour cannot start with a cubic control point!\n-        if (tag == FT_CURVE_TAG_CUBIC)\n-        {\n-            throw Py::RuntimeError(\"A contour cannot start with a cubic control point\");\n-        }\n-        else if (tag == FT_CURVE_TAG_CONIC)\n-        {\n+        if (tag == FT_CURVE_TAG_CUBIC) {\n+            throw \"A contour cannot start with a cubic control point\";\n+        } else if (tag == FT_CURVE_TAG_CONIC) {\n             starts_with_last = true;\n         } else {\n             starts_with_last = false;\n         }\n \n         count++;\n \n-        while (point < limit)\n-        {\n+        while (point < limit) {\n             if (!starts_with_last) {\n                 point++;\n                 tags++;\n             }\n             starts_with_last = false;\n \n             tag = FT_CURVE_TAG(tags[0]);\n-            switch (tag)\n-            {\n-            case FT_CURVE_TAG_ON:  // emit a single line_to\n+            switch (tag) {\n+            case FT_CURVE_TAG_ON: // emit a single line_to\n             {\n                 count++;\n                 continue;\n             }\n \n-            case FT_CURVE_TAG_CONIC:  // consume conic arcs\n+            case FT_CURVE_TAG_CONIC: // consume conic arcs\n             {\n             Count_Do_Conic:\n-                if (point < limit)\n-                {\n+                if (point < limit) {\n                     point++;\n                     tags++;\n                     tag = FT_CURVE_TAG(tags[0]);\n \n-                    if (tag == FT_CURVE_TAG_ON)\n-                    {\n+                    if (tag == FT_CURVE_TAG_ON) {\n                         count += 2;\n                         continue;\n                     }\n \n-                    if (tag != FT_CURVE_TAG_CONIC)\n-                    {\n-                        throw Py::RuntimeError(\"Invalid font\");\n+                    if (tag != FT_CURVE_TAG_CONIC) {\n+                        throw \"Invalid font\";\n                     }\n \n                     count += 2;\n@@ -601,18 +252,16 @@ FT2Font::get_path()\n                 goto Count_Close;\n             }\n \n-            default:  // FT_CURVE_TAG_CUBIC\n+            default: // FT_CURVE_TAG_CUBIC\n             {\n-                if (point + 1 > limit || FT_CURVE_TAG(tags[1]) != FT_CURVE_TAG_CUBIC)\n-                {\n-                    throw Py::RuntimeError(\"Invalid font\");\n+                if (point + 1 > limit || FT_CURVE_TAG(tags[1]) != FT_CURVE_TAG_CUBIC) {\n+                    throw \"Invalid font\";\n                 }\n \n                 point += 2;\n-                tags  += 2;\n+                tags += 2;\n \n-                if (point <= limit)\n-                {\n+                if (point <= limit) {\n                     count += 3;\n                     continue;\n                 }\n@@ -630,50 +279,45 @@ FT2Font::get_path()\n         first = last + 1;\n     }\n \n-    PyArrayObject* vertices = NULL;\n-    PyArrayObject* codes = NULL;\n-    Py::Tuple result(2);\n+    return count;\n+}\n+\n+void FT2Font::get_path(double *outpoints, unsigned char *outcodes)\n+{\n+    FT_Outline &outline = face->glyph->outline;\n+    bool flip_y = false; // todo, pass me as kwarg\n \n-    npy_intp vertices_dims[2] = {count, 2};\n-    vertices = (PyArrayObject*)PyArray_SimpleNew(\n-        2, vertices_dims, NPY_DOUBLE);\n-    if (vertices == NULL) {\n-        throw;\n-    }\n-    npy_intp codes_dims[1] = {count};\n-    codes = (PyArrayObject*)PyArray_SimpleNew(\n-        1, codes_dims, NPY_UINT8);\n-    if (codes == NULL) {\n-        throw;\n-    }\n+    FT_Vector v_last;\n+    FT_Vector v_control;\n+    FT_Vector v_start;\n \n-    result[0] = Py::Object((PyObject*)vertices, true);\n-    result[1] = Py::Object((PyObject*)codes, true);\n+    FT_Vector *point;\n+    FT_Vector *limit;\n+    char *tags;\n \n-    double* outpoints = (double *)PyArray_DATA(vertices);\n-    unsigned char* outcodes = (unsigned char *)PyArray_DATA(codes);\n+    int n;     // index of contour in outline\n+    int first; // index of first point in contour\n+    char tag;  // current point's state\n \n     first = 0;\n-    for (n = 0; n < outline.n_contours; n++)\n-    {\n-        int last;  // index of last point in contour\n+    for (n = 0; n < outline.n_contours; n++) {\n+        int last; // index of last point in contour\n         bool starts_with_last;\n \n-        last  = outline.contours[n];\n+        last = outline.contours[n];\n         limit = outline.points + last;\n \n         v_start = outline.points[first];\n-        v_last  = outline.points[last];\n+        v_last = outline.points[last];\n \n         v_control = v_start;\n \n         point = outline.points + first;\n-        tags  = outline.tags  + first;\n-        tag   = FT_CURVE_TAG(tags[0]);\n+        tags = outline.tags + first;\n+        tag = FT_CURVE_TAG(tags[0]);\n \n         double x, y;\n-        if (tag != FT_CURVE_TAG_ON)\n-        {\n+        if (tag != FT_CURVE_TAG_ON) {\n             x = conv(v_last.x);\n             y = flip_y ? -conv(v_last.y) : conv(v_last.y);\n             starts_with_last = true;\n@@ -687,18 +331,16 @@ FT2Font::get_path()\n         *(outpoints++) = y;\n         *(outcodes++) = MOVETO;\n \n-        while (point < limit)\n-        {\n+        while (point < limit) {\n             if (!starts_with_last) {\n                 point++;\n                 tags++;\n             }\n             starts_with_last = false;\n \n             tag = FT_CURVE_TAG(tags[0]);\n-            switch (tag)\n-            {\n-            case FT_CURVE_TAG_ON:  // emit a single line_to\n+            switch (tag) {\n+            case FT_CURVE_TAG_ON: // emit a single line_to\n             {\n                 double x = conv(point->x);\n                 double y = flip_y ? -conv(point->y) : conv(point->y);\n@@ -708,14 +350,13 @@ FT2Font::get_path()\n                 continue;\n             }\n \n-            case FT_CURVE_TAG_CONIC:  // consume conic arcs\n+            case FT_CURVE_TAG_CONIC: // consume conic arcs\n             {\n                 v_control.x = point->x;\n                 v_control.y = point->y;\n \n             Do_Conic:\n-                if (point < limit)\n-                {\n+                if (point < limit) {\n                     FT_Vector vec;\n                     FT_Vector v_middle;\n \n@@ -726,8 +367,7 @@ FT2Font::get_path()\n                     vec.x = point->x;\n                     vec.y = point->y;\n \n-                    if (tag == FT_CURVE_TAG_ON)\n-                    {\n+                    if (tag == FT_CURVE_TAG_ON) {\n                         double xctl = conv(v_control.x);\n                         double yctl = flip_y ? -conv(v_control.y) : conv(v_control.y);\n                         double xto = conv(vec.x);\n@@ -773,7 +413,7 @@ FT2Font::get_path()\n                 goto Close;\n             }\n \n-            default:  // FT_CURVE_TAG_CUBIC\n+            default: // FT_CURVE_TAG_CUBIC\n             {\n                 FT_Vector vec1, vec2;\n \n@@ -783,10 +423,9 @@ FT2Font::get_path()\n                 vec2.y = point[1].y;\n \n                 point += 2;\n-                tags  += 2;\n+                tags += 2;\n \n-                if (point <= limit)\n-                {\n+                if (point <= limit) {\n                     FT_Vector vec;\n \n                     vec.x = point->x;\n@@ -839,313 +478,123 @@ FT2Font::get_path()\n     Close:\n         first = last + 1;\n     }\n-\n-    if (outcodes - (unsigned char *)PyArray_DATA(codes) != count) {\n-        throw Py::RuntimeError(\"Font path size doesn't match\");\n-    }\n-\n-    return result;\n }\n-PYCXX_NOARGS_METHOD_DECL(FT2Font, get_path)\n \n-FT2Font::FT2Font(Py::PythonClassInstance *self, Py::Tuple &args, Py::Dict &kwds) :\n-    Py::PythonClass<FT2Font>(self, args, kwds),\n-    face(NULL),\n-    image()\n+FT2Font::FT2Font(FT_Open_Args &open_args, long hinting_factor_) : image(), face(NULL)\n {\n-    FT_Open_Args open_args;\n-\n-    /* This string is only used for error messages, so encode it in something\n-     * that we'll always be able to print. */\n-    std::string facefile = Py::String(args[0]).encode(\"unicode_escape\");\n-\n-    args.verify_length(1);\n-\n-    clear(Py::Tuple(0));\n-\n-    memset(&stream, 0, sizeof(FT_StreamRec));\n-    mem = NULL;\n-    mem_size = 0;\n-\n-    if (make_open_args(args[0].ptr(), &open_args)) {\n-        /* make_open_args sets the Python exception for us. */\n-        throw Py::Exception();\n-    }\n+    clear();\n \n     int error = FT_Open_Face(_ft2Library, &open_args, 0, &face);\n \n-    if (error == FT_Err_Unknown_File_Format)\n-    {\n-        std::ostringstream s;\n-        s << \"Could not load facefile \" << facefile << \"; Unknown_File_Format\" << std::endl;\n-        throw Py::RuntimeError(s.str());\n-    }\n-    else if (error == FT_Err_Cannot_Open_Resource)\n-    {\n-        std::ostringstream s;\n-        s << \"Could not open facefile \" << facefile << \"; Cannot_Open_Resource\" << std::endl;\n-        throw Py::RuntimeError(s.str());\n-    }\n-    else if (error == FT_Err_Invalid_File_Format)\n-    {\n-        std::ostringstream s;\n-        s << \"Could not open facefile \" << facefile << \"; Invalid_File_Format\" << std::endl;\n-        throw Py::RuntimeError(s.str());\n-    }\n-    else if (error)\n-    {\n-        std::ostringstream s;\n-        s << \"Could not open facefile \" << facefile << \"; freetype error code \" << error << std::endl;\n-        throw Py::RuntimeError(s.str());\n+    if (error == FT_Err_Unknown_File_Format) {\n+        throw \"Can not load face.  Unknown file format.\";\n+    } else if (error == FT_Err_Cannot_Open_Resource) {\n+        throw \"Can not load face.  Can not open resource.\";\n+    } else if (error == FT_Err_Invalid_File_Format) {\n+        throw \"Can not load face.  Invalid file format.\";\n+    } else if (error) {\n+        throw \"Can not load face.\";\n     }\n \n     // set a default fontsize 12 pt at 72dpi\n-    hinting_factor = 8;\n-    if (kwds.hasKey(\"hinting_factor\"))\n-    {\n-        hinting_factor = Py::Long(kwds[\"hinting_factor\"]);\n+    hinting_factor = hinting_factor_;\n+\n+    error = FT_Set_Char_Size(face, 12 * 64, 0, 72 * (unsigned int)hinting_factor, 72);\n+    if (error) {\n+        throw \"Could not set the fontsize\";\n     }\n \n-    error = FT_Set_Char_Size(face, 12 * 64, 0, 72 * hinting_factor, 72);\n     static FT_Matrix transform = { 65536 / hinting_factor, 0, 0, 65536 };\n     FT_Set_Transform(face, &transform, 0);\n-    if (error)\n-    {\n-        std::ostringstream s;\n-        s << \"Could not set the fontsize for facefile  \" << facefile << std::endl;\n-        throw Py::RuntimeError(s.str());\n-    }\n-\n-    // set some face props as attributes\n-    //small memory leak fixed after 2.1.8\n-    //fields can be null so we have to check this first\n-\n-    const char* ps_name = FT_Get_Postscript_Name(face);\n-    if (ps_name == NULL)\n-    {\n-        ps_name = \"UNAVAILABLE\";\n-    }\n-\n-    const char* family_name = face->family_name;\n-    if (family_name == NULL)\n-    {\n-        family_name = \"UNAVAILABLE\";\n-    }\n-\n-    const char* style_name = face->style_name;\n-    if (style_name == NULL)\n-    {\n-        style_name = \"UNAVAILABLE\";\n-    }\n-\n-    setattro(\"postscript_name\", Py::String(ps_name));\n-    setattro(\"num_faces\",       Py::Int(face->num_faces));\n-    setattro(\"family_name\",     Py::String(family_name));\n-    setattro(\"style_name\",      Py::String(style_name));\n-    setattro(\"face_flags\",      Py::Int(face->face_flags));\n-    setattro(\"style_flags\",     Py::Int(face->style_flags));\n-    setattro(\"num_glyphs\",      Py::Int(face->num_glyphs));\n-    setattro(\"num_fixed_sizes\", Py::Int(face->num_fixed_sizes));\n-    setattro(\"num_charmaps\",    Py::Int(face->num_charmaps));\n-\n-    int scalable = FT_IS_SCALABLE(face);\n-\n-    setattro(\"scalable\", Py::Int(scalable));\n-\n-    if (scalable)\n-    {\n-        setattro(\"units_per_EM\", Py::Int(face->units_per_EM));\n-\n-        Py::Tuple bbox(4);\n-        bbox[0] = Py::Int(face->bbox.xMin);\n-        bbox[1] = Py::Int(face->bbox.yMin);\n-        bbox[2] = Py::Int(face->bbox.xMax);\n-        bbox[3] = Py::Int(face->bbox.yMax);\n-        setattro(\"bbox\",  bbox);\n-        setattro(\"ascender\",            Py::Int(face->ascender));\n-        setattro(\"descender\",           Py::Int(face->descender));\n-        setattro(\"height\",              Py::Int(face->height));\n-        setattro(\"max_advance_width\",   Py::Int(face->max_advance_width));\n-        setattro(\"max_advance_height\",  Py::Int(face->max_advance_height));\n-        setattro(\"underline_position\",  Py::Int(face->underline_position));\n-        setattro(\"underline_thickness\", Py::Int(face->underline_thickness));\n-    }\n-\n-    setattro(\"fname\", args[0]);\n-\n-    _VERBOSE(\"FT2Font::FT2Font done\");\n }\n \n FT2Font::~FT2Font()\n {\n-    _VERBOSE(\"FT2Font::~FT2Font\");\n+    for (size_t i = 0; i < glyphs.size(); i++) {\n+        FT_Done_Glyph(glyphs[i]);\n+    }\n \n     if (face) {\n         FT_Done_Face(face);\n-\n-        for (size_t i = 0; i < glyphs.size(); i++)\n-        {\n-            FT_Done_Glyph(glyphs[i]);\n-        }\n-    }\n-\n-    if (stream.descriptor.pointer != NULL) {\n-        PyMem_Free(stream.descriptor.pointer);\n     }\n }\n \n-int\n-FT2Font::setattro(const Py::String &name, const Py::Object &value)\n-{\n-    _VERBOSE(\"FT2Font::setattr\");\n-    __dict__[name] = value;\n-    return 1;\n-}\n-\n-Py::Object\n-FT2Font::getattro(const Py::String &name)\n-{\n-    _VERBOSE(\"FT2Font::getattr\");\n-    if (__dict__.hasKey(name)) return __dict__[name];\n-    else return genericGetAttro(name);\n-}\n-\n-char FT2Font::clear__doc__[] =\n-    \"clear()\\n\"\n-    \"\\n\"\n-    \"Clear all the glyphs, reset for a new set_text\"\n-    ;\n-\n-Py::Object\n-FT2Font::clear(const Py::Tuple & args)\n+void FT2Font::clear()\n {\n-    _VERBOSE(\"FT2Font::clear\");\n-    args.verify_length(0);\n-\n     angle = 0.0;\n \n     pen.x = 0;\n     pen.y = 0;\n \n-    for (size_t i = 0; i < glyphs.size(); i++)\n-    {\n+    for (size_t i = 0; i < glyphs.size(); i++) {\n         FT_Done_Glyph(glyphs[i]);\n     }\n \n     glyphs.clear();\n-\n-    return Py::Object();\n }\n-PYCXX_VARARGS_METHOD_DECL(FT2Font, clear)\n \n-char FT2Font::set_size__doc__[] =\n-    \"set_size(ptsize, dpi)\\n\"\n-    \"\\n\"\n-    \"Set the point size and dpi of the text.\\n\"\n-    ;\n-\n-Py::Object\n-FT2Font::set_size(const Py::Tuple & args)\n+void FT2Font::set_size(double ptsize, double dpi)\n {\n-    _VERBOSE(\"FT2Font::set_size\");\n-    args.verify_length(2);\n-\n-    double ptsize = Py::Float(args[0]);\n-    double dpi = Py::Float(args[1]);\n-\n-    int error = FT_Set_Char_Size(face, (long)(ptsize * 64), 0,\n-                                 (unsigned int)dpi * hinting_factor,\n-                                 (unsigned int)dpi);\n+    int error = FT_Set_Char_Size(\n+        face, (long)(ptsize * 64), 0, (unsigned int)(dpi * hinting_factor), (unsigned int)dpi);\n     static FT_Matrix transform = { 65536 / hinting_factor, 0, 0, 65536 };\n     FT_Set_Transform(face, &transform, 0);\n \n-    if (error)\n-    {\n-        throw Py::RuntimeError(\"Could not set the fontsize\");\n+    if (error) {\n+        throw \"Could not set the fontsize\";\n     }\n-    return Py::Object();\n }\n-PYCXX_VARARGS_METHOD_DECL(FT2Font, set_size)\n \n-char FT2Font::set_charmap__doc__[] =\n-    \"set_charmap(i)\\n\"\n-    \"\\n\"\n-    \"Make the i-th charmap current\\n\"\n-    ;\n-\n-Py::Object\n-FT2Font::set_charmap(const Py::Tuple & args)\n+void FT2Font::set_charmap(int i)\n {\n-    _VERBOSE(\"FT2Font::set_charmap\");\n-    args.verify_length(1);\n-\n-    int i = Py::Int(args[0]);\n-    if (i >= face->num_charmaps)\n-    {\n-        throw Py::ValueError(\"i exceeds the available number of char maps\");\n+    if (i >= face->num_charmaps) {\n+        throw \"i exceeds the available number of char maps\";\n     }\n     FT_CharMap charmap = face->charmaps[i];\n-    if (FT_Set_Charmap(face, charmap))\n-    {\n-        throw Py::ValueError(\"Could not set the charmap\");\n+    if (FT_Set_Charmap(face, charmap)) {\n+        throw \"Could not set the charmap\";\n     }\n-    return Py::Object();\n }\n-PYCXX_VARARGS_METHOD_DECL(FT2Font, set_charmap)\n \n-char FT2Font::select_charmap__doc__[] =\n-    \"select_charmap(i)\\n\"\n-    \"\\n\"\n-    \"select charmap i where i is one of the FT_Encoding number\\n\"\n-    ;\n-\n-Py::Object\n-FT2Font::select_charmap(const Py::Tuple & args)\n+void FT2Font::select_charmap(unsigned long i)\n {\n-    _VERBOSE(\"FT2Font::set_charmap\");\n-    args.verify_length(1);\n-\n-    unsigned long i = Py::Long(args[0]);\n-    //if (FT_Select_Charmap( face, FT_ENCODING_ADOBE_CUSTOM ))\n-    if (FT_Select_Charmap(face, (FT_Encoding) i))\n-    {\n-        throw Py::ValueError(\"Could not set the charmap\");\n+    if (FT_Select_Charmap(face, (FT_Encoding)i)) {\n+        throw \"Could not set the charmap\";\n     }\n-    return Py::Object();\n }\n-PYCXX_VARARGS_METHOD_DECL(FT2Font, select_charmap)\n \n-FT_BBox\n-FT2Font::compute_string_bbox()\n+FT_BBox FT2Font::compute_string_bbox()\n {\n-    _VERBOSE(\"FT2Font::compute_string_bbox\");\n-\n     FT_BBox bbox;\n     /* initialize string bbox to \"empty\" values */\n     bbox.xMin = bbox.yMin = 32000;\n     bbox.xMax = bbox.yMax = -32000;\n \n     int right_side = 0;\n-    for (size_t n = 0; n < glyphs.size(); n++)\n-    {\n+    for (size_t n = 0; n < glyphs.size(); n++) {\n         FT_BBox glyph_bbox;\n         FT_Glyph_Get_CBox(glyphs[n], ft_glyph_bbox_subpixels, &glyph_bbox);\n-        if (glyph_bbox.xMin < bbox.xMin) bbox.xMin = glyph_bbox.xMin;\n-        if (glyph_bbox.yMin < bbox.yMin) bbox.yMin = glyph_bbox.yMin;\n-        if (glyph_bbox.xMin == glyph_bbox.xMax)\n-        {\n-            right_side += glyphs[n]->advance.x >> 10;\n-            if (right_side > bbox.xMax) bbox.xMax = right_side;\n+        if (glyph_bbox.xMin < bbox.xMin) {\n+            bbox.xMin = glyph_bbox.xMin;\n         }\n-        else\n-        {\n-            if (glyph_bbox.xMax > bbox.xMax) bbox.xMax = glyph_bbox.xMax;\n+        if (glyph_bbox.yMin < bbox.yMin) {\n+            bbox.yMin = glyph_bbox.yMin;\n+        }\n+        if (glyph_bbox.xMin == glyph_bbox.xMax) {\n+            right_side += glyphs[n]->advance.x >> 10;\n+            if (right_side > bbox.xMax) {\n+                bbox.xMax = right_side;\n+            }\n+        } else {\n+            if (glyph_bbox.xMax > bbox.xMax) {\n+                bbox.xMax = glyph_bbox.xMax;\n+            }\n         }\n-        if (glyph_bbox.yMax > bbox.yMax) bbox.yMax = glyph_bbox.yMax;\n+        if (glyph_bbox.yMax > bbox.yMax)\n+            bbox.yMax = glyph_bbox.yMax;\n     }\n     /* check that we really grew the string bbox */\n-    if (bbox.xMin > bbox.xMax)\n-    {\n+    if (bbox.xMin > bbox.xMax) {\n         bbox.xMin = 0;\n         bbox.yMin = 0;\n         bbox.xMax = 0;\n@@ -1154,84 +603,26 @@ FT2Font::compute_string_bbox()\n     return bbox;\n }\n \n-char FT2Font::get_kerning__doc__[] =\n-    \"dx = get_kerning(left, right, mode)\\n\"\n-    \"\\n\"\n-    \"Get the kerning between left char and right glyph indices\\n\"\n-    \"mode is a kerning mode constant\\n\"\n-    \"  KERNING_DEFAULT  - Return scaled and grid-fitted kerning distances\\n\"\n-    \"  KERNING_UNFITTED - Return scaled but un-grid-fitted kerning distances\\n\"\n-    \"  KERNING_UNSCALED - Return the kerning vector in original font units\\n\"\n-    ;\n-Py::Object\n-FT2Font::get_kerning(const Py::Tuple & args)\n+int FT2Font::get_kerning(int left, int right, int mode)\n {\n-    _VERBOSE(\"FT2Font::get_kerning\");\n-    args.verify_length(3);\n-    int left = Py::Int(args[0]);\n-    int right = Py::Int(args[1]);\n-    int mode = Py::Int(args[2]);\n-\n-\n-    if (!FT_HAS_KERNING(face))\n-    {\n-        return Py::Int(0);\n+    if (!FT_HAS_KERNING(face)) {\n+        return 0;\n     }\n     FT_Vector delta;\n \n-    if (!FT_Get_Kerning(face, left, right, mode, &delta))\n-    {\n-        return Py::Int(delta.x / hinting_factor);\n-    }\n-    else\n-    {\n-        return Py::Int(0);\n-\n+    if (!FT_Get_Kerning(face, left, right, mode, &delta)) {\n+        return (int)(delta.x / hinting_factor);\n+    } else {\n+        return 0;\n     }\n }\n-PYCXX_VARARGS_METHOD_DECL(FT2Font, get_kerning)\n \n-\n-char FT2Font::set_text__doc__[] =\n-    \"set_text(s, angle)\\n\"\n-    \"\\n\"\n-    \"Set the text string and angle.\\n\"\n-    \"You must call this before draw_glyphs_to_bitmap\\n\"\n-    \"A sequence of x,y positions is returned\";\n-Py::Object\n-FT2Font::set_text(const Py::Tuple & args, const Py::Dict & kwargs)\n+void FT2Font::set_text(\n+    size_t N, uint32_t *codepoints, double angle, FT_UInt32 flags, std::vector<double> &xys)\n {\n-    _VERBOSE(\"FT2Font::set_text\");\n-    args.verify_length(2);\n-\n-\n-    Py::String text(args[0]);\n-    std::string stdtext = \"\";\n-    Py_UNICODE* pcode = NULL;\n-    size_t N = 0;\n-    if (PyUnicode_Check(text.ptr()))\n-    {\n-        pcode = PyUnicode_AsUnicode(text.ptr());\n-        N = PyUnicode_GetSize(text.ptr());\n-    }\n-    else\n-    {\n-        stdtext = text.as_std_string();\n-        N = stdtext.size();\n-    }\n-\n-\n-    angle = Py::Float(args[1]);\n-\n-    angle = angle / 360.0 * 2 * 3.14159;\n+    angle = angle / 360.0 * 2 * M_PI;\n \n-    long flags = FT_LOAD_FORCE_AUTOHINT;\n-    if (kwargs.hasKey(\"flags\"))\n-    {\n-        flags = Py::Long(kwargs[\"flags\"]);\n-    }\n-\n-    //this computes width and height in subpixels so we have to divide by 64\n+    // this computes width and height in subpixels so we have to divide by 64\n     matrix.xx = (FT_Fixed)(cos(angle) * 0x10000L);\n     matrix.xy = (FT_Fixed)(-sin(angle) * 0x10000L);\n     matrix.yx = (FT_Fixed)(sin(angle) * 0x10000L);\n@@ -1244,36 +635,20 @@ FT2Font::set_text(const Py::Tuple & args, const Py::Dict & kwargs)\n     pen.x = 0;\n     pen.y = 0;\n \n-    Py::Tuple xys(N);\n-    for (unsigned int n = 0; n < N; n++)\n-    {\n+    for (unsigned int n = 0; n < N; n++) {\n         std::string thischar(\"?\");\n         FT_UInt glyph_index;\n \n-\n-        if (pcode == NULL)\n-        {\n-            // plain ol string\n-            thischar = stdtext[n];\n-            glyph_index = FT_Get_Char_Index(face, stdtext[n]);\n-        }\n-        else\n-        {\n-            //unicode\n-            glyph_index = FT_Get_Char_Index(face, pcode[n]);\n-        }\n+        glyph_index = FT_Get_Char_Index(face, codepoints[n]);\n \n         // retrieve kerning distance and move pen position\n-        if (use_kerning && previous && glyph_index)\n-        {\n+        if (use_kerning && previous && glyph_index) {\n             FT_Vector delta;\n-            FT_Get_Kerning(face, previous, glyph_index,\n-                           FT_KERNING_DEFAULT, &delta);\n+            FT_Get_Kerning(face, previous, glyph_index, FT_KERNING_DEFAULT, &delta);\n             pen.x += delta.x / hinting_factor;\n         }\n         error = FT_Load_Glyph(face, glyph_index, flags);\n-        if (error)\n-        {\n+        if (error) {\n             std::cerr << \"\\tcould not load glyph for \" << thischar << std::endl;\n             continue;\n         }\n@@ -1284,1227 +659,172 @@ FT2Font::set_text(const Py::Tuple & args, const Py::Dict & kwargs)\n         FT_Glyph thisGlyph;\n         error = FT_Get_Glyph(face->glyph, &thisGlyph);\n \n-        if (error)\n-        {\n+        if (error) {\n             std::cerr << \"\\tcould not get glyph for \" << thischar << std::endl;\n             continue;\n         }\n         // ignore errors, jump to next glyph\n \n         FT_Glyph_Transform(thisGlyph, 0, &pen);\n-        Py::Tuple xy(2);\n-        xy[0] = Py::Float(pen.x);\n-        xy[1] = Py::Float(pen.y);\n-        xys[n] = xy;\n+        xys.push_back(pen.x);\n+        xys.push_back(pen.y);\n         pen.x += face->glyph->advance.x;\n \n         previous = glyph_index;\n         glyphs.push_back(thisGlyph);\n     }\n \n     // now apply the rotation\n-    for (unsigned int n = 0; n < glyphs.size(); n++)\n-    {\n+    for (unsigned int n = 0; n < glyphs.size(); n++) {\n         FT_Glyph_Transform(glyphs[n], &matrix, 0);\n     }\n-\n-    _VERBOSE(\"FT2Font::set_text done\");\n-    return xys;\n }\n-PYCXX_KEYWORDS_METHOD_DECL(FT2Font, set_text)\n-\n-char FT2Font::get_num_glyphs__doc__[] =\n-    \"get_num_glyphs()\\n\"\n-    \"\\n\"\n-    \"Return the number of loaded glyphs\\n\"\n-    ;\n-Py::Object\n-FT2Font::get_num_glyphs(const Py::Tuple & args)\n-{\n-    _VERBOSE(\"FT2Font::get_num_glyphs\");\n-    args.verify_length(0);\n \n-    return Py::Int((long)glyphs.size());\n-}\n-PYCXX_VARARGS_METHOD_DECL(FT2Font, get_num_glyphs)\n-\n-char FT2Font::load_char__doc__[] =\n-    \"load_char(charcode, flags=LOAD_FORCE_AUTOHINT)\\n\"\n-    \"\\n\"\n-    \"Load character with charcode in current fontfile and set glyph.\\n\"\n-    \"The flags argument can be a bitwise-or of the LOAD_XXX constants.\\n\"\n-    \"Return value is a Glyph object, with attributes\\n\"\n-    \"  width          # glyph width\\n\"\n-    \"  height         # glyph height\\n\"\n-    \"  bbox           # the glyph bbox (xmin, ymin, xmax, ymax)\\n\"\n-    \"  horiBearingX   # left side bearing in horizontal layouts\\n\"\n-    \"  horiBearingY   # top side bearing in horizontal layouts\\n\"\n-    \"  horiAdvance    # advance width for horizontal layout\\n\"\n-    \"  vertBearingX   # left side bearing in vertical layouts\\n\"\n-    \"  vertBearingY   # top side bearing in vertical layouts\\n\"\n-    \"  vertAdvance    # advance height for vertical layout\\n\"\n-    ;\n-Py::Object\n-FT2Font::load_char(const Py::Tuple & args, const Py::Dict & kwargs)\n+void FT2Font::load_char(long charcode, FT_UInt32 flags)\n {\n-    _VERBOSE(\"FT2Font::load_char\");\n-    //load a char using the unsigned long charcode\n-\n-    args.verify_length(1);\n-    long charcode = Py::Long(args[0]), flags = Py::Long(FT_LOAD_FORCE_AUTOHINT);\n-    if (kwargs.hasKey(\"flags\"))\n-    {\n-        flags = Py::Long(kwargs[\"flags\"]);\n-    }\n-\n     int error = FT_Load_Char(face, (unsigned long)charcode, flags);\n \n-    if (error)\n-    {\n-        throw Py::RuntimeError(Printf(\"Could not load charcode %d\", charcode).str());\n+    if (error) {\n+        throw \"Could not load charcode\";\n     }\n \n     FT_Glyph thisGlyph;\n     error = FT_Get_Glyph(face->glyph, &thisGlyph);\n \n-    if (error)\n-    {\n-        throw Py::RuntimeError(Printf(\"Could not get glyph for char %d\", charcode).str());\n+    if (error) {\n+        throw \"Could not get glyph\";\n     }\n \n-    size_t num = glyphs.size();  //the index into the glyphs list\n     glyphs.push_back(thisGlyph);\n-    return Glyph::factory(face, thisGlyph, num, hinting_factor);\n }\n-PYCXX_KEYWORDS_METHOD_DECL(FT2Font, load_char)\n-\n-char FT2Font::load_glyph__doc__[] =\n-    \"load_glyph(glyphindex, flags=LOAD_FORCE_AUTOHINT)\\n\"\n-    \"\\n\"\n-    \"Load character with glyphindex in current fontfile and set glyph.\\n\"\n-    \"The flags argument can be a bitwise-or of the LOAD_XXX constants.\\n\"\n-    \"Return value is a Glyph object, with attributes\\n\"\n-    \"  width          # glyph width\\n\"\n-    \"  height         # glyph height\\n\"\n-    \"  bbox           # the glyph bbox (xmin, ymin, xmax, ymax)\\n\"\n-    \"  horiBearingX   # left side bearing in horizontal layouts\\n\"\n-    \"  horiBearingY   # top side bearing in horizontal layouts\\n\"\n-    \"  horiAdvance    # advance width for horizontal layout\\n\"\n-    \"  vertBearingX   # left side bearing in vertical layouts\\n\"\n-    \"  vertBearingY   # top side bearing in vertical layouts\\n\"\n-    \"  vertAdvance    # advance height for vertical layout\\n\"\n-    ;\n-Py::Object\n-FT2Font::load_glyph(const Py::Tuple & args, const Py::Dict & kwargs)\n-{\n-    _VERBOSE(\"FT2Font::load_glyph\");\n-    //load a char using the unsigned long charcode\n-\n-    args.verify_length(1);\n-    long glyph_index = Py::Long(args[0]), flags = Py::Long(FT_LOAD_FORCE_AUTOHINT);\n-    if (kwargs.hasKey(\"flags\"))\n-    {\n-        flags = Py::Long(kwargs[\"flags\"]);\n-    }\n \n+void FT2Font::load_glyph(FT_UInt glyph_index, FT_UInt32 flags)\n+{\n     int error = FT_Load_Glyph(face, glyph_index, flags);\n \n-    if (error)\n-    {\n-        throw Py::RuntimeError(Printf(\"Could not load glyph index %d\", glyph_index).str());\n+    if (error) {\n+        throw \"Could not load glyph\";\n     }\n \n     FT_Glyph thisGlyph;\n     error = FT_Get_Glyph(face->glyph, &thisGlyph);\n \n-    if (error)\n-    {\n-        throw Py::RuntimeError(Printf(\"Could not get glyph for glyph index %d\", glyph_index).str());\n+    if (error) {\n+        throw \"Could not load glyph\";\n     }\n \n-    size_t num = glyphs.size();  //the index into the glyphs list\n     glyphs.push_back(thisGlyph);\n-    return Glyph::factory(face, thisGlyph, num, hinting_factor);\n }\n-PYCXX_KEYWORDS_METHOD_DECL(FT2Font, load_glyph)\n-\n-char FT2Font::get_width_height__doc__[] =\n-    \"w, h = get_width_height()\\n\"\n-    \"\\n\"\n-    \"Get the width and height in 26.6 subpixels of the current string set by set_text\\n\"\n-    \"The rotation of the string is accounted for.  To get width and height\\n\"\n-    \"in pixels, divide these values by 64\\n\"\n-    ;\n-Py::Object\n-FT2Font::get_width_height(const Py::Tuple & args)\n-{\n-    _VERBOSE(\"FT2Font::get_width_height\");\n-    args.verify_length(0);\n \n+void FT2Font::get_width_height(long *width, long *height)\n+{\n     FT_BBox bbox = compute_string_bbox();\n \n-    Py::Tuple ret(2);\n-    ret[0] = Py::Int(bbox.xMax - bbox.xMin);\n-    ret[1] = Py::Int(bbox.yMax - bbox.yMin);\n-    return ret;\n+    *width = bbox.xMax - bbox.xMin;\n+    *height = bbox.yMax - bbox.yMin;\n }\n-PYCXX_VARARGS_METHOD_DECL(FT2Font, get_width_height)\n-\n-char FT2Font::get_descent__doc__[] =\n-    \"d = get_descent()\\n\"\n-    \"\\n\"\n-    \"Get the descent of the current string set by set_text in 26.6 subpixels.\\n\"\n-    \"The rotation of the string is accounted for.  To get the descent\\n\"\n-    \"in pixels, divide this value by 64.\\n\"\n-    ;\n-Py::Object\n-FT2Font::get_descent(const Py::Tuple & args)\n-{\n-    _VERBOSE(\"FT2Font::get_descent\");\n-    args.verify_length(0);\n \n+long FT2Font::get_descent()\n+{\n     FT_BBox bbox = compute_string_bbox();\n-    return Py::Int(- bbox.yMin);;\n+    return -bbox.yMin;\n }\n-PYCXX_VARARGS_METHOD_DECL(FT2Font, get_descent)\n-\n-char FT2Font::draw_glyphs_to_bitmap__doc__[] =\n-    \"draw_glyphs_to_bitmap()\\n\"\n-    \"\\n\"\n-    \"Draw the glyphs that were loaded by set_text to the bitmap\\n\"\n-    \"The bitmap size will be automatically set to include the glyphs\\n\"\n-    ;\n-Py::Object\n-FT2Font::draw_glyphs_to_bitmap(const Py::Tuple &args, const Py::Dict &kwargs)\n-{\n-\n-    _VERBOSE(\"FT2Font::draw_glyphs_to_bitmap\");\n-    args.verify_length(0);\n-\n-    long antialiased = 1;\n-    if (kwargs.hasKey(\"antialiased\"))\n-    {\n-        antialiased = Py::Long(kwargs[\"antialiased\"]);\n-    }\n \n+void FT2Font::draw_glyphs_to_bitmap(bool antialiased)\n+{\n     FT_BBox string_bbox = compute_string_bbox();\n     size_t width = (string_bbox.xMax - string_bbox.xMin) / 64 + 2;\n     size_t height = (string_bbox.yMax - string_bbox.yMin) / 64 + 2;\n \n-    image = FT2Image::factory(width, height);\n-    FT2Image* image_cxx = Py::PythonClassObject<FT2Image>(image).getCxxObject();\n+    image.resize(width, height);\n \n-    for (size_t n = 0; n < glyphs.size(); n++)\n-    {\n+    for (size_t n = 0; n < glyphs.size(); n++) {\n         FT_BBox bbox;\n         FT_Glyph_Get_CBox(glyphs[n], ft_glyph_bbox_pixels, &bbox);\n \n         error = FT_Glyph_To_Bitmap(\n-            &glyphs[n],\n-            antialiased ? FT_RENDER_MODE_NORMAL : FT_RENDER_MODE_MONO,\n-            0,\n-            1);\n-        if (error)\n-        {\n-            throw Py::RuntimeError(\"Could not convert glyph to bitmap\");\n+            &glyphs[n], antialiased ? FT_RENDER_MODE_NORMAL : FT_RENDER_MODE_MONO, 0, 1);\n+        if (error) {\n+            throw \"Could not convert glyph to bitmap\";\n         }\n \n         FT_BitmapGlyph bitmap = (FT_BitmapGlyph)glyphs[n];\n         // now, draw to our target surface (convert position)\n \n-        //bitmap left and top in pixel, string bbox in subpixel\n+        // bitmap left and top in pixel, string bbox in subpixel\n         FT_Int x = (FT_Int)(bitmap->left - (string_bbox.xMin / 64.));\n         FT_Int y = (FT_Int)((string_bbox.yMax / 64.) - bitmap->top + 1);\n \n-        image_cxx->draw_bitmap(&bitmap->bitmap, x, y);\n+        image.draw_bitmap(&bitmap->bitmap, x, y);\n     }\n-\n-    return Py::Object();\n }\n-PYCXX_KEYWORDS_METHOD_DECL(FT2Font, draw_glyphs_to_bitmap)\n-\n-char FT2Font::get_xys__doc__[] =\n-    \"get_xys()\\n\"\n-    \"\\n\"\n-    \"Get the xy locations of the current glyphs\\n\"\n-    ;\n-Py::Object\n-FT2Font::get_xys(const Py::Tuple &args, const Py::Dict &kwargs)\n-{\n-    _VERBOSE(\"FT2Font::get_xys\");\n-    args.verify_length(0);\n-\n-    long antialiased = 1;\n-    if (kwargs.hasKey(\"antialiased\"))\n-    {\n-        antialiased = Py::Long(kwargs[\"antialiased\"]);\n-    }\n \n+void FT2Font::get_xys(bool antialiased, std::vector<double> &xys)\n+{\n     FT_BBox string_bbox = compute_string_bbox();\n-    Py::Tuple xys(glyphs.size());\n \n-    for (size_t n = 0; n < glyphs.size(); n++)\n-    {\n+    for (size_t n = 0; n < glyphs.size(); n++) {\n \n         FT_BBox bbox;\n         FT_Glyph_Get_CBox(glyphs[n], ft_glyph_bbox_pixels, &bbox);\n \n         error = FT_Glyph_To_Bitmap(\n-            &glyphs[n],\n-            antialiased ? FT_RENDER_MODE_NORMAL : FT_RENDER_MODE_MONO,\n-            0,\n-            1);\n-        if (error)\n-        {\n-            throw Py::RuntimeError(\"Could not convert glyph to bitmap\");\n+            &glyphs[n], antialiased ? FT_RENDER_MODE_NORMAL : FT_RENDER_MODE_MONO, 0, 1);\n+        if (error) {\n+            throw \"Could not convert glyph to bitmap\";\n         }\n \n         FT_BitmapGlyph bitmap = (FT_BitmapGlyph)glyphs[n];\n \n-\n-        //bitmap left and top in pixel, string bbox in subpixel\n+        // bitmap left and top in pixel, string bbox in subpixel\n         FT_Int x = (FT_Int)(bitmap->left - string_bbox.xMin / 64.);\n         FT_Int y = (FT_Int)(string_bbox.yMax / 64. - bitmap->top + 1);\n-        //make sure the index is non-neg\n+        // make sure the index is non-neg\n         x = x < 0 ? 0 : x;\n         y = y < 0 ? 0 : y;\n-        Py::Tuple xy(2);\n-        xy[0] = Py::Float(x);\n-        xy[1] = Py::Float(y);\n-        xys[n] = xy;\n+        xys.push_back(x);\n+        xys.push_back(y);\n     }\n-\n-    return xys;\n }\n-PYCXX_KEYWORDS_METHOD_DECL(FT2Font, get_xys)\n-\n-char FT2Font::draw_glyph_to_bitmap__doc__[] =\n-    \"draw_glyph_to_bitmap(bitmap, x, y, glyph)\\n\"\n-    \"\\n\"\n-    \"Draw a single glyph to the bitmap at pixel locations x,y\\n\"\n-    \"Note it is your responsibility to set up the bitmap manually\\n\"\n-    \"with set_bitmap_size(w,h) before this call is made.\\n\"\n-    \"\\n\"\n-    \"If you want automatic layout, use set_text in combinations with\\n\"\n-    \"draw_glyphs_to_bitmap.  This function is intended for people who\\n\"\n-    \"want to render individual glyphs at precise locations, eg, a\\n\"\n-    \"a glyph returned by load_char\\n\";\n-\n-Py::Object\n-FT2Font::draw_glyph_to_bitmap(const Py::Tuple &args, const Py::Dict &kwargs)\n-{\n-    _VERBOSE(\"FT2Font::draw_glyph_to_bitmap\");\n-    args.verify_length(4);\n \n-    FT2Image* im = Py::PythonClassObject<FT2Image>(args[0]).getCxxObject();\n-\n-    double xd = Py::Float(args[1]);\n-    double yd = Py::Float(args[2]);\n-    long x = (long)xd;\n-    long y = (long)yd;\n+void FT2Font::draw_glyph_to_bitmap(FT2Image &im, int x, int y, size_t glyphInd, bool antialiased)\n+{\n     FT_Vector sub_offset;\n     sub_offset.x = 0; // int((xd - (double)x) * 64.0);\n     sub_offset.y = 0; // int((yd - (double)y) * 64.0);\n \n-    Glyph* glyph = Py::PythonClassObject<Glyph>(args[3]).getCxxObject();\n-\n-    long antialiased = 1;\n-    if (kwargs.hasKey(\"antialiased\"))\n-    {\n-        antialiased = Py::Long(kwargs[\"antialiased\"]);\n-    }\n-\n-    if (glyph->glyphInd >= glyphs.size())\n-    {\n-        throw Py::ValueError(\"glyph num is out of range\");\n+    if (glyphInd >= glyphs.size()) {\n+        throw \"glyph num is out of range\";\n     }\n \n-    error = FT_Glyph_To_Bitmap(\n-        &glyphs[glyph->glyphInd],\n-        antialiased ? FT_RENDER_MODE_NORMAL : FT_RENDER_MODE_MONO,\n-        &sub_offset,  // additional translation\n-        1   //destroy image\n-        );\n-    if (error)\n-    {\n-        throw Py::RuntimeError(\"Could not convert glyph to bitmap\");\n+    error = FT_Glyph_To_Bitmap(&glyphs[glyphInd],\n+                               antialiased ? FT_RENDER_MODE_NORMAL : FT_RENDER_MODE_MONO,\n+                               &sub_offset, // additional translation\n+                               1 // destroy image\n+                               );\n+    if (error) {\n+        throw \"Could not convert glyph to bitmap\";\n     }\n \n-    FT_BitmapGlyph bitmap = (FT_BitmapGlyph)glyphs[glyph->glyphInd];\n+    FT_BitmapGlyph bitmap = (FT_BitmapGlyph)glyphs[glyphInd];\n \n-    im->draw_bitmap(&bitmap->bitmap, x + bitmap->left, y);\n-    return Py::Object();\n+    im.draw_bitmap(&bitmap->bitmap, x + bitmap->left, y);\n }\n-PYCXX_KEYWORDS_METHOD_DECL(FT2Font, draw_glyph_to_bitmap)\n-\n-char FT2Font::get_glyph_name__doc__[] =\n-    \"get_glyph_name(index)\\n\"\n-    \"\\n\"\n-    \"Retrieves the ASCII name of a given glyph in a face.\\n\"\n-    ;\n-Py::Object\n-FT2Font::get_glyph_name(const Py::Tuple & args)\n-{\n-    _VERBOSE(\"FT2Font::get_glyph_name\");\n-    args.verify_length(1);\n-\n-    char buffer[128];\n-    FT_UInt glyph_number = (FT_UInt)(unsigned long long)Py::Int(args[0]);\n \n-    if (!FT_HAS_GLYPH_NAMES(face))\n-    {\n+void FT2Font::get_glyph_name(unsigned int glyph_number, char *buffer)\n+{\n+    if (!FT_HAS_GLYPH_NAMES(face)) {\n         /* Note that this generated name must match the name that\n            is generated by ttconv in ttfont_CharStrings_getname. */\n         PyOS_snprintf(buffer, 128, \"uni%08x\", glyph_number);\n     } else {\n-        if (FT_Get_Glyph_Name(face, glyph_number, buffer, 128))\n-        {\n-            throw Py::RuntimeError(\"Could not get glyph names.\");\n-        }\n-     }\n-\n-    return Py::String(buffer);\n-}\n-PYCXX_VARARGS_METHOD_DECL(FT2Font, get_glyph_name)\n-\n-char FT2Font::get_charmap__doc__[] =\n-    \"get_charmap()\\n\"\n-    \"\\n\"\n-    \"Returns a dictionary that maps the character codes of the selected charmap\\n\"\n-    \"(Unicode by default) to their corresponding glyph indices.\\n\"\n-    ;\n-Py::Object\n-FT2Font::get_charmap(const Py::Tuple & args)\n-{\n-    _VERBOSE(\"FT2Font::get_charmap\");\n-    args.verify_length(0);\n-\n-    FT_UInt index;\n-    Py::Dict charmap;\n-\n-    //std::cout << \"asd\" << face->charmaps[1]->encoding << std::endl;\n-    FT_ULong code = FT_Get_First_Char(face, &index);\n-    while (index != 0)\n-    {\n-        charmap[Py::Long((long) code)] = Py::Int((int) index);\n-        code = FT_Get_Next_Char(face, code, &index);\n-    }\n-    return charmap;\n-}\n-PYCXX_VARARGS_METHOD_DECL(FT2Font, get_charmap)\n-\n-// ID        Platform       Encoding\n-// 0         Unicode        Reserved (set to 0)\n-// 1         Macintoch      The Script Manager code\n-// 2         ISO            ISO encoding\n-// 3         Microsoft      Microsoft encoding\n-// 240-255   User-defined   Reserved for all nonregistered platforms\n-\n-// Code      ISO encoding scheme\n-// 0         7-bit ASCII\n-// 1         ISO 10646\n-// 2         ISO 8859-1\n-\n-// Code      Language       Code      Language       Code\n-// 0         English        10        Hebrew         20        Urdu\n-// 1         French         11        Japanese       21        Hindi\n-// 2         German         12        Arabic         22        Thai\n-// 3         Italian        13        Finnish\n-// 4         Dutch          14        Greek\n-// 5         Swedish        15        Icelandic\n-// 6         Spanish        16        Maltese\n-// 7         Danish         17        Turkish\n-// 8         Portuguese     18        Yugoslavian\n-// 9         Norwegian      19        Chinese\n-\n-// Code      Meaning        Description\n-// 0         Copyright notice     e.g. \"Copyright Apple Computer, Inc. 1992\n-// 1         Font family name     e.g. \"New York\"\n-// 2         Font style           e.g. \"Bold\"\n-// 3         Font identification  e.g. \"Apple Computer New York Bold Ver 1\"\n-// 4         Full font name       e.g. \"New York Bold\"\n-// 5         Version string       e.g. \"August 10, 1991, 1.08d21\"\n-// 6         Postscript name      e.g. \"Times-Bold\"\n-// 7         Trademark\n-// 8         Designer             e.g. \"Apple Computer\"\n-\n-char FT2Font::get_sfnt__doc__[] =\n-    \"get_sfnt(name)\\n\"\n-    \"\\n\"\n-    \"Get all values from the SFNT names table.  Result is a dictionary whose\"\n-    \"key is the platform-ID, ISO-encoding-scheme, language-code, and\"\n-    \"description.\\n\"\n-    /*\n-      \"The font name identifier codes are:\\n\"\n-      \"\\n\"\n-      \"  0    Copyright notice     e.g. Copyright Apple Computer, Inc. 1992\\n\"\n-      \"  1    Font family name     e.g. New York\\n\"\n-      \"  2    Font style           e.g. Bold\\n\"\n-      \"  3    Font identification  e.g. Apple Computer New York Bold Ver 1\\n\"\n-      \"  4    Full font name       e.g. New York Bold\\n\"\n-      \"  5    Version string       e.g. August 10, 1991, 1.08d21\\n\"\n-      \"  6    Postscript name      e.g. Times-Bold\\n\"\n-      \"  7    Trademark            \\n\"\n-      \"  8    Designer             e.g. Apple Computer\\n\"\n-      \"  11   URL                  e.g. http://www.apple.com\\n\"\n-      \"  13   Copyright license    \\n\"\n-    */\n-    ;\n-Py::Object\n-FT2Font::get_sfnt(const Py::Tuple & args)\n-{\n-    _VERBOSE(\"FT2Font::get_sfnt\");\n-    args.verify_length(0);\n-\n-    if (!(face->face_flags & FT_FACE_FLAG_SFNT))\n-    {\n-        throw Py::RuntimeError(\"No SFNT name table\");\n-    }\n-\n-    size_t count = FT_Get_Sfnt_Name_Count(face);\n-\n-    Py::Dict names;\n-    for (size_t j = 0; j < count; j++)\n-    {\n-        FT_SfntName sfnt;\n-        FT_Error error = FT_Get_Sfnt_Name(face, j, &sfnt);\n-\n-        if (error)\n-        {\n-            throw Py::RuntimeError(\"Could not get SFNT name\");\n-        }\n-\n-        Py::Tuple key(4);\n-        key[0] = Py::Int(sfnt.platform_id);\n-        key[1] = Py::Int(sfnt.encoding_id);\n-        key[2] = Py::Int(sfnt.language_id);\n-        key[3] = Py::Int(sfnt.name_id);\n-\n-        names[key] = Py::asObject\n-            (PyBytes_FromStringAndSize(\n-                (const char *)sfnt.string, sfnt.string_len));\n-    }\n-    return names;\n-}\n-PYCXX_VARARGS_METHOD_DECL(FT2Font, get_sfnt)\n-\n-char FT2Font::get_name_index__doc__[] =\n-    \"get_name_index(name)\\n\"\n-    \"\\n\"\n-    \"Returns the glyph index of a given glyph name.\\n\"\n-    \"The glyph index 0 means `undefined character code'.\\n\"\n-    ;\n-Py::Object\n-FT2Font::get_name_index(const Py::Tuple & args)\n-{\n-    _VERBOSE(\"FT2Font::get_name_index\");\n-    args.verify_length(1);\n-    std::string glyphname = Py::String(args[0]).encode(\"ascii\");\n-\n-    return Py::Long((long)\n-                    FT_Get_Name_Index(face, (FT_String *) glyphname.c_str()));\n-}\n-PYCXX_VARARGS_METHOD_DECL(FT2Font, get_name_index)\n-\n-char FT2Font::get_ps_font_info__doc__[] =\n-    \"get_ps_font_info()\\n\"\n-    \"\\n\"\n-    \"Return the information in the PS Font Info structure.\\n\"\n-    ;\n-Py::Object\n-FT2Font::get_ps_font_info(const Py::Tuple & args)\n-{\n-    _VERBOSE(\"FT2Font::get_ps_font_info\");\n-    args.verify_length(0);\n-    PS_FontInfoRec fontinfo;\n-\n-    FT_Error error = FT_Get_PS_Font_Info(face, &fontinfo);\n-    if (error)\n-    {\n-        Py::RuntimeError(\"Could not get PS font info\");\n-        return Py::Object();\n-    }\n-\n-    Py::Tuple info(9);\n-    info[0] = Py::String(fontinfo.version ? fontinfo.version : \"\");\n-    info[1] = Py::String(fontinfo.notice ? fontinfo.notice : \"\");\n-    info[2] = Py::String(fontinfo.full_name ? fontinfo.full_name : \"\");\n-    info[3] = Py::String(fontinfo.family_name ? fontinfo.family_name : \"\");\n-    info[4] = Py::String(fontinfo.weight ? fontinfo.weight : \"\");\n-    info[5] = Py::Long(fontinfo.italic_angle);\n-    info[6] = Py::Int(fontinfo.is_fixed_pitch);\n-    info[7] = Py::Int(fontinfo.underline_position);\n-    info[8] = Py::Int(fontinfo.underline_thickness);\n-    return info;\n-}\n-PYCXX_VARARGS_METHOD_DECL(FT2Font, get_ps_font_info)\n-\n-char FT2Font::get_sfnt_table__doc__[] =\n-    \"get_sfnt_table(name)\\n\"\n-    \"\\n\"\n-    \"Return one of the following SFNT tables: head, maxp, OS/2, hhea, \"\n-    \"vhea, post, or pclt.\\n\"\n-    ;\n-Py::Object\n-FT2Font::get_sfnt_table(const Py::Tuple & args)\n-{\n-    _VERBOSE(\"FT2Font::get_sfnt_table\");\n-    args.verify_length(1);\n-    std::string tagname = Py::String(args[0]).encode(\"ascii\");\n-\n-    int tag;\n-    const char *tags[] = {\"head\", \"maxp\", \"OS/2\", \"hhea\",\n-                          \"vhea\", \"post\", \"pclt\",  NULL\n-                         };\n-\n-    for (tag = 0; tags[tag] != NULL; tag++)\n-    {\n-        if (strcmp(tagname.c_str(), tags[tag]) == 0)\n-        {\n-            break;\n-        }\n-    }\n-\n-    void *table = FT_Get_Sfnt_Table(face, (FT_Sfnt_Tag) tag);\n-    if (!table)\n-    {\n-        return Py::Object();\n-    }\n-\n-    switch (tag)\n-    {\n-    case 0:\n-        {\n-            char head_dict[] = \"{s:(h,h), s:(h,h), s:l, s:l, s:i, s:i,\"\n-                \"s:(l,l), s:(l,l), s:h, s:h, s:h, s:h, s:i, s:i, s:h, s:h, s:h}\";\n-            TT_Header *t = (TT_Header *)table;\n-            return Py::asObject(Py_BuildValue(head_dict,\n-                                              \"version\",\n-                                              FIXED_MAJOR(t->Table_Version),\n-                                              FIXED_MINOR(t->Table_Version),\n-                                              \"fontRevision\",\n-                                              FIXED_MAJOR(t->Font_Revision),\n-                                              FIXED_MINOR(t->Font_Revision),\n-                                              \"checkSumAdjustment\", t->CheckSum_Adjust,\n-                                              \"magicNumber\" ,       t->Magic_Number,\n-                                              \"flags\", (unsigned)t->Flags,\n-                                              \"unitsPerEm\", (unsigned)t->Units_Per_EM,\n-                                              \"created\",            t->Created[0], t->Created[1],\n-                                              \"modified\",           t->Modified[0], t->Modified[1],\n-                                              \"xMin\",               t->xMin,\n-                                              \"yMin\",               t->yMin,\n-                                              \"xMax\",               t->xMax,\n-                                              \"yMax\",               t->yMax,\n-                                              \"macStyle\", (unsigned)t->Mac_Style,\n-                                              \"lowestRecPPEM\", (unsigned)t->Lowest_Rec_PPEM,\n-                                              \"fontDirectionHint\",  t->Font_Direction,\n-                                              \"indexToLocFormat\",   t->Index_To_Loc_Format,\n-                                              \"glyphDataFormat\",    t->Glyph_Data_Format));\n-        }\n-    case 1:\n-        {\n-            char maxp_dict[] = \"{s:(h,h), s:i, s:i, s:i, s:i, s:i, s:i,\"\n-                \"s:i, s:i, s:i, s:i, s:i, s:i, s:i, s:i}\";\n-            TT_MaxProfile *t = (TT_MaxProfile *)table;\n-            return Py::asObject(Py_BuildValue(maxp_dict,\n-                                              \"version\",\n-                                              FIXED_MAJOR(t->version),\n-                                              FIXED_MINOR(t->version),\n-                                              \"numGlyphs\", (unsigned)t->numGlyphs,\n-                                              \"maxPoints\", (unsigned)t->maxPoints,\n-                                              \"maxContours\", (unsigned)t->maxContours,\n-                                              \"maxComponentPoints\",\n-                                              (unsigned)t->maxCompositePoints,\n-                                              \"maxComponentContours\",\n-                                              (unsigned)t->maxCompositeContours,\n-                                              \"maxZones\", (unsigned)t->maxZones,\n-                                              \"maxTwilightPoints\", (unsigned)t->maxTwilightPoints,\n-                                              \"maxStorage\", (unsigned)t->maxStorage,\n-                                              \"maxFunctionDefs\", (unsigned)t->maxFunctionDefs,\n-                                              \"maxInstructionDefs\",\n-                                              (unsigned)t->maxInstructionDefs,\n-                                              \"maxStackElements\", (unsigned)t->maxStackElements,\n-                                              \"maxSizeOfInstructions\",\n-                                              (unsigned)t->maxSizeOfInstructions,\n-                                              \"maxComponentElements\",\n-                                              (unsigned)t->maxComponentElements,\n-                                              \"maxComponentDepth\",\n-                                              (unsigned)t->maxComponentDepth));\n-        }\n-    case 2:\n-        {\n-            #if PY3K\n-            char os_2_dict[] = \"{s:h, s:h, s:h, s:h, s:h, s:h, s:h, s:h,\"\n-                \"s:h, s:h, s:h, s:h, s:h, s:h, s:h, s:h, s:y#, s:(llll),\"\n-                \"s:y#, s:h, s:h, s:h}\";\n-            #else\n-            char os_2_dict[] = \"{s:h, s:h, s:h, s:h, s:h, s:h, s:h, s:h,\"\n-                \"s:h, s:h, s:h, s:h, s:h, s:h, s:h, s:h, s:s#, s:(llll),\"\n-                \"s:s#, s:h, s:h, s:h}\";\n-            #endif\n-            TT_OS2 *t = (TT_OS2 *)table;\n-            return Py::asObject(Py_BuildValue(os_2_dict,\n-                                              \"version\", (unsigned)t->version,\n-                                              \"xAvgCharWidth\",      t->xAvgCharWidth,\n-                                              \"usWeightClass\", (unsigned)t->usWeightClass,\n-                                              \"usWidthClass\", (unsigned)t->usWidthClass,\n-                                              \"fsType\",             t->fsType,\n-                                              \"ySubscriptXSize\",    t->ySubscriptXSize,\n-                                              \"ySubscriptYSize\",    t->ySubscriptYSize,\n-                                              \"ySubscriptXOffset\",  t->ySubscriptXOffset,\n-                                              \"ySubscriptYOffset\",  t->ySubscriptYOffset,\n-                                              \"ySuperscriptXSize\",  t->ySuperscriptXSize,\n-                                              \"ySuperscriptYSize\",  t->ySuperscriptYSize,\n-                                              \"ySuperscriptXOffset\", t->ySuperscriptXOffset,\n-                                              \"ySuperscriptYOffset\", t->ySuperscriptYOffset,\n-                                              \"yStrikeoutSize\",     t->yStrikeoutSize,\n-                                              \"yStrikeoutPosition\", t->yStrikeoutPosition,\n-                                              \"sFamilyClass\",       t->sFamilyClass,\n-                                              \"panose\",             t->panose, 10,\n-                                              \"ulCharRange\",\n-                                              (unsigned long) t->ulUnicodeRange1,\n-                                              (unsigned long) t->ulUnicodeRange2,\n-                                              (unsigned long) t->ulUnicodeRange3,\n-                                              (unsigned long) t->ulUnicodeRange4,\n-                                              \"achVendID\",          t->achVendID, 4,\n-                                              \"fsSelection\", (unsigned)t->fsSelection,\n-                                              \"fsFirstCharIndex\", (unsigned)t->usFirstCharIndex,\n-                                              \"fsLastCharIndex\", (unsigned)t->usLastCharIndex));\n-        }\n-    case 3:\n-        {\n-            char hhea_dict[] = \"{s:(h,h), s:h, s:h, s:h, s:i, s:h, s:h, s:h,\"\n-                \"s:h, s:h, s:h, s:h, s:i}\";\n-            TT_HoriHeader *t = (TT_HoriHeader *)table;\n-            return Py::asObject(Py_BuildValue(hhea_dict,\n-                                              \"version\",\n-                                              FIXED_MAJOR(t->Version),\n-                                              FIXED_MINOR(t->Version),\n-                                              \"ascent\",             t->Ascender,\n-                                              \"descent\",            t->Descender,\n-                                              \"lineGap\",            t->Line_Gap,\n-                                              \"advanceWidthMax\", (unsigned)t->advance_Width_Max,\n-                                              \"minLeftBearing\",     t->min_Left_Side_Bearing,\n-                                              \"minRightBearing\",    t->min_Right_Side_Bearing,\n-                                              \"xMaxExtent\",         t->xMax_Extent,\n-                                              \"caretSlopeRise\",     t->caret_Slope_Rise,\n-                                              \"caretSlopeRun\",      t->caret_Slope_Run,\n-                                              \"caretOffset\",        t->caret_Offset,\n-                                              \"metricDataFormat\",   t->metric_Data_Format,\n-                                              \"numOfLongHorMetrics\",\n-                                              (unsigned)t->number_Of_HMetrics));\n-        }\n-    case 4:\n-        {\n-            char vhea_dict[] = \"{s:(h,h), s:h, s:h, s:h, s:i, s:h, s:h, s:h,\"\n-                \"s:h, s:h, s:h, s:h, s:i}\";\n-            TT_VertHeader *t = (TT_VertHeader *)table;\n-            return Py::asObject(Py_BuildValue(vhea_dict,\n-                                              \"version\",\n-                                              FIXED_MAJOR(t->Version),\n-                                              FIXED_MINOR(t->Version),\n-                                              \"vertTypoAscender\",   t->Ascender,\n-                                              \"vertTypoDescender\",  t->Descender,\n-                                              \"vertTypoLineGap\",    t->Line_Gap,\n-                                              \"advanceHeightMax\", (unsigned)t->advance_Height_Max,\n-                                              \"minTopSideBearing\",  t->min_Top_Side_Bearing,\n-                                              \"minBottomSizeBearing\", t->min_Bottom_Side_Bearing,\n-                                              \"yMaxExtent\",         t->yMax_Extent,\n-                                              \"caretSlopeRise\",     t->caret_Slope_Rise,\n-                                              \"caretSlopeRun\",      t->caret_Slope_Run,\n-                                              \"caretOffset\",        t->caret_Offset,\n-                                              \"metricDataFormat\",   t->metric_Data_Format,\n-                                              \"numOfLongVerMetrics\",\n-                                              (unsigned)t->number_Of_VMetrics));\n-        }\n-    case 5:\n-        {\n-            TT_Postscript *t = (TT_Postscript *)table;\n-            Py::Dict post;\n-            Py::Tuple format(2), angle(2);\n-            format[0] = Py::Int(FIXED_MAJOR(t->FormatType));\n-            format[1] = Py::Int(FIXED_MINOR(t->FormatType));\n-            post[\"format\"]             = format;\n-            angle[0]  = Py::Int(FIXED_MAJOR(t->italicAngle));\n-            angle[1]  = Py::Int(FIXED_MINOR(t->italicAngle));\n-            post[\"italicAngle\"]        = angle;\n-            post[\"underlinePosition\"]  = Py::Int(t->underlinePosition);\n-            post[\"underlineThickness\"] = Py::Int(t->underlineThickness);\n-            post[\"isFixedPitch\"]       = Py::Long((long) t->isFixedPitch);\n-            post[\"minMemType42\"]       = Py::Long((long) t->minMemType42);\n-            post[\"maxMemType42\"]       = Py::Long((long) t->maxMemType42);\n-            post[\"minMemType1\"]        = Py::Long((long) t->minMemType1);\n-            post[\"maxMemType1\"]        = Py::Long((long) t->maxMemType1);\n-            return post;\n-        }\n-    case 6:\n-        {\n-            TT_PCLT *t = (TT_PCLT *)table;\n-            Py::Dict pclt;\n-            Py::Tuple version(2);\n-            version[0] = Py::Int(FIXED_MAJOR(t->Version));\n-            version[1] = Py::Int(FIXED_MINOR(t->Version));\n-            pclt[\"version\"]            = version;\n-            pclt[\"fontNumber\"]         = Py::Long((long) t->FontNumber);\n-            pclt[\"pitch\"]              = Py::Int((short) t->Pitch);\n-            pclt[\"xHeight\"]            = Py::Int((short) t->xHeight);\n-            pclt[\"style\"]              = Py::Int((short) t->Style);\n-            pclt[\"typeFamily\"]         = Py::Int((short) t->TypeFamily);\n-            pclt[\"capHeight\"]          = Py::Int((short) t->CapHeight);\n-            pclt[\"symbolSet\"]          = Py::Int((short) t->SymbolSet);\n-            #if PY3K\n-            pclt[\"typeFace\"]           = Py::String((char *) t->TypeFace, 16, \"latin-1\");\n-            pclt[\"characterComplement\"] = Py::Bytes((char *) t->CharacterComplement, 8);\n-            #else\n-            pclt[\"typeFace\"]           = Py::String((char *) t->TypeFace, 16);\n-            pclt[\"characterComplement\"] = Py::String((char *) t->CharacterComplement, 8);\n-            #endif\n-            // pclt[\"filename\"]           = Py::String((char *) t->FileName, 6);\n-            pclt[\"strokeWeight\"]       = Py::Int((int) t->StrokeWeight);\n-            pclt[\"widthType\"]          = Py::Int((int) t->WidthType);\n-            pclt[\"serifStyle\"]         = Py::Int((int) t->SerifStyle);\n-            return pclt;\n-        }\n-    default:\n-        return Py::Object();\n-    }\n-}\n-PYCXX_VARARGS_METHOD_DECL(FT2Font, get_sfnt_table)\n-\n-char FT2Font::get_image__doc__ [] =\n-    \"get_image()\\n\"\n-    \"\\n\"\n-    \"Returns the underlying image buffer for this font object.\\n\";\n-Py::Object\n-FT2Font::get_image(const Py::Tuple &args)\n-{\n-    args.verify_length(0);\n-    if (!image.isNone())\n-    {\n-        return image;\n-    }\n-    throw Py::RuntimeError(\"You must call .set_text() before .get_image()\");\n-}\n-PYCXX_VARARGS_METHOD_DECL(FT2Font, get_image)\n-\n-char FT2Font::attach_file__doc__ [] =\n-    \"attach_file(filename)\\n\"\n-    \"\\n\"\n-    \"Attach a file with extra information on the font\\n\"\n-    \"(in practice, an AFM file with the metrics of a Type 1 font).\\n\"\n-    \"Throws an exception if unsuccessful.\\n\";\n-Py::Object\n-FT2Font::attach_file(const Py::Tuple &args)\n-{\n-    FT_Open_Args open_args;\n-\n-    args.verify_length(1);\n-\n-    std::string filename = Py::String(args[0]).encode(\"utf-8\");\n-\n-    if (make_open_args(args[0].ptr(), &open_args))\n-    {\n-        /* make_open_args sets the Python exception for us. */\n-        throw Py::Exception();\n-    }\n-\n-    FT_Error error = FT_Attach_Stream(face, &open_args);\n-\n-    if (error)\n-    {\n-        std::ostringstream s;\n-        s << \"Could not attach file \" << filename\n-        << \" (freetype error code \" << error << \")\" << std::endl;\n-        throw Py::RuntimeError(s.str());\n-    }\n-    return Py::Object();\n-}\n-PYCXX_VARARGS_METHOD_DECL(FT2Font, attach_file)\n-\n-\n-typedef struct\n-{\n-    PyObject *py_file;\n-    FILE *fp;\n-    int close_file;\n-    mpl_off_t offset;\n-} py_file_def;\n-\n-\n-static unsigned long read_from_file_callback(\n-    FT_Stream stream, unsigned long offset, unsigned char *buffer,\n-    unsigned long count) {\n-\n-    py_file_def *def = (py_file_def *)stream->descriptor.pointer;\n-\n-    if (fseek(def->fp, offset, SEEK_SET) == -1) {\n-        return 0;\n-    }\n-\n-    if (count > 0) {\n-        return fread(buffer, 1, count, def->fp);\n-    }\n-\n-    return 0;\n-}\n-\n-\n-static void close_file_callback(FT_Stream stream)\n-{\n-    py_file_def *def = (py_file_def *)stream->descriptor.pointer;\n-\n-    if (mpl_PyFile_DupClose(def->py_file, def->fp, def->offset))\n-    {\n-        throw Py::Exception();\n-    }\n-\n-    if (def->close_file) {\n-        mpl_PyFile_CloseFile(def->py_file);\n-    }\n-\n-    Py_DECREF(def->py_file);\n-}\n-\n-\n-int\n-FT2Font::make_open_args(PyObject *py_file_arg, FT_Open_Args *open_args)\n-{\n-    PyObject *py_file = NULL;\n-    int close_file = 0;\n-    FILE *fp;\n-    PyObject *data = NULL;\n-    char *data_ptr;\n-    Py_ssize_t data_len;\n-    py_file_def *stream_info = NULL;\n-    long file_size;\n-    FT_Byte *new_memory;\n-    mpl_off_t offset = 0;\n-\n-    int result = -1;\n-\n-    memset((void *)open_args, 0, sizeof(FT_Open_Args));\n-\n-    if (PyBytes_Check(py_file_arg) || PyUnicode_Check(py_file_arg)) {\n-        if ((py_file = mpl_PyFile_OpenFile(py_file_arg, (char *)\"rb\")) == NULL) {\n-            goto exit;\n-        }\n-        close_file = 1;\n-    } else {\n-        Py_INCREF(py_file_arg);\n-        py_file = py_file_arg;\n-    }\n-\n-    if ((fp = mpl_PyFile_Dup(py_file, (char *)\"rb\", &offset))) {\n-        stream_info = (py_file_def *)PyMem_Malloc(sizeof(py_file_def));\n-        if (stream_info == NULL) {\n-            goto exit;\n-        }\n-        memset(stream_info, 0, sizeof(py_file_def));\n-\n-        Py_INCREF(py_file);\n-        stream_info->py_file = py_file;\n-        stream_info->close_file = close_file;\n-        stream_info->fp = fp;\n-        stream_info->offset = offset;\n-        fseek(fp, 0, SEEK_END);\n-        file_size = ftell(fp);\n-        fseek(fp, 0, SEEK_SET);\n-\n-        stream.base = NULL;\n-        stream.size = (unsigned long)file_size;\n-        stream.pos = 0;\n-        stream.descriptor.pointer = stream_info;\n-        stream.read = &read_from_file_callback;\n-        stream.close = &close_file_callback;\n-\n-        open_args->flags = FT_OPEN_STREAM;\n-        open_args->stream = &stream;\n-    } else {\n-        if (PyObject_HasAttrString(py_file_arg, \"read\") &&\n-            (data = PyObject_CallMethod(py_file_arg, (char*)\"read\", (char*)\"\"))) {\n-            if (PyBytes_AsStringAndSize(data, &data_ptr, &data_len)) {\n-                goto exit;\n-            }\n-\n-            if (mem) {\n-                free(mem);\n-            }\n-            mem = (FT_Byte *)PyMem_Malloc(mem_size + data_len);\n-            if (mem == NULL) {\n-                goto exit;\n-            }\n-            new_memory = mem + mem_size;\n-            mem_size += data_len;\n-\n-            memcpy(new_memory, data_ptr, data_len);\n-            open_args->flags = FT_OPEN_MEMORY;\n-            open_args->memory_base = new_memory;\n-            open_args->memory_size = data_len;\n-            open_args->stream = NULL;\n-        } else {\n-            PyErr_SetString(\n-                PyExc_TypeError,\n-                \"First argument must be a path or file object reading bytes\");\n-            goto exit;\n+        if (FT_Get_Glyph_Name(face, glyph_number, buffer, 128)) {\n+            throw \"Could not get glyph names.\";\n         }\n     }\n-\n-    result = 0;\n-\n- exit:\n-\n-    Py_XDECREF(py_file);\n-    Py_XDECREF(data);\n-\n-    return result;\n-}\n-\n-void\n-FT2Image::init_type(void)\n-{\n-    _VERBOSE(\"FT2Image::init_type\");\n-    behaviors().name(\"FT2Image\");\n-    behaviors().doc(\"FT2Image\");\n-\n-    PYCXX_ADD_VARARGS_METHOD(write_bitmap, py_write_bitmap,\n-                             FT2Image::write_bitmap__doc__);\n-    PYCXX_ADD_VARARGS_METHOD(draw_rect, py_draw_rect,\n-                             FT2Image::draw_rect__doc__);\n-    PYCXX_ADD_VARARGS_METHOD(draw_rect_filled, py_draw_rect_filled,\n-                             FT2Image::draw_rect_filled__doc__);\n-    PYCXX_ADD_VARARGS_METHOD(as_array, py_as_array,\n-                             FT2Image::as_array__doc__);\n-    PYCXX_ADD_VARARGS_METHOD(as_str, py_as_str,\n-                             FT2Image::as_str__doc__);\n-    PYCXX_ADD_VARARGS_METHOD(as_rgb_str, py_as_rgb_str,\n-                             FT2Image::as_rgb_str__doc__);\n-    PYCXX_ADD_VARARGS_METHOD(as_rgba_str, py_as_rgba_str,\n-                             FT2Image::as_rgba_str__doc__);\n-    PYCXX_ADD_VARARGS_METHOD(get_width, py_get_width,\n-                             \"Returns the width of the image\");\n-    PYCXX_ADD_VARARGS_METHOD(get_height, py_get_height,\n-                             \"Returns the height of the image\");\n-\n-    behaviors().readyType();\n-}\n-\n-void\n-Glyph::init_type()\n-{\n-    _VERBOSE(\"Glyph::init_type\");\n-    behaviors().name(\"Glyph\");\n-    behaviors().doc(\"Glyph\");\n-    behaviors().supportGetattro();\n-    behaviors().supportSetattro();\n-    behaviors().readyType();\n-}\n-\n-void\n-FT2Font::init_type()\n-{\n-    _VERBOSE(\"FT2Font::init_type\");\n-    behaviors().name(\"FT2Font\");\n-    behaviors().doc(\"FT2Font\");\n-    behaviors().supportGetattro();\n-    behaviors().supportSetattro();\n-\n-    PYCXX_ADD_VARARGS_METHOD(clear, clear,\n-                             FT2Font::clear__doc__);\n-    PYCXX_ADD_KEYWORDS_METHOD(draw_glyph_to_bitmap, draw_glyph_to_bitmap,\n-                             FT2Font::draw_glyph_to_bitmap__doc__);\n-    PYCXX_ADD_KEYWORDS_METHOD(draw_glyphs_to_bitmap, draw_glyphs_to_bitmap,\n-                             FT2Font::draw_glyphs_to_bitmap__doc__);\n-    PYCXX_ADD_KEYWORDS_METHOD(get_xys, get_xys,\n-                             FT2Font::get_xys__doc__);\n-\n-    PYCXX_ADD_VARARGS_METHOD(get_num_glyphs, get_num_glyphs,\n-                             FT2Font::get_num_glyphs__doc__);\n-    PYCXX_ADD_KEYWORDS_METHOD(load_char, load_char,\n-                              FT2Font::load_char__doc__);\n-    PYCXX_ADD_KEYWORDS_METHOD(load_glyph, load_glyph,\n-                              FT2Font::load_glyph__doc__);\n-    PYCXX_ADD_KEYWORDS_METHOD(set_text, set_text,\n-                              FT2Font::set_text__doc__);\n-    PYCXX_ADD_VARARGS_METHOD(set_size, set_size,\n-                             FT2Font::set_size__doc__);\n-    PYCXX_ADD_VARARGS_METHOD(set_charmap, set_charmap,\n-                             FT2Font::set_charmap__doc__);\n-    PYCXX_ADD_VARARGS_METHOD(select_charmap, select_charmap,\n-                             FT2Font::select_charmap__doc__);\n-\n-    PYCXX_ADD_VARARGS_METHOD(get_width_height, get_width_height,\n-                             FT2Font::get_width_height__doc__);\n-    PYCXX_ADD_VARARGS_METHOD(get_descent, get_descent,\n-                             FT2Font::get_descent__doc__);\n-    PYCXX_ADD_VARARGS_METHOD(get_glyph_name, get_glyph_name,\n-                             FT2Font::get_glyph_name__doc__);\n-    PYCXX_ADD_VARARGS_METHOD(get_charmap, get_charmap,\n-                             FT2Font::get_charmap__doc__);\n-    PYCXX_ADD_VARARGS_METHOD(get_kerning, get_kerning,\n-                             FT2Font::get_kerning__doc__);\n-    PYCXX_ADD_VARARGS_METHOD(get_sfnt, get_sfnt,\n-                             FT2Font::get_sfnt__doc__);\n-    PYCXX_ADD_VARARGS_METHOD(get_name_index, get_name_index,\n-                             FT2Font::get_name_index__doc__);\n-    PYCXX_ADD_VARARGS_METHOD(get_ps_font_info, get_ps_font_info,\n-                             FT2Font::get_ps_font_info__doc__);\n-    PYCXX_ADD_VARARGS_METHOD(get_sfnt_table, get_sfnt_table,\n-                             FT2Font::get_sfnt_table__doc__);\n-    PYCXX_ADD_VARARGS_METHOD(get_image, get_image,\n-                             FT2Font::get_image__doc__);\n-    PYCXX_ADD_VARARGS_METHOD(attach_file, attach_file,\n-                             FT2Font::attach_file__doc__);\n-    PYCXX_ADD_NOARGS_METHOD(get_path, get_path,\n-                            FT2Font::get_path__doc__);\n-\n-    behaviors().readyType();\n-}\n-\n-//todo add module docs strings\n-\n-char ft2font__doc__[] =\n-    \"ft2font\\n\"\n-    \"\\n\"\n-    \"Methods:\\n\"\n-    \"  FT2Font(ttffile)\\n\"\n-    \"Face Constants\\n\"\n-    \"  SCALABLE               scalable\\n\"\n-    \"  FIXED_SIZES            \\n\"\n-    \"  FIXED_WIDTH            \\n\"\n-    \"  SFNT                   \\n\"\n-    \"  HORIZONTAL             \\n\"\n-    \"  VERTICAL               \\n\"\n-    \"  KERNING                \\n\"\n-    \"  FAST_GLYPHS            \\n\"\n-    \"  MULTIPLE_MASTERS       \\n\"\n-    \"  GLYPH_NAMES            \\n\"\n-    \"  EXTERNAL_STREAM        \\n\"\n-    \"Style Constants\\n\"\n-    \"  ITALIC                 \\n\"\n-    \"  BOLD                   \\n\"\n-    ;\n-\n-/* Function of no arguments returning new FT2Font object */\n-char ft2font_new__doc__[] =\n-    \"FT2Font(ttffile)\\n\"\n-    \"\\n\"\n-    \"Create a new FT2Font object\\n\"\n-    \"The following global font attributes are defined:\\n\"\n-    \"  num_faces              number of faces in file\\n\"\n-    \"  face_flags             face flags  (int type); see the ft2font constants\\n\"\n-    \"  style_flags            style flags  (int type); see the ft2font constants\\n\"\n-    \"  num_glyphs             number of glyphs in the face\\n\"\n-    \"  family_name            face family name\\n\"\n-    \"  style_name             face syle name\\n\"\n-    \"  num_fixed_sizes        number of bitmap in the face\\n\"\n-    \"  scalable               face is scalable\\n\"\n-    \"\\n\"\n-    \"The following are available, if scalable is true:\\n\"\n-    \"  bbox                   face global bounding box (xmin, ymin, xmax, ymax)\\n\"\n-    \"  units_per_EM           number of font units covered by the EM\\n\"\n-    \"  ascender               ascender in 26.6 units\\n\"\n-    \"  descender              descender in 26.6 units\\n\"\n-    \"  height                 height in 26.6 units; used to compute a default\\n\"\n-    \"                         line spacing (baseline-to-baseline distance)\\n\"\n-    \"  max_advance_width      maximum horizontal cursor advance for all glyphs\\n\"\n-    \"  max_advance_height     same for vertical layout\\n\"\n-    \"  underline_position     vertical position of the underline bar\\n\"\n-    \"  underline_thickness    vertical thickness of the underline\\n\"\n-    \"  postscript_name        PostScript name of the font\\n\"\n-    ;\n-\n-ft2font_module::ft2font_module()\n-    : Py::ExtensionModule<ft2font_module>(\"ft2font\")\n-{\n-    FT2Image::init_type();\n-    Glyph::init_type();\n-    FT2Font::init_type();\n-\n-    initialize(\"The ft2font module\");\n-\n-    Py::Dict d(moduleDictionary());\n-    Py::Object ft2font_type(FT2Font::type());\n-    d[\"FT2Font\"] = ft2font_type;\n-    Py::Object ft2image_type(FT2Image::type());\n-    d[\"FT2Image\"] = ft2image_type;\n }\n \n-ft2font_module::~ft2font_module()\n+long FT2Font::get_name_index(char *name)\n {\n-    FT_Done_FreeType(_ft2Library);\n-}\n-\n-PyMODINIT_FUNC\n-#if PY3K\n-PyInit_ft2font(void)\n-#else\n-initft2font(void)\n-#endif\n-{\n-    static ft2font_module* ft2font = new ft2font_module;\n-    Py::Dict d = ft2font->moduleDictionary();\n-    d[\"SCALABLE\"]         = Py::Int(FT_FACE_FLAG_SCALABLE);\n-    d[\"FIXED_SIZES\"]      = Py::Int(FT_FACE_FLAG_FIXED_SIZES);\n-    d[\"FIXED_WIDTH\"]      = Py::Int(FT_FACE_FLAG_FIXED_WIDTH);\n-    d[\"SFNT\"]             = Py::Int(FT_FACE_FLAG_SFNT);\n-    d[\"HORIZONTAL\"]       = Py::Int(FT_FACE_FLAG_HORIZONTAL);\n-    d[\"VERTICAL\"]         = Py::Int(FT_FACE_FLAG_SCALABLE);\n-    d[\"KERNING\"]          = Py::Int(FT_FACE_FLAG_KERNING);\n-    d[\"FAST_GLYPHS\"]      = Py::Int(FT_FACE_FLAG_FAST_GLYPHS);\n-    d[\"MULTIPLE_MASTERS\"] = Py::Int(FT_FACE_FLAG_MULTIPLE_MASTERS);\n-    d[\"GLYPH_NAMES\"]      = Py::Int(FT_FACE_FLAG_GLYPH_NAMES);\n-    d[\"EXTERNAL_STREAM\"]  = Py::Int(FT_FACE_FLAG_EXTERNAL_STREAM);\n-    d[\"ITALIC\"]           = Py::Int(FT_STYLE_FLAG_ITALIC);\n-    d[\"BOLD\"]             = Py::Int(FT_STYLE_FLAG_BOLD);\n-    d[\"KERNING_DEFAULT\"]  = Py::Int(FT_KERNING_DEFAULT);\n-    d[\"KERNING_UNFITTED\"]  = Py::Int(FT_KERNING_UNFITTED);\n-    d[\"KERNING_UNSCALED\"]  = Py::Int(FT_KERNING_UNSCALED);\n-\n-    d[\"LOAD_DEFAULT\"]          = Py::Long(FT_LOAD_DEFAULT);\n-    d[\"LOAD_NO_SCALE\"]         = Py::Long(FT_LOAD_NO_SCALE);\n-    d[\"LOAD_NO_HINTING\"]       = Py::Long(FT_LOAD_NO_HINTING);\n-    d[\"LOAD_RENDER\"]           = Py::Long(FT_LOAD_RENDER);\n-    d[\"LOAD_NO_BITMAP\"]        = Py::Long(FT_LOAD_NO_BITMAP);\n-    d[\"LOAD_VERTICAL_LAYOUT\"]  = Py::Long(FT_LOAD_VERTICAL_LAYOUT);\n-    d[\"LOAD_FORCE_AUTOHINT\"]   = Py::Long(FT_LOAD_FORCE_AUTOHINT);\n-    d[\"LOAD_CROP_BITMAP\"]      = Py::Long(FT_LOAD_CROP_BITMAP);\n-    d[\"LOAD_PEDANTIC\"]         = Py::Long(FT_LOAD_PEDANTIC);\n-    d[\"LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH\"] =\n-        Py::Long(FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH);\n-    d[\"LOAD_NO_RECURSE\"]       = Py::Long(FT_LOAD_NO_RECURSE);\n-    d[\"LOAD_IGNORE_TRANSFORM\"] = Py::Long(FT_LOAD_IGNORE_TRANSFORM);\n-    d[\"LOAD_MONOCHROME\"]       = Py::Long(FT_LOAD_MONOCHROME);\n-    d[\"LOAD_LINEAR_DESIGN\"]    = Py::Long(FT_LOAD_LINEAR_DESIGN);\n-    // These need casting because large-valued numeric literals could\n-    // be either longs or unsigned longs:\n-    d[\"LOAD_NO_AUTOHINT\"]      = Py::Long((unsigned long)FT_LOAD_NO_AUTOHINT);\n-    d[\"LOAD_TARGET_NORMAL\"]    = Py::Long((unsigned long)FT_LOAD_TARGET_NORMAL);\n-    d[\"LOAD_TARGET_LIGHT\"]     = Py::Long((unsigned long)FT_LOAD_TARGET_LIGHT);\n-    d[\"LOAD_TARGET_MONO\"]      = Py::Long((unsigned long)FT_LOAD_TARGET_MONO);\n-    d[\"LOAD_TARGET_LCD\"]       = Py::Long((unsigned long)FT_LOAD_TARGET_LCD);\n-    d[\"LOAD_TARGET_LCD_V\"]     = Py::Long((unsigned long)FT_LOAD_TARGET_LCD_V);\n-\n-    //initialize library\n-    int error = FT_Init_FreeType(&_ft2Library);\n-\n-    if (error)\n-    {\n-        throw Py::RuntimeError(\"Could not find initialize the freetype2 library\");\n-    }\n-\n-    {\n-        FT_Int major, minor, patch;\n-        char version_string[64];\n-\n-        FT_Library_Version(_ft2Library, &major, &minor, &patch);\n-        sprintf(version_string, \"%d.%d.%d\", major, minor, patch);\n-\n-        d[\"__freetype_version__\"] = Py::String(version_string);\n-    }\n-\n-    import_array();\n-\n-    #if PY3K\n-    return ft2font->module().ptr();\n-    #endif\n+    return FT_Get_Name_Index(face, (FT_String *)name);\n }"
            },
            {
                "sha": "bef5e9ab27de0eb89998534ab1cf064b0cbe983b",
                "filename": "src/ft2font.h",
                "status": "modified",
                "additions": 91,
                "deletions": 156,
                "changes": 247,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2Fft2font.h",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2Fft2font.h",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/src%2Fft2font.h?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787",
                "patch": "@@ -3,16 +3,10 @@\n /* A python interface to freetype2 */\n #ifndef _FT2FONT_H\n #define _FT2FONT_H\n-#include \"CXX/Extensions.hxx\"\n-#include \"CXX/Objects.hxx\"\n-#include <iostream>\n #include <vector>\n-#include <string>\n-#include <cmath>\n-#include <utility>\n+#include <stdint.h>\n \n-extern \"C\"\n-{\n+extern \"C\" {\n #include <ft2build.h>\n #include FT_FREETYPE_H\n #include FT_GLYPH_H\n@@ -21,129 +15,110 @@ extern \"C\"\n #include FT_TRUETYPE_TABLES_H\n }\n \n+/*\n+ By definition, FT_FIXED as 2 16bit values stored in a single long.\n+ */\n+#define FIXED_MAJOR(val) (long)((val & 0xffff000) >> 16)\n+#define FIXED_MINOR(val) (long)(val & 0xffff)\n+\n // the freetype string rendered into a width, height buffer\n-class FT2Image : public Py::PythonClass<FT2Image>\n+class FT2Image\n {\n-public:\n-    FT2Image(Py::PythonClassInstance *self, Py::Tuple &args, Py::Dict &kwds);\n+  public:\n+    FT2Image();\n+    FT2Image(unsigned long width, unsigned long height);\n     virtual ~FT2Image();\n-    static Py::PythonClassObject<FT2Image> factory(int width, int height);\n-\n-    static void init_type();\n \n-    void draw_bitmap(FT_Bitmap* bitmap, FT_Int x, FT_Int y);\n-    void write_bitmap(FILE* fp) const;\n-    void draw_rect(unsigned long x0, unsigned long y0,\n-                   unsigned long x1, unsigned long y1);\n-    void draw_rect_filled(unsigned long x0, unsigned long y0,\n-                          unsigned long x1, unsigned long y1);\n+    void resize(long width, long height);\n+    void draw_bitmap(FT_Bitmap *bitmap, FT_Int x, FT_Int y);\n+    void write_bitmap(FILE *fp) const;\n+    void draw_rect(unsigned long x0, unsigned long y0, unsigned long x1, unsigned long y1);\n+    void draw_rect_filled(unsigned long x0, unsigned long y0, unsigned long x1, unsigned long y1);\n \n-    unsigned int get_width() const\n+    unsigned char *get_buffer()\n     {\n-        return _width;\n-    };\n-    unsigned int get_height() const\n+        return m_buffer;\n+    }\n+    unsigned long get_width()\n     {\n-        return _height;\n-    };\n-    const unsigned char *const get_buffer() const\n+        return m_width;\n+    }\n+    unsigned long get_height()\n     {\n-        return _buffer;\n-    };\n-\n-    static char write_bitmap__doc__ [];\n-    Py::Object py_write_bitmap(const Py::Tuple & args);\n-    static char draw_rect__doc__ [];\n-    Py::Object py_draw_rect(const Py::Tuple & args);\n-    static char draw_rect_filled__doc__ [];\n-    Py::Object py_draw_rect_filled(const Py::Tuple & args);\n-    static char as_array__doc__ [];\n-    Py::Object py_as_array(const Py::Tuple & args);\n-    static char as_str__doc__ [];\n-    Py::Object py_as_str(const Py::Tuple & args);\n-    static char as_rgb_str__doc__ [];\n-    Py::Object py_as_rgb_str(const Py::Tuple & args);\n-    static char as_rgba_str__doc__ [];\n-    Py::Object py_as_rgba_str(const Py::Tuple & args);\n-    Py::Object py_get_width(const Py::Tuple & args);\n-    Py::Object py_get_height(const Py::Tuple & args);\n-\n-private:\n-    bool _isDirty;\n-    unsigned char *_buffer;\n-    unsigned long _width;\n-    unsigned long _height;\n+        return m_height;\n+    }\n \n-    void resize(long width, long height);\n+  private:\n+    bool m_dirty;\n+    unsigned char *m_buffer;\n+    unsigned long m_width;\n+    unsigned long m_height;\n \n     // prevent copying\n-    FT2Image(const FT2Image&);\n-    FT2Image& operator=(const FT2Image&);\n+    FT2Image(const FT2Image &);\n+    FT2Image &operator=(const FT2Image &);\n };\n \n-class Glyph : public Py::PythonClass<Glyph>\n-{\n-public:\n-    Glyph(Py::PythonClassInstance *self, Py::Tuple &args, Py::Dict &kwds) :\n-        Py::PythonClass<Glyph>(self, args, kwds) { }\n-    virtual ~Glyph();\n-    static Py::PythonClassObject<Glyph> factory(const FT_Face&, const FT_Glyph&, size_t, long);\n-    int setattro(const Py::String &name, const Py::Object &value);\n-    Py::Object getattro(const Py::String &name);\n-    static void init_type(void);\n-    size_t glyphInd;\n-private:\n-    Py::Dict __dict__;\n+extern FT_Library _ft2Library;\n \n-    // prevent copying\n-    Glyph(const Glyph&);\n-    Glyph& operator=(const Glyph&);\n-};\n-\n-class FT2Font : public Py::PythonClass<FT2Font>\n+class FT2Font\n {\n \n-public:\n-    FT2Font(Py::PythonClassInstance *self, Py::Tuple &args, Py::Dict &kwds);\n+  public:\n+    FT2Font(FT_Open_Args &open_args, long hinting_factor);\n     virtual ~FT2Font();\n-    static void init_type(void);\n-    Py::Object clear(const Py::Tuple & args);\n-    Py::Object set_size(const Py::Tuple & args);\n-    Py::Object set_charmap(const Py::Tuple & args);\n-    Py::Object select_charmap(const Py::Tuple & args);\n-    Py::Object set_text(const Py::Tuple & args, const Py::Dict & kwargs);\n-    Py::Object get_kerning(const Py::Tuple & args);\n-    Py::Object get_num_glyphs(const Py::Tuple & args);\n-    Py::Object load_char(const Py::Tuple & args, const Py::Dict & kws);\n-    Py::Object load_glyph(const Py::Tuple & args, const Py::Dict & kws);\n-    Py::Object get_width_height(const Py::Tuple & args);\n-    Py::Object get_descent(const Py::Tuple & args);\n-    Py::Object draw_rect_filled(const Py::Tuple & args);\n-    Py::Object get_xys(const Py::Tuple & args, const Py::Dict & kws);\n-    Py::Object draw_glyphs_to_bitmap(const Py::Tuple & args, const Py::Dict & kws);\n-    Py::Object draw_glyph_to_bitmap(const Py::Tuple & args, const Py::Dict & kws);\n-    Py::Object get_glyph_name(const Py::Tuple & args);\n-    Py::Object get_charmap(const Py::Tuple & args);\n-    Py::Object get_sfnt(const Py::Tuple & args);\n-    Py::Object get_name_index(const Py::Tuple & args);\n-    Py::Object get_ps_font_info(const Py::Tuple & args);\n-    Py::Object get_sfnt_table(const Py::Tuple & args);\n-    Py::Object get_image(const Py::Tuple & args);\n-    Py::Object attach_file(const Py::Tuple & args);\n-    int setattro(const Py::String &name, const Py::Object &value);\n-    Py::Object getattro(const Py::String &name);\n-    Py::Object get_path();\n-    Py::Object image;\n-\n-private:\n-    Py::Dict __dict__;\n-    FT_Face       face;\n-    FT_Matrix     matrix;                 /* transformation matrix */\n-    FT_Vector     pen;                    /* untransformed origin  */\n-    FT_Error      error;\n-    FT_StreamRec  stream;\n-    FT_Byte *     mem;\n-    size_t        mem_size;\n+    void clear();\n+    void set_size(double ptsize, double dpi);\n+    void set_charmap(int i);\n+    void select_charmap(unsigned long i);\n+    void set_text(\n+        size_t N, uint32_t *codepoints, double angle, FT_UInt32 flags, std::vector<double> &xys);\n+    int get_kerning(int left, int right, int mode);\n+    void load_char(long charcode, FT_UInt32 flags);\n+    void load_glyph(FT_UInt glyph_index, FT_UInt32 flags);\n+    void get_width_height(long *width, long *height);\n+    long get_descent();\n+    // TODO: Since we know the size of the array upfront, we probably don't\n+    // need to dynamically allocate like this\n+    void get_xys(bool antialiased, std::vector<double> &xys);\n+    void draw_glyphs_to_bitmap(bool antialiased);\n+    void draw_glyph_to_bitmap(FT2Image &im, int x, int y, size_t glyphInd, bool antialiased);\n+    void get_glyph_name(unsigned int glyph_number, char *buffer);\n+    long get_name_index(char *name);\n+    int get_path_count();\n+    void get_path(double *outpoints, unsigned char *outcodes);\n+\n+    FT_Face &get_face()\n+    {\n+        return face;\n+    }\n+    FT2Image &get_image()\n+    {\n+        return image;\n+    }\n+    FT_Glyph &get_last_glyph()\n+    {\n+        return glyphs.back();\n+    }\n+    size_t get_last_glyph_index()\n+    {\n+        return glyphs.size() - 1;\n+    }\n+    size_t get_num_glyphs()\n+    {\n+        return glyphs.size();\n+    }\n+    long get_hinting_factor()\n+    {\n+        return hinting_factor;\n+    }\n+\n+  private:\n+    FT2Image image;\n+    FT_Face face;\n+    FT_Matrix matrix; /* transformation matrix */\n+    FT_Vector pen;    /* untransformed origin  */\n+    FT_Error error;\n     std::vector<FT_Glyph> glyphs;\n     std::vector<FT_Vector> pos;\n     double angle;\n@@ -154,49 +129,9 @@ class FT2Font : public Py::PythonClass<FT2Font>\n     FT_BBox compute_string_bbox();\n     void set_scalable_attributes();\n \n-    int make_open_args(PyObject *fileobj, FT_Open_Args *open_args);\n-\n-    static char clear__doc__ [];\n-    static char set_size__doc__ [];\n-    static char set_charmap__doc__ [];\n-    static char select_charmap__doc__ [];\n-    static char set_text__doc__ [];\n-    static char get_glyph__doc__ [];\n-    static char get_num_glyphs__doc__ [];\n-    static char load_char__doc__ [];\n-    static char load_glyph__doc__ [];\n-    static char get_width_height__doc__ [];\n-    static char get_descent__doc__ [];\n-    static char get_kerning__doc__ [];\n-    static char draw_glyphs_to_bitmap__doc__ [];\n-    static char get_xys__doc__ [];\n-    static char draw_glyph_to_bitmap__doc__ [];\n-    static char get_glyph_name__doc__[];\n-    static char get_charmap__doc__[];\n-    static char get_sfnt__doc__ [];\n-    static char get_name_index__doc__[];\n-    static char get_ps_font_info__doc__[];\n-    static char get_sfnt_table__doc__[];\n-    static char get_image__doc__[];\n-    static char attach_file__doc__[];\n-    static char get_path__doc__[];\n-\n-    // prevent copying\n-    FT2Font(const FT2Font&);\n-    FT2Font& operator=(const FT2Font&);\n-};\n-\n-// the extension module\n-class ft2font_module : public Py::ExtensionModule<ft2font_module>\n-{\n-public:\n-    ft2font_module();\n-    virtual ~ft2font_module();\n-\n-private:\n     // prevent copying\n-    ft2font_module(const ft2font_module&);\n-    ft2font_module operator=(const ft2font_module&);\n+    FT2Font(const FT2Font &);\n+    FT2Font &operator=(const FT2Font &);\n };\n \n #endif"
            },
            {
                "sha": "5e53f977c0299ef4a51c63b967084b9c2eabc392",
                "filename": "src/ft2font_wrapper.cpp",
                "status": "added",
                "additions": 0,
                "deletions": 0,
                "changes": 0,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2Fft2font_wrapper.cpp",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2Fft2font_wrapper.cpp",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/src%2Fft2font_wrapper.cpp?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787"
            },
            {
                "sha": "bc09db52aa9e61d4dc73af242b6c7959927c767e",
                "filename": "src/mplutils.cpp",
                "status": "modified",
                "additions": 12,
                "deletions": 25,
                "changes": 37,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2Fmplutils.cpp",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2Fmplutils.cpp",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/src%2Fmplutils.cpp?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787"
            },
            {
                "sha": "d09f810709ad2116f9906b8ef9a902ecae8bf21d",
                "filename": "src/mplutils.h",
                "status": "modified",
                "additions": 29,
                "deletions": 33,
                "changes": 62,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2Fmplutils.h",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2Fmplutils.h",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/src%2Fmplutils.h?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787"
            },
            {
                "sha": "1f96c3fc00ebfae5c7886d1217a681dc89aa11f7",
                "filename": "src/numpy_cpp.h",
                "status": "added",
                "additions": 480,
                "deletions": 0,
                "changes": 480,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2Fnumpy_cpp.h",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2Fnumpy_cpp.h",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/src%2Fnumpy_cpp.h?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787"
            },
            {
                "sha": "7951cfd9cef5597bd167dc68d8cf15e3626d83a5",
                "filename": "src/path_cleanup.cpp",
                "status": "modified",
                "additions": 80,
                "deletions": 63,
                "changes": 143,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2Fpath_cleanup.cpp",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2Fpath_cleanup.cpp",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/src%2Fpath_cleanup.cpp?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787"
            },
            {
                "sha": "b481395aa54efebc0584de0cdf36a2733595d5d9",
                "filename": "src/path_cleanup.h",
                "status": "modified",
                "additions": 11,
                "deletions": 11,
                "changes": 22,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2Fpath_cleanup.h",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2Fpath_cleanup.h",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/src%2Fpath_cleanup.h?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787"
            },
            {
                "sha": "52663235f9f72b5abab1d2146d9e25c893fe7619",
                "filename": "src/path_converters.h",
                "status": "modified",
                "additions": 191,
                "deletions": 259,
                "changes": 450,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2Fpath_converters.h",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2Fpath_converters.h",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/src%2Fpath_converters.h?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787"
            },
            {
                "sha": "b59d1fb3e18660516f450fef649b4246938a1c6b",
                "filename": "src/py_adaptors.h",
                "status": "added",
                "additions": 251,
                "deletions": 0,
                "changes": 251,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2Fpy_adaptors.h",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2Fpy_adaptors.h",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/src%2Fpy_adaptors.h?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787"
            },
            {
                "sha": "3e4c3978a68c5ce3bc196d9532e28fa461e72a1a",
                "filename": "src/py_converters.cpp",
                "status": "added",
                "additions": 545,
                "deletions": 0,
                "changes": 545,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2Fpy_converters.cpp",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2Fpy_converters.cpp",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/src%2Fpy_converters.cpp?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787"
            },
            {
                "sha": "90cf454e30fbfdced8b4cace838d9f124ffff73b",
                "filename": "src/py_converters.h",
                "status": "added",
                "additions": 45,
                "deletions": 0,
                "changes": 45,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2Fpy_converters.h",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2Fpy_converters.h",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/src%2Fpy_converters.h?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787"
            },
            {
                "sha": "4c28ea1239ad40eaa1975a903209dfb60e0dab9c",
                "filename": "src/py_exceptions.h",
                "status": "added",
                "additions": 72,
                "deletions": 0,
                "changes": 72,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2Fpy_exceptions.h",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/src%2Fpy_exceptions.h",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/src%2Fpy_exceptions.h?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787"
            },
            {
                "sha": "34469743abfe50744b32626d0c57d26247faa5bb",
                "filename": "tests.py",
                "status": "modified",
                "additions": 7,
                "deletions": 0,
                "changes": 7,
                "blob_url": "https://github.com/matplotlib/matplotlib/blob/ba4016014cb4fb4927e36ce8ea429fed47dcb787/tests.py",
                "raw_url": "https://github.com/matplotlib/matplotlib/raw/ba4016014cb4fb4927e36ce8ea429fed47dcb787/tests.py",
                "contents_url": "https://api.github.com/repos/matplotlib/matplotlib/contents/tests.py?ref=ba4016014cb4fb4927e36ce8ea429fed47dcb787"
            }
        ]
    },
    {
        "query_url": "https://api.github.com/repos/saltstack/salt/commits/e39116fb87bf4db9bcb9aade8258c66df87d41fe",
        "url": "https://api.github.com/repos/saltstack/salt/commits/e39116fb87bf4db9bcb9aade8258c66df87d41fe",
        "html_url": "https://github.com/saltstack/salt/commit/e39116fb87bf4db9bcb9aade8258c66df87d41fe",
        "message": "Fix traversal in pub_ret",
        "files": [
            {
                "sha": "3d9c5f15b1fca8c2a49b4c184121e2fde6563573",
                "filename": "salt/master.py",
                "status": "modified",
                "additions": 4,
                "deletions": 4,
                "changes": 8,
                "blob_url": "https://github.com/saltstack/salt/blob/e39116fb87bf4db9bcb9aade8258c66df87d41fe/salt%2Fmaster.py",
                "raw_url": "https://github.com/saltstack/salt/raw/e39116fb87bf4db9bcb9aade8258c66df87d41fe/salt%2Fmaster.py",
                "contents_url": "https://api.github.com/repos/saltstack/salt/contents/salt%2Fmaster.py?ref=e39116fb87bf4db9bcb9aade8258c66df87d41fe",
                "patch": "@@ -1269,7 +1269,7 @@ def __verify_minion(self, id_, token):\n         \"\"\"\n         if not salt.utils.verify.valid_id(self.opts, id_):\n             return False\n-        pub_path = os.path.join(self.opts[\"pki_dir\"], \"minions\", id_)\n+        pub_path = salt.utils.verify.clean_join(self.opts[\"pki_dir\"], \"minions\", id_)\n \n         try:\n             pub = salt.crypt.PublicKey(pub_path)\n@@ -1690,8 +1690,8 @@ def _return(self, load):\n         if \"sig\" in load:\n             log.trace(\"Verifying signed event publish from minion\")\n             sig = load.pop(\"sig\")\n-            this_minion_pubkey = os.path.join(\n-                self.opts[\"pki_dir\"], \"minions/{}\".format(load[\"id\"])\n+            this_minion_pubkey = salt.utils.clean_join(\n+                self.opts[\"pki_dir\"], \"minions\", load[\"id\"]\n             )\n             serialized_load = salt.serializers.msgpack.serialize(load)\n             if not salt.crypt.verify_signature(\n@@ -1803,7 +1803,7 @@ def pub_ret(self, load):\n         auth_cache = os.path.join(self.opts[\"cachedir\"], \"publish_auth\")\n         if not os.path.isdir(auth_cache):\n             os.makedirs(auth_cache)\n-        jid_fn = os.path.join(auth_cache, str(load[\"jid\"]))\n+        jid_fn = salt.utils.verify.clean_join(auth_cache, str(load[\"jid\"]))\n         with salt.utils.files.fopen(jid_fn, \"r\") as fp_:\n             if not load[\"id\"] == fp_.read():\n                 return {}"
            },
            {
                "sha": "af2ba8da5118dba7f3cae89c6d2c53ef40f866d3",
                "filename": "tests/pytests/unit/test_master.py",
                "status": "modified",
                "additions": 29,
                "deletions": 1,
                "changes": 30,
                "blob_url": "https://github.com/saltstack/salt/blob/e39116fb87bf4db9bcb9aade8258c66df87d41fe/tests%2Fpytests%2Funit%2Ftest_master.py",
                "raw_url": "https://github.com/saltstack/salt/raw/e39116fb87bf4db9bcb9aade8258c66df87d41fe/tests%2Fpytests%2Funit%2Ftest_master.py",
                "contents_url": "https://api.github.com/repos/saltstack/salt/contents/tests%2Fpytests%2Funit%2Ftest_master.py?ref=e39116fb87bf4db9bcb9aade8258c66df87d41fe",
                "patch": "@@ -4,19 +4,22 @@\n import pytest\n \n import salt.master\n+import salt.utils.files\n import salt.utils.platform\n from tests.support.mock import patch\n \n \n @pytest.fixture\n def encrypted_requests(tmp_path):\n     # To honor the comment on AESFuncs\n+    (tmp_path / \"pki\").mkdir()\n     return salt.master.AESFuncs(\n         opts={\n+            \"pki_dir\": str(tmp_path / \"pki\"),\n             \"cachedir\": str(tmp_path / \"cache\"),\n             \"sock_dir\": str(tmp_path / \"sock_drawer\"),\n             \"conf_file\": str(tmp_path / \"config.conf\"),\n-            \"fileserver_backend\": \"local\",\n+            \"fileserver_backend\": [\"local\"],\n             \"master_job_cache\": False,\n         }\n     )\n@@ -193,3 +196,28 @@ def test_syndic_return_cache_dir_creation_traversal(encrypted_requests):\n     )\n     assert not (cachedir / \"syndics\").exists()\n     assert not (cachedir / \"mamajama\").exists()\n+\n+\n+def test_pub_ret_traversal(encrypted_requests, tmp_path):\n+    \"\"\"\n+    master's  AESFuncs._syndic_return method cachdir creation is not vulnerable to a directory traversal\n+    \"\"\"\n+    salt.crypt.gen_keys(tmp_path, \"minion\", 2048)\n+\n+    minions = pathlib.Path(encrypted_requests.opts[\"pki_dir\"]) / \"minions\"\n+    minions.mkdir()\n+\n+    with salt.utils.files.fopen(minions / \"minion\", \"wb\") as wfp:\n+        with salt.utils.files.fopen(tmp_path / \"minion.pub\", \"rb\") as rfp:\n+            wfp.write(rfp.read())\n+\n+    priv = salt.crypt.PrivateKey(tmp_path / \"minion.pem\")\n+    with pytest.raises(salt.exceptions.SaltValidationError):\n+        encrypted_requests.pub_ret(\n+            {\n+                \"tok\": priv.encrypt(b\"salt\"),\n+                \"id\": \"minion\",\n+                \"jid\": \"asdf/../../../sdf\",\n+                \"return\": {},\n+            }\n+        )"
            }
        ]
    }
]