[
    {
        "query_url": "https://api.github.com/repos/rancher/steve/commits/2175e090fe4b1e603a54e1cdc5148a2b1c11b4d9",
        "url": "https://api.github.com/repos/rancher/steve/commits/2175e090fe4b1e603a54e1cdc5148a2b1c11b4d9",
        "html_url": "https://github.com/rancher/steve/commit/2175e090fe4b1e603a54e1cdc5148a2b1c11b4d9",
        "message": "Refactor ID based partitioning, add unit tests (#309)\n\n* Refactor ID based partitioning, add unit tests\r\n\r\nThis resolves an issue where the requested namespace filter was not\r\nalways honored.\r\n\r\n* Correct naming issues to appease the linter",
        "files": [
            {
                "sha": "cf3f5959adf4d1b5644049d54353242d099f108e",
                "filename": "pkg/stores/proxy/rbac_store.go",
                "status": "modified",
                "additions": 84,
                "deletions": 13,
                "changes": 97,
                "blob_url": "https://github.com/rancher/steve/blob/2175e090fe4b1e603a54e1cdc5148a2b1c11b4d9/pkg%2Fstores%2Fproxy%2Frbac_store.go",
                "raw_url": "https://github.com/rancher/steve/raw/2175e090fe4b1e603a54e1cdc5148a2b1c11b4d9/pkg%2Fstores%2Fproxy%2Frbac_store.go",
                "contents_url": "https://api.github.com/repos/rancher/steve/contents/pkg%2Fstores%2Fproxy%2Frbac_store.go?ref=2175e090fe4b1e603a54e1cdc5148a2b1c11b4d9",
                "patch": "@@ -9,6 +9,7 @@ import (\n \t\"github.com/rancher/steve/pkg/attributes\"\n \t\"github.com/rancher/steve/pkg/stores/partition\"\n \t\"github.com/rancher/wrangler/v3/pkg/kv\"\n+\t\"github.com/sirupsen/logrus\"\n \t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"\n \t\"k8s.io/apimachinery/pkg/util/sets\"\n \t\"k8s.io/apimachinery/pkg/watch\"\n@@ -64,17 +65,10 @@ func (p *rbacPartitioner) All(apiOp *types.APIRequest, schema *types.APISchema,\n \t\tfallthrough\n \tcase \"watch\":\n \t\tif id != \"\" {\n-\t\t\tns, name := kv.RSplit(id, \"/\")\n-\t\t\treturn []partition.Partition{\n-\t\t\t\tPartition{\n-\t\t\t\t\tNamespace:   ns,\n-\t\t\t\t\tAll:         false,\n-\t\t\t\t\tPassthrough: false,\n-\t\t\t\t\tNames:       sets.NewString(name),\n-\t\t\t\t},\n-\t\t\t}, nil\n+\t\t\tpartitions := generatePartitionsByID(apiOp, schema, verb, id)\n+\t\t\treturn partitions, nil\n \t\t}\n-\t\tpartitions, passthrough := isPassthrough(apiOp, schema, verb)\n+\t\tpartitions, passthrough := generateAggregatePartitions(apiOp, schema, verb)\n \t\tif passthrough {\n \t\t\treturn passthroughPartitions, nil\n \t\t}\n@@ -126,15 +120,92 @@ func (b *byNameOrNamespaceStore) Watch(apiOp *types.APIRequest, schema *types.AP\n \treturn b.Store.WatchNames(apiOp, schema, wr, b.partition.Names)\n }\n \n-// isPassthrough determines whether a request can be passed through directly to the underlying store\n+// generatePartitionsById determines whether a requester can access a particular resource\n+// and if so, returns the corresponding partitions\n+func generatePartitionsByID(apiOp *types.APIRequest, schema *types.APISchema, verb string, id string) []partition.Partition {\n+\taccessListByVerb, _ := attributes.Access(schema).(accesscontrol.AccessListByVerb)\n+\tresources := accessListByVerb.Granted(verb)\n+\n+\tidNamespace, name := kv.RSplit(id, \"/\")\n+\tapiNamespace := apiOp.Namespace\n+\teffectiveNamespace := idNamespace\n+\n+\t// If a non-empty namespace was provided, be sure to select that for filtering and permissions checks\n+\tif idNamespace == \"\" && apiNamespace != \"\" {\n+\t\teffectiveNamespace = apiNamespace\n+\t}\n+\n+\t// The external API is flexible, and permits specifying a namespace as a separate key or embedded\n+\t// within the ID of the object. Both of these cases should be valid:\n+\t//   {\"namespace\": \"n1\", \"id\": \"r1\"}\n+\t//   {\"id\": \"n1/r1\"}\n+\t// however, the following conflicting request is not valid, but was previously accepted:\n+\t//   {\"namespace\": \"n1\", \"id\": \"n2/r1\"}\n+\t// To avoid breaking UI plugins that may inadvertently rely on the feature, we issue a deprecation\n+\t// warning for now. We still need to pick one of the namespaces for permission verification purposes.\n+\tif idNamespace != \"\" && apiNamespace != \"\" && idNamespace != apiNamespace {\n+\t\tlogrus.Warningf(\"DEPRECATION: Conflicting namespaces '%v' and '%v' requested. \"+\n+\t\t\t\"Selecting '%v' as the effective namespace. Future steve versions will reject this request.\",\n+\t\t\tidNamespace, apiNamespace, effectiveNamespace)\n+\t}\n+\n+\tif accessListByVerb.All(verb) {\n+\t\treturn []partition.Partition{\n+\t\t\tPartition{\n+\t\t\t\tNamespace:   effectiveNamespace,\n+\t\t\t\tAll:         false,\n+\t\t\t\tPassthrough: false,\n+\t\t\t\tNames:       sets.NewString(name),\n+\t\t\t},\n+\t\t}\n+\t}\n+\n+\tif effectiveNamespace != \"\" {\n+\t\tif resources[effectiveNamespace].All {\n+\t\t\treturn []partition.Partition{\n+\t\t\t\tPartition{\n+\t\t\t\t\tNamespace:   effectiveNamespace,\n+\t\t\t\t\tAll:         false,\n+\t\t\t\t\tPassthrough: false,\n+\t\t\t\t\tNames:       sets.NewString(name),\n+\t\t\t\t},\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// For cluster-scoped resources, we will have parsed a \"\" out\n+\t// of the ID field from RSplit, but accessListByVerb specifies \"*\" for\n+\t// the namespace, so correct that here\n+\tresourceNamespace := effectiveNamespace\n+\tif resourceNamespace == \"\" {\n+\t\tresourceNamespace = accesscontrol.All\n+\t}\n+\n+\tnameset, ok := resources[resourceNamespace]\n+\tif ok && nameset.Names.Has(name) {\n+\t\treturn []partition.Partition{\n+\t\t\tPartition{\n+\t\t\t\tNamespace:   effectiveNamespace,\n+\t\t\t\tAll:         false,\n+\t\t\t\tPassthrough: false,\n+\t\t\t\tNames:       sets.NewString(name),\n+\t\t\t},\n+\t\t}\n+\t}\n+\n+\treturn nil\n+}\n+\n+// generateAggregatePartitions determines whether a request can be passed through directly to the underlying store\n // or if the results need to be partitioned by namespace and name based on the requester's access.\n-func isPassthrough(apiOp *types.APIRequest, schema *types.APISchema, verb string) ([]partition.Partition, bool) {\n+func generateAggregatePartitions(apiOp *types.APIRequest, schema *types.APISchema, verb string) ([]partition.Partition, bool) {\n \taccessListByVerb, _ := attributes.Access(schema).(accesscontrol.AccessListByVerb)\n+\tresources := accessListByVerb.Granted(verb)\n+\n \tif accessListByVerb.All(verb) {\n \t\treturn nil, true\n \t}\n \n-\tresources := accessListByVerb.Granted(verb)\n \tif apiOp.Namespace != \"\" {\n \t\tif resources[apiOp.Namespace].All {\n \t\t\treturn nil, true"
            },
            {
                "sha": "973b48e73c7b3c6efda99d9784797d40be230e0c",
                "filename": "pkg/stores/proxy/rbac_store_test.go",
                "status": "modified",
                "additions": 610,
                "deletions": 3,
                "changes": 613,
                "blob_url": "https://github.com/rancher/steve/blob/2175e090fe4b1e603a54e1cdc5148a2b1c11b4d9/pkg%2Fstores%2Fproxy%2Frbac_store_test.go",
                "raw_url": "https://github.com/rancher/steve/raw/2175e090fe4b1e603a54e1cdc5148a2b1c11b4d9/pkg%2Fstores%2Fproxy%2Frbac_store_test.go",
                "contents_url": "https://api.github.com/repos/rancher/steve/contents/pkg%2Fstores%2Fproxy%2Frbac_store_test.go?ref=2175e090fe4b1e603a54e1cdc5148a2b1c11b4d9",
                "patch": "@@ -11,7 +11,7 @@ import (\n \t\"k8s.io/apimachinery/pkg/util/sets\"\n )\n \n-func TestAll(t *testing.T) {\n+func TestVerbList(t *testing.T) {\n \ttests := []struct {\n \t\tname           string\n \t\tapiOp          *types.APIRequest\n@@ -223,23 +223,308 @@ func TestAll(t *testing.T) {\n \t\t\t},\n \t\t},\n \t\t{\n-\t\t\tname:  \"by id\",\n+\t\t\tname:  \"by id fully unauthorized\",\n \t\t\tapiOp: &types.APIRequest{},\n \t\t\tid:    \"n1/r1\",\n \t\t\tschema: &types.APISchema{\n \t\t\t\tSchema: &schemas.Schema{\n \t\t\t\t\tID: \"foo\",\n \t\t\t\t},\n \t\t\t},\n+\t\t\twantPartitions: nil,\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"by id missing namespace\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n2\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: nil,\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"by id missing resource\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: nil,\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"by id authorized by name\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\tPartition{\n+\t\t\t\t\tNamespace: \"n1\",\n+\t\t\t\t\tNames:     sets.NewString(\"r1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"by id authorized by namespace\",\n+\t\t\tapiOp: &types.APIRequest{\n+\t\t\t\tNamespace: \"n1\",\n+\t\t\t},\n+\t\t\tid: \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"*\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\tPartition{\n+\t\t\t\t\tNamespace: \"n1\",\n+\t\t\t\t\tNames:     sets.NewString(\"r1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"by namespaced id authorized by name\",\n+\t\t\tapiOp: &types.APIRequest{\n+\t\t\t\tNamespace: \"n1\",\n+\t\t\t},\n+\t\t\tid: \"r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\tPartition{\n+\t\t\t\t\tNamespace: \"n1\",\n+\t\t\t\t\tNames:     sets.NewString(\"r1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"by id ignores unrequested resources\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\tPartition{\n+\t\t\t\t\tNamespace: \"n1\",\n+\t\t\t\t\tNames:     sets.NewString(\"r1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t// Note: this is deprecated fallback behavior. When we remove the behavior,\n+\t\t// rewrite this test to expect an error instead.\n+\t\t{\n+\t\t\tname: \"by id prefers id embedded namespace\",\n+\t\t\tapiOp: &types.APIRequest{\n+\t\t\t\tNamespace: \"n2\",\n+\t\t\t},\n+\t\t\tid: \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n2\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n \t\t\twantPartitions: []partition.Partition{\n \t\t\t\tPartition{\n \t\t\t\t\tNamespace: \"n1\",\n \t\t\t\t\tNames:     sets.NewString(\"r1\"),\n \t\t\t\t},\n \t\t\t},\n \t\t},\n+\t\t{\n+\t\t\tname:  \"cluster scoped id unauthorized\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"c1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: nil,\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"cluster scoped id authorized by name\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"c1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": false,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"c1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\tPartition{\n+\t\t\t\t\tNamespace: \"\",\n+\t\t\t\t\tNames:     sets.NewString(\"c1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"cluster scoped id authorized globally\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"c1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": false,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"*\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\tPartition{\n+\t\t\t\t\tNamespace: \"\",\n+\t\t\t\t\tNames:     sets.NewString(\"c1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"cluster scoped id ignores unrequested resources\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"c1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": false,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"c1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"c2\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\tPartition{\n+\t\t\t\t\tNamespace: \"\",\n+\t\t\t\t\tNames:     sets.NewString(\"c1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n \t}\n-\n \tfor _, test := range tests {\n \t\tt.Run(test.name, func(t *testing.T) {\n \t\t\tpartitioner := rbacPartitioner{}\n@@ -250,3 +535,325 @@ func TestAll(t *testing.T) {\n \t\t})\n \t}\n }\n+\n+func TestVerbWatch(t *testing.T) {\n+\ttests := []struct {\n+\t\tname           string\n+\t\tapiOp          *types.APIRequest\n+\t\tid             string\n+\t\tschema         *types.APISchema\n+\t\twantPartitions []partition.Partition\n+\t}{\n+\t\t{\n+\t\t\tname:  \"by id fully unauthorized\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: nil,\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"by id missing namespace\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n2\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: nil,\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"by id missing resource\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: nil,\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"by id authorized by name\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\tPartition{\n+\t\t\t\t\tNamespace: \"n1\",\n+\t\t\t\t\tNames:     sets.NewString(\"r1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"by namespaced id authorized by name\",\n+\t\t\tapiOp: &types.APIRequest{\n+\t\t\t\tNamespace: \"n1\",\n+\t\t\t},\n+\t\t\tid: \"r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\tPartition{\n+\t\t\t\t\tNamespace: \"n1\",\n+\t\t\t\t\tNames:     sets.NewString(\"r1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"by id authorized by namespace\",\n+\t\t\tapiOp: &types.APIRequest{\n+\t\t\t\tNamespace: \"n1\",\n+\t\t\t},\n+\t\t\tid: \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"*\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\tPartition{\n+\t\t\t\t\tNamespace: \"n1\",\n+\t\t\t\t\tNames:     sets.NewString(\"r1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"by id ignores unrequested resources\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\tPartition{\n+\t\t\t\t\tNamespace: \"n1\",\n+\t\t\t\t\tNames:     sets.NewString(\"r1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t// Note: this is deprecated fallback behavior. When we remove the behavior,\n+\t\t// rewrite this test to expect an error instead.\n+\t\t{\n+\t\t\tname: \"by id prefers id embedded namespace\",\n+\t\t\tapiOp: &types.APIRequest{\n+\t\t\t\tNamespace: \"n2\",\n+\t\t\t},\n+\t\t\tid: \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n2\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\tPartition{\n+\t\t\t\t\tNamespace: \"n1\",\n+\t\t\t\t\tNames:     sets.NewString(\"r1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"cluster scoped id unauthorized\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"c1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: nil,\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"cluster scoped id authorized by name\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"c1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": false,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"c1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\tPartition{\n+\t\t\t\t\tNamespace: \"\",\n+\t\t\t\t\tNames:     sets.NewString(\"c1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"cluster scoped id authorized globally\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"c1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": false,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"*\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\tPartition{\n+\t\t\t\t\tNamespace: \"\",\n+\t\t\t\t\tNames:     sets.NewString(\"c1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"cluster scoped id ignores unrequested resources\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"c1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": false,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"c1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"c2\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\tPartition{\n+\t\t\t\t\tNamespace: \"\",\n+\t\t\t\t\tNames:     sets.NewString(\"c1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+\tfor _, test := range tests {\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tpartitioner := rbacPartitioner{}\n+\t\t\tverb := \"watch\"\n+\t\t\tgotPartitions, gotErr := partitioner.All(test.apiOp, test.schema, verb, test.id)\n+\t\t\tassert.Nil(t, gotErr)\n+\t\t\tassert.Equal(t, test.wantPartitions, gotPartitions)\n+\t\t})\n+\t}\n+}"
            },
            {
                "sha": "ffee38df9058dcf52423388956376e45f6e3c1b7",
                "filename": "pkg/stores/sqlpartition/partitioner.go",
                "status": "modified",
                "additions": 84,
                "deletions": 13,
                "changes": 97,
                "blob_url": "https://github.com/rancher/steve/blob/2175e090fe4b1e603a54e1cdc5148a2b1c11b4d9/pkg%2Fstores%2Fsqlpartition%2Fpartitioner.go",
                "raw_url": "https://github.com/rancher/steve/raw/2175e090fe4b1e603a54e1cdc5148a2b1c11b4d9/pkg%2Fstores%2Fsqlpartition%2Fpartitioner.go",
                "contents_url": "https://api.github.com/repos/rancher/steve/contents/pkg%2Fstores%2Fsqlpartition%2Fpartitioner.go?ref=2175e090fe4b1e603a54e1cdc5148a2b1c11b4d9",
                "patch": "@@ -9,6 +9,7 @@ import (\n \t\"github.com/rancher/steve/pkg/accesscontrol\"\n \t\"github.com/rancher/steve/pkg/attributes\"\n \t\"github.com/rancher/wrangler/v3/pkg/kv\"\n+\t\"github.com/sirupsen/logrus\"\n \t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"\n \t\"k8s.io/apimachinery/pkg/util/sets\"\n \t\"k8s.io/apimachinery/pkg/watch\"\n@@ -46,17 +47,10 @@ func (p *rbacPartitioner) All(apiOp *types.APIRequest, schema *types.APISchema,\n \t\tfallthrough\n \tcase \"watch\":\n \t\tif id != \"\" {\n-\t\t\tns, name := kv.RSplit(id, \"/\")\n-\t\t\treturn []partition.Partition{\n-\t\t\t\t{\n-\t\t\t\t\tNamespace:   ns,\n-\t\t\t\t\tAll:         false,\n-\t\t\t\t\tPassthrough: false,\n-\t\t\t\t\tNames:       sets.New[string](name),\n-\t\t\t\t},\n-\t\t\t}, nil\n+\t\t\tpartitions := generatePartitionsByID(apiOp, schema, verb, id)\n+\t\t\treturn partitions, nil\n \t\t}\n-\t\tpartitions, passthrough := isPassthrough(apiOp, schema, verb)\n+\t\tpartitions, passthrough := generateAggregatePartitions(apiOp, schema, verb)\n \t\tif passthrough {\n \t\t\treturn passthroughPartitions, nil\n \t\t}\n@@ -74,15 +68,92 @@ func (p *rbacPartitioner) Store() UnstructuredStore {\n \treturn p.proxyStore\n }\n \n-// isPassthrough determines whether a request can be passed through directly to the underlying store\n+// generatePartitionsById determines whether a requester can access a particular resource\n+// and if so, returns the corresponding partitions\n+func generatePartitionsByID(apiOp *types.APIRequest, schema *types.APISchema, verb string, id string) []partition.Partition {\n+\taccessListByVerb, _ := attributes.Access(schema).(accesscontrol.AccessListByVerb)\n+\tresources := accessListByVerb.Granted(verb)\n+\n+\tidNamespace, name := kv.RSplit(id, \"/\")\n+\tapiNamespace := apiOp.Namespace\n+\teffectiveNamespace := idNamespace\n+\n+\t// If a non-empty namespace was provided, be sure to select that for filtering and permissions checks\n+\tif idNamespace == \"\" && apiNamespace != \"\" {\n+\t\teffectiveNamespace = apiNamespace\n+\t}\n+\n+\t// The external API is flexible, and permits specifying a namespace as a separate key or embedded\n+\t// within the ID of the object. Both of these cases should be valid:\n+\t//   {\"namespace\": \"n1\", \"id\": \"r1\"}\n+\t//   {\"id\": \"n1/r1\"}\n+\t// however, the following conflicting request is not valid, but was previously accepted:\n+\t//   {\"namespace\": \"n1\", \"id\": \"n2/r1\"}\n+\t// To avoid breaking UI plugins that may inadvertently rely on the feature, we issue a deprecation\n+\t// warning for now. We still need to pick one of the namespaces for permission verification purposes.\n+\tif idNamespace != \"\" && apiNamespace != \"\" && idNamespace != apiNamespace {\n+\t\tlogrus.Warningf(\"DEPRECATION: Conflicting namespaces '%v' and '%v' requested. \"+\n+\t\t\t\"Selecting '%v' as the effective namespace. Future steve versions will reject this request.\",\n+\t\t\tidNamespace, apiNamespace, effectiveNamespace)\n+\t}\n+\n+\tif accessListByVerb.All(verb) {\n+\t\treturn []partition.Partition{\n+\t\t\t{\n+\t\t\t\tNamespace:   effectiveNamespace,\n+\t\t\t\tAll:         false,\n+\t\t\t\tPassthrough: false,\n+\t\t\t\tNames:       sets.New(name),\n+\t\t\t},\n+\t\t}\n+\t}\n+\n+\tif effectiveNamespace != \"\" {\n+\t\tif resources[effectiveNamespace].All {\n+\t\t\treturn []partition.Partition{\n+\t\t\t\t{\n+\t\t\t\t\tNamespace:   effectiveNamespace,\n+\t\t\t\t\tAll:         false,\n+\t\t\t\t\tPassthrough: false,\n+\t\t\t\t\tNames:       sets.New(name),\n+\t\t\t\t},\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// For cluster-scoped resources, we will have parsed a \"\" out\n+\t// of the ID field from RSplit, but accessListByVerb specifies \"*\" for\n+\t// the nameset, so correct that here\n+\tresourceNamespace := effectiveNamespace\n+\tif resourceNamespace == \"\" {\n+\t\tresourceNamespace = accesscontrol.All\n+\t}\n+\n+\tnameset, ok := resources[resourceNamespace]\n+\tif ok && nameset.Names.Has(name) {\n+\t\treturn []partition.Partition{\n+\t\t\t{\n+\t\t\t\tNamespace:   effectiveNamespace,\n+\t\t\t\tAll:         false,\n+\t\t\t\tPassthrough: false,\n+\t\t\t\tNames:       sets.New(name),\n+\t\t\t},\n+\t\t}\n+\t}\n+\n+\treturn nil\n+}\n+\n+// generateAggregatePartitions determines whether a request can be passed through directly to the underlying store\n // or if the results need to be partitioned by namespace and name based on the requester's access.\n-func isPassthrough(apiOp *types.APIRequest, schema *types.APISchema, verb string) ([]partition.Partition, bool) {\n+func generateAggregatePartitions(apiOp *types.APIRequest, schema *types.APISchema, verb string) ([]partition.Partition, bool) {\n \taccessListByVerb, _ := attributes.Access(schema).(accesscontrol.AccessListByVerb)\n+\tresources := accessListByVerb.Granted(verb)\n+\n \tif accessListByVerb.All(verb) {\n \t\treturn nil, true\n \t}\n \n-\tresources := accessListByVerb.Granted(verb)\n \tif apiOp.Namespace != \"\" {\n \t\tif resources[apiOp.Namespace].All {\n \t\t\treturn nil, true"
            },
            {
                "sha": "caba1897da7b48b3b19e96c8999aa46644bd88fb",
                "filename": "pkg/stores/sqlpartition/partitioner_test.go",
                "status": "modified",
                "additions": 614,
                "deletions": 2,
                "changes": 616,
                "blob_url": "https://github.com/rancher/steve/blob/2175e090fe4b1e603a54e1cdc5148a2b1c11b4d9/pkg%2Fstores%2Fsqlpartition%2Fpartitioner_test.go",
                "raw_url": "https://github.com/rancher/steve/raw/2175e090fe4b1e603a54e1cdc5148a2b1c11b4d9/pkg%2Fstores%2Fsqlpartition%2Fpartitioner_test.go",
                "contents_url": "https://api.github.com/repos/rancher/steve/contents/pkg%2Fstores%2Fsqlpartition%2Fpartitioner_test.go?ref=2175e090fe4b1e603a54e1cdc5148a2b1c11b4d9",
                "patch": "@@ -13,7 +13,7 @@ import (\n \t\"k8s.io/apimachinery/pkg/util/sets\"\n )\n \n-func TestAll(t *testing.T) {\n+func TestVerbList(t *testing.T) {\n \ttests := []struct {\n \t\tname           string\n \t\tapiOp          *types.APIRequest\n@@ -225,21 +225,309 @@ func TestAll(t *testing.T) {\n \t\t\t},\n \t\t},\n \t\t{\n-\t\t\tname:  \"by id\",\n+\t\t\tname:  \"by id fully unauthorized\",\n \t\t\tapiOp: &types.APIRequest{},\n \t\t\tid:    \"n1/r1\",\n \t\t\tschema: &types.APISchema{\n \t\t\t\tSchema: &schemas.Schema{\n \t\t\t\t\tID: \"foo\",\n \t\t\t\t},\n \t\t\t},\n+\t\t\twantPartitions: nil,\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"by id missing namespace\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n2\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: nil,\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"by id missing resource\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: nil,\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"by id authorized by name\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\t{\n+\t\t\t\t\tNamespace: \"n1\",\n+\t\t\t\t\tNames:     sets.New[string](\"r1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"by id authorized by namespace\",\n+\t\t\tapiOp: &types.APIRequest{\n+\t\t\t\tNamespace: \"n1\",\n+\t\t\t},\n+\t\t\tid: \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"*\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\t{\n+\t\t\t\t\tNamespace: \"n1\",\n+\t\t\t\t\tAll:       false,\n+\t\t\t\t\tNames:     sets.New[string](\"r1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"by namespaced id authorized by name\",\n+\t\t\tapiOp: &types.APIRequest{\n+\t\t\t\tNamespace: \"n1\",\n+\t\t\t},\n+\t\t\tid: \"r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\t{\n+\t\t\t\t\tNamespace: \"n1\",\n+\t\t\t\t\tAll:       false,\n+\t\t\t\t\tNames:     sets.New[string](\"r1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"by id ignores unrequested resources\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\t{\n+\t\t\t\t\tNamespace: \"n1\",\n+\t\t\t\t\tNames:     sets.New[string](\"r1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t// Note: this is deprecated fallback behavior. When we remove the behavior,\n+\t\t// rewrite this test to expect an error instead.\n+\t\t{\n+\t\t\tname: \"by id prefers id embedded namespace\",\n+\t\t\tapiOp: &types.APIRequest{\n+\t\t\t\tNamespace: \"n2\",\n+\t\t\t},\n+\t\t\tid: \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n2\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n \t\t\twantPartitions: []partition.Partition{\n \t\t\t\t{\n \t\t\t\t\tNamespace: \"n1\",\n \t\t\t\t\tNames:     sets.New[string](\"r1\"),\n \t\t\t\t},\n \t\t\t},\n \t\t},\n+\t\t{\n+\t\t\tname:  \"cluster scoped id unauthorized\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"c1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: nil,\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"cluster scoped id authorized by name\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"c1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": false,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"c1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\t{\n+\t\t\t\t\tNamespace: \"\",\n+\t\t\t\t\tNames:     sets.New[string](\"c1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"cluster scoped id authorized globally\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"c1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": false,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"*\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\t{\n+\t\t\t\t\tNamespace: \"\",\n+\t\t\t\t\tNames:     sets.New[string](\"c1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"cluster scoped id ignores unrequested resources\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"c1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": false,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"list\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"c1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"c2\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\t{\n+\t\t\t\t\tNamespace: \"\",\n+\t\t\t\t\tNames:     sets.New[string](\"c1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n \t}\n \n \tfor _, test := range tests {\n@@ -253,6 +541,330 @@ func TestAll(t *testing.T) {\n \t}\n }\n \n+func TestVerbWatch(t *testing.T) {\n+\ttests := []struct {\n+\t\tname           string\n+\t\tapiOp          *types.APIRequest\n+\t\tid             string\n+\t\tschema         *types.APISchema\n+\t\twantPartitions []partition.Partition\n+\t}{\n+\t\t{\n+\t\t\tname:  \"by id fully unauthorized\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: nil,\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"by id missing namespace\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n2\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: nil,\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"by id missing resource\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: nil,\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"by id authorized by name\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\t{\n+\t\t\t\t\tNamespace: \"n1\",\n+\t\t\t\t\tNames:     sets.New[string](\"r1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"by id authorized by namespace\",\n+\t\t\tapiOp: &types.APIRequest{\n+\t\t\t\tNamespace: \"n1\",\n+\t\t\t},\n+\t\t\tid: \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"*\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\t{\n+\t\t\t\t\tNamespace: \"n1\",\n+\t\t\t\t\tAll:       false,\n+\t\t\t\t\tNames:     sets.New[string](\"r1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"by namespaced id authorized by name\",\n+\t\t\tapiOp: &types.APIRequest{\n+\t\t\t\tNamespace: \"n1\",\n+\t\t\t},\n+\t\t\tid: \"r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\t{\n+\t\t\t\t\tNamespace: \"n1\",\n+\t\t\t\t\tAll:       false,\n+\t\t\t\t\tNames:     sets.New[string](\"r1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"by id ignores unrequested resources\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\t{\n+\t\t\t\t\tNamespace: \"n1\",\n+\t\t\t\t\tNames:     sets.New[string](\"r1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t// Note: this is deprecated fallback behavior. When we remove the behavior,\n+\t\t// rewrite this test to expect an error instead.\n+\t\t{\n+\t\t\tname: \"by id prefers id embedded namespace\",\n+\t\t\tapiOp: &types.APIRequest{\n+\t\t\t\tNamespace: \"n2\",\n+\t\t\t},\n+\t\t\tid: \"n1/r1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": true,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n1\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"n2\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"r2\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\t{\n+\t\t\t\t\tNamespace: \"n1\",\n+\t\t\t\t\tNames:     sets.New[string](\"r1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"cluster scoped id unauthorized\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"c1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: nil,\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"cluster scoped id authorized by name\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"c1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": false,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"c1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\t{\n+\t\t\t\t\tNamespace: \"\",\n+\t\t\t\t\tNames:     sets.New[string](\"c1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"cluster scoped id authorized globally\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"c1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": false,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"*\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\t{\n+\t\t\t\t\tNamespace: \"\",\n+\t\t\t\t\tNames:     sets.New[string](\"c1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"cluster scoped id ignores unrequested resources\",\n+\t\t\tapiOp: &types.APIRequest{},\n+\t\t\tid:    \"c1\",\n+\t\t\tschema: &types.APISchema{\n+\t\t\t\tSchema: &schemas.Schema{\n+\t\t\t\t\tID: \"foo\",\n+\t\t\t\t\tAttributes: map[string]interface{}{\n+\t\t\t\t\t\t\"namespaced\": false,\n+\t\t\t\t\t\t\"access\": accesscontrol.AccessListByVerb{\n+\t\t\t\t\t\t\t\"watch\": accesscontrol.AccessList{\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"c1\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t\taccesscontrol.Access{\n+\t\t\t\t\t\t\t\t\tNamespace:    \"*\",\n+\t\t\t\t\t\t\t\t\tResourceName: \"c2\",\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantPartitions: []partition.Partition{\n+\t\t\t\t{\n+\t\t\t\t\tNamespace: \"\",\n+\t\t\t\t\tNames:     sets.New[string](\"c1\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+\tfor _, test := range tests {\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tpartitioner := rbacPartitioner{}\n+\t\t\tverb := \"watch\"\n+\t\t\tgotPartitions, gotErr := partitioner.All(test.apiOp, test.schema, verb, test.id)\n+\t\t\tassert.Nil(t, gotErr)\n+\t\t\tassert.Equal(t, test.wantPartitions, gotPartitions)\n+\t\t})\n+\t}\n+}\n+\n func TestStore(t *testing.T) {\n \texpectedStore := NewMockUnstructuredStore(gomock.NewController(t))\n \trp := rbacPartitioner{"
            }
        ]
    }
]